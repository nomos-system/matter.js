/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */

/*** THIS FILE IS GENERATED, DO NOT EDIT ***/

import {
    MatterElement as Matter,
    ClusterElement as Cluster,
    AttributeElement as Attribute,
    CommandElement as Command,
    FieldElement as Field,
    DatatypeElement as Datatype,
    EventElement as Event,
    DeviceTypeElement as DeviceType,
    RequirementElement as Requirement,
    SemanticNamespaceElement as SemanticNamespace,
    SemanticTagElement as SemanticTag
} from "#model";

export const SpecMatter = Matter(
    { name: "SpecMatter" },

    Cluster(
        {
            name: "Identify", id: 0x3, classification: "endpoint", pics: "I", xref: "cluster§1.2",

            details: "This cluster supports an endpoint identification state (e.g., flashing a light), that indicates to " +
                "an observer (e.g., an installer) which of several nodes and/or endpoints it is. It also supports a " +
                "multicast request that any endpoint that is identifying itself to respond to the initiator." +
                "\n" +
                "The state of this cluster may be shared on more than one endpoint on a node." +
                "\n" +
                "For Example: Two endpoints on a single node, one a temperature sensor, and one a humidity sensor, " +
                "may both share the same cluster instance and therefore identification state (e.g. single LED on the " +
                "node)."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 6 }),

        Attribute({
            name: "IdentifyTime", id: 0x0, type: "uint16", access: "RW VO", conformance: "M", quality: "Q",
            xref: "cluster§1.2.5.1",

            details: "Indicates the remaining length of time, in seconds, that the endpoint will continue to identify " +
                "itself." +
                "\n" +
                "If this attribute is set to a value other than 0 then the device shall enter its identification " +
                "state, in order to indicate to an observer which of several nodes and/or endpoints it is. It is " +
                "recommended that this state consists of flashing a light with a period of 0.5 seconds. The " +
                "IdentifyTime attribute shall be decremented every second while in this state." +
                "\n" +
                "If this attribute reaches or is set to the value 0 then the device shall terminate its " +
                "identification state." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • When it changes from 0 to any other value and vice versa, or" +
                "\n" +
                "  • When it is written by a client, or" +
                "\n" +
                "  • When the value is set by an Identify command." +
                "\n" +
                "Since this attribute is not being reported during a regular countdown, clients SHOULD NOT rely on " +
                "the reporting of this attribute in order to keep track of the remaining duration."
        }),

        Attribute({
            name: "IdentifyType", id: 0x1, type: "IdentifyTypeEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§1.2.5.2",
            details: "Indicates how the identification state is presented to the user." +
                "\n" +
                "This attribute shall contain one of the values defined in IdentifyTypeEnum. The value None shall NOT " +
                "be used if the device is capable of presenting its identification state using one of the other " +
                "methods defined in IdentifyTypeEnum."
        }),

        Command(
            {
                name: "Identify", id: 0x0, access: "M", conformance: "M", direction: "request", response: "status",
                xref: "cluster§1.2.6.1",
                details: "This command starts or stops the receiving device identifying itself."
            },
            Field({ name: "IdentifyTime", id: 0x0, type: "uint16", conformance: "M" })
        ),

        Command(
            {
                name: "TriggerEffect", id: 0x40, access: "M", conformance: "O", direction: "request",
                response: "status", xref: "cluster§1.2.6.2",

                details: "This command allows the support of feedback to the user, such as a certain light effect. It is used " +
                    "to allow an implementation to provide visual feedback to the user under certain circumstances such " +
                    "as a color light turning green when it has successfully connected to a network. The use of this " +
                    "command and the effects themselves are entirely up to the implementer to use whenever a visual " +
                    "feedback is useful but it is not the same as and does not replace the identify mechanism used during " +
                    "commissioning."
            },

            Field({
                name: "EffectIdentifier", id: 0x0, type: "EffectIdentifierEnum", conformance: "M",
                constraint: "desc", xref: "cluster§1.2.6.2.1",

                details: "This field shall indicate the identify effect to use and shall contain one of the non-reserved " +
                    "values in EffectIdentifierEnum." +
                    "\n" +
                    "All values of the EffectIdentifierEnum shall be supported. Implementors may deviate from the example " +
                    "light effects in EffectIdentifierEnum, but they SHOULD indicate during testing how they handle each " +
                    "effect."
            }),

            Field({
                name: "EffectVariant", id: 0x1, type: "EffectVariantEnum", conformance: "M", constraint: "desc",
                xref: "cluster§1.2.6.2.2",
                details: "This field shall indicate which variant of the effect, indicated in the EffectIdentifier field, " +
                    "SHOULD be triggered. If a device does not support the given variant, it shall use the default " +
                    "variant. This field shall contain one of the values in EffectVariantEnum."
            })
        ),

        Datatype(
            { name: "IdentifyTypeEnum", type: "enum8", xref: "cluster§1.2.4.1" },
            Field({ name: "None", id: 0x0, conformance: "M", description: "No presentation." }),
            Field({ name: "LightOutput", id: 0x1, conformance: "M", description: "Light output of a lighting product." }),
            Field({ name: "VisibleIndicator", id: 0x2, conformance: "M", description: "Typically a small LED." }),
            Field({ name: "AudibleBeep", id: 0x3, conformance: "M" }),
            Field({
                name: "Display", id: 0x4, conformance: "M",
                description: "Presentation will be visible on display screen."
            }),
            Field({
                name: "Actuator", id: 0x5, conformance: "M",
                description: "Presentation will be conveyed by actuator functionality such as through a window blind operation or in-wall relay."
            })
        ),

        Datatype(
            { name: "EffectIdentifierEnum", type: "enum8", xref: "cluster§1.2.4.2" },
            Field({ name: "Blink", id: 0x0, conformance: "M", description: "e.g., Light is turned on/off once." }),
            Field({
                name: "Breathe", id: 0x1, conformance: "M",
                description: "e.g., Light is turned on/off over 1 second and repeated 15 times."
            }),
            Field({
                name: "Okay", id: 0x2, conformance: "M",
                description: "e.g., Colored light turns green for 1 second; non-colored light flashes twice."
            }),
            Field({
                name: "ChannelChange", id: 0xb, conformance: "M",
                description: "e.g., Colored light turns orange for 8 seconds; non-colored light switches to the maximum brightness for 0.5s and then minimum brightness for 7.5s."
            }),
            Field({
                name: "FinishEffect", id: 0xfe, conformance: "M",
                description: "Complete the current effect sequence before terminating. e.g., if in the middle of a breathe effect (as above), first complete the current 1s breathe effect and then terminate the effect."
            }),
            Field({
                name: "StopEffect", id: 0xff, conformance: "M",
                description: "Terminate the effect as soon as possible."
            })
        ),

        Datatype(
            { name: "EffectVariantEnum", type: "enum8", xref: "cluster§1.2.4.3" },
            Field({ name: "Default", id: 0x0, conformance: "M", description: "Indicates the default effect is used" })
        )
    ),

    Cluster(
        {
            name: "Groups", id: 0x4, classification: "endpoint", pics: "G", xref: "cluster§1.3",

            details: "The Groups cluster manages, per endpoint, the content of the node-wide Group Table that is part of " +
                "the underlying interaction layer." +
                "\n" +
                "In a network supporting fabrics, group IDs referenced by attributes or other elements of this " +
                "cluster are scoped to the accessing fabric." +
                "\n" +
                "The Groups cluster is scoped to the endpoint. Groups cluster commands support discovering the " +
                "endpoint membership in a group, adding the endpoint to a group, removing the endpoint from a group, " +
                "removing endpoint membership from all groups. All commands defined in this cluster shall only affect " +
                "groups scoped to the accessing fabric." +
                "\n" +
                "When group names are supported, the server stores a name string, which is set by the client for each " +
                "assigned group and indicated in response to a client request." +
                "\n" +
                "Note that configuration of group addresses for outgoing commands is achieved using the Message Layer " +
                "mechanisms where the Group Table is not involved. Hence this cluster does not play a part in that."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 4 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.3.4" },
            Field({
                name: "GN", constraint: "0", title: "GroupNames", xref: "cluster§1.3.4.1",
                details: "The Group Names feature indicates the ability to store a name for a group when a group is added."
            })
        ),

        Attribute({
            name: "NameSupport", id: 0x0, type: "NameSupportBitmap", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "cluster§1.3.6.1",
            details: "This attribute provides legacy, read-only access to whether the Group Names feature is supported. " +
                "The most significant bit, bit 7 (GroupNames), shall be equal to bit 0 of the FeatureMap attribute " +
                "(GN Feature). All other bits shall be 0."
        }),

        Command(
            {
                name: "AddGroup", id: 0x0, access: "F M", conformance: "M", direction: "request",
                response: "AddGroupResponse", xref: "cluster§1.3.7.1",
                details: "The AddGroup command allows a client to add group membership in a particular group for the server " +
                    "endpoint."
            },

            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", constraint: "min 1",
                xref: "cluster§1.3.7.1.1",
                details: "This field shall be used to identify the group and any associated key material to which the server " +
                    "endpoint is to be added."
            }),

            Field({
                name: "GroupName", id: 0x1, type: "string", conformance: "M", constraint: "max 16",
                xref: "cluster§1.3.7.1.2",
                details: "This field may be set to a human-readable name for the group. If the client has no name for the " +
                    "group, the GroupName field shall be set to the empty string." +
                    "\n" +
                    "Support of group names is optional and is indicated by the FeatureMap and NameSupport attribute."
            })
        ),

        Command(
            {
                name: "ViewGroup", id: 0x1, access: "F O", conformance: "M", direction: "request",
                response: "ViewGroupResponse", xref: "cluster§1.3.7.2",
                details: "The ViewGroup command allows a client to request that the server responds with a ViewGroupResponse " +
                    "command containing the name string for a particular group."
            },

            Field({ name: "GroupId", id: 0x0, type: "group-id", conformance: "M", constraint: "min 1" })
        ),

        Command(
            {
                name: "GetGroupMembership", id: 0x2, access: "F O", conformance: "M", direction: "request",
                response: "GetGroupMembershipResponse", xref: "cluster§1.3.7.3",
                details: "The GetGroupMembership command allows a client to inquire about the group membership of the server " +
                    "endpoint, in a number of ways."
            },

            Field(
                { name: "GroupList", id: 0x0, type: "list", conformance: "M", constraint: "all[min 1]" },
                Field({ name: "entry", type: "group-id" })
            )
        ),

        Command(
            {
                name: "RemoveGroup", id: 0x3, access: "F M", conformance: "M", direction: "request",
                response: "RemoveGroupResponse", xref: "cluster§1.3.7.4",
                details: "The RemoveGroup command allows a client to request that the server removes the membership for the " +
                    "server endpoint, if any, in a particular group."
            },

            Field({ name: "GroupId", id: 0x0, type: "group-id", conformance: "M", constraint: "min 1" })
        ),

        Command({
            name: "RemoveAllGroups", id: 0x4, access: "F M", conformance: "M", direction: "request",
            response: "status", xref: "cluster§1.3.7.5",
            details: "The RemoveAllGroups command allows a client to direct the server to remove all group associations " +
                "for the server endpoint."
        }),

        Command(
            {
                name: "AddGroupIfIdentifying", id: 0x5, access: "F M", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.3.7.6",

                details: "The AddGroupIfIdentifying command allows a client to add group membership in a particular group for " +
                    "the server endpoint, on condition that the endpoint is identifying itself. Identifying functionality " +
                    "is controlled using the Identify cluster, (see Identify Cluster)." +
                    "\n" +
                    "For correct operation of the AddGroupIfIdentifying command, any endpoint that supports the Groups " +
                    "server cluster shall also support the Identify server cluster." +
                    "\n" +
                    "This command might be used to assist configuring group membership in the absence of a commissioning " +
                    "tool."
            },

            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", constraint: "min 1",
                xref: "cluster§1.3.7.6.1",
                details: "This field shall be used to identify the group and any associated key material to which the server " +
                    "endpoint is to be added."
            }),

            Field({
                name: "GroupName", id: 0x1, type: "string", conformance: "M", constraint: "max 16",
                xref: "cluster§1.3.7.6.2",
                details: "This field may be set to a human-readable name for the group. If the client has no name for the " +
                    "group, the GroupName field shall be set to the empty string." +
                    "\n" +
                    "Support of group names is optional and is indicated by the FeatureMap and NameSupport attribute."
            })
        ),

        Command(
            {
                name: "AddGroupResponse", id: 0x0, conformance: "M", direction: "response", xref: "cluster§1.3.7.7",
                details: "The AddGroupResponse is sent by the Groups cluster server in response to an AddGroup command."
            },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.3.7.7.1",
                details: "This field is set according to the Effect on Receipt section of the AddGroup command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", constraint: "min 1",
                xref: "cluster§1.3.7.7.2",
                details: "This field is set to the GroupID field of the received AddGroup command."
            })
        ),

        Command(
            {
                name: "ViewGroupResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "cluster§1.3.7.8",
                details: "The ViewGroupResponse command is sent by the Groups cluster server in response to a ViewGroup " +
                    "command."
            },

            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.3.7.8.1",
                details: "This field is according to the Effect on Receipt section of the ViewGroup command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", constraint: "min 1",
                xref: "cluster§1.3.7.8.2",
                details: "This field is set to the GroupID field of the received ViewGroup command."
            }),

            Field({
                name: "GroupName", id: 0x2, type: "string", conformance: "M", constraint: "max 16",
                xref: "cluster§1.3.7.8.3",
                details: "If the status is SUCCESS, and group names are supported, this field is set to the group name " +
                    "associated with that group in the Group Table; otherwise it is set to the empty string."
            })
        ),

        Command(
            {
                name: "GetGroupMembershipResponse", id: 0x2, conformance: "M", direction: "response",
                xref: "cluster§1.3.7.9",
                details: "The GetGroupMembershipResponse command is sent by the Groups cluster server in response to a " +
                    "GetGroupMembership command."
            },

            Field({
                name: "Capacity", id: 0x0, type: "uint8", conformance: "M", quality: "X", xref: "cluster§1.3.7.9.1",

                details: "This field shall contain the remaining capacity of the Group Table of the node. The following values " +
                    "apply:" +
                    "\n" +
                    "  • 0 - No further groups may be added." +
                    "\n" +
                    "  • 0 < Capacity < 0xFE - Capacity holds the number of groups that may be added." +
                    "\n" +
                    "  • 0xFE - At least 1 further group may be added (exact number is unknown)." +
                    "\n" +
                    "  • null - It is unknown if any further groups may be added."
            }),

            Field(
                {
                    name: "GroupList", id: 0x1, type: "list", conformance: "M", constraint: "all[min 1]",
                    xref: "cluster§1.3.7.9.2",

                    details: "The GroupList field shall contain either the group IDs of all the groups in the Group Table for " +
                        "which the server endpoint is a member of the group (in the case where the GroupList field of the " +
                        "received GetGroupMembership command was empty), or the group IDs of all the groups in the Group " +
                        "Table for which the server endpoint is a member of the group and for which the group ID was included " +
                        "in the the GroupList field of the received GetGroupMembership command (in the case where the " +
                        "GroupList field of the received GetGroupMembership command was not empty)." +
                        "\n" +
                        "Zigbee: If the total number of groups will cause the maximum payload length of a frame to be " +
                        "exceeded, then the GroupList field shall contain only as many groups as will fit."
                },

                Field({ name: "entry", type: "group-id" })
            )
        ),

        Command(
            {
                name: "RemoveGroupResponse", id: 0x3, conformance: "M", direction: "response",
                xref: "cluster§1.3.7.10",
                details: "The RemoveGroupResponse command is generated by the server in response to the receipt of a " +
                    "RemoveGroup command."
            },

            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.3.7.10.1",
                details: "This field is according to the Effect on Receipt section of the RemoveGroup command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", constraint: "min 1",
                xref: "cluster§1.3.7.10.2",
                details: "This field is set to the GroupID field of the received RemoveGroup command."
            })
        ),

        Datatype(
            { name: "NameSupportBitmap", type: "map8", xref: "cluster§1.3.5.1" },
            Field({ name: "GroupNames", constraint: "7", description: "The ability to store a name for a group." })
        )
    ),

    Cluster(
        {
            name: "ScenesManagement", id: 0x62, classification: "application", pics: "S", xref: "cluster§1.4",

            details: "The Scenes Management cluster provides attributes and commands for setting up and recalling scenes. " +
                "Each scene corresponds to a set of stored values of specified attributes for one or more clusters on " +
                "the same end point as the Scenes Management cluster." +
                "\n" +
                "In most cases scenes are associated with a particular group identifier. Scenes may also exist " +
                "without a group, in which case the value 0 replaces the group identifier. Note that extra care is " +
                "required in these cases to avoid a scene identifier collision, and that commands related to scenes " +
                "without a group may only be unicast, i.e., they shall NOT be multicast or broadcast."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.4.4" },
            Field({
                name: "SN", conformance: "O", constraint: "0", title: "SceneNames", xref: "cluster§1.4.4.1",
                details: "This feature indicates the ability to store a name for a scene when a scene is added."
            })
        ),

        Attribute({ name: "DoNotUse", id: 0x0, access: "R V", conformance: "X", xref: "cluster§1.4.8" }),

        Attribute({
            name: "SceneTableSize", id: 0x1, type: "uint16", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "cluster§1.4.8.1",
            details: "Indicates the number of entries in the Scene Table on this endpoint. This is the total across all " +
                "fabrics; note that a single fabric cannot use all those entries (see Handling of fabric-scoping). " +
                "The minimum size of this table, (i.e., the minimum number of scenes to support across all fabrics " +
                "per endpoint) shall be 16, unless a device type in which this cluster is used, defines a larger " +
                "value in the device type definition."
        }),

        Attribute(
            {
                name: "FabricSceneInfo", id: 0x2, type: "list", access: "R F V", conformance: "M",
                constraint: "desc", xref: "cluster§1.4.8.2",
                details: "Indicates a list of fabric scoped information about scenes on this endpoint." +
                    "\n" +
                    "The number of list entries for this attribute shall NOT exceed the number of supported fabrics by " +
                    "the device."
            },

            Field({ name: "entry", type: "SceneInfoStruct" })
        ),

        Command(
            {
                name: "AddScene", id: 0x0, access: "F M", conformance: "M", direction: "request",
                response: "AddSceneResponse", xref: "cluster§1.4.9.2",
                details: "It is not mandatory for an extension field set to be included in the command for every cluster on " +
                    "that endpoint that has a defined extension field set. Extension field sets may be omitted, including " +
                    "the case of no extension field sets at all."
            },

            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.2.1",
                details: "This field shall indicate the group identifier in the Group Table."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.2.2",
                details: "This field shall indicate the scene identifier in the Scene Table."
            }),
            Field({
                name: "TransitionTime", id: 0x2, type: "uint32", conformance: "M", constraint: "max 60000000",
                xref: "cluster§1.4.9.2.3",
                details: "This field shall indicate the transition time of the scene, measured in milliseconds."
            }),
            Field({
                name: "SceneName", id: 0x3, type: "string", conformance: "M", constraint: "max 16",
                xref: "cluster§1.4.9.2.4",
                details: "This field shall indicate the name of the scene."
            }),

            Field(
                {
                    name: "ExtensionFieldSetStructs", id: 0x4, type: "list", conformance: "M", constraint: "desc",
                    xref: "cluster§1.4.9.2.5",
                    details: "This field shall contains the list of extension fields."
                },
                Field({ name: "entry", type: "ExtensionFieldSetStruct" })
            )
        ),

        Command(
            { name: "AddSceneResponse", id: 0x0, conformance: "M", direction: "response", xref: "cluster§1.4.9.3" },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.3.1",
                details: "This field shall be set according to the Effect on Receipt section for AddScene command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", xref: "cluster§1.4.9.3.2",
                details: "The GroupID field shall be set to the corresponding field of the received AddScene command."
            }),
            Field({
                name: "SceneId", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.3.3",
                details: "The SceneID field shall be set to the corresponding field of the received AddScene command."
            })
        ),

        Command(
            {
                name: "ViewScene", id: 0x1, access: "F O", conformance: "M", direction: "request",
                response: "ViewSceneResponse", xref: "cluster§1.4.9.4"
            },
            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.4.1",
                details: "This field shall indicate the group identifier in the Group Table."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.4.2",
                details: "This field shall indicate the scene identifier in the Scene Table."
            })
        ),

        Command(
            { name: "ViewSceneResponse", id: 0x1, conformance: "M", direction: "response", xref: "cluster§1.4.9.5" },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.5.1",
                details: "This field shall be set according to the Effect on Receipt section for ViewScene command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", xref: "cluster§1.4.9.5.2",
                details: "The GroupID field shall be set to the corresponding field of the received ViewScene command."
            }),
            Field({
                name: "SceneId", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.5.3",
                details: "The SceneID field shall be set to the corresponding field of the received ViewScene command."
            }),
            Field({
                name: "TransitionTime", id: 0x3, type: "uint32", conformance: "Status == Success",
                constraint: "max 60000000", xref: "cluster§1.4.9.5.4",
                details: "This field shall be set to the corresponding field in the Scene Table entry."
            }),
            Field({
                name: "SceneName", id: 0x4, type: "string", conformance: "Status == Success", constraint: "max 16",
                xref: "cluster§1.4.9.5.5",
                details: "This field shall be set to the corresponding field in the Scene Table entry."
            }),

            Field(
                {
                    name: "ExtensionFieldSetStructs", id: 0x5, type: "list", conformance: "Status == Success",
                    xref: "cluster§1.4.9.5.6",
                    details: "This field shall be set to the corresponding field in the Scene Table entry."
                },
                Field({ name: "entry", type: "ExtensionFieldSetStruct" })
            )
        ),

        Command(
            {
                name: "RemoveScene", id: 0x2, access: "F M", conformance: "M", direction: "request",
                response: "RemoveSceneResponse", xref: "cluster§1.4.9.6"
            },
            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.6.1",
                details: "This field shall indicate the group identifier in the Group Table."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.6.2",
                details: "This field shall indicate the scene identifier in the Scene Table."
            })
        ),

        Command(
            { name: "RemoveSceneResponse", id: 0x2, conformance: "M", direction: "response", xref: "cluster§1.4.9.7" },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.7.1",
                details: "This field shall be set according to the Effect on Receipt section for RemoveScene command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", xref: "cluster§1.4.9.7.2",
                details: "The GroupID field shall be set to the corresponding field of the received RemoveScene command."
            }),
            Field({
                name: "SceneId", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.7.3",
                details: "The SceneID field shall be set to the corresponding field of the received RemoveScene command."
            })
        ),

        Command(
            {
                name: "RemoveAllScenes", id: 0x3, access: "F M", conformance: "M", direction: "request",
                response: "RemoveAllScenesResponse", xref: "cluster§1.4.9.8"
            },
            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.8.1",
                details: "This field shall indicate the group identifier in the Group Table."
            })
        ),

        Command(
            {
                name: "RemoveAllScenesResponse", id: 0x3, conformance: "M", direction: "response",
                xref: "cluster§1.4.9.9"
            },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.9.1",
                details: "This field shall be set according to the Effect on Receipt section for RemoveAllScenes command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", xref: "cluster§1.4.9.9.2",
                details: "The GroupID field shall be set to the corresponding field of the received RemoveAllScenes command."
            })
        ),

        Command(
            {
                name: "StoreScene", id: 0x4, access: "F M", conformance: "M", direction: "request",
                response: "StoreSceneResponse", xref: "cluster§1.4.9.10"
            },
            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.10.1",
                details: "This field shall indicate the group identifier in the Group Table."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.10.2",
                details: "This field shall indicate the scene identifier in the Scene Table."
            })
        ),

        Command(
            { name: "StoreSceneResponse", id: 0x4, conformance: "M", direction: "response", xref: "cluster§1.4.9.11" },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.11.1",
                details: "This field shall be set according to the Effect on Receipt section for StoreScene command."
            }),
            Field({
                name: "GroupId", id: 0x1, type: "group-id", conformance: "M", xref: "cluster§1.4.9.11.2",
                details: "The GroupID field shall be set to the corresponding field of the received StoreScene command."
            }),
            Field({
                name: "SceneId", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.11.3",
                details: "The SceneID field shall be set to the corresponding field of the received StoreScene command."
            })
        ),

        Command(
            {
                name: "RecallScene", id: 0x5, access: "F O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.4.9.12"
            },
            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.12.1",
                details: "This field shall indicate the group identifier in the Group Table."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.12.2",
                details: "This field shall indicate the scene identifier in the Scene Table."
            }),
            Field({
                name: "TransitionTime", id: 0x2, type: "uint32", conformance: "O", constraint: "max 60000000",
                quality: "X", xref: "cluster§1.4.9.12.3",
                details: "This field shall indicate the transition time of the scene, measured in milliseconds."
            })
        ),

        Command(
            {
                name: "GetSceneMembership", id: 0x6, access: "F O", conformance: "M", direction: "request",
                response: "GetSceneMembershipResponse", xref: "cluster§1.4.9.13",
                details: "This command can be used to get the used scene identifiers within a certain group, for the endpoint " +
                    "that implements this cluster."
            },

            Field({
                name: "GroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.9.13.1",
                details: "This field shall indicate the group identifier in the Group Table."
            })
        ),

        Command(
            {
                name: "GetSceneMembershipResponse", id: 0x6, conformance: "M", direction: "response",
                xref: "cluster§1.4.9.14"
            },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.14.1",
                details: "This field shall be set according to the Effect on Receipt section for GetSceneMembership command."
            }),

            Field({
                name: "Capacity", id: 0x1, type: "uint8", conformance: "M", quality: "X",
                xref: "cluster§1.4.9.14.2",

                details: "This field shall contain the remaining capacity of the Scene Table of the server (for all groups for " +
                    "the accessing fabric). The following values apply:" +
                    "\n" +
                    "  • 0 - No further scenes may be added." +
                    "\n" +
                    "  • 0 < Capacity < 0xFE - Capacity holds the number of scenes that may be added." +
                    "\n" +
                    "  • 0xFE - At least 1 further scene may be added (exact number is unknown)." +
                    "\n" +
                    "  • null - It is unknown if any further scenes may be added."
            }),

            Field({
                name: "GroupId", id: 0x2, type: "group-id", conformance: "M", xref: "cluster§1.4.9.14.3",
                details: "This field shall be set to the corresponding field of the received GetSceneMembership command."
            }),

            Field(
                {
                    name: "SceneList", id: 0x3, type: "list", conformance: "Status == Success",
                    xref: "cluster§1.4.9.14.4",
                    details: "If the status is not SUCCESS then this field shall be omitted, else this field shall contain the " +
                        "identifiers of all the scenes in the Scene Table with the corresponding Group ID."
                },

                Field({ name: "entry", type: "uint8" })
            )
        ),

        Command(
            {
                name: "CopyScene", id: 0x40, access: "F M", conformance: "O", direction: "request",
                response: "CopySceneResponse", xref: "cluster§1.4.9.15",
                details: "This command allows a client to efficiently copy scenes from one group/scene identifier pair to " +
                    "another group/scene identifier pair."
            },

            Field({
                name: "Mode", id: 0x0, type: "CopyModeBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.15.1",
                details: "This field shall contain the information of how the scene copy is to proceed." +
                    "\n" +
                    "The CopyAllScenes bit of the Mode indicates whether all scenes are to be copied. If this value is " +
                    "set to 1, all scenes are to be copied and the SceneIdentifierFrom and SceneIdentifierTo fields shall " +
                    "be ignored. Otherwise this bit is set to 0."
            }),

            Field({
                name: "GroupIdentifierFrom", id: 0x1, type: "group-id", conformance: "M",
                xref: "cluster§1.4.9.15.2",
                details: "This field shall indicate the identifier of the group from which the scene is to be copied. Together " +
                    "with the SceneIdentifierFrom field, this field uniquely identifies the scene to copy from the Scene " +
                    "Table."
            }),

            Field({
                name: "SceneIdentifierFrom", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.15.3",
                details: "This field shall indicate the identifier of the scene from which the scene is to be copied. Together " +
                    "with the GroupIdentifierFrom field, this field uniquely identifies the scene to copy from the Scene " +
                    "Table."
            }),

            Field({
                name: "GroupIdentifierTo", id: 0x3, type: "group-id", conformance: "M", xref: "cluster§1.4.9.15.4",
                details: "This field shall indicate the identifier of the group to which the scene is to be copied. Together " +
                    "with the SceneIdentifierTo field, this field uniquely identifies the scene to copy to the Scene " +
                    "Table."
            }),

            Field({
                name: "SceneIdentifierTo", id: 0x4, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.15.5",
                details: "This field shall indicate the identifier of the scene to which the scene is to be copied. Together " +
                    "with the GroupIdentifierTo field, this field uniquely identifies the scene to copy to the Scene " +
                    "Table."
            })
        ),

        Command(
            {
                name: "CopySceneResponse", id: 0x40, conformance: "CopyScene", direction: "response",
                xref: "cluster§1.4.9.16"
            },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.9.16.1",
                details: "This field shall be set according to the Effect on Receipt section for the CopyScene command."
            }),

            Field({
                name: "GroupIdentifierFrom", id: 0x1, type: "group-id", conformance: "M",
                xref: "cluster§1.4.9.16.2",
                details: "This field shall be set to the same values as in the corresponding fields of the received CopyScene " +
                    "command."
            }),

            Field({
                name: "SceneIdentifierFrom", id: 0x2, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.9.16.3",
                details: "This field shall be set to the same values as in the corresponding fields of the received CopyScene " +
                    "command."
            })
        ),

        Datatype(
            { name: "CopyModeBitmap", type: "map8", xref: "cluster§1.4.7.1" },
            Field({ name: "CopyAllScenes", constraint: "0", description: "Copy all scenes in the scene table" })
        ),

        Datatype(
            { name: "SceneInfoStruct", type: "struct", xref: "cluster§1.4.7.2" },

            Field({
                name: "SceneCount", id: 0x0, type: "uint8", access: "F", conformance: "M",
                xref: "cluster§1.4.7.2.1",
                details: "This field shall indicate the number of scenes currently used in the server’s Scene Table on the " +
                    "endpoint where the Scenes Management cluster appears." +
                    "\n" +
                    "This only includes the count for the associated fabric."
            }),

            Field({
                name: "CurrentScene", id: 0x1, type: "uint8", access: "S", conformance: "M", constraint: "desc",
                xref: "cluster§1.4.7.2.2",
                details: "This field shall indicate the scene identifier of the scene last invoked on the associated fabric. " +
                    "If no scene has been invoked, the value of this field shall be 0xFF, the undefined scene identifier."
            }),

            Field({
                name: "CurrentGroup", id: 0x2, type: "group-id", access: "S", conformance: "M",
                xref: "cluster§1.4.7.2.3",
                details: "This field shall indicate the group identifier of the scene last invoked on the associated fabric, " +
                    "or 0 if the scene last invoked is not associated with a group."
            }),

            Field({
                name: "SceneValid", id: 0x3, type: "bool", access: "S", conformance: "M", xref: "cluster§1.4.7.2.4",

                details: "This field shall indicate whether the state of the server corresponds to that associated with the " +
                    "CurrentScene and CurrentGroup fields of the SceneInfoStruct they belong to. TRUE indicates that " +
                    "these fields are valid, FALSE indicates that they are not valid." +
                    "\n" +
                    "This field shall be set to False for all other fabrics when an attribute with the Scenes (\"S\") " +
                    "designation in the Quality column of another cluster present on the same endpoint is modified or " +
                    "when the current scene is modified by a fabric through the RecallScene or StoreScene commands, " +
                    "regardless of the fabric-scoped access quality of the command." +
                    "\n" +
                    "In the event where the SceneValid field is set to False for a fabric, the CurrentScene and " +
                    "CurrentGroup fields shall be the last invoked scene and group for that fabric. In the event where no " +
                    "scene was previously invoked for that fabric, the CurrentScene and CurrentGroup fields shall be " +
                    "their default values."
            }),

            Field({
                name: "RemainingCapacity", id: 0x4, type: "uint8", access: "F", conformance: "M",
                constraint: "max 253", xref: "cluster§1.4.7.2.5",
                details: "This field shall indicate the remaining capacity of the Scene Table on this endpoint for the " +
                    "accessing fabric. Note that this value may change between reads, even if no entries are added or " +
                    "deleted on the accessing fabric, due to other clients associated with other fabrics adding or " +
                    "deleting entries that impact the resource usage on the device."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            {
                name: "AttributeValuePairStruct", type: "struct", xref: "cluster§1.4.7.3",
                details: "This data type indicates a combination of an identifier and the value of an attribute."
            },

            Field({
                name: "AttributeId", id: 0x0, type: "attrib-id", conformance: "M", xref: "cluster§1.4.7.3.1",

                details: "This field shall be present for all instances in a given ExtensionFieldSetStruct." +
                    "\n" +
                    "Which Value* field is used shall be determined based on the data type of the attribute indicated by " +
                    "AttributeID, as described in the Value* Fields subsection." +
                    "\n" +
                    "The AttributeID field shall NOT refer to an attribute without the Scenes (\"S\") designation in the " +
                    "Quality column of the cluster specification." +
                    "\n" +
                    "### 1.4.7.3.2. ValueUnsigned8, ValueSigned8, ValueUnsigned16, ValueSigned16, ValueUnsigned32, " +
                    "ValueSigned32, ValueUnsigned64, ValueSigned64 Fields" +
                    "\n" +
                    "These fields shall indicate the attribute value as part of an extension field set, associated with a " +
                    "given AttributeID under an ExtensionFieldSetStruct’s ClusterID. Which of the fields is used shall be " +
                    "determined by the type of the attribute indicated by AttributeID as follows:" +
                    "\n" +
                    "  • Data types bool, map8, and uint8 shall map to ValueUnsigned8." +
                    "\n" +
                    "  • Data types int8 shall map to ValueSigned8." +
                    "\n" +
                    "  • Data types map16 and uint16 shall map to ValueUnsigned16." +
                    "\n" +
                    "  • Data types int16 shall map to ValueSigned16." +
                    "\n" +
                    "  • Data types map32, uint24, and uint32 shall map to ValueUnsigned32." +
                    "\n" +
                    "  • Data types int24 and int32 shall map to ValueSigned32." +
                    "\n" +
                    "  • Data types map64, uint40, uint48, uint56 and uint64 shall map to ValueUnsigned64." +
                    "\n" +
                    "  • Data types int40, int48, int56 and int64 shall map to ValueSigned64." +
                    "\n" +
                    "  • For derived types, the mapping shall be based on the base type. For example, an attribute of " +
                    "    type percent shall be treated as if it were of type uint8, whereas an attribute of type " +
                    "    percent100ths shall be treated as if it were of type uint16." +
                    "\n" +
                    "  • For boolean nullable attributes, any value that is not 0 or 1 shall be considered to have the " +
                    "    null value." +
                    "\n" +
                    "  • For boolean non-nullable attributes, any value that is not 0 or 1 shall be considered to have " +
                    "    the value FALSE." +
                    "\n" +
                    "  • For non-boolean nullable attributes, any value that is not a valid numeric value for the " +
                    "    attribute’s type after accounting for range reductions due to being nullable and constraints " +
                    "    shall be considered to have the null value for the type." +
                    "\n" +
                    "  • For non-boolean non-nullable attributes, any value that is not a valid numeric value for the " +
                    "    attribute’s type after accounting for constraints shall be considered to be the valid attribute " +
                    "    value that is closest to the provided value." +
                    "\n" +
                    "    ◦ In the event that an invalid provided value is of equal numerical distance to the two closest " +
                    "      valid values, the lowest of those values shall be considered the closest valid attribute " +
                    "      value." +
                    "\n" +
                    "If the used field does not match the data type of the attribute indicated by AttributeID, the " +
                    "AttributeValuePairStruct shall be considered invalid." +
                    "\n" +
                    "Examples of processing are:" +
                    "\n" +
                    "  • ColorControl cluster CurrentX (AttributeID 0x0003) has a type of uint16 and is not nullable." +
                    "\n" +
                    "    ◦ ValueUnsigned16 of 0xAB12 would be used as-is, as it is in range." +
                    "\n" +
                    "    ◦ ValueUnsigned16 of 0xFF80 is outside of the range allowed for attribute CurrentX, and would be " +
                    "      saturated to the closest valid value, which is the maximum of the attribute’s constraint " +
                    "      range: 0xFEFF." +
                    "\n" +
                    "  • LevelControl cluster CurrentLevel (AttributeID 0x0000) has a type of uint8 and is nullable." +
                    "\n" +
                    "    ◦ ValueUnsigned8 of 0xA1 would be used as-is, as it is in range." +
                    "\n" +
                    "    ◦ ValueUnsigned8 of 0xFF is outside the range allowed for nullable attribute CurrentLevel, and " +
                    "      would be considered as the null value."
            }),

            Field({ name: "ValueUnsigned8", id: 0x1, type: "uint8", conformance: "O.a" }),
            Field({ name: "ValueSigned8", id: 0x2, type: "int8", conformance: "O.a" }),
            Field({ name: "ValueUnsigned16", id: 0x3, type: "uint16", conformance: "O.a" }),
            Field({ name: "ValueSigned16", id: 0x4, type: "int16", conformance: "O.a" }),
            Field({ name: "ValueUnsigned32", id: 0x5, type: "uint32", conformance: "O.a" }),
            Field({ name: "ValueSigned32", id: 0x6, type: "int32", conformance: "O.a" }),
            Field({ name: "ValueUnsigned64", id: 0x7, type: "uint64", conformance: "O.a" }),
            Field({ name: "ValueSigned64", id: 0x8, type: "int64", conformance: "O.a" })
        ),

        Datatype(
            {
                name: "ExtensionFieldSetStruct", type: "struct", xref: "cluster§1.4.7.4",
                details: "This data type indicates for a given cluster a set of attributes and their values."
            },
            Field({
                name: "ClusterId", id: 0x0, type: "cluster-id", conformance: "M", xref: "cluster§1.4.7.4.1",
                details: "This field shall indicate the cluster-id of the cluster whose attributes are in the " +
                    "AttributeValueList field."
            }),

            Field(
                {
                    name: "AttributeValueList", id: 0x1, type: "list", conformance: "M", constraint: "desc",
                    xref: "cluster§1.4.7.4.2",
                    details: "This field shall indicate a set of attributes and their values which are stored as part of a scene." +
                        "\n" +
                        "Attributes which do not have the Scenes (\"S\") designation in the Quality column of their cluster " +
                        "specification shall NOT be used in the AttributeValueList field."
                },

                Field({ name: "entry", type: "AttributeValuePairStruct" })
            )
        ),

        Datatype(
            {
                name: "LogicalSceneTable", type: "struct", xref: "cluster§1.4.7.5",

                details: "The Scene Table is used to store information for each scene capable of being invoked on the server. " +
                    "Each scene is defined for a particular group. The Scene Table is defined here as a conceptual " +
                    "illustration to assist in understanding the underlying data to be stored when scenes are defined. " +
                    "Though the Scene Table is defined here using the data model architecture rules and format, the " +
                    "design is not normative." +
                    "\n" +
                    "The Scene table is logically a list of fabric-scoped structs. The logical fields of each Scene Table " +
                    "entry struct are illustrated below. An ExtensionFieldSetStruct may be present for each " +
                    "Scenes-supporting cluster implemented on the same endpoint."
            },

            Field({
                name: "SceneGroupId", id: 0x0, type: "group-id", conformance: "M", xref: "cluster§1.4.7.5.1",
                details: "This field is the group identifier for which this scene applies, or 0 if the scene is not associated " +
                    "with a group."
            }),
            Field({
                name: "SceneId", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§1.4.7.5.2",
                details: "This field is unique within this group, which is used to identify this scene."
            }),

            Field({
                name: "SceneName", id: 0x2, type: "string", conformance: "SN", constraint: "max 16",
                xref: "cluster§1.4.7.5.3",
                details: "The field is the name of the scene." +
                    "\n" +
                    "If scene names are not supported, any commands that write a scene name shall simply discard the " +
                    "name, and any command that returns a scene name shall return an empty string."
            }),

            Field({
                name: "SceneTransitionTime", id: 0x3, type: "uint32", conformance: "M", constraint: "max 60000000",
                default: 0, xref: "cluster§1.4.7.5.4",
                details: "This field is the amount of time, in milliseconds, it will take for a cluster to change from its " +
                    "current state to the requested state."
            }),

            Field(
                {
                    name: "ExtensionFields", id: 0x4, type: "list", conformance: "M", default: [],
                    xref: "cluster§1.4.7.5.5",
                    details: "See the Scene Table Extensions subsections of individual clusters. A Scene Table Extension shall " +
                        "only use attributes with the Scene quality. Each ExtensionFieldSetStruct holds a set of values of " +
                        "these attributes for a cluster implemented on the same endpoint where the Scene (\"S\") designation " +
                        "appears in the quality column. A scene is the aggregate of all such fields across all clusters on " +
                        "the endpoint."
                },

                Field({ name: "entry", type: "ExtensionFieldSetStruct" })
            )
        )
    ),

    Cluster(
        {
            name: "OnOff", id: 0x6, classification: "application", pics: "OO", xref: "cluster§1.5",
            details: "Attributes and commands for turning devices on and off."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 6 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.5.4" },

            Field({
                name: "LT", conformance: "[!OFFONLY]", constraint: "0", title: "Lighting", xref: "cluster§1.5.4.1",

                details: "This cluster is used for a lighting application." +
                    "\n" +
                    "On receipt of a Level Control cluster command that causes the OnOff attribute to be set to FALSE, " +
                    "the OnTime attribute shall be set to 0." +
                    "\n" +
                    "On receipt of a Level Control cluster command that causes the OnOff attribute to be set to TRUE, if " +
                    "the value of the OnTime attribute is equal to 0, the server shall set the OffWaitTime attribute to " +
                    "0."
            }),

            Field({
                name: "DF", conformance: "[!OFFONLY]", constraint: "1", title: "DeadFrontBehavior",
                xref: "cluster§1.5.4.2",

                details: "When this feature is supported, the device exposing this server cluster exhibits \"dead front\" " +
                    "behavior when the \"OnOff\" attribute is FALSE (Off). This \"dead front\" behavior includes:" +
                    "\n" +
                    "  • clusters other than this cluster that are also exposed may respond with failures to Invoke and " +
                    "    Write interactions. Such failure responses when in a \"dead front\" shall be with an " +
                    "    INVALID_IN_STATE status code." +
                    "\n" +
                    "  • clusters other than this cluster may change the values of their attributes to best-effort " +
                    "    values, due to the actual values not being defined or available in this state. Device type " +
                    "    specifications that require support for the DF feature SHOULD define what these best-effort " +
                    "    values are." +
                    "\n" +
                    "  • Report Transactions shall continue to be generated. Such transactions may include best-effort " +
                    "    values as noted above." +
                    "\n" +
                    "  • Event generation logic for clusters other than this cluster is unchanged (noting possible use of " +
                    "    best-effort attribute values as in the preceding bullets)." +
                    "\n" +
                    "When this feature is supported and the OnOff attribute changes from TRUE to FALSE (e.g. when " +
                    "receiving an Off Command, or due to a manual interaction on the device), it shall start executing " +
                    "this \"dead front\" behavior." +
                    "\n" +
                    "When this feature is supported and the OnOff attribute changes from FALSE to TRUE (e.g. when " +
                    "receiving an On Command, or due to a manual interaction on the device), it shall stop executing this " +
                    "\"dead front\" behavior." +
                    "\n" +
                    "When this feature is supported, and any change of the \"dead front\" state leads to changes in " +
                    "attributes of other clusters due to the \"dead front\" feature, these attribute changes shall NOT be " +
                    "skipped or omitted from the usual processing associated with attribute changes. For example, if an " +
                    "attribute changes from value 4 to null on \"dead front\" behavior due to an Off command being " +
                    "received, this change shall be processed for reporting and subscriptions."
            }),

            Field({
                name: "OFFONLY", conformance: "[!LT | DF]", constraint: "2", title: "OffOnly",
                xref: "cluster§1.5.4.3",

                details: "When this feature is supported, the Off command shall be supported and the On and Toggle commands " +
                    "shall NOT be supported." +
                    "\n" +
                    "This feature is useful for devices which can be turned off via the Off command received by an " +
                    "instance of this cluster but cannot be turned on via commands received by an instance of this " +
                    "cluster due to regulatory requirements."
            })
        ),

        Attribute({
            name: "OnOff", id: 0x0, type: "bool", access: "R V", conformance: "M", quality: "N S",
            xref: "cluster§1.5.6.2",
            details: "This attribute indicates whether the device type implemented on the endpoint is turned off or turned " +
                "on, in these cases the value of the OnOff attribute equals FALSE, or TRUE respectively."
        }),

        Attribute({
            name: "GlobalSceneControl", id: 0x4000, type: "bool", access: "R V", conformance: "LT",
            xref: "cluster§1.5.6.3",

            details: "In order to support the use case where the user gets back the last setting of a set of devices (e.g. " +
                "level settings for lights), a global scene is introduced which is stored when the devices are turned " +
                "off and recalled when the devices are turned on. The global scene is defined as the scene that is " +
                "stored with group identifier 0 and scene identifier 0." +
                "\n" +
                "This attribute is defined in order to prevent a second Off command storing the all-devices-off " +
                "situation as a global scene, and to prevent a second On command destroying the current settings by " +
                "going back to the global scene." +
                "\n" +
                "This attribute shall be set to TRUE after the reception of a command which causes the OnOff " +
                "attribute to be set to TRUE, such as a standard On command, a MoveToLevel(WithOnOff) command, a " +
                "RecallScene command or a OnWithRecallGlobalScene command." +
                "\n" +
                "This attribute is set to FALSE after reception of a OffWithEffect command."
        }),

        Attribute({
            name: "OnTime", id: 0x4001, type: "uint16", access: "RW VO", conformance: "LT",
            xref: "cluster§1.5.6.4",
            details: "This attribute specifies the length of time (in 1/10ths second) that the On state shall be " +
                "maintained before automatically transitioning to the Off state when using the OnWithTimedOff " +
                "command. This attribute can be written at any time, but writing a value only has effect when in the " +
                "Timed On state. See OnWithTimedOff for more details."
        }),

        Attribute({
            name: "OffWaitTime", id: 0x4002, type: "uint16", access: "RW VO", conformance: "LT",
            xref: "cluster§1.5.6.5",

            details: "This attribute specifies the length of time (in 1/10ths second) that the Off state shall be guarded " +
                "to prevent another OnWithTimedOff command turning the server back to its On state (e.g., when " +
                "leaving a room, the lights are turned off but an occupancy sensor detects the leaving person and " +
                "attempts to turn the lights back on). This attribute can be written at any time, but writing a value " +
                "only has an effect when in the Timed On state followed by a transition to the Delayed Off state, or " +
                "in the Delayed Off state. See OnWithTimedOff for more details."
        }),

        Attribute({
            name: "StartUpOnOff", id: 0x4003, type: "StartUpOnOffEnum", access: "RW VM", conformance: "LT",
            constraint: "desc", quality: "X N", xref: "cluster§1.5.6.6",

            details: "This attribute shall define the desired startup behavior of a device when it is supplied with power " +
                "and this state shall be reflected in the OnOff attribute. If the value is null, the OnOff attribute " +
                "is set to its previous value. Otherwise, the behavior is defined in the table defining " +
                "StartUpOnOffEnum." +
                "\n" +
                "This behavior does not apply to reboots associated with OTA. After an OTA restart, the OnOff " +
                "attribute shall return to its value prior to the restart."
        }),

        Command({
            name: "Off", id: 0x0, access: "O", conformance: "M", direction: "request", response: "status",
            xref: "cluster§1.5.7.1"
        }),
        Command({
            name: "On", id: 0x1, access: "O", conformance: "!OFFONLY", direction: "request", response: "status",
            xref: "cluster§1.5.7.2"
        }),
        Command({
            name: "Toggle", id: 0x2, access: "O", conformance: "!OFFONLY", direction: "request",
            response: "status", xref: "cluster§1.5.7.3"
        }),

        Command(
            {
                name: "OffWithEffect", id: 0x40, access: "O", conformance: "LT", direction: "request",
                response: "status", xref: "cluster§1.5.7.4",
                details: "The OffWithEffect command allows devices to be turned off using enhanced ways of fading."
            },

            Field({
                name: "EffectIdentifier", id: 0x0, type: "EffectIdentifierEnum", conformance: "M",
                constraint: "desc", xref: "cluster§1.5.7.4.1",
                details: "This field specifies the fading effect to use when turning the device off. This field shall contain " +
                    "one of the non-reserved values listed in EffectIdentifierEnum."
            }),

            Field({
                name: "EffectVariant", id: 0x1, type: "enum8", conformance: "M", constraint: "desc",
                xref: "cluster§1.5.7.4.2",
                details: "This field is used to indicate which variant of the effect, indicated in the EffectIdentifier field, " +
                    "SHOULD be triggered. If the server does not support the given variant, it shall use the default " +
                    "variant. This field is dependent on the value of the EffectIdentifier field and shall contain one of " +
                    "the non-reserved values listed in either DelayedAllOffEffectVariantEnum or " +
                    "DyingLightEffectVariantEnum."
            })
        ),

        Command({
            name: "OnWithRecallGlobalScene", id: 0x41, access: "O", conformance: "LT", direction: "request",
            response: "status", xref: "cluster§1.5.7.5",
            details: "This command allows the recall of the settings when the device was turned off."
        }),

        Command(
            {
                name: "OnWithTimedOff", id: 0x42, access: "O", conformance: "LT", direction: "request",
                response: "status", xref: "cluster§1.5.7.6",
                details: "This command allows devices to be turned on for a specific duration with a guarded off duration so " +
                    "that SHOULD the device be subsequently turned off, further OnWithTimedOff commands, received during " +
                    "this time, are prevented from turning the devices back on. Further OnWithTimedOff commands received " +
                    "while the server is turned on, will update the period that the device is turned on."
            },

            Field({
                name: "OnOffControl", id: 0x0, type: "OnOffControlBitmap", conformance: "M", constraint: "0 to 1",
                xref: "cluster§1.5.7.6.1",
                details: "This field contains information on how the server is to be operated."
            }),
            Field({
                name: "OnTime", id: 0x1, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§1.5.7.6.2",
                details: "This field is used to adjust the value of the OnTime attribute."
            }),
            Field({
                name: "OffWaitTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§1.5.7.6.3",
                details: "This field is used to adjust the value of the OffWaitTime attribute."
            })
        ),

        Datatype(
            { name: "OnOffControlBitmap", type: "map8", xref: "cluster§1.5.5.1" },
            Field({
                name: "AcceptOnlyWhenOn", constraint: "0",
                description: "Indicates a command is only accepted when in On state."
            })
        ),

        Datatype(
            { name: "StartUpOnOffEnum", type: "enum8", xref: "cluster§1.5.5.2" },
            Field({ name: "Off", id: 0x0, conformance: "M", description: "Set the OnOff attribute to FALSE" }),
            Field({ name: "On", id: 0x1, conformance: "M", description: "Set the OnOff attribute to TRUE" }),
            Field({
                name: "Toggle", id: 0x2, conformance: "M",
                description: "If the previous value of the OnOff attribute is equal to FALSE, set the OnOff attribute to TRUE. If the previous value of the OnOff attribute is equal to TRUE, set the OnOff attribute to FALSE (toggle)."
            })
        ),

        Datatype(
            { name: "EffectIdentifierEnum", type: "enum8", xref: "cluster§1.5.5.3" },
            Field({ name: "DelayedAllOff", id: 0x0, conformance: "M", description: "Delayed All Off" }),
            Field({ name: "DyingLight", id: 0x1, conformance: "M", description: "Dying Light" })
        ),

        Datatype(
            { name: "DelayedAllOffEffectVariantEnum", type: "enum8", xref: "cluster§1.5.5.4" },
            Field({ name: "DelayedOffFastFade", id: 0x0, conformance: "M", description: "Fade to off in 0.8 seconds" }),
            Field({ name: "NoFade", id: 0x1, conformance: "M", description: "No fade" }),
            Field({
                name: "DelayedOffSlowFade", id: 0x2, conformance: "M",
                description: "50% dim down in 0.8 seconds then fade to off in 12 seconds"
            })
        ),

        Datatype(
            { name: "DyingLightEffectVariantEnum", type: "enum8", xref: "cluster§1.5.5.5" },
            Field({
                name: "DyingLightFadeOff", id: 0x0, conformance: "M",
                description: "20% dim up in 0.5s then fade to off in 1 second"
            })
        )
    ),

    Cluster(
        {
            name: "LevelControl", id: 0x8, classification: "application", pics: "LVL", xref: "cluster§1.6",
            details: "This cluster provides an interface for controlling a characteristic of a device that can be set to a " +
                "level, for example the brightness of a light, the degree of closure of a door, or the power output " +
                "of a heater."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 6 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.6.4" },
            Field({
                name: "OO", conformance: "O", constraint: "0", default: 1, title: "OnOff",
                details: "Dependency with the On/Off cluster"
            }),

            Field({
                name: "LT", conformance: "O", constraint: "1", default: 0, title: "Lighting",
                xref: "cluster§1.6.4.2",

                details: "This feature supports an interface for controlling the level of a light source. For the CurrentLevel " +
                    "attribute:" +
                    "\n" +
                    "A value of 0x00 shall NOT be used." +
                    "\n" +
                    "A value of 0x01 shall indicate the minimum level that can be attained on a device. A value of 0xFE " +
                    "shall indicate the maximum level that can be attained on a device. A value of null shall represent " +
                    "an undefined value." +
                    "\n" +
                    "All other values are application specific gradations from the minimum to the maximum level."
            }),

            Field({
                name: "FQ", conformance: "P", constraint: "2", default: 0, title: "Frequency",
                xref: "cluster§1.6.4.3",
                details: "NOTE The Frequency feature is provisional."
            })
        ),

        Attribute({
            name: "CurrentLevel", id: 0x0, type: "uint8", access: "R V", conformance: "M",
            constraint: "minLevel to maxLevel", quality: "X N S Q", xref: "cluster§1.6.6.2",

            details: "Indicates the current level of this device. The meaning of 'level' is device dependent." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once per second, or" +
                "\n" +
                "  • At the end of the movement/transition, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa."
        }),

        Attribute({
            name: "RemainingTime", id: 0x1, type: "uint16", access: "R V", conformance: "LT", quality: "Q",
            xref: "cluster§1.6.6.3",

            details: "Indicates the time remaining until the current command is complete - it is specified in 1/10ths of a " +
                "second." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • When it changes from 0 to any value higher than 10, or" +
                "\n" +
                "  • When it changes, with a delta larger than 10, caused by the invoke of a command, or" +
                "\n" +
                "  • When it changes to 0." +
                "\n" +
                "For commands with a transition time or changes to the transition time less than 1 second, changes to " +
                "this attribute shall NOT be reported." +
                "\n" +
                "As this attribute is not being reported during a regular countdown, clients SHOULD NOT rely on the " +
                "reporting of this attribute in order to keep track of the remaining duration."
        }),

        Attribute({
            name: "MinLevel", id: 0x2, type: "uint8", access: "R V", conformance: "[LT]",
            constraint: "1 to 254", default: 1, xref: "cluster§1.6.6.4",
            details: "Indicates the minimum value of CurrentLevel that is capable of being assigned."
        }),
        Attribute({
            name: "MinLevel", id: 0x2, type: "uint8", access: "R V", conformance: "[!LT]",
            constraint: "max 254", default: 0, xref: "cluster§1.6.6.4",
            details: "Indicates the minimum value of CurrentLevel that is capable of being assigned."
        }),
        Attribute({
            name: "MaxLevel", id: 0x3, type: "uint8", access: "R V", conformance: "O",
            constraint: "minLevel to 254", default: 254, xref: "cluster§1.6.6.5",
            details: "Indicates the maximum value of CurrentLevel that is capable of being assigned."
        }),

        Attribute({
            name: "CurrentFrequency", id: 0x4, type: "uint16", access: "R V", conformance: "FQ",
            constraint: "minFrequency to maxFrequency", quality: "S P Q", xref: "cluster§1.6.6.6",

            details: "Indicates the frequency at which the device is at CurrentLevel. A CurrentFrequency of 0 is unknown." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once per second, or" +
                "\n" +
                "  • At the start of the movement/transition, or" +
                "\n" +
                "  • At the end of the movement/transition."
        }),

        Attribute({
            name: "MinFrequency", id: 0x5, type: "uint16", access: "R V", conformance: "FQ",
            xref: "cluster§1.6.6.7",
            details: "Indicates the minimum value of CurrentFrequency that is capable of being assigned. MinFrequency " +
                "shall be less than or equal to MaxFrequency. A value of 0 indicates undefined."
        }),

        Attribute({
            name: "MaxFrequency", id: 0x6, type: "uint16", access: "R V", conformance: "FQ",
            constraint: "min minFrequency", xref: "cluster§1.6.6.8",
            details: "Indicates the maximum value of CurrentFrequency that is capable of being assigned. MaxFrequency " +
                "shall be greater than or equal to MinFrequency. A value of 0 indicates undefined."
        }),

        Attribute({
            name: "OnOffTransitionTime", id: 0x10, type: "uint16", access: "RW VO", conformance: "O",
            default: 0, xref: "cluster§1.6.6.10",

            details: "Indicates the time taken to move to or from the target level when On or Off commands are received by " +
                "an On/Off cluster on the same endpoint. It is specified in 1/10ths of a second." +
                "\n" +
                "The actual time taken SHOULD be as close to OnOffTransitionTime as the device is able. Please note " +
                "that if the device is not able to move at a variable rate, the OnOffTransitionTime attribute SHOULD " +
                "NOT be implemented."
        }),

        Attribute({
            name: "OnLevel", id: 0x11, type: "uint8", access: "RW VO", conformance: "M",
            constraint: "minLevel to maxLevel", quality: "X", xref: "cluster§1.6.6.11",

            details: "Indicates the value that the CurrentLevel attribute is set to when the OnOff attribute of an On/Off " +
                "cluster on the same endpoint is set to TRUE, as a result of processing an On/Off cluster command. If " +
                "the OnLevel attribute is not implemented, or is set to the null value, it has no effect. For more " +
                "details see Effect of On/Off Commands on the CurrentLevel attribute." +
                "\n" +
                "OnLevel represents a mandatory field that was previously not present or optional. Implementers " +
                "should be aware that older devices may not implement it."
        }),

        Attribute({
            name: "OnTransitionTime", id: 0x12, type: "uint16", access: "RW VO", conformance: "O",
            default: null, quality: "X", xref: "cluster§1.6.6.12",
            details: "Indicates the time taken to move the current level from the minimum level to the maximum level when " +
                "an On command is received by an On/Off cluster on the same endpoint. It is specified in 1/10ths of a " +
                "second. If this attribute is not implemented, or contains a null value, the OnOffTransitionTime " +
                "shall be used instead."
        }),

        Attribute({
            name: "OffTransitionTime", id: 0x13, type: "uint16", access: "RW VO", conformance: "O",
            default: null, quality: "X", xref: "cluster§1.6.6.13",
            details: "Indicates the time taken to move the current level from the maximum level to the minimum level when " +
                "an Off command is received by an On/Off cluster on the same endpoint. It is specified in 1/10ths of " +
                "a second. If this attribute is not implemented, or contains a null value, the OnOffTransitionTime " +
                "shall be used instead."
        }),

        Attribute({
            name: "DefaultMoveRate", id: 0x14, type: "uint8", access: "RW VO", conformance: "O",
            constraint: "min 1", quality: "X", xref: "cluster§1.6.6.14",
            details: "Indicates the movement rate, in units per second, when a Move command is received with a null value " +
                "Rate parameter."
        }),

        Attribute({
            name: "Options", id: 0xf, type: "OptionsBitmap", access: "RW VO", conformance: "M",
            constraint: "desc", xref: "cluster§1.6.6.9",

            details: "Indicates the selected options of the device." +
                "\n" +
                "The Options attribute is a bitmap that determines the default behavior of some cluster commands. " +
                "Each command that is dependent on the Options attribute shall first construct a temporary Options " +
                "bitmap that is in effect during the command processing. The temporary Options bitmap has the same " +
                "format and meaning as the Options attribute, but includes any bits that may be overridden by command " +
                "fields." +
                "\n" +
                "This attribute is meant to be changed only during commissioning." +
                "\n" +
                "Command execution shall NOT continue beyond the Options processing if all of these criteria are " +
                "true:" +
                "\n" +
                "  • The command is one of the ‘without On/Off’ commands: Move, Move to Level, Step, or Stop." +
                "\n" +
                "  • The On/Off cluster exists on the same endpoint as this cluster." +
                "\n" +
                "  • The OnOff attribute of the On/Off cluster, on this endpoint, is FALSE." +
                "\n" +
                "  • The value of the ExecuteIfOff bit is 0."
        }),

        Attribute({
            name: "StartUpCurrentLevel", id: 0x4000, type: "uint8", access: "RW VM", conformance: "LT",
            constraint: "desc", quality: "X N", xref: "cluster§1.6.6.15",

            details: "Indicates the desired startup level for a device when it is supplied with power and this level shall " +
                "be reflected in the CurrentLevel attribute. The values of the StartUpCurrentLevel attribute are " +
                "listed below:" +
                "\n" +
                "This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentLevel " +
                "attribute shall return to its value prior to the restart."
        }),

        Command(
            {
                name: "MoveToLevel", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.6.7.1"
            },
            Field({ name: "Level", id: 0x0, type: "uint8", conformance: "M", constraint: "max 254" }),
            Field({ name: "TransitionTime", id: 0x1, type: "uint16", conformance: "M", quality: "X" }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "Move", id: 0x1, access: "O", conformance: "M", direction: "request", response: "status",
                xref: "cluster§1.6.7.2"
            },
            Field({
                name: "MoveMode", id: 0x0, type: "MoveModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§1.6.7.2.1",
                details: "This field shall be one of the non-reserved values in MoveModeEnum."
            }),

            Field({
                name: "Rate", id: 0x1, type: "uint8", conformance: "M", quality: "X", xref: "cluster§1.6.7.2.2",

                details: "This field shall indicate the rate of movement in units per second. The actual rate of movement " +
                    "SHOULD be as close to this rate as the device is able. If the Rate field is null, then the value of " +
                    "the DefaultMoveRate attribute shall be used if that attribute is supported and its value is not " +
                    "null. If the Rate field is null and the DefaultMoveRate attribute is either not supported or set to " +
                    "null, then the device SHOULD move as fast as it is able. If the device is not able to move at a " +
                    "variable rate, this field may be disregarded."
            }),

            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "Step", id: 0x2, access: "O", conformance: "M", direction: "request", response: "status",
                xref: "cluster§1.6.7.3"
            },
            Field({
                name: "StepMode", id: 0x0, type: "StepModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§1.6.7.3.1",
                details: "This field shall be one of the non-reserved values in StepModeEnum."
            }),
            Field({
                name: "StepSize", id: 0x1, type: "uint8", conformance: "M", xref: "cluster§1.6.7.3.2",
                details: "This field shall indicate the change to CurrentLevel."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§1.6.7.3.3",

                details: "This field shall indicate the time that shall be taken to perform the step, in tenths of a second. A " +
                    "step is a change in the CurrentLevel of StepSize units. The actual time taken SHOULD be as close to " +
                    "this as the device is able. If the TransitionTime field is equal to null, the device SHOULD move as " +
                    "fast as it is able." +
                    "\n" +
                    "If the device is not able to move at a variable rate, the TransitionTime field may be disregarded."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "Stop", id: 0x3, access: "O", conformance: "M", direction: "request", response: "status",
                xref: "cluster§1.6.7.4"
            },
            Field({ name: "OptionsMask", id: 0x0, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x1, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command({
            name: "MoveToLevelWithOnOff", id: 0x4, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§1.6.7"
        }),
        Command({
            name: "MoveWithOnOff", id: 0x5, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§1.6.7"
        }),
        Command({
            name: "StepWithOnOff", id: 0x6, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§1.6.7"
        }),
        Command({
            name: "StopWithOnOff", id: 0x7, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§1.6.7"
        }),

        Command(
            {
                name: "MoveToClosestFrequency", id: 0x8, access: "O", conformance: "FQ", direction: "request",
                response: "status", xref: "cluster§1.6.7.5"
            },
            Field({ name: "Frequency", id: 0x0, type: "uint16", conformance: "M" })
        ),

        Datatype(
            { name: "OptionsBitmap", type: "map8", xref: "cluster§1.6.5.1" },
            Field({
                name: "ExecuteIfOff", constraint: "0", description: "Dependency on On/Off cluster",
                xref: "cluster§1.6.5.1.1",
                details: "This bit indicates if this cluster has a dependency with the On/Off cluster."
            }),
            Field({
                name: "CoupleColorTempToLevel", constraint: "1", description: "Dependency on Color Control cluster",
                xref: "cluster§1.6.5.1.2",
                details: "This bit indicates if this cluster has a dependency with the Color Control cluster."
            })
        ),

        Datatype(
            { name: "MoveModeEnum", type: "enum8", xref: "cluster§1.6.5.2" },
            Field({ name: "Up", id: 0x0, conformance: "M", description: "Increase the level" }),
            Field({ name: "Down", id: 0x1, conformance: "M", description: "Decrease the level" })
        ),
        Datatype(
            { name: "StepModeEnum", type: "enum8", xref: "cluster§1.6.5.3" },
            Field({ name: "Up", id: 0x0, conformance: "M", description: "Step upwards" }),
            Field({ name: "Down", id: 0x1, conformance: "M", description: "Step downwards" })
        )
    ),

    Cluster(
        {
            name: "BooleanState", id: 0x45, classification: "application", pics: "BOOL", xref: "cluster§1.7",
            details: "This cluster provides an interface to a boolean state."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "StateValue", id: 0x0, type: "bool", access: "R V", conformance: "M", quality: "P",
            xref: "cluster§1.7.4.1",
            details: "This represents a boolean state." +
                "\n" +
                "The semantics of this boolean state are defined by the device type using this cluster." +
                "\n" +
                "For example, in a Contact Sensor device type, FALSE=open or no contact, TRUE=closed or contact."
        }),

        Event(
            {
                name: "StateChange", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "cluster§1.7.5.1",
                details: "If this event is supported, it shall be generated when the StateValue attribute changes."
            },
            Field({
                name: "StateValue", id: 0x0, type: "bool", conformance: "M", xref: "cluster§1.7.5.1.1",
                details: "This field shall indicate the new value of the StateValue attribute."
            })
        )
    ),

    Cluster(
        {
            name: "BooleanStateConfiguration", id: 0x80, classification: "application", pics: "BOOLCFG",
            xref: "cluster§1.8",
            details: "This cluster is used to configure a boolean sensor, including optional state change alarm features " +
                "and configuration of the sensitivity level associated with the sensor."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.8.4" },
            Field({ name: "VIS", conformance: "O", constraint: "0", title: "Visual", details: "Supports visual alarms" }),
            Field({ name: "AUD", conformance: "O", constraint: "1", title: "Audible", details: "Supports audible alarms" }),

            Field({
                name: "SPRS", conformance: "[VIS | AUD]", constraint: "2", title: "AlarmSuppress",
                xref: "cluster§1.8.4.1",

                details: "This feature shall indicate that the device is able to suppress the supported alarm modes, when the " +
                    "user acknowledges the alarm. This is intended to stop visual and/or audible alarms, when the user " +
                    "has become aware that the sensor is triggered, but it is no longer desired to have the alarm modes " +
                    "active on the device, e.g.:" +
                    "\n" +
                    "  • The triggering cause have been resolved by the user, but the sensor has not yet stopped " +
                    "    detecting the triggering cause." +
                    "\n" +
                    "  • The user is not able to address the triggering cause, but is aware of the alarm and " +
                    "    suppress/acknowledge it be addressed at a later point." +
                    "\n" +
                    "Acknowledge of alarms will for the remainder of this cluster be referred to as suppress." +
                    "\n" +
                    "A suppressed alarm is still considered active and will remain so unless it is actively disabled or " +
                    "the triggering condition is not longer present. The action of suppressing an alarm mode is only " +
                    "applicable to and is intended to stop the physical alarming, e.g. emitting a sound or blinking a " +
                    "light; it does not impact alarm reporting in AlarmsActive."
            }),

            Field({
                name: "SENSLVL", conformance: "O", constraint: "3", title: "SensitivityLevel",
                details: "Supports ability to set sensor sensitivity"
            })
        ),

        Attribute({
            name: "CurrentSensitivityLevel", id: 0x0, type: "uint8", access: "RW VO", conformance: "SENSLVL",
            constraint: "max supportedSensitivityLevels - 1", quality: "N", xref: "cluster§1.8.6.1",
            details: "Indicates the currently selected sensitivity level." +
                "\n" +
                "If a write interaction to this attribute contains an unsupported sensitivity value, a " +
                "CONSTRAINT_ERROR status shall be returned."
        }),

        Attribute({
            name: "SupportedSensitivityLevels", id: 0x1, type: "uint8", access: "R V", conformance: "SENSLVL",
            constraint: "2 to 10", quality: "F", xref: "cluster§1.8.6.2",

            details: "Indicates the number of supported sensitivity levels by the device." +
                "\n" +
                "These supported sensitivity levels shall be ordered by sensitivity, where a value of 0 shall be " +
                "considered the lowest sensitivity level (least sensitive) and the highest supported value shall be " +
                "considered the highest sensitivity level." +
                "\n" +
                "The number of supported sensitivity levels SHOULD represent unique sensitivity levels supported by " +
                "the device."
        }),

        Attribute({
            name: "DefaultSensitivityLevel", id: 0x2, type: "uint8", access: "R V", conformance: "[SENSLVL]",
            constraint: "max supportedSensitivityLevels - 1", quality: "F", xref: "cluster§1.8.6.3",
            details: "Indicates the default sensitivity level selected by the manufacturer."
        }),

        Attribute(
            {
                name: "AlarmsActive", id: 0x3, type: "AlarmModeBitmap", access: "R V", conformance: "VIS | AUD",
                xref: "cluster§1.8.6.4",

                details: "Indicates which specific alarm modes on the server are currently active. When the sensor is no " +
                    "longer triggered, this attribute shall be set to the inactive state, by setting the bit to 0, for " +
                    "all supported alarm modes." +
                    "\n" +
                    "If an alarm mode is not supported, the bit indicating this alarm mode shall always be 0. A bit shall " +
                    "indicate whether the alarm mode inactive or not:" +
                    "\n" +
                    "  • 0 = Inactive" +
                    "\n" +
                    "  • 1 = Active"
            }
        ),

        Attribute(
            {
                name: "AlarmsSuppressed", id: 0x4, type: "AlarmModeBitmap", access: "R V", conformance: "SPRS",
                xref: "cluster§1.8.6.5",

                details: "Indicates which specific alarm modes on the server are currently suppressed. When the sensor is no " +
                    "longer triggered, this attribute shall be set to the unsuppressed state, by setting the bit to 0, " +
                    "for all supported alarm modes." +
                    "\n" +
                    "If an alarm mode is not supported, the bit indicating this alarm mode shall always be 0. A bit shall " +
                    "indicate whether the alarm mode is suppressed or not:" +
                    "\n" +
                    "  • 0 = Not suppressed" +
                    "\n" +
                    "  • 1 = Suppressed"
            }
        ),

        Attribute(
            {
                name: "AlarmsEnabled", id: 0x5, type: "AlarmModeBitmap", access: "R V", conformance: "[VIS | AUD]",
                quality: "N", xref: "cluster§1.8.6.6",

                details: "Indicates the alarm modes that will be emitted if the sensor is triggered. If an alarm mode is not " +
                    "supported, the bit indicating this alarm mode shall always be 0." +
                    "\n" +
                    "A bit shall indicate whether the alarm mode is enabled or disabled:" +
                    "\n" +
                    "  • 0 = Disabled" +
                    "\n" +
                    "  • 1 = Enabled"
            }
        ),

        Attribute(
            {
                name: "AlarmsSupported", id: 0x6, type: "AlarmModeBitmap", access: "R V", conformance: "VIS | AUD",
                quality: "F", xref: "cluster§1.8.6.7",

                details: "Indicates the alarms supported by the sensor. A bit shall indicate whether the alarm mode is " +
                    "supported:" +
                    "\n" +
                    "  • 0 = Not supported" +
                    "\n" +
                    "  • 1 = Supported"
            }
        ),

        Attribute({
            name: "SensorFault", id: 0x7, type: "SensorFaultBitmap", access: "R V", conformance: "O",
            default: 0, xref: "cluster§1.8.6.8",
            details: "Indicates any faults registered by the device."
        }),

        Event(
            {
                name: "AlarmsStateChanged", id: 0x0, access: "V", conformance: "VIS | AUD", priority: "info",
                xref: "cluster§1.8.8.1",

                details: "This event shall be generated after any bits in the AlarmsActive and/or AlarmsSuppressed attributes " +
                    "change. This may occur in situations such as when internal processing by the server determines that " +
                    "an alarm mode becomes active or inactive, or when the SuppressAlarm or EnableDisableAlarm commands " +
                    "are processed in a way that some alarm modes becomes suppressed, active or inactive." +
                    "\n" +
                    "If several alarm modes change state at the same time, a single event combining multiple changes may " +
                    "be emitted instead of multiple events each representing a single change."
            },

            Field({
                name: "AlarmsActive", id: 0x0, type: "AlarmModeBitmap", conformance: "M", xref: "cluster§1.8.8.1.1",
                details: "This field shall indicate the state of active alarm modes, as indicated by the AlarmsActive " +
                    "attribute, at the time the event was generated."
            }),

            Field({
                name: "AlarmsSuppressed", id: 0x1, type: "AlarmModeBitmap", conformance: "SPRS",
                xref: "cluster§1.8.8.1.2",
                details: "This field shall indicate the state of suppressed alarm modes, as indicated by the AlarmsSuppressed " +
                    "attribute, at the time the event was generated."
            })
        ),

        Event(
            {
                name: "SensorFault", id: 0x1, access: "V", conformance: "O", priority: "info",
                xref: "cluster§1.8.8.2",
                details: "This event shall be generated when the device registers or clears a fault."
            },

            Field({
                name: "SensorFault", id: 0x0, type: "SensorFaultBitmap", conformance: "M",
                xref: "cluster§1.8.8.2.1",
                details: "This field shall indicate the value of the SensorFault attribute, at the time this event is " +
                    "generated."
            })
        ),

        Command(
            {
                name: "SuppressAlarm", id: 0x0, access: "O", conformance: "SPRS", direction: "request",
                response: "status", xref: "cluster§1.8.7.1"
            },
            Field({
                name: "AlarmsToSuppress", id: 0x0, type: "AlarmModeBitmap", conformance: "M",
                xref: "cluster§1.8.7.1.1",
                details: "This field shall indicate the alarm modes to suppress."
            })
        ),

        Command(
            {
                name: "EnableDisableAlarm", id: 0x1, access: "O", conformance: "VIS | AUD", direction: "request",
                response: "status", xref: "cluster§1.8.7.2"
            },

            Field({
                name: "AlarmsToEnableDisable", id: 0x0, type: "AlarmModeBitmap", conformance: "M",
                xref: "cluster§1.8.7.2.1",
                details: "This field shall indicate the alarm modes to either enable or disable depending on the bit status, " +
                    "as specified for the AlarmsEnabled attribute."
            })
        ),

        Datatype(
            { name: "AlarmModeBitmap", type: "map8", xref: "cluster§1.8.5.1" },
            Field({ name: "Visual", constraint: "0", description: "Visual alarming" }),
            Field({ name: "Audible", constraint: "1", description: "Audible alarming" })
        ),
        Datatype(
            { name: "SensorFaultBitmap", type: "map16", xref: "cluster§1.8.5.2" },
            Field({ name: "GeneralFault", constraint: "0", description: "Unspecified fault detected" })
        )
    ),

    Cluster(
        {
            name: "ModeSelect", id: 0x50, classification: "application", pics: "MOD", xref: "cluster§1.9",

            details: "This cluster provides an interface for controlling a characteristic of a device that can be set to " +
                "one of several predefined values. For example, the light pattern of a disco ball, the mode of a " +
                "massage chair, or the wash cycle of a laundry machine." +
                "\n" +
                "The server allows the client to set a mode on the server. A mode is one of a list of options that " +
                "may be presented by a client for a user choice, or understood by the client, via the semantic tags " +
                "on the mode." +
                "\n" +
                "A semantic tag is either a standard tag within a standard category namespace, or a manufacturer " +
                "specific tag, within the namespace of the vendor ID of the manufacturer. If there is no semantic " +
                "tag, the mode is anonymous, and the selection is made by the user solely based on the Label string." +
                "\n" +
                "Each cluster ID that indicates this specification shall define a distinct purpose for the cluster " +
                "instance. For example: A LightBlinking cluster ID supports blinking modes for a light (and is " +
                "described that way)." +
                "\n" +
                "An anonymous mode shall support the derived cluster purpose. A manufacturer specific semantic tag " +
                "shall support the derived cluster purpose. An anonymous mode shall NOT replace the meaning of a " +
                "standard semantic tag, when one exists, for the cluster purpose."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.9.4" },
            Field({
                name: "DEPONOFF", constraint: "0", title: "OnOff", xref: "cluster§1.9.4.1",
                details: "This feature creates a dependency between an OnOff cluster instance and this cluster instance on the " +
                    "same endpoint. See Section 1.9.6.6, “OnMode Attribute” for more information."
            })
        ),

        Attribute({
            name: "Description", id: 0x0, type: "string", access: "R V", conformance: "M", constraint: "max 64",
            quality: "F", xref: "cluster§1.9.6.1",

            details: "This attribute describes the purpose of the server, in readable text." +
                "\n" +
                "For example, a coffee machine may have a Mode Select cluster for the amount of milk to add, and " +
                "another Mode Select cluster for the amount of sugar to add. In this case, the first instance can " +
                "have the description Milk and the second instance can have the description Sugar. This allows the " +
                "user to tell the purpose of each of the instances."
        }),

        Attribute({
            name: "StandardNamespace", id: 0x1, type: "enum16", access: "R V", conformance: "M",
            constraint: "desc", default: null, quality: "X F", xref: "cluster§1.9.6.2",
            details: "This attribute, when not null, shall indicate a single standard namespace for any standard semantic " +
                "tag value supported in this or any other cluster instance with the same value of this attribute. A " +
                "null value indicates no standard namespace, and therefore, no standard semantic tags are provided in " +
                "this cluster instance. Each standard namespace and corresponding values and value meanings shall be " +
                "defined in another document."
        }),

        Attribute(
            {
                name: "SupportedModes", id: 0x2, type: "list", access: "R V", conformance: "M",
                constraint: "max 255", quality: "F", xref: "cluster§1.9.6.3",
                details: "This attribute is the list of supported modes that may be selected for the CurrentMode attribute. " +
                    "Each item in this list represents a unique mode as indicated by the Mode field of the " +
                    "ModeOptionStruct. Each entry in this list shall have a unique value for the Mode field."
            },

            Field({ name: "entry", type: "ModeOptionStruct" })
        ),

        Attribute({
            name: "CurrentMode", id: 0x3, type: "uint8", access: "R V", conformance: "M", constraint: "desc",
            quality: "N", xref: "cluster§1.9.6.4",
            details: "This attribute represents the current mode of the server." +
                "\n" +
                "The value of this field must match the Mode field of one of the entries in the SupportedModes " +
                "attribute."
        }),

        Attribute({
            name: "StartUpMode", id: 0x4, type: "uint8", access: "RW VO", conformance: "O", constraint: "desc",
            quality: "X N", xref: "cluster§1.9.6.5",

            details: "The StartUpMode attribute value indicates the desired startup mode for the server when it is " +
                "supplied with power." +
                "\n" +
                "If this attribute is not null, the CurrentMode attribute shall be set to the StartUpMode value, when " +
                "the server is powered up, except in the case when the OnMode attribute overrides the StartUpMode " +
                "attribute (see Section 1.9.6.6.1, “OnMode with Power Up”)." +
                "\n" +
                "This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentMode " +
                "attribute shall return to its value prior to the restart." +
                "\n" +
                "The value of this field shall match the Mode field of one of the entries in the SupportedModes " +
                "attribute." +
                "\n" +
                "If this attribute is not implemented, or is set to the null value, it shall have no effect."
        }),

        Attribute({
            name: "OnMode", id: 0x5, type: "uint8", access: "RW VO", conformance: "DEPONOFF",
            constraint: "desc", default: null, quality: "X N", xref: "cluster§1.9.6.6",

            details: "Indicates the value of CurrentMode that depends on the state of the On/Off cluster on the same " +
                "endpoint. If this attribute is not present or is set to null, it shall NOT have an effect, otherwise " +
                "the CurrentMode attribute shall depend on the OnOff attribute of the On/Off cluster" +
                "\n" +
                "The value of this field shall match the Mode field of one of the entries in the SupportedModes " +
                "attribute."
        }),

        Command(
            {
                name: "ChangeToMode", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.9.7.1",
                details: "On receipt of this command, if the NewMode field indicates a valid mode transition within the " +
                    "supported list, the server shall set the CurrentMode attribute to the NewMode value, otherwise, the " +
                    "server shall respond with an INVALID_COMMAND status response."
            },

            Field({ name: "NewMode", id: 0x0, type: "uint8", conformance: "M", constraint: "desc" })
        ),

        Datatype(
            {
                name: "SemanticTagStruct", type: "struct", xref: "cluster§1.9.5.1",
                details: "A Semantic Tag is meant to be interpreted by the client for the purpose the cluster serves."
            },

            Field({
                name: "MfgCode", id: 0x0, type: "vendor-id", conformance: "M", constraint: "desc", quality: "F",
                xref: "cluster§1.9.5.1.2",
                details: "This field shall indicate a manufacturer code (Vendor ID), and the Value field shall indicate a " +
                    "semantic tag defined by the manufacturer. Each manufacturer code supports a single namespace of " +
                    "values. The same manufacturer code and semantic tag value in separate cluster instances are part of " +
                    "the same namespace and have the same meaning. For example: a manufacturer tag meaning \"pinch\", has " +
                    "the same meaning in a cluster whose purpose is to choose the amount of sugar, or amount of salt."
            }),

            Field({
                name: "Value", id: 0x1, type: "enum16", conformance: "M", quality: "F", xref: "cluster§1.9.5.1.1",
                details: "This field shall indicate the semantic tag within a semantic tag namespace which is either " +
                    "manufacturer specific or standard. For semantic tags in a standard namespace, see Standard " +
                    "Namespace."
            })
        ),

        Datatype(
            {
                name: "ModeOptionStruct", type: "struct", xref: "cluster§1.9.5.2",
                details: "This is a struct representing a possible mode of the server."
            },

            Field({
                name: "Label", id: 0x0, type: "string", conformance: "M", constraint: "max 64", quality: "F",
                xref: "cluster§1.9.5.2.1",
                details: "This field is readable text that describes the mode option that can be used by a client to indicate " +
                    "to the user what this option means. This field is meant to be readable and understandable by the " +
                    "user."
            }),

            Field({
                name: "Mode", id: 0x1, type: "uint8", conformance: "M", quality: "F", xref: "cluster§1.9.5.2.2",
                details: "The Mode field is used to identify the mode option. The value shall be unique for every item in the " +
                    "SupportedModes attribute."
            }),

            Field(
                {
                    name: "SemanticTags", id: 0x2, type: "list", conformance: "M", constraint: "max 64", quality: "F",
                    xref: "cluster§1.9.5.2.3",

                    details: "This field is a list of semantic tags that map to the mode option. This may be used by clients to " +
                        "determine the meaning of the mode option as defined in a standard or manufacturer specific " +
                        "namespace. Semantic tags can help clients look for options that meet certain criteria. A semantic " +
                        "tag shall be either a standard tag or manufacturer specific tag as defined in each SemanticTagStruct " +
                        "list entry." +
                        "\n" +
                        "A mode option may have more than one semantic tag. A mode option may be mapped to a mixture of " +
                        "standard and manufacturer specific semantic tags." +
                        "\n" +
                        "All standard semantic tags are from a single namespace indicated by the StandardNamespace attribute." +
                        "\n" +
                        "For example: A mode labeled \"100%\" can have both the HIGH (MS) and MAX (standard) semantic tag. " +
                        "Clients seeking the option for either HIGH or MAX will find the same option in this case."
                },

                Field({ name: "entry", type: "SemanticTagStruct" })
            )
        )
    ),

    Cluster(
        {
            name: "ModeBase", classification: "application", pics: "MODB", xref: "cluster§1.10",

            details: "This cluster provides an interface for controlling a characteristic of a device that can be set to " +
                "one of several predefined values. For example, the light pattern of a disco ball, the mode of a " +
                "massage chair, or the wash cycle of a laundry machine." +
                "\n" +
                "The server allows the client to set a mode on the server. A mode is one of a list of options that " +
                "may be presented by a client for a user choice, or understood by the client, via the mode’s tags." +
                "\n" +
                "A mode tag is either a standard tag within a standard category namespace, or a manufacturer specific " +
                "tag, within the namespace of the vendor ID of the manufacturer." +
                "\n" +
                "Any derived cluster specification based on this cluster shall support the standard mode tag value " +
                "definitions and command status definitions defined in this cluster and may define additional " +
                "standard mode tag values and standard command status values that are supported in the respective " +
                "derived cluster instances." +
                "\n" +
                "Each cluster ID that indicates this specification shall define a distinct purpose for the cluster " +
                "instance. For example: A LightBlinking cluster ID supports blinking modes for a light (and is " +
                "described that way)." +
                "\n" +
                "An anonymous mode shall NOT replace the meaning of a standard mode tag, when one exists, for the " +
                "cluster purpose."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.10.4" },
            Field({
                name: "DEPONOFF", constraint: "0", title: "OnOff", xref: "cluster§1.10.4.1",
                details: "This feature creates a dependency between an OnOff cluster instance and this cluster instance on the " +
                    "same endpoint. See OnMode for more information."
            })
        ),

        Attribute(
            {
                name: "SupportedModes", id: 0x0, type: "list", access: "R V", conformance: "M",
                constraint: "2 to 255", quality: "F", xref: "cluster§1.10.6.1",

                details: "This attribute shall contain the list of supported modes that may be selected for the CurrentMode " +
                    "attribute. Each item in this list represents a unique mode as indicated by the Mode field of the " +
                    "ModeOptionStruct." +
                    "\n" +
                    "Each entry in this list shall have a unique value for the Mode field. Each entry in this list shall " +
                    "have a unique value for the Label field." +
                    "\n" +
                    "The set of ModeTags listed in each entry in this list shall be distinct from the sets of ModeTags " +
                    "listed in the other entries. This comparison shall NOT depend on the order of the ModeTags in the " +
                    "lists. Two sets shall be considered distinct if one of them contains an element that the other one " +
                    "does not. Note that the two sets could have a non-empty intersection, or one could be a subset of " +
                    "the other, and still be distinct." +
                    "\n" +
                    "Simplified examples of allowed ModeTags lists:" +
                    "\n" +
                    "Simplified examples of disallowed ModeTags lists:"
            },

            Field({ name: "entry", type: "ModeOptionStruct" })
        ),

        Attribute({
            name: "CurrentMode", id: 0x1, type: "uint8", access: "R V", conformance: "M", constraint: "desc",
            quality: "N", xref: "cluster§1.10.6.2",

            details: "Indicates the current mode of the server." +
                "\n" +
                "The value of this field shall match the Mode field of one of the entries in the SupportedModes " +
                "attribute." +
                "\n" +
                "The value of this attribute may change at any time via an out-of-band interaction outside of the " +
                "server, such as interactions with a user interface, via internal mode changes due to autonomously " +
                "progressing through a sequence of operations, on system time-outs or idle delays, or via " +
                "interactions coming from a fabric other than the one which last executed a ChangeToMode."
        }),

        Attribute({
            name: "StartUpMode", id: 0x2, type: "uint8", access: "RW VO", conformance: "O", constraint: "desc",
            quality: "X N", xref: "cluster§1.10.6.3",

            details: "Indicates the desired startup mode for the server when it is supplied with power." +
                "\n" +
                "If this attribute is not null, the CurrentMode attribute shall be set to the StartUpMode value, when " +
                "the server is powered up, except in the case when the OnMode attribute overrides the StartUpMode " +
                "attribute (see Section 1.10.6.4.1, “OnMode with Power Up”)." +
                "\n" +
                "This behavior does not apply to reboots associated with OTA. After an OTA restart, the CurrentMode " +
                "attribute shall return to its value prior to the restart." +
                "\n" +
                "The value of this field shall match the Mode field of one of the entries in the SupportedModes " +
                "attribute." +
                "\n" +
                "If this attribute is not implemented, or is set to the null value, it shall have no effect."
        }),

        Attribute({
            name: "OnMode", id: 0x3, type: "uint8", access: "RW VO", conformance: "DEPONOFF",
            constraint: "desc", quality: "X N", xref: "cluster§1.10.6.4",

            details: "Indicates whether the value of CurrentMode depends on the state of the On/Off cluster on the same " +
                "endpoint. If this attribute is not present or is set to null, there is no dependency, otherwise the " +
                "CurrentMode attribute shall depend on the OnOff attribute in the On/Off cluster" +
                "\n" +
                "The value of this field shall match the Mode field of one of the entries in the SupportedModes " +
                "attribute."
        }),

        Command(
            {
                name: "ChangeToMode", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "ChangeToModeResponse", xref: "cluster§1.10.7.1",
                details: "This command is used to change device modes." +
                    "\n" +
                    "On receipt of this command the device shall respond with a ChangeToModeResponse command."
            },

            Field({
                name: "NewMode", id: 0x0, type: "uint8", conformance: "M", constraint: "desc",
                xref: "cluster§1.10.7.1.1",

                details: "If the NewMode field doesn’t match the Mode field of any entry of the SupportedModes list, the " +
                    "ChangeToModeResponse command’s Status field shall indicate UnsupportedMode and the StatusText field " +
                    "shall be included and may be used to indicate the issue, with a human readable string, or include an " +
                    "empty string." +
                    "\n" +
                    "If the NewMode field matches the Mode field of one entry of the SupportedModes list, but the device " +
                    "is not able to transition as requested, the ChangeToModeResponse command shall:" +
                    "\n" +
                    "  • Have the Status set to a product-specific Status value representing the error, or GenericFailure " +
                    "    if a more specific error cannot be provided. See Status field for details." +
                    "\n" +
                    "  • Provide a human readable string in the StatusText field." +
                    "\n" +
                    "If the NewMode field matches the Mode field of one entry of the SupportedModes list and the device " +
                    "is able to transition as requested, the server shall transition into the mode associated with " +
                    "NewMode, the ChangeToModeResponse command shall have the Status field set to Success, the StatusText " +
                    "field may be supplied with a human readable string or include an empty string and the CurrentMode " +
                    "field shall be set to the value of the NewMode field." +
                    "\n" +
                    "If the NewMode field is the same as the value of the CurrentMode attribute the ChangeToModeResponse " +
                    "command shall have the Status field set to Success and the StatusText field may be supplied with a " +
                    "human readable string or include an empty string."
            })
        ),

        Command(
            {
                name: "ChangeToModeResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "cluster§1.10.7.2",
                details: "This command is sent by the device on receipt of the ChangeToMode command."
            },
            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§1.10.7.2.1"
            }),
            Field({
                name: "StatusText", id: 0x1, type: "string", conformance: "[Status == Success], M",
                constraint: "max 64"
            })
        ),

        Datatype(
            {
                name: "ModeTagStruct", type: "struct", xref: "cluster§1.10.5.1",
                details: "A Mode Tag is meant to be interpreted by the client for the purpose the cluster serves."
            },

            Field({
                name: "MfgCode", id: 0x0, type: "vendor-id", conformance: "O", constraint: "desc",
                xref: "cluster§1.10.5.1.1",

                details: "If the MfgCode field exists, the Value field shall be in the manufacturer-specific value range (see " +
                    "Section 1.10.8, “Mode Namespace”)." +
                    "\n" +
                    "This field shall indicate the manufacturer’s VendorID and it shall determine the meaning of the " +
                    "Value field." +
                    "\n" +
                    "The same manufacturer code and mode tag value in separate cluster instances are part of the same " +
                    "namespace and have the same meaning. For example: a manufacturer tag meaning \"pinch\" can be used " +
                    "both in a cluster whose purpose is to choose the amount of sugar, or in a cluster whose purpose is " +
                    "to choose the amount of salt."
            }),

            Field({
                name: "Value", id: 0x1, type: "enum16", conformance: "M", xref: "cluster§1.10.5.1.2",
                details: "This field shall indicate the mode tag within a mode tag namespace which is either manufacturer " +
                    "specific or standard."
            })
        ),

        Datatype(
            {
                name: "ModeOptionStruct", type: "struct", xref: "cluster§1.10.5.2",
                details: "This is a struct representing a possible mode of the server."
            },

            Field({
                name: "Label", id: 0x0, type: "string", conformance: "M", constraint: "max 64", quality: "F",
                xref: "cluster§1.10.5.2.1",
                details: "This field shall indicate readable text that describes the mode option, so that a client can provide " +
                    "it to the user to indicate what this option means. This field is meant to be readable and " +
                    "understandable by the user."
            }),

            Field({
                name: "Mode", id: 0x1, type: "uint8", conformance: "M", quality: "F", xref: "cluster§1.10.5.2.2",
                details: "This field is used to identify the mode option."
            }),

            Field(
                {
                    name: "ModeTags", id: 0x2, type: "list", conformance: "M", constraint: "max 8", quality: "F",
                    xref: "cluster§1.10.5.2.3",

                    details: "This field shall contain a list of tags that are associated with the mode option. This may be used " +
                        "by clients to determine the full or the partial semantics of a certain mode, depending on which tags " +
                        "they understand, using standard definitions and/or manufacturer specific namespace definitions." +
                        "\n" +
                        "The standard mode tags are defined in this cluster specification. For the derived cluster instances, " +
                        "if the specification of the derived cluster defines a namespace, the set of standard mode tags also " +
                        "includes the mode tag values from that namespace." +
                        "\n" +
                        "Mode tags can help clients look for options that meet certain criteria, render the user interface, " +
                        "use the mode in an automation, or to craft help text their voice-driven interfaces. A mode tag shall " +
                        "be either a standard tag or a manufacturer specific tag, as defined in each ModeTagStruct list " +
                        "entry." +
                        "\n" +
                        "A mode option may have more than one mode tag. A mode option may be associated with a mixture of " +
                        "standard and manufacturer specific mode tags. A mode option shall be associated with at least one " +
                        "standard mode tag." +
                        "\n" +
                        "Each mode tag in this field shall be distinct from other mode tags in this field. For example, a " +
                        "simplified list containing [Auto, Auto] would not be allowed." +
                        "\n" +
                        "A few examples are provided below." +
                        "\n" +
                        "  • A mode named \"100%\" can have both the High (manufacturer specific) and Max (standard) mode tag. " +
                        "    Clients seeking the mode for either High or Max will find the same mode in this case." +
                        "\n" +
                        "  • A mode that includes a LowEnergy tag can be displayed by the client using a widget icon that " +
                        "    shows a green leaf." +
                        "\n" +
                        "  • A mode that includes a LowNoise tag may be used by the client when the user wishes for a lower " +
                        "    level of audible sound, less likely to disturb the household’s activities." +
                        "\n" +
                        "  • A mode that includes a LowEnergy tag (standard, defined in this cluster specification) and also " +
                        "    a Delicate tag (standard, defined in the namespace of a Laundry Mode derived cluster)." +
                        "\n" +
                        "  • A mode that includes both a generic Quick tag (defined here), and Vacuum and Mop tags, (defined " +
                        "    in the RVC Clean cluster that is a derivation of this cluster)."
                },

                Field({ name: "entry", type: "ModeTagStruct" })
            )
        ),

        Datatype(
            { name: "ModeChangeStatus", type: "enum8" },
            Field({
                name: "Success", id: 0x0,
                description: "Switching to the mode indicated by the NewMode field is allowed and possible. The CurrentMode attribute is set to the value of the NewMode field.",
                xref: "cluster§1.10.7.2.1.2"
            }),
            Field({
                name: "UnsupportedMode", id: 0x1,
                description: "The value of the NewMode field doesn’t match any entries in the SupportedModes attribute.",
                xref: "cluster§1.10.7.2.1.2"
            }),
            Field({
                name: "GenericFailure", id: 0x2,
                description: "Generic failure code, indicating that switching to the mode indicated by the NewMode field is not allowed or not possible.",
                xref: "cluster§1.10.7.2.1.2"
            }),
            Field({
                name: "InvalidInMode", id: 0x3,
                description: "The received request cannot be handled due to the current mode of the device",
                xref: "cluster§1.10.7.2.1.2"
            })
        ),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§1.10.8" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§1.10.8" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§1.10.8" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§1.10.8" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§1.10.8" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§1.10.8" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§1.10.8" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§1.10.8" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§1.10.8" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§1.10.8" })
        )
    ),

    Cluster(
        {
            name: "LowPower", id: 0x508, classification: "application", pics: "LOWPOWER", xref: "cluster§1.11",

            details: "This cluster provides an interface for managing low power mode on a device." +
                "\n" +
                "This cluster would be supported on an endpoint that represents a physical device with a low power " +
                "mode. This cluster provides a sleep() command to allow clients to manually put the device into low " +
                "power mode. There is no command here to wake up a sleeping device because that operation often " +
                "involves other protocols such as Wake On LAN. Most devices automatically enter low power mode based " +
                "upon inactivity." +
                "\n" +
                "The cluster server for Low Power is implemented by a device that supports a low power mode, such as " +
                "a TV, Set-top box, or Smart Speaker." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> We have considered a “DisableLowPowerMode” command but have not added it due to suspected issues " +
                "  with energy consumption regulations. This can be added in the future."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),
        Command({
            name: "Sleep", id: 0x0, access: "O", conformance: "M", direction: "request", response: "status",
            xref: "cluster§1.11.4.1",
            details: "This command shall put the device into low power mode."
        })
    ),

    Cluster(
        {
            name: "WakeOnLan", id: 0x503, classification: "application", pics: "WAKEONLAN",
            xref: "cluster§1.12",

            details: "This cluster provides an interface for managing low power mode on a device that supports the Wake On " +
                "LAN or Wake On Wireless LAN (WLAN) protocol (see [Wake On LAN])." +
                "\n" +
                "This cluster would be supported on IP devices that have a low power mode AND support the ability to " +
                "be woken up using the Wake on LAN or Wake on WLAN protocol. This cluster provides the device MAC " +
                "address which is a required input to the Wake on LAN protocol. Besides the MAC address, this cluster " +
                "provides an optional link-local IPv6 address which is useful to support \"Wake on Direct Packet\" used " +
                "by some Ethernet and Wi-Fi devices." +
                "\n" +
                "Acting on the MAC address or link-local IPv6 address information does require the caller to be in " +
                "the same broadcast domain as the destination. To wake the destination up, the caller sends a " +
                "multicast-based magic UDP packet that contains destination’s MAC address in the UDP payload to " +
                "FF02::1, the IPv6 all-nodes link-local multicast group address. If the optional link-local address " +
                "is provided by the destination through this cluster, the caller also sends the magic UDP packet in " +
                "unicast to that link-local address. This unicast-based method is particularly useful for Wi-Fi " +
                "devices, since due to lack of MAC layer retransmission mechanism, multicast over Wi-Fi is not as " +
                "reliable as unicast. If a device provides the link-local address in this cluster, its Ethernet " +
                "controller or Wi-Fi radio shall respond to the IPv6 neighbor solicitation message for the link-local " +
                "address without the need to wake host CPU up. In order to receive the magic or neighbor solicitation " +
                "packets in multicast, the Wi-Fi devices must support Group Temporal Key (GTK) rekey operation in low " +
                "power mode." +
                "\n" +
                "Most devices automatically enter low power mode based upon inactivity." +
                "\n" +
                "The cluster server for Wake on LAN or Wake on WLAN is implemented by a device that supports the Wake " +
                "on LAN/WLAN protocol, such as a TV, Set-top Box, or Smart Speaker."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "MacAddress", id: 0x0, type: "string", access: "R V", conformance: "O", constraint: "max 12",
            quality: "F", xref: "cluster§1.12.4.1",
            details: "Indicates the current MAC address of the device. Only 48-bit MAC Addresses shall be used for this " +
                "attribute as required by the Wake on LAN protocol." +
                "\n" +
                "Format of this attribute shall be an upper-case hex-encoded string representing the hex address, " +
                "like 12345678ABCD."
        }),

        Attribute({
            name: "LinkLocalAddress", id: 0x1, type: "ipv6adr", access: "R V", conformance: "O",
            constraint: "desc", quality: "F", xref: "cluster§1.12.4.2",

            details: "Indicates the current link-local address of the device. Only 128-bit IPv6 link-local addresses shall " +
                "be used for this attribute." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Some companies may consider MAC Address to be protected data subject to PII handling " +
                "  considerations and will therefore choose not to include it or read it. The MAC Address can often " +
                "  be determined using ARP in IPv4 or NDP in IPv6."
        })
    ),

    Cluster(
        {
            name: "Switch", id: 0x3b, classification: "application", pics: "SWTCH", xref: "cluster§1.13",

            details: "This cluster exposes interactions with a switch device, for the purpose of using those interactions " +
                "by other devices." +
                "\n" +
                "Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch " +
                "(e.g. push button), distinguished with their feature flags." +
                "\n" +
                "Interactions with the switch device are exposed as attributes (for the latching switch) and as " +
                "events (for both types of switches)." +
                "\n" +
                "An interested client may subscribe to these attributes/events and thus be informed of the " +
                "interactions, and can perform actions based on this, for example by sending commands to perform an " +
                "action such as controlling a light or a window shade."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.13.4" },
            Field({
                name: "LS", conformance: "O.a", constraint: "0", title: "LatchingSwitch", xref: "cluster§1.13.4.1",
                details: "This feature flag is for a switch that maintains its position after being pressed (or turned)."
            }),
            Field({
                name: "MS", conformance: "O.a", constraint: "1", title: "MomentarySwitch", xref: "cluster§1.13.4.2",
                details: "This feature flag is for a switch that does not maintain its position after being pressed (or " +
                    "turned). After releasing, it goes back to its idle position."
            }),
            Field({
                name: "MSR", conformance: "[MS & !AS]", constraint: "2", title: "MomentarySwitchRelease",
                xref: "cluster§1.13.4.3",
                details: "This feature flag is for a momentary switch that can distinguish and report release events."
            }),

            Field({
                name: "MSL", conformance: "[MS & (MSR | AS)]", constraint: "3", title: "MomentarySwitchLongPress",
                xref: "cluster§1.13.4.4",
                details: "This feature flag is for a momentary switch that can distinguish and report long presses from short " +
                    "presses."
            }),

            Field({
                name: "MSM", conformance: "AS, [MS & MSR]", constraint: "4", title: "MomentarySwitchMultiPress",
                xref: "cluster§1.13.4.5",
                details: "This feature flag is for a momentary switch that can distinguish and report double press and " +
                    "potentially multiple presses with more events, such as triple press, etc."
            }),

            Field({
                name: "AS", conformance: "[MS]", constraint: "5", title: "ActionSwitch", xref: "cluster§1.13.4.6",
                details: "This feature flag indicates simplified handling of events for multi-press-capable switches. See " +
                    "Section 1.13.8, “Sequence of events for MultiPress”."
            })
        ),

        Attribute({
            name: "NumberOfPositions", id: 0x0, type: "uint8", access: "R V", conformance: "M",
            constraint: "min 2", quality: "F", xref: "cluster§1.13.5.1",
            details: "Indicates the maximum number of positions the switch has. Any kind of switch has a minimum of 2 " +
                "positions. Also see Section 1.13.10, “Multi Position Details” for the case NumberOfPositions>2."
        }),

        Attribute({
            name: "CurrentPosition", id: 0x1, type: "uint8", access: "R V", conformance: "M",
            constraint: "max numberOfPositions - 1", quality: "N", xref: "cluster§1.13.5.2",
            details: "Indicates the position of the switch. The valid range is zero to NumberOfPositions - 1." +
                "\n" +
                "CurrentPosition value 0 shall be assigned to the default position of the switch: for example the " +
                "\"open\" state of a rocker switch, or the \"idle\" state of a push button switch."
        }),

        Attribute({
            name: "MultiPressMax", id: 0x2, type: "uint8", access: "R V", conformance: "MSM",
            constraint: "min 2", quality: "F", xref: "cluster§1.13.5.3",

            details: "Indicates how many consecutive presses can be detected and reported by a momentary switch which " +
                "supports multi-press (MSM feature flag set)." +
                "\n" +
                "For example, a momentary switch supporting single press, double press and triple press, but not quad " +
                "press and beyond, would return the value 3." +
                "\n" +
                "When more than MultiPressMax presses are detected within a multi-press sequence:" +
                "\n" +
                "  • The server for cluster revision < 2 SHOULD generate a MultiPressComplete event with the " +
                "    TotalNumberOfPressesCounted field set to the value of the MultiPressMax attribute, and avoid " +
                "    generating any further InitialPress and MultiPressOngoing events until the switch has become " +
                "    fully idle (i.e. no longer in the process of counting presses within the multipress)." +
                "\n" +
                "  • The server for cluster revision >= 2 shall generate a MultiPressComplete event with the " +
                "    TotalNumberOfPressesCounted field set to zero (indicating an aborted sequence), and shall NOT " +
                "    generate any further InitialPress and MultiPressOngoing events until the switch has become fully " +
                "    idle (i.e. no longer in the process of counting presses within the multipress)." +
                "\n" +
                "This approach avoids unintentionally causing intermediate actions where there is a very long " +
                "sequence of presses beyond MultiPressMax that may be taken in account specially by switches (e.g. to " +
                "trigger special behavior such as factory reset for which generating events towards the client is not " +
                "appropriate)."
        }),

        Event(
            {
                name: "SwitchLatched", id: 0x0, access: "V", conformance: "LS", priority: "info",
                xref: "cluster§1.13.6.1",
                details: "This event shall be generated, when the latching switch is moved to a new position. It may have been " +
                    "delayed by debouncing within the switch."
            },

            Field({
                name: "NewPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.1.1",
                details: "This field shall indicate the new value of the CurrentPosition attribute, i.e. after the move."
            })
        ),

        Event(
            {
                name: "InitialPress", id: 0x1, access: "V", conformance: "MS", priority: "info",
                xref: "cluster§1.13.6.2",
                details: "This event shall be generated, when the momentary switch starts to be pressed (after debouncing)."
            },
            Field({
                name: "NewPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.2.1",
                details: "This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed."
            })
        ),

        Event(
            {
                name: "LongPress", id: 0x2, access: "V", conformance: "MSL", priority: "info",
                xref: "cluster§1.13.6.3",

                details: "This event shall be generated when the momentary switch has been pressed for a \"long\" time. The time " +
                    "interval constituting a \"long\" time is manufacturer-determined, since it depends on the switch " +
                    "physics." +
                    "\n" +
                    "  • When the AS feature flag is set, this event:" +
                    "\n" +
                    "    ◦ shall NOT be generated during a multi-press sequence (since a long press is a separate cycle " +
                    "      from any multi-press cycles);" +
                    "\n" +
                    "    ◦ shall only be generated after the first InitialPress following a MultiPressComplete when a " +
                    "      long press is detected after the idle time." +
                    "\n" +
                    "  • Else, when the MSM feature flag is set, this event:" +
                    "\n" +
                    "    ◦ shall NOT be generated during a multi-press sequence (since a long press is a separate cycle " +
                    "      from any multi-press cycles);" +
                    "\n" +
                    "    ◦ shall only be generated after the first InitialPress following a MultiPressComplete when a " +
                    "      long press is detected after the idle time;" +
                    "\n" +
                    "    ◦ shall NOT be generated after a MultiPressOngoing event without an intervening " +
                    "      MultiPressComplete event." +
                    "\n" +
                    "The above constraints imply that for a given activity detection cycle of a switch having MSM and/or " +
                    "MSL feature flags set, the entire activity is either a single long press detection cycle of " +
                    "(InitialPress, LongPress, LongRelease), or a single multi-press detection cycle (ending in " +
                    "MultiPressComplete), where presses that would otherwise be reported as long presses are instead " +
                    "reported as a counted press in the MultiPressComplete event, and as InitialPress/ShortRelease pairs " +
                    "otherwise (where applicable)." +
                    "\n" +
                    "The rationale for this constraint is the ambiguity of interpretation of events when mixing long " +
                    "presses and multi-press events."
            },

            Field({
                name: "NewPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.3.1",
                details: "This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed."
            })
        ),

        Event(
            {
                name: "ShortRelease", id: 0x3, access: "V", conformance: "MSR", priority: "info",
                xref: "cluster§1.13.6.4",

                details: "If the server has the Action Switch (AS) feature flag set, this event shall NOT be generated at all, " +
                    "since setting the Action Switch feature flag forbids the Momentary Switch ShortRelease (MSR) feature " +
                    "flag from being set. Otherwise, the following paragraphs describe the situations where this event is " +
                    "generated." +
                    "\n" +
                    "This event shall be generated, when the momentary switch has been released (after debouncing)." +
                    "\n" +
                    "  • If the server has the Momentary Switch LongPress (MSL) feature flag set, then this event shall " +
                    "    be generated when the switch is released if no LongPress event had been generated since the " +
                    "    previous InitialPress event." +
                    "\n" +
                    "  • If the server does not have the Momentary Switch LongPress (MSL) feature flag set, this event " +
                    "    shall be generated when the switch is released - even when the switch was pressed for a long " +
                    "    time." +
                    "\n" +
                    "  • Also see Section 1.13.7, “Sequence of generated events”."
            },

            Field({
                name: "PreviousPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.4.1",
                details: "This field shall indicate the previous value of the CurrentPosition attribute, i.e. just prior to " +
                    "release."
            })
        ),

        Event(
            {
                name: "LongRelease", id: 0x4, access: "V", conformance: "MSL", priority: "info",
                xref: "cluster§1.13.6.5",
                details: "This event shall be generated, when the momentary switch has been released (after debouncing) and " +
                    "after having been pressed for a long time, i.e. this event shall be generated when the switch is " +
                    "released if a LongPress event has been generated since the previous InitialPress event. Also see " +
                    "Section 1.13.7, “Sequence of generated events”."
            },

            Field({
                name: "PreviousPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.5.1",
                details: "This field shall indicate the previous value of the CurrentPosition attribute, i.e. just prior to " +
                    "release."
            })
        ),

        Event(
            {
                name: "MultiPressOngoing", id: 0x5, access: "V", conformance: "MSM & !AS", priority: "info",
                xref: "cluster§1.13.6.6",
                details: "If the server has the Action Switch (AS) feature flag set, this event shall NOT be generated at all. " +
                    "Otherwise, the following paragraphs describe the situations where this event is generated." +
                    "\n" +
                    "This event shall be generated to indicate how many times the momentary switch has been pressed in a " +
                    "multi-press sequence, during that sequence. See Section 1.13.8, “Sequence of events for MultiPress”."
            },

            Field({
                name: "NewPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1", xref: "cluster§1.13.6.6.1",
                details: "This field shall indicate the new value of the CurrentPosition attribute, i.e. while pressed."
            }),

            Field({
                name: "CurrentNumberOfPressesCounted", id: 0x1, type: "uint8", conformance: "M",
                constraint: "2 to multiPressMax", xref: "cluster§1.13.6.6.2",

                details: "This field shall contain:" +
                    "\n" +
                    "  • a value of 2 when the second press of a multi-press sequence has been detected," +
                    "\n" +
                    "  • a value of 3 when the third press of a multi-press sequence has been detected," +
                    "\n" +
                    "  • a value of N when the Nth press of a multi-press sequence has been detected."
            })
        ),

        Event(
            {
                name: "MultiPressComplete", id: 0x6, access: "V", conformance: "MSM", priority: "info",
                xref: "cluster§1.13.6.7",

                details: "This event shall be generated to indicate how many times the momentary switch has been pressed in a " +
                    "multi-press sequence, after it has been detected that the sequence has ended. See Section 1.13.8, " +
                    "“Sequence of events for MultiPress”." +
                    "\n" +
                    "The PreviousPosition field shall indicate the previous value of the CurrentPosition attribute, i.e. " +
                    "just prior to release." +
                    "\n" +
                    "The TotalNumberOfPressesCounted field shall contain:" +
                    "\n" +
                    "  • a value of 0 when there was an aborted multi-press sequence, where the number of presses goes " +
                    "    beyond MultiPressMax presses," +
                    "\n" +
                    "  • a value of 1 when there was exactly one press in a multi-press sequence (and the sequence has " +
                    "    ended), i.e. there was no double press (or more)," +
                    "\n" +
                    "  • a value of 2 when there were exactly two presses in a multi-press sequence (and the sequence has " +
                    "    ended)," +
                    "\n" +
                    "  • a value of 3 when there were exactly three presses in a multi-press sequence (and the sequence " +
                    "    has ended)," +
                    "\n" +
                    "  • a value of N when there were exactly N presses in a multi-press sequence (and the sequence has " +
                    "    ended)." +
                    "\n" +
                    "    > [!NOTE]" +
                    "\n" +
                    "    > The introduction of TotalNumberOfPressesCounted supporting the value 0 may impact clients of " +
                    "      switches using cluster revision 1 since such servers would not use this value of " +
                    "      TotalNumberOfPressesCounted to indicate an aborted sequence. Clients SHOULD always act using " +
                    "      the TotalNumberOfPressesCounted field taken into account since for values from 1 to " +
                    "      MultiPressMax, the user action that led to the event was different depending on the count."
            },

            Field({
                name: "PreviousPosition", id: 0x0, type: "uint8", conformance: "M",
                constraint: "0 to numberOfPositions - 1"
            }),
            Field({
                name: "TotalNumberOfPressesCounted", id: 0x1, type: "uint8", conformance: "M",
                constraint: "max multiPressMax"
            })
        )
    ),

    Cluster(
        {
            name: "OperationalState", id: 0x60, classification: "application", pics: "OPSTATE",
            xref: "cluster§1.14",

            details: "This cluster supports remotely monitoring and, where supported, changing the operational state of " +
                "any device where a state machine is a part of the operation." +
                "\n" +
                "This cluster defines common states, scoped to this cluster (e.g. Stopped, Running, Paused, Error). A " +
                "derived cluster specification may define more states scoped to the derivation. Manufacturer specific " +
                "states are supported in this cluster and any derived clusters thereof. When defined in a derived " +
                "instance, such states are scoped to the derivation." +
                "\n" +
                "Actual state transitions are dependent on both the implementation, and the requirements that may " +
                "additionally be imposed by a derived cluster." +
                "\n" +
                "An implementation that supports remotely starting its operation can make use of this cluster’s Start " +
                "command to do so. A device that supports remote pause or stop of its currently selected operation " +
                "can similarly make use of this cluster’s Pause and Stop commands to do so. The ability to remotely " +
                "pause or stop is independent of how the operation was started (for example, an operation started by " +
                "using a manual button press can be stopped by using a Stop command if the device supports remotely " +
                "stopping the operation)." +
                "\n" +
                "Additionally, this cluster provides events for monitoring the operational state of the device."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            {
                name: "PhaseList", id: 0x0, type: "list", access: "R V", conformance: "M",
                constraint: "max 32[max 64]", quality: "X", xref: "cluster§1.14.5.1",

                details: "Indicates a list of names of different phases that the device can go through for the selected " +
                    "function or mode. The list may not be in sequence order. For example in a washing machine this could " +
                    "include items such as \"pre-soak\", \"rinse\", and \"spin\". These phases are manufacturer specific and " +
                    "may change when a different function or mode is selected." +
                    "\n" +
                    "A null value indicates that the device does not present phases during its operation. When this " +
                    "attribute’s value is null, the CurrentPhase attribute shall also be set to null."
            },

            Field({ name: "entry", type: "string" })
        ),

        Attribute({
            name: "CurrentPhase", id: 0x1, type: "uint8", access: "R V", conformance: "M", constraint: "desc",
            quality: "X", xref: "cluster§1.14.5.2",

            details: "This attribute represents the current phase of operation being performed by the server. This shall " +
                "be the positional index representing the value from the set provided in the PhaseList Attribute, " +
                "where the first item in that list is an index of 0. Thus, this attribute shall have a maximum value " +
                "that is \"length(PhaseList) - 1\"." +
                "\n" +
                "Null if the PhaseList attribute is null or if the PhaseList attribute is an empty list."
        }),

        Attribute({
            name: "CountdownTime", id: 0x2, type: "elapsed-s", access: "R V", conformance: "O",
            constraint: "max 259200", default: null, quality: "X Q", xref: "cluster§1.14.5.3",

            details: "Indicates the estimated time left before the operation is completed, in seconds." +
                "\n" +
                "A value of 0 (zero) means that the operation has completed." +
                "\n" +
                "A value of null represents that there is no time currently defined until operation completion. This " +
                "may happen, for example, because no operation is in progress or because the completion time is " +
                "unknown." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • If it has changed due to a change in the CurrentPhase or OperationalState attributes, or" +
                "\n" +
                "  • When it changes from 0 to any other value and vice versa, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa, or" +
                "\n" +
                "  • When it increases, or" +
                "\n" +
                "  • When there is any increase or decrease in the estimated time remaining that was due to " +
                "    progressing insight of the server’s control logic, or" +
                "\n" +
                "  • When it changes at a rate significantly different from one unit per second." +
                "\n" +
                "Changes to this attribute merely due to the normal passage of time with no other dynamic change of " +
                "device state shall NOT be reported." +
                "\n" +
                "As this attribute is not being reported during a regular countdown, clients SHOULD NOT rely on the " +
                "reporting of this attribute in order to keep track of the remaining duration."
        }),

        Attribute(
            {
                name: "OperationalStateList", id: 0x3, type: "list", access: "R V", conformance: "M",
                constraint: "desc", xref: "cluster§1.14.5.4",

                details: "This attribute describes the set of possible operational states that the device exposes. An " +
                    "operational state is a fundamental device state such as Running or Error. Details of the phase of a " +
                    "device when, for example, in a state of Running are provided by the CurrentPhase attribute." +
                    "\n" +
                    "All devices shall, at a minimum, expose the set of states matching the commands that are also " +
                    "supported by the cluster instance, in addition to Error. The set of possible device states are " +
                    "defined in the OperationalStateEnum. A device type requiring implementation of this cluster shall " +
                    "define the set of states that are applicable to that specific device type."
            },

            Field({ name: "entry", type: "OperationalStateStruct" })
        ),

        Attribute({
            name: "OperationalState", id: 0x4, type: "OperationalStateEnum", access: "R V", conformance: "M",
            xref: "cluster§1.14.5.5",
            details: "This attribute specifies the current operational state of a device. This shall be populated with a " +
                "valid OperationalStateID from the set of values in the OperationalStateList Attribute."
        }),

        Attribute({
            name: "OperationalError", id: 0x5, type: "ErrorStateStruct", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§1.14.5.6",
            details: "This attribute shall specify the details of any current error condition being experienced on the " +
                "device when the OperationalState attribute is populated with Error. See Section 1.14.4.4, " +
                "“ErrorStateStruct Type” for general requirements on the population of this attribute." +
                "\n" +
                "When there is no error detected, this shall have an ErrorStateID of NoError."
        }),

        Event(
            {
                name: "OperationalError", id: 0x0, access: "V", conformance: "M", priority: "critical",
                xref: "cluster§1.14.7.1",
                details: "This event is generated when a reportable error condition is detected. A device that generates this " +
                    "event shall also set the OperationalState attribute to Error, indicating an error condition." +
                    "\n" +
                    "This event shall contain the following fields:"
            },

            Field({ name: "ErrorState", id: 0x0, type: "ErrorStateStruct", conformance: "M" })
        ),

        Event(
            {
                name: "OperationCompletion", id: 0x1, access: "V", conformance: "O", priority: "info",
                xref: "cluster§1.14.7.2",

                details: "This event SHOULD be generated when the overall operation ends, successfully or otherwise. For " +
                    "example, the completion of a cleaning operation in a Robot Vacuum Cleaner, or the completion of a " +
                    "wash cycle in a Washing Machine." +
                    "\n" +
                    "It is highly recommended that appliances device types employing the Operational State cluster " +
                    "support this event, even if it is optional. This assists clients in executing automations or issuing " +
                    "notifications at critical points in the device operation cycles." +
                    "\n" +
                    "This event shall contain the following fields:"
            },

            Field({
                name: "CompletionErrorCode", id: 0x0, type: "enum8", conformance: "M", xref: "cluster§1.14.7.2.1",
                details: "This field provides an indication of the state at the end of the operation. This field shall have a " +
                    "value from the ErrorStateEnum set. A value of NoError indicates success, that is, no error has been " +
                    "detected."
            }),

            Field({
                name: "TotalOperationalTime", id: 0x1, type: "elapsed-s", conformance: "O", quality: "X",
                xref: "cluster§1.14.7.2.2",
                details: "The total operational time, in seconds, from when the operation was started via an initial Start " +
                    "command or autonomous/manual starting action, until the operation completed. This includes any time " +
                    "spent while paused. There may be cases whereby the total operational time exceeds the maximum value " +
                    "that can be conveyed by this attribute, in such instances, this attribute shall be populated with " +
                    "null."
            }),

            Field({
                name: "PausedTime", id: 0x2, type: "elapsed-s", conformance: "O", quality: "X",
                xref: "cluster§1.14.7.2.3",
                details: "The total time spent in the paused state, in seconds. There may be cases whereby the total paused " +
                    "time exceeds the maximum value that can be conveyed by this attribute, in such instances, this " +
                    "attribute shall be populated with null."
            })
        ),

        Command({
            name: "Pause", id: 0x0, access: "O", conformance: "Resume, O", direction: "request",
            response: "OperationalCommandResponse", xref: "cluster§1.14.6.1",

            details: "This command shall be supported if the device supports remotely pausing the operation. If this " +
                "command is supported, the Resume command shall also be supported." +
                "\n" +
                "On receipt of this command, the device shall pause its operation if it is possible based on the " +
                "current function of the server. For example, if it is at a point where it is safe to do so and/or " +
                "permitted, but can be restarted from the point at which pause occurred." +
                "\n" +
                "If this command is received when already in the Paused state the device shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of NoError but take no further action." +
                "\n" +
                "A device that receives this command in any state which is not Pause-compatible shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of CommandInvalidInState and shall take no " +
                "further action." +
                "\n" +
                "States are defined as Pause-compatible as follows:" +
                "\n" +
                "  • For states defined in this cluster specification, in Table 3, “Pause Compatibility”." +
                "\n" +
                "  • For states defined by derived cluster specifications, in the corresponding specifications." +
                "\n" +
                "  • For manufacturer-specific states, by the manufacturer." +
                "\n" +
                "A device that is unable to honor the Pause command for whatever reason shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of CommandInvalidInState but take no further " +
                "action." +
                "\n" +
                "Otherwise, on success:" +
                "\n" +
                "  • The OperationalState attribute shall be set to Paused." +
                "\n" +
                "  • The device shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "    NoError." +
                "\n" +
                "The following table defines the compatibility of this cluster’s states with the Pause command." +
                "\n" +
                "### Table 3. Pause Compatibility"
        }),

        Command({
            name: "Stop", id: 0x1, access: "O", conformance: "Start, O", direction: "request",
            response: "OperationalCommandResponse", xref: "cluster§1.14.6.2",

            details: "This command shall be supported if the device supports remotely stopping the operation." +
                "\n" +
                "On receipt of this command, the device shall stop its operation if it is at a position where it is " +
                "safe to do so and/or permitted. Restart of the device following the receipt of the Stop command " +
                "shall require attended operation unless remote start is allowed by the device type and any " +
                "jurisdiction governing remote operation of the device." +
                "\n" +
                "If this command is received when already in the Stopped state the device shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of NoError but take no further action." +
                "\n" +
                "A device that is unable to honor the Stop command for whatever reason shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of CommandInvalidInState but take no further " +
                "action." +
                "\n" +
                "Otherwise, on success:" +
                "\n" +
                "  • The OperationalState attribute shall be set to Stopped." +
                "\n" +
                "  • The device shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "    NoError."
        }),

        Command({
            name: "Start", id: 0x2, access: "O", conformance: "O", direction: "request",
            response: "OperationalCommandResponse", xref: "cluster§1.14.6.3",

            details: "This command shall be supported if the device supports remotely starting the operation. If this " +
                "command is supported, the 'Stop command shall also be supported." +
                "\n" +
                "On receipt of this command, the device shall start its operation if it is safe to do so and the " +
                "device is in an operational state from which it can be started. There may be either regulatory or " +
                "manufacturer-imposed safety and security requirements that first necessitate some specific action at " +
                "the device before a Start command can be honored. In such instances, a device shall respond with a " +
                "status code of CommandInvalidInState if a Start command is received prior to the required on-device " +
                "action." +
                "\n" +
                "If this command is received when already in the Running state the device shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of NoError but take no further action." +
                "\n" +
                "A device that is unable to honor the Start command for whatever reason shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of UnableToStartOrResume but take no further " +
                "action." +
                "\n" +
                "Otherwise, on success:" +
                "\n" +
                "  • The OperationalState attribute shall be set to Running." +
                "\n" +
                "  • The device shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "    NoError."
        }),

        Command({
            name: "Resume", id: 0x3, access: "O", conformance: "Pause, O", direction: "request",
            response: "OperationalCommandResponse", xref: "cluster§1.14.6.4",

            details: "This command shall be supported if the device supports remotely resuming the operation. If this " +
                "command is supported, the Pause command shall also be supported." +
                "\n" +
                "On receipt of this command, the device shall resume its operation from the point it was at when it " +
                "received the Pause command, or from the point when it was paused by means outside of this cluster " +
                "(for example by manual button press)." +
                "\n" +
                "If this command is received when already in the Running state the device shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of NoError but take no further action." +
                "\n" +
                "A device that receives this command in any state which is not Resume-compatible shall respond with " +
                "an OperationalCommandResponse command with an ErrorStateID of CommandInvalidInState and shall take " +
                "no further action." +
                "\n" +
                "States are defined as Resume-compatible as follows:" +
                "\n" +
                "  • For states defined in this cluster specification, in Table 4, “Resume Compatibility”." +
                "\n" +
                "  • For states defined by derived cluster specifications, in the corresponding specifications." +
                "\n" +
                "  • For manufacturer-specific states, by the manufacturer." +
                "\n" +
                "The following table defines the compatibility of this cluster’s states with the Resume command." +
                "\n" +
                "### Table 4. Resume Compatibility" +
                "\n" +
                "A device that is unable to honor the Resume command for any other reason shall respond with an " +
                "OperationalCommandResponse command with an ErrorStateID of UnableToStartOrResume but take no further " +
                "action." +
                "\n" +
                "Otherwise, on success:" +
                "\n" +
                "  • The OperationalState attribute shall be set to the most recent non-Error operational state prior " +
                "    to entering the Paused state." +
                "\n" +
                "  • The device shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "    NoError."
        }),

        Command(
            {
                name: "OperationalCommandResponse", id: 0x4, access: "O",
                conformance: "Pause | Stop | Start | Resume", direction: "response", xref: "cluster§1.14.6.5",

                details: "This command shall be supported by an implementation if any of the other commands defined by this " +
                    "cluster are supported (i.e. listed in the AcceptedCommandList global attribute). This command shall " +
                    "also be supported by an implementation of a derived cluster as a response to any commands that may " +
                    "be additionally defined therein." +
                    "\n" +
                    "This command shall be generated in response to any of the Start, Stop, Pause, or Resume commands."
            },

            Field({
                name: "CommandResponseState", id: 0x0, type: "ErrorStateStruct", conformance: "M",
                xref: "cluster§1.14.6.5.1",
                details: "This shall indicate the success or otherwise of the attempted command invocation. On a successful " +
                    "invocation of the attempted command, the ErrorStateID shall be populated with NoError. See the " +
                    "individual command sections for additional specific requirements on population."
            })
        ),

        Datatype(
            {
                name: "OperationalStateEnum", type: "enum8", xref: "cluster§1.14.4.1",

                details: "This type defines the set of known operational state values, and is derived from enum8. The " +
                    "following table defines the applicable ranges for values that are defined within this type. All " +
                    "values that are undefined shall be treated as reserved. As shown by the table, states that may be " +
                    "specific to a certain Device Type or other modality shall be defined in a derived cluster of this " +
                    "cluster." +
                    "\n" +
                    "The derived cluster-specific state definitions shall NOT duplicate any general state definitions. " +
                    "That is, a derived cluster specification of this cluster cannot define states with the same " +
                    "semantics as the general states defined below." +
                    "\n" +
                    "A manufacturer-specific state definition shall NOT duplicate the general state definitions or " +
                    "derived cluster state definitions. That is, a manufacturer-defined state defined for this cluster or " +
                    "a derived cluster thereof cannot define a state with the same semantics as the general states " +
                    "defined below or states defined in a derived cluster. Such manufacturer-specific state definitions " +
                    "shall be scoped in the context of the Vendor ID present in the Basic Information cluster." +
                    "\n" +
                    "The following table defines the generally applicable states."
            },

            Field({ name: "Stopped", id: 0x0, conformance: "M", description: "The device is stopped" }),
            Field({ name: "Running", id: 0x1, conformance: "M", description: "The device is operating" }),
            Field({ name: "Paused", id: 0x2, conformance: "M", description: "The device is paused during an operation" }),
            Field({ name: "Error", id: 0x3, conformance: "M", description: "The device is in an error state" })
        ),

        Datatype(
            {
                name: "OperationalStateStruct", type: "struct", xref: "cluster§1.14.4.2",
                details: "The OperationalStateStruct is used to indicate a possible state of the device."
            },
            Field({
                name: "OperationalStateId", id: 0x0, type: "OperationalStateEnum", conformance: "M", default: 0,
                xref: "cluster§1.14.4.2.1",
                details: "This shall be populated with a value from the OperationalStateEnum."
            }),

            Field({
                name: "OperationalStateLabel", id: 0x1, type: "string",
                conformance: "OperationalStateID >= 128 & OperationalStateID <= 191", constraint: "max 64",
                xref: "cluster§1.14.4.2.2",
                details: "This field is present when the OperationalStateID is from the set reserved for Manufacturer Specific " +
                    "States. If present, this shall contain a human-readable description of the operational state."
            })
        ),

        Datatype(
            {
                name: "ErrorStateEnum", type: "enum8", xref: "cluster§1.14.4.3",

                details: "This type defines the set of known operational error values, and is derived from enum8. The " +
                    "following table defines the applicable ranges for values that are defined within this type. All " +
                    "values that are undefined shall be treated as reserved. As shown by the table, errors that may be " +
                    "specific to a certain Device Type or other modality shall be defined in a derived cluster of this " +
                    "cluster." +
                    "\n" +
                    "The derived cluster-specific error definitions shall NOT duplicate the general error definitions. " +
                    "That is, a derived cluster specification of this cluster cannot define errors with the same " +
                    "semantics as the general errors defined below." +
                    "\n" +
                    "The manufacturer-specific error definitions shall NOT duplicate the general error definitions or " +
                    "derived cluster-specific error definitions. That is, a manufacturer-defined error defined for this " +
                    "cluster or a derived cluster thereof cannot define errors with the same semantics as the general " +
                    "errors defined below or errors defined in a derived cluster. Such manufacturer-specific error " +
                    "definitions shall be scoped in the context of the Vendor ID present in the Basic Information " +
                    "cluster." +
                    "\n" +
                    "The set of ErrorStateID field values defined in each of the generic or derived Operational State " +
                    "cluster specifications is called ErrorState."
            },

            Field({ name: "NoError", id: 0x0, conformance: "M", description: "The device is not in an error state" }),
            Field({
                name: "UnableToStartOrResume", id: 0x1, conformance: "M",
                description: "The device is unable to start or resume operation"
            }),
            Field({
                name: "UnableToCompleteOperation", id: 0x2, conformance: "M",
                description: "The device was unable to complete the current operation"
            }),
            Field({
                name: "CommandInvalidInState", id: 0x3, conformance: "M",
                description: "The device cannot process the command in its current state"
            })
        ),

        Datatype(
            { name: "ErrorStateStruct", type: "struct", xref: "cluster§1.14.4.4" },
            Field({
                name: "ErrorStateId", id: 0x0, type: "ErrorStateEnum", conformance: "M", default: 0,
                xref: "cluster§1.14.4.4.1",
                details: "This shall be populated with a value from the ErrorStateEnum."
            }),

            Field({
                name: "ErrorStateLabel", id: 0x1, type: "string",
                conformance: "ErrorStateID >= 128 & ErrorStateID <= 191", constraint: "max 64",
                xref: "cluster§1.14.4.4.2",
                details: "This field is present when the ErrorStateID is from the set reserved for Manufacturer Specific " +
                    "errors. If present, this shall contain a human-readable description of the error state."
            }),

            Field({
                name: "ErrorStateDetails", id: 0x2, type: "string", conformance: "O", constraint: "max 64",
                xref: "cluster§1.14.4.4.3",
                details: "This shall be a human-readable string that provides details about the error condition. As an " +
                    "example, if the ErrorStateID indicates that the device is a Robotic Vacuum that is stuck, the " +
                    "ErrorStateDetails contains \"left wheel blocked\"."
            })
        )
    ),

    Cluster(
        {
            name: "AlarmBase", classification: "application", pics: "ALARM", xref: "cluster§1.15",
            details: "This cluster is a base cluster from which clusters for particular alarms for a device type can be " +
                "derived. Each derivation shall define the values for the AlarmBitmap data type used in this cluster. " +
                "Each derivation shall define which alarms are latched."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.15.4" },
            Field({
                name: "RESET", constraint: "0", title: "Reset", xref: "cluster§1.15.4.1",
                details: "This feature indicates that alarms can be reset via the Reset command."
            })
        ),

        Attribute({
            name: "Mask", id: 0x0, type: "AlarmBitmap", access: "R V", conformance: "M",
            xref: "cluster§1.15.6.1",
            details: "Indicates a bitmap where each bit set in the Mask attribute corresponds to an alarm that shall be " +
                "enabled."
        }),

        Attribute({
            name: "Latch", id: 0x1, type: "AlarmBitmap", access: "R V", conformance: "RESET", quality: "F",
            xref: "cluster§1.15.6.2",
            details: "Indicates a bitmap where each bit set in the Latch attribute shall indicate that the corresponding " +
                "alarm will be latched when set, and will not reset to inactive when the underlying condition which " +
                "caused the alarm is no longer present, and so requires an explicit reset using the Reset command."
        }),

        Attribute({
            name: "State", id: 0x2, type: "AlarmBitmap", access: "R V", conformance: "M",
            xref: "cluster§1.15.6.3",
            details: "Indicates a bitmap where each bit shall represent the state of an alarm. The value of true means the " +
                "alarm is active, otherwise the alarm is inactive."
        }),

        Attribute({
            name: "Supported", id: 0x3, type: "AlarmBitmap", access: "R V", conformance: "M", quality: "F",
            xref: "cluster§1.15.6.4",
            details: "Indicates a bitmap where each bit shall represent whether or not an alarm is supported. The value of " +
                "true means the alarm is supported, otherwise the alarm is not supported." +
                "\n" +
                "If an alarm is not supported, the corresponding bit in Mask, Latch, and State shall be false."
        }),

        Event(
            {
                name: "Notify", id: 0x0, access: "V", conformance: "M", priority: "info", xref: "cluster§1.15.8.1",
                details: "This event shall be generated when one or more alarms change state."
            },
            Field({
                name: "Active", id: 0x0, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.8.1.1",
                details: "This field shall indicate those alarms that have become active."
            }),
            Field({
                name: "Inactive", id: 0x1, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.8.1.2",
                details: "This field shall indicate those alarms that have become inactive."
            }),

            Field({
                name: "State", id: 0x2, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.8.1.4",
                details: "This field shall be a copy of the new State attribute value that resulted in the event being " +
                    "generated. That is, this field shall have all the bits in Active set and shall NOT have any of the " +
                    "bits in Inactive set."
            }),

            Field({
                name: "Mask", id: 0x3, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.8.1.3",
                details: "This field shall be a copy of the Mask attribute when this event was generated."
            })
        ),

        Command(
            {
                name: "Reset", id: 0x0, access: "O", conformance: "RESET", direction: "request", response: "status",
                xref: "cluster§1.15.7.1",
                details: "This command resets active and latched alarms (if possible). Any generated Notify event shall " +
                    "contain fields that represent the state of the server after the command has been processed."
            },

            Field({
                name: "Alarms", id: 0x0, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.7.1.1",
                details: "This field shall indicate a bitmap where each bit set in this field corresponds to an alarm that " +
                    "shall be reset to inactive in the State attribute unless the alarm definition requires manual " +
                    "intervention. If the alarms indicated are successfully reset, the response status code shall be " +
                    "SUCCESS, otherwise, the response status code shall be FAILURE."
            })
        ),

        Command(
            {
                name: "ModifyEnabledAlarms", id: 0x1, access: "O", conformance: "O", direction: "request",
                response: "status", xref: "cluster§1.15.7.2",
                details: "This command allows a client to request that an alarm be enabled or suppressed at the server."
            },

            Field({
                name: "Mask", id: 0x0, type: "AlarmBitmap", conformance: "M", xref: "cluster§1.15.7.2.1",

                details: "This field shall indicate a bitmap where each bit set in the this field corresponds to an alarm that " +
                    "SHOULD be enabled or suppressed. A value of 1 shall indicate that the alarm SHOULD be enabled while " +
                    "a value of 0 shall indicate that the alarm SHOULD be suppressed." +
                    "\n" +
                    "A server that receives this command with a Mask that includes bits that are set for unknown alarms " +
                    "shall respond with a status code of INVALID_COMMAND." +
                    "\n" +
                    "A server that receives this command with a Mask that includes bits that are set for alarms which are " +
                    "not supported, as indicated in the Supported attribute, shall respond with a status code of " +
                    "INVALID_COMMAND." +
                    "\n" +
                    "A server that is unable to enable a currently suppressed alarm, or is unable to suppress a currently " +
                    "enabled alarm shall respond with a status code of FAILURE; otherwise the server shall respond with a " +
                    "status code of SUCCESS." +
                    "\n" +
                    "On a SUCCESS case, the server shall also change the value of the Mask attribute to the value of the " +
                    "Mask field from this command. After that the server shall also update the value of its State " +
                    "attribute to reflect the status of the new alarm set as indicated by the new value of the Mask " +
                    "attribute."
            })
        ),

        Datatype({
            name: "AlarmBitmap", type: "map32", xref: "cluster§1.15.5.1",
            details: "This data type shall be a map32 with values defined by the derived cluster. The meaning of each bit " +
                "position shall be consistent for all attributes in a derived cluster. That is, if bit 0 is defined " +
                "for an alarm, the Latch, State, and Supported information for that alarm are also bit 0."
        })
    ),

    Cluster(
        {
            name: "Messages", id: 0x97, classification: "application", pics: "MESS", xref: "cluster§1.16",
            details: "This cluster provides an interface for passing messages to be presented by a device."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.16.4" },

            Field({
                name: "CONF", conformance: "O", constraint: "0", title: "ReceivedConfirmation",
                xref: "cluster§1.16.4.1",
                details: "This feature shall indicate that the device can get confirmation from a user that the message was " +
                    "received."
            }),

            Field({
                name: "RESP", conformance: "[CONF]", constraint: "1", title: "ConfirmationResponse",
                xref: "cluster§1.16.4.2",
                details: "This feature shall indicate that the device is capable of presenting a list of responses to the user " +
                    "and recording the user’s choice of response."
            }),

            Field({
                name: "RPLY", conformance: "[CONF]", constraint: "2", title: "ConfirmationReply",
                xref: "cluster§1.16.4.3",
                details: "This feature shall indicate that the device is capable of collecting a free-form text response to a " +
                    "message."
            }),

            Field({
                name: "PROT", conformance: "O", constraint: "3", title: "ProtectedMessages",
                xref: "cluster§1.16.4.4",
                details: "This feature shall indicate that the device is capable of requiring the user to authenticate before " +
                    "viewing a message; e.g. entering a PIN or password before viewing a message with billing " +
                    "information."
            })
        ),

        Attribute(
            {
                name: "Messages", id: 0x0, type: "list", access: "R F V", conformance: "M", constraint: "max 8",
                xref: "cluster§1.16.6.1",
                details: "Indicates a list of queued messages." +
                    "\n" +
                    "In addition to filtering based upon fabric, to preserve user privacy, the server may further limit " +
                    "the set of messages returned in a read request. At minimum, the server shall return to a client " +
                    "those messages that the client itself created/submitted."
            },

            Field({ name: "entry", type: "MessageStruct" })
        ),

        Attribute(
            {
                name: "ActiveMessageIDs", id: 0x1, type: "list", access: "R V", conformance: "M",
                constraint: "max 8", xref: "cluster§1.16.6.2",
                details: "Indicates a list of the MessageIDs of the Messages currently being presented. If this list is empty, " +
                    "no messages are currently being presented." +
                    "\n" +
                    "This list shall NOT be fabric-scoped; it shall contain MessageIDs for all Messages being presented, " +
                    "no matter what fabric the client that queued them is on."
            },

            Field({ name: "entry", type: "MessageID" })
        ),

        Event(
            {
                name: "MessageQueued", id: 0x0, access: "S V", conformance: "M", priority: "info",
                xref: "cluster§1.16.8.1",
                details: "This event shall be generated when a message is added to the messages attribute."
            },
            Field({
                name: "MessageId", id: 0x0, type: "MessageID", access: "S", conformance: "M",
                xref: "cluster§1.16.8.1.1",
                details: "This field shall indicate the MessageID for newly added message."
            }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Event(
            {
                name: "MessagePresented", id: 0x1, access: "S V", conformance: "M", priority: "info",
                xref: "cluster§1.16.8.2",
                details: "This event shall be generated when the message is presented to the user."
            },
            Field({
                name: "MessageId", id: 0x0, type: "MessageID", access: "S", conformance: "M",
                xref: "cluster§1.16.8.2.1",
                details: "This field shall indicate the MessageID for the message being presented."
            }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Event(
            {
                name: "MessageComplete", id: 0x2, access: "S V", conformance: "M", priority: "info",
                xref: "cluster§1.16.8.3",
                details: "This event shall be generated when the message is confirmed by the user, or when the Duration field " +
                    "of the message has elapsed without confirmation."
            },

            Field({
                name: "MessageId", id: 0x0, type: "MessageID", access: "S", conformance: "M",
                xref: "cluster§1.16.8.3.1",
                details: "This field shall indicate the MessageID for the message being confirmed."
            }),

            Field({
                name: "ResponseId", id: 0x1, type: "uint32", access: "S", conformance: "RESP", quality: "X",
                xref: "cluster§1.16.8.3.2",
                details: "This field shall indicate the MessageResponseID selected by the user. If there was no response " +
                    "before the Duration field of the message has elapsed, this field shall be null."
            }),

            Field({
                name: "Reply", id: 0x2, type: "string", access: "S", conformance: "RPLY", constraint: "max 256",
                quality: "X", xref: "cluster§1.16.8.3.3",
                details: "This field shall indicate a user-provided reply to the message. If there was no reply, or the " +
                    "message did not have the ReplyRequired bit set, this field shall be null."
            }),

            Field({
                name: "FutureMessagesPreference", id: 0x3, type: "FutureMessagePreferenceEnum", access: "S",
                conformance: "M", quality: "X"
            }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "PresentMessagesRequest", id: 0x0, access: "F O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.16.7.1",

                details: "Upon receipt, this shall cause the message in the passed fields to be appended to the Messages " +
                    "attribute." +
                    "\n" +
                    "If appending the message would cause the number of messages to be greater than the capacity of the " +
                    "list, the device shall NOT append any message to Messages, and shall return a status code of " +
                    "RESOURCE_EXHAUSTED." +
                    "\n" +
                    "When displaying a message in response to this command, an indication (ex. visual) of the origin node " +
                    "of the command shall be provided. This could be in the form of a friendly name label which uniquely " +
                    "identifies the node to the user. This friendly name label is typically assigned by the Matter Admin " +
                    "at the time of commissioning and, when it’s a device, is often editable by the user. It might be a " +
                    "combination of a company name and friendly name, for example, ”Acme” or “Acme Streaming Service on " +
                    "Alice’s Phone”." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> It is currently not specified where the friendly name label can be found on the node, meaning that " +
                    "  clients SHOULD NOT rely on a certain method they happen to observe in a particular server " +
                    "  instance, since other instances could employ a different method." +
                    "\n" +
                    "The device SHOULD make it possible for the user to view which nodes have access to this cluster and " +
                    "to individually remove privileges for each node."
            },

            Field({
                name: "MessageId", id: 0x0, type: "MessageID", conformance: "M", xref: "cluster§1.16.7.1.1",
                details: "This field shall indicate a globally unique ID for this message. See MessageID."
            }),
            Field({
                name: "Priority", id: 0x1, type: "MessagePriorityEnum", conformance: "M",
                xref: "cluster§1.16.7.1.2",
                details: "This field shall indicate the priority level for this message. See Priority."
            }),
            Field({
                name: "MessageControl", id: 0x2, type: "MessageControlBitmap", conformance: "M",
                xref: "cluster§1.16.7.1.3",
                details: "This field shall indicate control information related to the message. See MessageControl."
            }),

            Field({
                name: "StartTime", id: 0x3, type: "epoch-s", conformance: "M", quality: "X",
                xref: "cluster§1.16.7.1.4",
                details: "This field shall indicate the time in UTC at which the message becomes available to be presented. A " +
                    "null value shall indicate \"now.\" See StartTime."
            }),

            Field({
                name: "Duration", id: 0x4, type: "uint64", conformance: "M", quality: "X",
                xref: "cluster§1.16.7.1.5",
                details: "This field shall indicate the amount of time, in milliseconds, after the StartTime during which the " +
                    "message is available to be presented. A null value shall indicate \"until changed\". See Duration."
            }),

            Field({
                name: "MessageText", id: 0x5, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§1.16.7.1.6",
                details: "This field shall indicate a string containing the message to be presented. See MessageText."
            }),

            Field(
                {
                    name: "Responses", id: 0x6, type: "list", conformance: "RESP", constraint: "max 4",
                    xref: "cluster§1.16.7.1.7",

                    details: "This field shall indicate a list of potential responses to the message. The entries in this list " +
                        "shall have unique values of MessageResponseID." +
                        "\n" +
                        "If the ResponseRequired bit is set on the message but this list is empty, the device shall provide a " +
                        "generic acknowledgement button, e.g. \"OK\"." +
                        "\n" +
                        "If the ResponseRequired bit is not set on the message, this list shall be ignored. See Responses."
                },

                Field({ name: "entry", type: "MessageResponseOptionStruct" })
            )
        ),

        Command(
            {
                name: "CancelMessagesRequest", id: 0x1, access: "F O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§1.16.7.2"
            },

            Field(
                {
                    name: "MessageIDs", id: 0x0, type: "list", conformance: "M", constraint: "max 8",
                    xref: "cluster§1.16.7.2.1",

                    details: "This field shall indicate the MessageIDs for the messages being cancelled." +
                        "\n" +
                        "Cancelling a message shall cause it to be removed from Messages, cause its MessageID to be removed " +
                        "from ActiveMessageIDs and cause any active presentation of the message to cease." +
                        "\n" +
                        "Message IDs in this command that indicate messages that do not exist in Messages, or that are not " +
                        "scoped to the fabric of the sender, shall be ignored."
                },

                Field({ name: "entry", type: "MessageID" })
            )
        ),

        Datatype({
            name: "MessageID", type: "octstr", constraint: "16", xref: "cluster§1.16.5.1",
            details: "This data type is an octstr of fixed length 16, containing the binary encoding of a UUID as " +
                "specified in RFC 4122."
        }),

        Datatype(
            {
                name: "MessageControlBitmap", type: "map16", xref: "cluster§1.16.5.2",
                details: "This data type is derived from map16, and indicates control information related to a message."
            },

            Field({
                name: "ConfirmationRequired", constraint: "0",
                description: "Message requires confirmation from user", xref: "cluster§1.16.5.2.1",
                details: "This bit shall indicate that the message originator requests a confirmation of receipt by the user. " +
                    "If confirmation is required, the device SHOULD present the message until it is either confirmed by " +
                    "the user selecting a confirmation option, or the message expires."
            }),

            Field({
                name: "ResponseRequired", constraint: "1", description: "Message requires response from user",
                xref: "cluster§1.16.5.2.2",
                details: "This bit shall indicate that a MessagePresented event SHOULD be generated based on the response of " +
                    "the user to the message."
            }),

            Field({
                name: "ReplyMessage", constraint: "2", description: "Message supports reply message from user",
                xref: "cluster§1.16.5.2.3",
                details: "This bit shall indicate that a free-form user reply is to be included in the confirmation of " +
                    "receipt."
            }),

            Field({
                name: "MessageConfirmed", constraint: "3", description: "Message has already been confirmed",
                xref: "cluster§1.16.5.2.4",
                details: "This bit shall indicate the current confirmation state of a message, which is useful in the event " +
                    "that there are multiple Messages cluster client devices on a network."
            }),

            Field({
                name: "MessageProtected", constraint: "4", description: "Message required PIN/password protection",
                xref: "cluster§1.16.5.2.5",
                details: "This bit shall indicate that user authentication (e.g. by password or PIN) is required before " +
                    "viewing a message."
            })
        ),

        Datatype(
            {
                name: "FutureMessagePreferenceEnum", type: "enum8", xref: "cluster§1.16.5.3",
                details: "A display device may include this preference in the MessageComplete event as a hint to clients about " +
                    "how to handle future similar messages."
            },
            Field({ name: "Allowed", id: 0x0, conformance: "M", description: "Similar messages are allowed" }),
            Field({ name: "Increased", id: 0x1, conformance: "M", description: "Similar messages should be sent more often" }),
            Field({ name: "Reduced", id: 0x2, conformance: "M", description: "Similar messages should be sent less often" }),
            Field({ name: "Disallowed", id: 0x3, conformance: "M", description: "Similar messages should not be sent" }),
            Field({ name: "Banned", id: 0x4, conformance: "M", description: "No further messages should be sent" })
        ),

        Datatype(
            {
                name: "MessagePriorityEnum", type: "enum8", xref: "cluster§1.16.5.4",
                details: "Priority SHOULD be used to decide which messages to show when the number of eligible messages is " +
                    "larger than the device’s capacity to present them."
            },
            Field({
                name: "Low", id: 0x0, conformance: "M",
                description: "Message to be transferred with a low level of importance"
            }),
            Field({
                name: "Medium", id: 0x1, conformance: "M",
                description: "Message to be transferred with a medium level of importance"
            }),
            Field({
                name: "High", id: 0x2, conformance: "M",
                description: "Message to be transferred with a high level of importance"
            }),
            Field({
                name: "Critical", id: 0x3, conformance: "M",
                description: "Message to be transferred with a critical level of importance"
            })
        ),

        Datatype(
            {
                name: "MessageStruct", type: "struct", xref: "cluster§1.16.5.5",
                details: "This represents a single message."
            },
            Field({
                name: "MessageId", id: 0x0, type: "MessageID", access: "S", conformance: "M",
                xref: "cluster§1.16.5.5.1",
                details: "This field shall indicate a globally unique ID for this message."
            }),
            Field({
                name: "Priority", id: 0x1, type: "MessagePriorityEnum", access: "S", conformance: "M",
                xref: "cluster§1.16.5.5.2",
                details: "This field shall indicate the priority level for this message."
            }),
            Field({
                name: "MessageControl", id: 0x2, type: "MessageControlBitmap", access: "S", conformance: "M",
                xref: "cluster§1.16.5.5.3",
                details: "This field shall indicate control information related to the message."
            }),

            Field({
                name: "StartTime", id: 0x3, type: "epoch-s", access: "S", conformance: "M", quality: "X",
                xref: "cluster§1.16.5.5.4",
                details: "This field shall indicate the time in UTC at which the message becomes available to be presented. A " +
                    "null value shall indicate \"now.\""
            }),

            Field({
                name: "Duration", id: 0x4, type: "uint64", access: "S", conformance: "M", quality: "X",
                xref: "cluster§1.16.5.5.5",
                details: "This field shall indicate the amount of time, in milliseconds, after the StartTime during which the " +
                    "message is available to be presented. A null value shall indicate \"until changed\"."
            }),

            Field({
                name: "MessageText", id: 0x5, type: "string", access: "S", conformance: "M", constraint: "max 256",
                xref: "cluster§1.16.5.5.6",
                details: "This field shall indicate a string containing the message to be presented."
            }),

            Field(
                {
                    name: "Responses", id: 0x6, type: "list", access: "S", conformance: "RESP", constraint: "max 4",
                    xref: "cluster§1.16.5.5.7",

                    details: "This field shall indicate a list of potential responses to the message. The entries in this list " +
                        "shall have unique values of MessageResponseID." +
                        "\n" +
                        "If the ResponseRequired bit is set on the message but this list is empty, the device shall provide a " +
                        "generic acknowledgement button, e.g. \"OK\"." +
                        "\n" +
                        "If the ResponseRequired bit is not set on the message, this list shall be ignored."
                },

                Field({ name: "entry", type: "MessageResponseOptionStruct" })
            ),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            {
                name: "MessageResponseOptionStruct", type: "struct", xref: "cluster§1.16.5.6",
                details: "This represents a possible response to a message."
            },

            Field({
                name: "MessageResponseId", id: 0x0, type: "uint32", conformance: "M", constraint: "min 1",
                xref: "cluster§1.16.5.6.1",
                details: "This field shall indicate a unique unsigned 32-bit number identifier for this message response " +
                    "option."
            }),

            Field({
                name: "Label", id: 0x1, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§1.16.5.6.2",
                details: "This field shall indicate the text for this option; e.g. \"Yes\", \"No\", etc."
            })
        )
    ),

    Cluster(
        {
            name: "ServiceArea", id: 0x150, classification: "application", pics: "SEAR", xref: "cluster§1.17",

            details: "This cluster provides an interface for controlling the areas where a device should operate, for " +
                "reporting the status at each area, and for querying the current area." +
                "\n" +
                "The device may operate at one area at a time, as in the case of a mobile device, such as a robot. " +
                "Other devices may operate at (service) multiple areas simultaneously, as in the case of a sensor " +
                "that can monitor multiple areas. This cluster specification uses the term \"operate\" to describe both " +
                "the operating and servicing actions, regardless of the device type." +
                "\n" +
                "The cluster allows the client to select one or more areas on the server, to indicate where the " +
                "device SHOULD attempt to operate. An area is one of a list of options that may be presented by a " +
                "client for a user choice, or understood by the client, via the semantic data of the area." +
                "\n" +
                "The area semantic data is a combination of semantic tags, indicating one or more of the following: " +
                "the building floor, area type, landmark, and relative position."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§1.17.4" },
            Field({
                name: "SELRUN", constraint: "0", title: "SelectWhileRunning", xref: "cluster§1.17.4.1",
                details: "This feature indicates whether this device allows changing the selected areas, by using the " +
                    "SelectAreas command, while operating."
            }),
            Field({
                name: "PROG", constraint: "1", title: "ProgressReporting",
                details: "The device implements the progress reporting feature"
            }),
            Field({ name: "MAPS", constraint: "2", title: "Maps", details: "The device has map support" })
        ),

        Attribute(
            {
                name: "SupportedAreas", id: 0x0, type: "list", access: "R V", conformance: "M",
                constraint: "max 255", xref: "cluster§1.17.6.1",

                details: "This attribute shall contain the list of areas that can be included in the SelectedAreas attribute’s " +
                    "list. Each item in this list represents a unique area, as indicated by the AreaID field of " +
                    "AreaStruct." +
                    "\n" +
                    "Each entry in this list shall have a unique value for the AreaID field." +
                    "\n" +
                    "If the SupportedMaps attribute is not empty, each entry in this list shall have a unique value for " +
                    "the combination of the MapID and AreaInfo fields." +
                    "\n" +
                    "If the SupportedMaps attribute is empty, each entry in this list shall have a unique value for the " +
                    "AreaInfo field and shall have the MapID field set to null." +
                    "\n" +
                    "An empty value indicates that the device is currently unable to provide the list of supported areas." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> due to the maximum size of this list and to the fact that the entries may include strings (see " +
                    "  LocationName), care must be taken by implementers to avoid creating a data structure that is " +
                    "  overly large, which can result in significant latency in accessing this attribute." +
                    "\n" +
                    "The value of this attribute may change at any time via an out-of-band interaction outside of the " +
                    "server, such as interactions with a user interface, or due to internal device changes." +
                    "\n" +
                    "When removing entries in the SupportedAreas attribute list the server shall adjust the values of the " +
                    "SelectedAreas, CurrentArea, and Progress attributes such that they only reference valid entries in " +
                    "the updated SupportedAreas attribute list. These changes to the SelectedAreas, CurrentArea, and " +
                    "Progress attributes may result in the server setting some or all of them to empty (for SelectedAreas " +
                    "and Progress) or null (for CurrentArea), or updating them with data that matches the constraints " +
                    "from the description of the respective attributes. These actions are required to ensure having a " +
                    "consistent representation of the maps and locations available to the clients." +
                    "\n" +
                    "The SupportedAreas attribute list changes mentioned above SHOULD NOT be allowed while the device is " +
                    "operating, to reduce the impact on the clients, and the potential confusion for the users." +
                    "\n" +
                    "A few examples are provided below. Valid list of areas:" +
                    "\n" +
                    "  • AreaID=0, LocationName=\"yellow bedroom\", MapID=null" +
                    "\n" +
                    "  • AreaID=1, LocationName=\"orange bedroom\", MapID=null Valid list of areas:" +
                    "\n" +
                    "  • AreaID=5, LocationName=\"hallway\", MapID=1" +
                    "\n" +
                    "  • AreaID=3, LocationName=\"hallway\", MapID=2"
            },

            Field({ name: "entry", type: "AreaStruct" })
        ),

        Attribute(
            {
                name: "SupportedMaps", id: 0x1, type: "list", access: "R V", conformance: "MAPS",
                constraint: "max 255", xref: "cluster§1.17.6.2",

                details: "This attribute shall contain the list of supported maps." +
                    "\n" +
                    "A map is a full or a partial representation of a home, known to the device. For example:" +
                    "\n" +
                    "  • a single level home may be represented using a single map" +
                    "\n" +
                    "  • a two level home may be represented using two maps, one for each level" +
                    "\n" +
                    "  • a single level home may be represented using two maps, each including a different set of rooms, " +
                    "    such as \"map of living room and kitchen\" and \"map of bedrooms and hallway\"" +
                    "\n" +
                    "  • a single level home may be represented using one map for the indoor areas (living room, bedrooms " +
                    "    etc.) and one for the outdoor areas (garden, swimming pool etc.)" +
                    "\n" +
                    "Each map includes one or more areas - see the SupportedAreas attribute. In the context of this " +
                    "cluster specification, a map is effectively a group label for a set of areas, rather than a " +
                    "graphical representation that the clients can display to the users. The clients that present the " +
                    "list of available areas for user selection (see the SelectAreas command) may choose to filter the " +
                    "SupportedAreas list based on the associated map. For example, the clients may allow the user to " +
                    "indicate that the device is to operate on the first floor, and allow the user to choose only from " +
                    "the areas situated on that level." +
                    "\n" +
                    "If empty, that indicates that the device is currently unable to provide this information. Each entry " +
                    "in this list shall have a unique value for the MapID field." +
                    "\n" +
                    "Each entry in this list shall have a unique value for the Name field." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> due to the maximum size of this list and to the fact that the entries may include strings (see the " +
                    "  Name field of the MapStruct data type), care must be taken by implementers to avoid creating a " +
                    "  data structure that is overly large, which can result in significant latency in accessing this " +
                    "  attribute." +
                    "\n" +
                    "The value of this attribute may change at any time via an out-of-band interaction outside of the " +
                    "server, such as interactions with a user interface." +
                    "\n" +
                    "When updating the SupportedMaps attribute list by deleting entries, or by setting the attribute to " +
                    "an empty list, the SupportedAreas attribute shall be updated such that all entries in that list meet " +
                    "the constraints indicated in the description of the SupportedAreas attribute. This may result in the " +
                    "server removing entries from the SupportedAreas attribute list. See the SupportedAreas attribute " +
                    "description for the implications of changing that attribute." +
                    "\n" +
                    "The SupportedMaps attribute list changes mentioned above SHOULD NOT be allowed while the device is " +
                    "operating, to reduce the impact on the clients, and the potential confusion for the users."
            },

            Field({ name: "entry", type: "MapStruct" })
        ),

        Attribute(
            {
                name: "SelectedAreas", id: 0x2, type: "list", access: "R V", conformance: "M", constraint: "desc",
                default: [], xref: "cluster§1.17.6.3",

                details: "Indicates the set of areas where the device SHOULD attempt to operate." +
                    "\n" +
                    "The mobile devices may travel without operating across any areas while attempting to reach the areas " +
                    "indicated by the SelectedAreas attribute. For example, a robotic vacuum cleaner may drive without " +
                    "cleaning when traveling without operating." +
                    "\n" +
                    "If this attribute is empty, the device is not constrained to operate in any specific areas. If this " +
                    "attribute is not empty:" +
                    "\n" +
                    "  • each item in this list shall match the AreaID field of an entry in the SupportedAreas " +
                    "    attribute’s list" +
                    "\n" +
                    "  • each entry in this list shall have a unique value"
            },

            Field({ name: "entry", type: "uint32" })
        ),

        Attribute({
            name: "CurrentArea", id: 0x3, type: "uint32", access: "R V", conformance: "desc",
            constraint: "desc", default: null, quality: "X", xref: "cluster§1.17.6.4",

            details: "If the device is mobile, this attribute shall indicate the area where the device is currently " +
                "located, regardless of whether it is operating or not, such as while traveling between areas." +
                "\n" +
                "If the device is not mobile and can operate at multiple areas sequentially, this attribute shall " +
                "indicate the area which is currently being serviced, or the area which is currently traversed by the " +
                "device. For example, a camera device may use this attribute to indicate which area it currently " +
                "takes video of (serviced area) or which area it currently has in view but not taking video of (e.g. " +
                "an area which is traversed while panning)." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> A device may traverse an area regardless of the status of the area (pending, skipped, or " +
                "  completed)." +
                "\n" +
                "If a device can simultaneously operate at multiple areas, such as in the case of a sensor that can " +
                "monitor multiple areas at the same time, the CurrentArea attribute shall NOT be implemented, since " +
                "it doesn’t apply. Else this attribute shall be optionally implemented." +
                "\n" +
                "A null value indicates that the device is currently unable to provide this information. For example, " +
                "the device is traversing an unknown area, or the SupportedAreas attribute was updated and the area " +
                "where the device is located was removed from that list." +
                "\n" +
                "If not null, the value of this attribute shall match the AreaID field of an entry on the " +
                "SupportedAreas attribute’s list."
        }),

        Attribute({
            name: "EstimatedEndTime", id: 0x4, type: "epoch-s", access: "R V", conformance: "[CurrentArea]",
            default: null, quality: "X Q", xref: "cluster§1.17.6.5",

            details: "Indicates the estimated Epoch time for completing operating at the area indicated by the CurrentArea " +
                "attribute, in seconds." +
                "\n" +
                "A value of 0 means that the operation has completed." +
                "\n" +
                "When this attribute is null, that represents that there is no time currently defined until operation " +
                "completion. This may happen, for example, because no operation is in progress or because the " +
                "completion time is unknown." +
                "\n" +
                "Null if the CurrentArea attribute is null." +
                "\n" +
                "If the Progress attribute is available, and it contains an entry matching CurrentArea, the server " +
                "may use the time estimate provided in the EstimatedTime field of that entry to compute the " +
                "EstimatedEndTime attribute." +
                "\n" +
                "The value of this attribute shall only be reported in the following cases:" +
                "\n" +
                "  • when it changes to or from 0" +
                "\n" +
                "  • when it decreases" +
                "\n" +
                "  • when it changes to or from null" +
                "\n" +
                "    > [!NOTE]" +
                "\n" +
                "    > If the device is capable of pausing its operation, this attribute may be set to null, to " +
                "      indicate that completion time is unknown, or increment the value while being in the paused " +
                "      state."
        }),

        Attribute(
            {
                name: "Progress", id: 0x5, type: "list", access: "R V", conformance: "PROG", constraint: "max 255",
                default: [], xref: "cluster§1.17.6.6",

                details: "Indicates the operating status at one or more areas. Each entry in this list shall have a unique " +
                    "value for the AreaID field." +
                    "\n" +
                    "For each entry in this list, the AreaID field shall match an entry on the SupportedAreas attribute’s " +
                    "list." +
                    "\n" +
                    "When this attribute is empty, that represents that no progress information is currently available." +
                    "\n" +
                    "If the SelectedAreas attribute is empty, indicating the device is not constrained to operate in any " +
                    "specific areas, the Progress attribute list may change while the device operates, due to the device " +
                    "adding new entries dynamically, when it determines which ones it can attempt to operate at." +
                    "\n" +
                    "If the SelectedAreas attribute is not empty, and the device starts operating:" +
                    "\n" +
                    "  • the Progress attribute list shall be updated so each entry of SelectedAreas has a matching " +
                    "    Progress list entry, based on the AreaID field" +
                    "\n" +
                    "  • the length of the Progress and SelectedAreas list shall be the same" +
                    "\n" +
                    "  • the entries in the Progress list shall be initialized by the server, by having their status set " +
                    "    to Pending or Operating, and the TotalOperationalTime field set to null" +
                    "\n" +
                    "When the device ends operation unexpectedly, such as due to an error, the server shall update all " +
                    "Progress list entries with the Status field set to Operating or Pending to Skipped." +
                    "\n" +
                    "When the device finishes operating, successfully or not, it shall NOT change the Progress attribute, " +
                    "except in the case of an unexpected end of operation as described above, or due to changes to the " +
                    "SupportedMaps or SupportedAreas attributes, so the clients can retrieve the progress information at " +
                    "that time." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> if the device implements the Operational Status cluster, or a derivation of it, in case the device " +
                    "  fails to service any locations in the SelectedAreas list before ending the operation, it SHOULD " +
                    "  use the Operational Status cluster to indicate that the device was unable to complete the " +
                    "  operation (see the UnableToCompleteOperation error from that cluster specification). The clients " +
                    "  SHOULD then read the Progress attribute, and indicate which areas have been successfully serviced " +
                    "  (marked as completed)."
            },

            Field({ name: "entry", type: "ProgressStruct" })
        ),

        Command(
            {
                name: "SelectAreas", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "SelectAreasResponse", xref: "cluster§1.17.7.1",
                details: "This command is used to select a set of device areas, where the device is to operate." +
                    "\n" +
                    "On receipt of this command the device shall respond with a SelectAreasResponse command."
            },

            Field(
                {
                    name: "NewAreas", id: 0x0, type: "list", conformance: "M", constraint: "desc",
                    xref: "cluster§1.17.7.1.1",

                    details: "This field indicates which areas the device is to operate at." +
                        "\n" +
                        "If this field is empty, that indicates that the device is to operate without being constrained to " +
                        "any specific areas, and the operation will not allow skipping using the SkipArea Command, otherwise " +
                        "the field shall be a list of unique values that match the AreaID field of entries on the " +
                        "SupportedAreas list."
                },

                Field({ name: "entry", type: "uint32" })
            )
        ),

        Command(
            {
                name: "SelectAreasResponse", id: 0x1, access: "O", conformance: "M", direction: "response",
                xref: "cluster§1.17.7.2",
                details: "This command is sent by the device on receipt of the SelectAreas command."
            },

            Field({
                name: "Status", id: 0x0, type: "SelectAreasStatus", conformance: "M", xref: "cluster§1.17.7.2.1",

                details: "If the Status field is set to Success or UnsupportedArea, the server may use a non-empty string for " +
                    "the StatusText field to provide additional information. For example, if Status is set to Unsupport " +
                    "edArea, the server may use StatusText to indicate which areas are unsupported." +
                    "\n" +
                    "If the Status field is not set to Success, or UnsupportedArea, the StatusText field shall include a " +
                    "vendor-defined error description which can be used to explain the error to the user. For example, if " +
                    "the Status field is set to InvalidInMode, the StatusText field SHOULD indicate why the request is " +
                    "not allowed, given the current mode of the device, which may involve other clusters."
            }),

            Field({ name: "StatusText", id: 0x1, type: "string", conformance: "M", constraint: "max 256" })
        ),

        Command(
            {
                name: "SkipArea", id: 0x2, access: "O", conformance: "[CurrentArea | Progress]",
                direction: "request", response: "SkipAreaResponse", xref: "cluster§1.17.7.3",
                details: "This command is used to skip the given area, and to attempt operating at other areas on the " +
                    "SupportedAreas attribute list." +
                    "\n" +
                    "On receipt of this command the device shall respond with a SkipAreaResponse command."
            },

            Field({
                name: "SkippedArea", id: 0x0, type: "uint32", conformance: "M", constraint: "desc",
                xref: "cluster§1.17.7.3.1",
                details: "The SkippedArea field indicates the area to be skipped." +
                    "\n" +
                    "The SkippedArea field shall match an entry in the SupportedAreas list."
            })
        ),

        Command(
            {
                name: "SkipAreaResponse", id: 0x3, access: "O", conformance: "SkipArea", direction: "response",
                xref: "cluster§1.17.7.4",
                details: "This command is sent by the device on receipt of the SkipArea command."
            },

            Field({
                name: "Status", id: 0x0, type: "SkipAreaStatus", conformance: "M", xref: "cluster§1.17.7.4.1",

                details: "If the Status field is set to Success or InvalidAreaList, the server may use a non-empty string for " +
                    "the StatusText field to provide additional information. For example, if Status is set to " +
                    "InvalidAreaList, the server may use StatusText to indicate why this list is invalid." +
                    "\n" +
                    "If the Status field is not set to Success or InvalidAreaList, the StatusText field shall include a " +
                    "vendor defined error description which can be used to explain the error to the user. For example, if " +
                    "the Status field is set to InvalidInMode, the StatusText field SHOULD indicate why the request is " +
                    "not allowed, given the current mode of the device, which may involve other clusters."
            }),

            Field({ name: "StatusText", id: 0x1, type: "string", conformance: "M", constraint: "max 256" })
        ),

        Datatype(
            {
                name: "LandmarkInfoStruct", type: "struct", xref: "cluster§1.17.5.1",
                details: "The data from this structure indicates a landmark and position relative to the landmark."
            },

            Field({
                name: "LandmarkTag", id: 0x0, type: "tag", conformance: "M", xref: "cluster§1.17.5.1.1",
                details: "This field shall indicate that the area is associated with a landmark." +
                    "\n" +
                    "This field shall be the ID of a landmark semantic tag, located within the Common Landmark Namespace. " +
                    "For example, this tag may indicate that the area refers to an area next to a table."
            }),

            Field({
                name: "RelativePositionTag", id: 0x1, type: "tag", conformance: "M", quality: "X",
                xref: "cluster§1.17.5.1.2",

                details: "This field shall identify the position of the area relative to a landmark. This is a static " +
                    "description of a zone known to the server, and this field never reflects the device’s own proximity " +
                    "or position relative to the landmark, but that of the zone." +
                    "\n" +
                    "This field shall be the ID of a relative position semantic tag, located within the Common Relative " +
                    "Position Namespace." +
                    "\n" +
                    "If the RelativePositionTag field is null, this field indicates proximity to the landmark. Otherwise, " +
                    "the RelativePositionTag field indicates the position of the area relative to the landmark indicated " +
                    "by the LandmarkTag field. For example, this tag, in conjunction with the LandmarkTag field, may " +
                    "indicate that the area refers to a zone under a table."
            })
        ),

        Datatype(
            {
                name: "AreaInfoStruct", type: "struct", xref: "cluster§1.17.5.2",

                details: "The data from this structure indicates the name and/or semantic data describing an area, as detailed " +
                    "below." +
                    "\n" +
                    "This data type includes the LocationInfo field, with the following fields: LocationName, " +
                    "FloorNumber, AreaType. Additional semantic data may be available in the LandmarkInfo field." +
                    "\n" +
                    "For an area description to be meaningful, it shall have at least one of the following:" +
                    "\n" +
                    "  • a non-empty name (LocationInfo’s LocationName field) OR" +
                    "\n" +
                    "  • some semantic data (one or more of these: FloorNumber, AreaType or LandmarkTag) The normative " +
                    "    text from the remainder of this section describes these constraints." +
                    "\n" +
                    "If the LocationInfo field is null, the LandmarkInfo field shall NOT be null. If the LandmarkInfo " +
                    "field is null, the LocationInfo field shall NOT be null." +
                    "\n" +
                    "If LocationInfo is not null, and its LocationName field is an empty string, at least one of the " +
                    "following shall NOT be null:" +
                    "\n" +
                    "  • LocationInfo’s FloorNumber field" +
                    "\n" +
                    "  • LocationInfo’s AreaType field" +
                    "\n" +
                    "  • LandmarkInfo field" +
                    "\n" +
                    "If all three of the following are null, LocationInfo’s LocationName field shall NOT be an empty " +
                    "string:" +
                    "\n" +
                    "  • LocationInfo’s FloorNumber field" +
                    "\n" +
                    "  • LocationInfo’s AreaType field" +
                    "\n" +
                    "  • LandmarkInfo field"
            },

            Field({
                name: "LocationInfo", id: 0x0, type: "locationdesc", conformance: "M", quality: "X",
                xref: "cluster§1.17.5.2.1",

                details: "This field shall indicate the name of the area, floor number and/or area type. A few examples are " +
                    "provided below." +
                    "\n" +
                    "  • An area can have LocationInfo’s LocationName field set to \"blue room\", and the AreaType field " +
                    "    set to the ID of a \"Living Room\" semantic tag. Clients wishing to direct the device to operate " +
                    "    in (or service) the living room can use this area." +
                    "\n" +
                    "  • An area can have LocationInfo set to null, the LandmarkInfo’s LandmarkTag field set to the ID of " +
                    "    the \"Table\" landmark semantic tag, and the RelativePositionTag field set to the ID of the " +
                    "    \"Under\" position semantic tag. With such an area indication, the client can request the device " +
                    "    to operate in (or service) the area located under the table."
            }),

            Field({
                name: "LandmarkInfo", id: 0x1, type: "LandmarkInfoStruct", conformance: "M", quality: "X",
                xref: "cluster§1.17.5.2.2",

                details: "This field shall indicate an association with a landmark. A value of null indicates that the " +
                    "information is not available or known. For example, this may indicate that the area refers to a zone " +
                    "next to a table." +
                    "\n" +
                    "If this field is not null, that indicates that the area is restricted to the zone where the landmark " +
                    "is located, as indicated by the LandmarkTag and, if not null, by the RelativePositionTag fields, " +
                    "rather than to the entire room or floor where the landmark is located, if those are indicated by the " +
                    "LocationInfo field."
            })
        ),

        Datatype(
            {
                name: "MapStruct", type: "struct", xref: "cluster§1.17.5.3",
                details: "This is a struct representing a map."
            },
            Field({
                name: "MapId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§1.17.5.3.1",
                details: "This field shall represent the map’s identifier."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "M", constraint: "max 64",
                xref: "cluster§1.17.5.3.2",
                details: "This field shall represent a human understandable map description. For example: \"Main Floor\", or " +
                    "\"Second Level\"."
            })
        ),

        Datatype(
            {
                name: "AreaStruct", type: "struct", xref: "cluster§1.17.5.4",
                details: "This is a struct representing an area known to the server."
            },
            Field({
                name: "AreaId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§1.17.5.4.1",
                details: "This field shall represent the identifier of the area."
            }),

            Field({
                name: "MapId", id: 0x1, type: "uint32", conformance: "M", constraint: "desc", quality: "X",
                xref: "cluster§1.17.5.4.2",

                details: "This field shall indicate the map identifier which the area is associated with. A value of null " +
                    "indicates that the area is not associated with a map." +
                    "\n" +
                    "If the SupportedMaps attribute is not empty, this field shall match the MapID field of an entry from " +
                    "the SupportedMaps attribute’s list. If the SupportedMaps attribute is empty, this field shall be " +
                    "null."
            }),

            Field({
                name: "AreaInfo", id: 0x2, type: "AreaInfoStruct", conformance: "M", xref: "cluster§1.17.5.4.3",

                details: "This field shall contain data describing the area." +
                    "\n" +
                    "This SHOULD be used by clients to determine the name and/or the full, or the partial, semantics of a " +
                    "certain area." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> If any entries on the SupportedAreas attribute’s list have the AreaInfo field missing the semantic " +
                    "  data, the client may remind the user to assign the respective data."
            })
        ),

        Datatype(
            {
                name: "ProgressStruct", type: "struct", xref: "cluster§1.17.5.5",
                details: "This is a struct indicating the progress."
            },
            Field({
                name: "AreaId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§1.17.5.5.1",
                details: "This field shall indicate the identifier of the area, and the identifier shall be an entry in the " +
                    "SupportedAreas attribute’s list."
            }),

            Field({
                name: "Status", id: 0x1, type: "OperationalStatusEnum", conformance: "M",
                xref: "cluster§1.17.5.5.2",
                details: "This field shall indicate the operational status of the device regarding the area indicated by the " +
                    "AreaID field."
            }),

            Field({
                name: "TotalOperationalTime", id: 0x2, type: "elapsed-s", conformance: "O", quality: "X",
                xref: "cluster§1.17.5.5.3",

                details: "This field shall indicate the total operational time, in seconds, from when the device started to " +
                    "operate at the area indicated by the AreaID field, until the operation finished, due to completion " +
                    "or due to skipping, including any time spent while paused." +
                    "\n" +
                    "A value of null indicates that the total operational time is unknown." +
                    "\n" +
                    "There may be cases where the total operational time exceeds the maximum value that can be conveyed " +
                    "by this attribute, and in such instances this attribute shall be populated with null." +
                    "\n" +
                    "Null if the Status field is not set to Completed or Skipped."
            }),

            Field({
                name: "EstimatedTime", id: 0x3, type: "elapsed-s", conformance: "O", quality: "X",
                xref: "cluster§1.17.5.5.4",

                details: "This field shall indicate the estimated time for the operation, in seconds, from when the device " +
                    "will start operating at the area indicated by the AreaID field, until the operation completes, " +
                    "excluding any time spent while not operating in the area." +
                    "\n" +
                    "A value of null indicates that the estimated time is unknown. If the estimated time is unknown, or " +
                    "if it exceeds the maximum value that can be conveyed by this attribute, this attribute shall be " +
                    "null." +
                    "\n" +
                    "After initializing the ProgressStruct instance, the server SHOULD NOT change the value of this " +
                    "field, except when repopulating the entire instance, to avoid excessive reporting of the Progress " +
                    "attribute changes."
            })
        ),

        Datatype(
            {
                name: "OperationalStatusEnum", type: "enum8", xref: "cluster§1.17.5.6",
                details: "The following table defines the status values."
            },
            Field({
                name: "Pending", id: 0x0, conformance: "M",
                description: "The device has not yet started operating at the given area, or has not finished operating at that area but it is not currently operating at the area"
            }),
            Field({
                name: "Operating", id: 0x1, conformance: "M",
                description: "The device is currently operating at the given area"
            }),
            Field({
                name: "Skipped", id: 0x2, conformance: "M",
                description: "The device has skipped the given area, before or during operating at it, due to a SkipArea command, due an out of band command (e.g. from the vendor’s application), due to a vendor specific reason, such as a time limit used by the device, or due the device ending operating unsuccessfully"
            }),
            Field({
                name: "Completed", id: 0x3, conformance: "M",
                description: "The device has completed operating at the given area"
            })
        ),

        Datatype(
            { name: "SelectAreasStatus", type: "enum8", xref: "cluster§1.17.5.6.1" },
            Field({
                name: "Success", id: 0x0, conformance: "M",
                description: "Attempting to operate in the areas identified by the entries of the NewAreas field is allowed and possible. The SelectedAreas attribute is set to the value of the NewAreas field."
            }),
            Field({
                name: "UnsupportedArea", id: 0x1, conformance: "M",
                description: "The value of at least one of the entries of the NewAreas field doesn’t match any entries in the SupportedAreas attribute."
            }),
            Field({
                name: "InvalidInMode", id: 0x2, conformance: "M",
                description: "The received request cannot be handled due to the current mode of the device."
            }),
            Field({
                name: "InvalidSet", id: 0x3, conformance: "M",
                description: "The set of values is invalid. For example, areas on different floors, that a robot knows it can’t reach on its own."
            })
        ),

        Datatype(
            { name: "SkipAreaStatus", type: "enum8", xref: "cluster§1.17.5.6.2" },
            Field({
                name: "Success", id: 0x0, conformance: "M",
                description: "Skipping the area is allowed and possible, or the device was operating at the last available area and has stopped."
            }),
            Field({
                name: "InvalidAreaList", id: 0x1, conformance: "M",
                description: "The SelectedAreas attribute is empty."
            }),
            Field({
                name: "InvalidInMode", id: 0x2, conformance: "M",
                description: "The received request cannot be handled due to the current mode of the device. For example, the CurrentArea attribute is null or the device is not operating."
            }),
            Field({
                name: "InvalidSkippedArea", id: 0x3, conformance: "M",
                description: "The SkippedArea field doesn’t match an entry in the SupportedAreas list."
            })
        )
    ),

    Datatype(
        { name: "MeasurementTypeEnum", type: "enum16", xref: "cluster§2.1.3.1" },
        Field({ name: "Unspecified", id: 0x0, conformance: "M" }),
        Field({ name: "Voltage", id: 0x1, conformance: "M", description: "Voltage in millivolts (mV)" }),
        Field({ name: "ActiveCurrent", id: 0x2, conformance: "M", description: "Active current in milliamps (mA)" }),
        Field({ name: "ReactiveCurrent", id: 0x3, conformance: "M", description: "Reactive current in milliamps (mA)" }),
        Field({ name: "ApparentCurrent", id: 0x4, conformance: "M", description: "Apparent current in milliamps (mA)" }),
        Field({ name: "ActivePower", id: 0x5, conformance: "M", description: "Active power in milliwatts (mW)" }),
        Field({
            name: "ReactivePower", id: 0x6, conformance: "M",
            description: "Reactive power in millivolt-amps reactive (mVAR)"
        }),
        Field({ name: "ApparentPower", id: 0x7, conformance: "M", description: "Apparent power in millivolt-amps (mVA)" }),
        Field({ name: "RmsVoltage", id: 0x8, conformance: "M", description: "Root mean squared voltage in millivolts (mV)" }),
        Field({ name: "RmsCurrent", id: 0x9, conformance: "M", description: "Root mean squared current in milliamps (mA)" }),
        Field({ name: "RmsPower", id: 0xa, conformance: "M", description: "Root mean squared power in milliwatts (mW)" }),
        Field({ name: "Frequency", id: 0xb, conformance: "M", description: "AC frequency in millihertz (mHz)" }),
        Field({
            name: "PowerFactor", id: 0xc, conformance: "M",
            description: "Power Factor ratio in+/- 1/100ths of a percent."
        }),
        Field({ name: "NeutralCurrent", id: 0xd, conformance: "M", description: "AC neutral current in milliamps (mA)" }),
        Field({
            name: "ElectricalEnergy", id: 0xe, conformance: "M",
            description: "Electrical energy in milliwatt-hours (mWh)"
        }),
        Field({
            name: "ReactiveEnergy", id: 0xf, conformance: "M",
            description: "Reactive power in millivolt-amp-hours reactive (mVARh)"
        }),
        Field({
            name: "ApparentEnergy", id: 0x10, conformance: "M",
            description: "Apparent power in millivolt-amp-hours (mVAh)"
        }),
        Field({ name: "SoilMoisture", id: 0x11, conformance: "M", description: "Soil moisture in percent" })
    ),

    Datatype(
        {
            name: "MeasurementAccuracyRangeStruct", type: "struct", xref: "cluster§2.1.3.2",

            details: "This struct represents the accuracy of a measurement for a range of measurement values. Accuracy " +
                "shall be expressed as a maximum +/- percentage of the true value, a maximum +/- fixed value of the " +
                "true value, or both." +
                "\n" +
                "  • If both PercentMax and FixedMax are indicated, then for a given true value in the range between " +
                "    RangeMin and RangeMax," +
                "\n" +
                "    ◦ the reported value shall be less than or equal to the sum of the true value, FixedMax and " +
                "      PercentMax percent of the true value." +
                "\n" +
                "    ◦ the reported value shall be greater than or equal to the true value minus the sum of FixedMax " +
                "      and PercentMax percent of the true value." +
                "\n" +
                "  • If only PercentMax is indicated, then for a given true value in the range between RangeMin and " +
                "    RangeMax," +
                "\n" +
                "    ◦ the reported value shall be less than or equal to the sum of the true value and PercentMax " +
                "      percent of the true value." +
                "\n" +
                "    ◦ the reported value shall be greater than or equal to the true value minus PercentMax percent " +
                "      of the true value." +
                "\n" +
                "  • If only FixedMax is indicated, then for a given true value in the range between RangeMin and " +
                "    RangeMax," +
                "\n" +
                "    ◦ the reported value shall be less than or equal to the sum of the true value and FixedMax." +
                "\n" +
                "    ◦ the reported value shall be greater than or equal to the true value minus FixedMax."
        },

        Field({
            name: "RangeMin", id: 0x0, type: "int64", conformance: "M", xref: "cluster§2.1.3.2.1",

            details: "This field shall indicate the minimum measurement value for the specified level of accuracy." +
                "\n" +
                "The value of this field shall be greater than or equal to the value of the MinMeasuredValue field on " +
                "the encompassing MeasurementAccuracyStruct." +
                "\n" +
                "The value of this field shall be less than or equal to the value of the MaxMeasuredValue field on " +
                "the encompassing MeasurementAccuracyStruct."
        }),

        Field({
            name: "RangeMax", id: 0x1, type: "int64", conformance: "M", xref: "cluster§2.1.3.2.2",

            details: "This field shall indicate the maximum measurement value for the specified level of accuracy. The " +
                "value of this field shall be greater than the value of the RangeMin field." +
                "\n" +
                "The value of this field shall be greater than or equal to the value of the MinMeasuredValue field on " +
                "the encompassing MeasurementAccuracyStruct." +
                "\n" +
                "The value of this field shall be less than or equal to the value of the MaxMeasuredValue field on " +
                "the encompassing MeasurementAccuracyStruct."
        }),

        Field({
            name: "PercentMax", id: 0x2, type: "percent100ths", conformance: "O.a+", xref: "cluster§2.1.3.2.3",
            details: "This field shall indicate the maximum +/- percentage accuracy for the associated measurement."
        }),
        Field({
            name: "PercentMin", id: 0x3, type: "percent100ths", conformance: "[PercentMax]",
            constraint: "max percentTypical", xref: "cluster§2.1.3.2.4",
            details: "This field shall indicate the minimum +/- percentage accuracy for the associated measurement."
        }),
        Field({
            name: "PercentTypical", id: 0x4, type: "percent100ths", conformance: "[PercentMin]",
            constraint: "percentMin to percentMax", xref: "cluster§2.1.3.2.5",
            details: "This field shall indicate the typical +/- percentage accuracy for the associated measurement."
        }),
        Field({
            name: "FixedMax", id: 0x5, type: "uint64", conformance: "O.a+", xref: "cluster§2.1.3.2.6",
            details: "This field shall indicate the maximum +/- fixed accuracy for the associated measurement, in the unit " +
                "indicated by MeasurementType."
        }),

        Field({
            name: "FixedMin", id: 0x6, type: "uint64", conformance: "[FixedMax]", constraint: "max fixedMax",
            xref: "cluster§2.1.3.2.7",
            details: "This field shall indicate the minimum +/- fixed accuracy for the associated measurement, in the unit " +
                "indicated by MeasurementType."
        }),

        Field({
            name: "FixedTypical", id: 0x7, type: "uint64", conformance: "[FixedMin]",
            constraint: "fixedMin to fixedMax", xref: "cluster§2.1.3.2.8",
            details: "This field shall indicate the typical +/- fixed accuracy for the associated measurement, in the unit " +
                "indicated by MeasurementType."
        })
    ),

    Datatype(
        {
            name: "MeasurementAccuracyStruct", type: "struct", xref: "cluster§2.1.3.3",
            details: "This struct represents the set of accuracy ranges for a given measurement, the maximum and minimum " +
                "values for the measurement, and whether the measurement is directly measured or just estimated from " +
                "other information."
        },

        Field({
            name: "MeasurementType", id: 0x0, type: "MeasurementTypeEnum", conformance: "M",
            xref: "cluster§2.1.3.3.1",
            details: "This field shall indicate the type of measurement for the accuracy provided."
        }),
        Field({
            name: "Measured", id: 0x1, type: "bool", conformance: "M", xref: "cluster§2.1.3.3.2",
            details: "This field shall indicate whether the associated measurement was directly measured. If this field is " +
                "not set to true, then the associated measurement was estimated."
        }),
        Field({ name: "MinMeasuredValue", id: 0x2, type: "int64", conformance: "M" }),
        Field({ name: "MaxMeasuredValue", id: 0x3, type: "int64", conformance: "M" }),

        Field(
            {
                name: "AccuracyRanges", id: 0x4, type: "list", conformance: "M", constraint: "min 1",
                xref: "cluster§2.1.3.3.5",

                details: "This field shall indicate a list of measurement ranges and their associated accuracies." +
                    "\n" +
                    "The value of the RangeMin field on the first MeasurementAccuracyRangeStruct in this list shall be " +
                    "equal to the value of the MinMeasuredValue field." +
                    "\n" +
                    "The value of the RangeMax field on the last MeasurementAccuracyRangeStruct in this list shall be " +
                    "less than or equal to the value of the MaxMeasuredValue field." +
                    "\n" +
                    "The value of the RangeMin field on each MeasurementAccuracyRangeStruct in this list other than the " +
                    "first shall be one more the value of the RangeMax field on the previous " +
                    "MeasurementAccuracyRangeStruct in this list (i.e. there shall be no gaps in the accuracy ranges, and " +
                    "the ranges shall be in increasing order)."
            },

            Field({ name: "entry", type: "MeasurementAccuracyRangeStruct" })
        )
    ),

    Cluster(
        {
            name: "IlluminanceMeasurement", id: 0x400, classification: "application", pics: "ILL",
            xref: "cluster§2.2",
            details: "The Illuminance Measurement cluster provides an interface to illuminance measurement functionality, " +
                "including configuration and provision of notifications of illuminance measurements."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            {
                name: "MeasuredValue", id: 0x0, type: "uint16", access: "R V", conformance: "M",
                constraint: "0, minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.2.5.1",

                details: "Indicates the illuminance in Lux (symbol lx) as follows:" +
                    "\n" +
                    "  • MeasuredValue = 10,000 x log10(illuminance) + 1," +
                    "\n" +
                    "where 1 lx <= illuminance <= 3.576 Mlx, corresponding to a MeasuredValue in the range 1 to 0xFFFE. " +
                    "The MeasuredValue attribute can take the following values:" +
                    "\n" +
                    "  • 0 indicates a value of illuminance that is too low to be measured," +
                    "\n" +
                    "  • MinMeasuredValue <= MeasuredValue <= MaxMeasuredValue under normal circumstances," +
                    "\n" +
                    "  • null indicates that the illuminance measurement is invalid." +
                    "\n" +
                    "The MeasuredValue attribute is updated continuously as new measurements are made."
            }
        ),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "uint16", access: "R V", conformance: "M",
            constraint: "1 to 65533", quality: "X", xref: "cluster§2.2.5.2",
            details: "Indicates the minimum value of MeasuredValue that can be measured. A value of null indicates that " +
                "this attribute is not defined. See Measured Value for more details."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "uint16", access: "R V", conformance: "M",
            constraint: "min minMeasuredValue + 1", quality: "X", xref: "cluster§2.2.5.3",
            details: "Indicates the maximum value of MeasuredValue that can be measured. A value of null indicates that " +
                "this attribute is not defined. See Measured Value for more details."
        }),

        Attribute({
            name: "Tolerance", id: 0x3, type: "uint16", access: "R V", conformance: "O", constraint: "max 2048",
            xref: "cluster§2.2.5.4",
            details: "See Measured Value."
        }),

        Attribute({
            name: "LightSensorType", id: 0x4, type: "LightSensorTypeEnum", access: "R V", conformance: "O",
            default: null, quality: "X", xref: "cluster§2.2.5.5",
            details: "Indicates the electronic type of the light sensor. This attribute shall be set to one of the " +
                "non-reserved values listed in LightSensorTypeEnum or null in case the sensor type is unknown."
        }),

        Datatype(
            { name: "LightSensorTypeEnum", type: "enum8", xref: "cluster§2.2.4.1" },
            Field({ name: "Photodiode", id: 0x0, conformance: "M", description: "Indicates photodiode sensor type" }),
            Field({ name: "Cmos", id: 0x1, conformance: "M", description: "Indicates CMOS sensor type" })
        )
    ),

    Cluster(
        {
            name: "TemperatureMeasurement", id: 0x402, classification: "application", pics: "TMP",
            xref: "cluster§2.3",
            details: "This cluster provides an interface to temperature measurement functionality, including configuration " +
                "and provision of notifications of temperature measurements."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 4 }),
        Attribute({
            name: "MeasuredValue", id: 0x0, type: "temperature", access: "R V", conformance: "M",
            constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.3.4.1",
            details: "Indicates the measured temperature. The null value indicates that the temperature is unknown."
        }),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "temperature", access: "R V", conformance: "M",
            constraint: "-27315 to 32766", quality: "X", xref: "cluster§2.3.4.2",
            details: "Indicates the minimum value of MeasuredValue that is capable of being measured. See Measured Value " +
                "for more details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "temperature", access: "R V", conformance: "M",
            constraint: "min minMeasuredValue + 1", quality: "X", xref: "cluster§2.3.4.3",
            details: "This attribute indicates the maximum value of MeasuredValue that is capable of being measured. See " +
                "Measured Value for more details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "Tolerance", id: 0x3, type: "uint16", access: "R V", conformance: "O", constraint: "max 2048",
            default: 0, xref: "cluster§2.3.4.4",
            details: "See Measured Value."
        })
    ),

    Cluster(
        {
            name: "PressureMeasurement", id: 0x403, classification: "application", pics: "PRS",
            xref: "cluster§2.4",
            details: "This cluster provides an interface to pressure measurement functionality, including configuration " +
                "and provision of notifications of pressure measurements."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.4.4" },
            Field({
                name: "EXT", conformance: "O", constraint: "0", title: "Extended",
                details: "Extended range and resolution"
            })
        ),

        Attribute(
            {
                name: "MeasuredValue", id: 0x0, type: "int16", access: "R V", conformance: "M",
                constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.4.5.1",
                details: "Indicates the pressure in kPa as follows:" +
                    "\n" +
                    "MeasuredValue = 10 x Pressure [kPa]" +
                    "\n" +
                    "The null value indicates that the value is not available."
            }
        ),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "int16", access: "R V", conformance: "M",
            constraint: "max 32766", quality: "X", xref: "cluster§2.4.5.2",
            details: "Indicates the minimum value of MeasuredValue that can be measured. See Measured Value for more " +
                "details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "int16", access: "R V", conformance: "M",
            constraint: "minMeasuredValue + 1 to 32767", quality: "X", xref: "cluster§2.4.5.3",
            details: "Indicates the maximum value of MeasuredValue that can be measured. See Measured Value for more " +
                "details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "Tolerance", id: 0x3, type: "uint16", access: "R V", conformance: "O", constraint: "max 2048",
            default: 0, xref: "cluster§2.4.5.4",
            details: "See Measured Value."
        }),

        Attribute(
            {
                name: "ScaledValue", id: 0x10, type: "int16", access: "R V", conformance: "EXT",
                constraint: "minScaledValue to maxScaledValue", quality: "X", xref: "cluster§2.4.5.5",
                details: "Indicates the pressure in Pascals as follows:" +
                    "\n" +
                    "ScaledValue = 10Scale x Pressure [Pa]" +
                    "\n" +
                    "The null value indicates that the value is not available."
            }
        ),

        Attribute({
            name: "MinScaledValue", id: 0x11, type: "int16", access: "R V", conformance: "EXT",
            constraint: "max 32766", quality: "X", xref: "cluster§2.4.5.6",
            details: "Indicates the minimum value of ScaledValue that can be measured. The null value indicates that the " +
                "value is not available."
        }),

        Attribute({
            name: "MaxScaledValue", id: 0x12, type: "int16", access: "R V", conformance: "EXT",
            constraint: "minScaledValue + 1 to 32767", quality: "X", xref: "cluster§2.4.5.7",
            details: "Indicates the maximum value of ScaledValue that can be measured. The null value indicates that the " +
                "value is not available."
        }),

        Attribute({
            name: "ScaledTolerance", id: 0x13, type: "uint16", access: "R V", conformance: "[EXT]",
            constraint: "max 2048", default: 0, xref: "cluster§2.4.5.8",
            details: "Indicates the magnitude of the possible error that is associated with Scaled" +
                "\n" +
                "### Value. The true value is located in the range" +
                "\n" +
                "(ScaledValue – ScaledTolerance) to (ScaledValue + ScaledTolerance)."
        }),

        Attribute({
            name: "Scale", id: 0x14, type: "int8", access: "R V", conformance: "EXT", constraint: "min -127",
            xref: "cluster§2.4.5.9",
            details: "Indicates the base 10 exponent used to obtain ScaledValue (see ScaledValue)."
        })
    ),

    Cluster(
        {
            name: "FlowMeasurement", id: 0x404, classification: "application", pics: "FLW", xref: "cluster§2.5",
            details: "This cluster provides an interface to flow measurement functionality, including configuration and " +
                "provision of notifications of flow measurements."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            {
                name: "MeasuredValue", id: 0x0, type: "uint16", access: "R V", conformance: "M",
                constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.5.4.1",

                details: "Indicates the flow in m/h as follows:" +
                    "\n" +
                    "MeasuredValue = 10 x Flow" +
                    "\n" +
                    "The null value indicates that the flow measurement is unknown, otherwise the range shall be as " +
                    "described in Measured Value."
            }
        ),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "uint16", access: "R V", conformance: "M",
            constraint: "max 65533", quality: "X", xref: "cluster§2.5.4.2",
            details: "Indicates the minimum value of MeasuredValue that can be measured. See Measured Value for more " +
                "details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "uint16", access: "R V", conformance: "M",
            constraint: "min minMeasuredValue + 1", quality: "X", xref: "cluster§2.5.4.3",
            details: "Indicates the maximum value of MeasuredValue that can be measured. See Measured Value for more " +
                "details." +
                "\n" +
                "The null value indicates that the value is not available."
        }),

        Attribute({
            name: "Tolerance", id: 0x3, type: "uint16", access: "R V", conformance: "O", constraint: "max 2048",
            default: 0, xref: "cluster§2.5.4.4",
            details: "See Measured Value."
        })
    ),

    Cluster(
        {
            name: "RelativeHumidityMeasurement", id: 0x405, classification: "application", pics: "RH",
            xref: "cluster§2.6",
            details: "This is a base cluster. The server cluster provides an interface to water content measurement " +
                "functionality. The measurement is reportable and may be configured for reporting. Water content " +
                "measurements currently is, but are not limited to relative humidity."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            {
                name: "MeasuredValue", id: 0x0, type: "uint16", access: "R V", conformance: "M",
                constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.6.4.1",

                details: "MeasuredValue represents the water content in % as follows:" +
                    "\n" +
                    "MeasuredValue = 100 x water content" +
                    "\n" +
                    "Where 0% < = water content < = 100%, corresponding to a MeasuredValue in the range 0 to 10000. The " +
                    "maximum resolution this format allows is 0.01%." +
                    "\n" +
                    "MinMeasuredValue and MaxMeasuredValue define the range of the sensor." +
                    "\n" +
                    "The null value indicates that the measurement is unknown, otherwise the range shall be as described " +
                    "in Measured Value." +
                    "\n" +
                    "MeasuredValue is updated continuously as new measurements are made."
            }
        ),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "uint16", access: "R V", conformance: "M",
            constraint: "max 9999", quality: "X", xref: "cluster§2.6.4.2",
            details: "The MinMeasuredValue attribute indicates the minimum value of MeasuredValue that can be measured. " +
                "The null value means this attribute is not defined. See Measured Value for more details."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "uint16", access: "R V", conformance: "M",
            constraint: "minMeasuredValue + 1 to 10000", quality: "X", xref: "cluster§2.6.4.3",
            details: "The MaxMeasuredValue attribute indicates the maximum value of MeasuredValue that can be measured. " +
                "The null value means this attribute is not defined. See Measured Value for more details."
        }),

        Attribute({
            name: "Tolerance", id: 0x3, type: "uint16", access: "R V", conformance: "O", constraint: "max 2048",
            xref: "cluster§2.6.4.4",
            details: "See Measured Value."
        })
    ),

    Cluster(
        {
            name: "OccupancySensing", id: 0x406, classification: "application", pics: "OCC",
            xref: "cluster§2.7",
            details: "The server cluster provides an interface to occupancy sensing functionality based on one or more " +
                "sensing modalities, including configuration and provision of notifications of occupancy status."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 5 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.7.4" },
            Field({
                name: "OTHER", conformance: "O.a+", constraint: "0", title: "Other",
                details: "Supports sensing using a modality not listed in the other bits"
            }),
            Field({
                name: "PIR", conformance: "O.a+", constraint: "1", title: "PassiveInfrared",
                details: "Supports sensing using PIR (Passive InfraRed)"
            }),
            Field({
                name: "US", conformance: "O.a+", constraint: "2", title: "Ultrasonic",
                details: "Supports sensing using UltraSound"
            }),
            Field({
                name: "PHY", conformance: "O.a+", constraint: "3", title: "PhysicalContact",
                details: "Supports sensing using a physical contact"
            }),
            Field({
                name: "AIR", conformance: "O.a+", constraint: "4", title: "ActiveInfrared",
                details: "Supports sensing using Active InfraRed measurement (e.g. time-of-flight or transflective/reflective " +
                    "IR sensing)"
            }),
            Field({
                name: "RAD", conformance: "O.a+", constraint: "5", title: "Radar",
                details: "Supports sensing using radar waves (microwave)"
            }),
            Field({
                name: "RFS", conformance: "O.a+", constraint: "6", title: "RfSensing",
                details: "Supports sensing using analysis of radio signals, e.g.: RSSI, CSI and/or any other metric from the " +
                    "signal"
            }),
            Field({
                name: "VIS", conformance: "O.a+", constraint: "7", title: "Vision",
                details: "Supports sensing based on analyzing images"
            })
        ),

        Attribute({
            name: "Occupancy", id: 0x0, type: "OccupancyBitmap", access: "R V", conformance: "M",
            constraint: "0 to 1", quality: "P", xref: "cluster§2.7.6.1",
            details: "Indicates the sensed (processed) status of occupancy. For compatibility reasons this is expressed as " +
                "a bitmap where the status is indicated in bit 0: a value of 1 means occupied, and 0 means " +
                "unoccupied, with the other bits set to 0; this can be considered equivalent to a boolean."
        }),

        Attribute({
            name: "OccupancySensorType", id: 0x1, type: "OccupancySensorTypeEnum", access: "R V",
            conformance: "M, D", constraint: "desc", quality: "F", xref: "cluster§2.7.6"
        }),
        Attribute({
            name: "OccupancySensorTypeBitmap", id: 0x2, type: "OccupancySensorTypeBitmap", access: "R V",
            conformance: "M, D", constraint: "0 to 7", quality: "F", xref: "cluster§2.7.6"
        }),

        Attribute({
            name: "HoldTime", id: 0x3, type: "uint16", access: "RW VM", conformance: "O",
            constraint: "holdTimeLimits.holdTimeMin to holdTimeLimits.holdTimeMax", quality: "N",
            xref: "cluster§2.7.6.3",

            details: "This attribute shall specify the time delay, in seconds, before the sensor changes to its unoccupied " +
                "state after the last detection of occupancy in the sensed area. This is equivalent to the legacy " +
                "*OccupiedToUnoccupiedDelay attributes." +
                "\n" +
                "Low values of HoldTime SHOULD be avoided since they could lead to many reporting messages. A value 0 " +
                "for HoldTime shall NOT be used." +
                "\n" +
                "The figure below illustrates this with an example of how this attribute is used for a PIR sensor. It " +
                "uses threshold detection to generate an \"internal detection\" signal, which needs post-processing to " +
                "become usable for transmission (traffic shaping). The bit in the Occupancy attribute will be set to " +
                "1 when the internal detection signal goes high, and will stay at 1 for HoldTime after the (last) " +
                "instance where the internal detection signal goes low." +
                "\n" +
                "The top half of the figure shows the case of a single trigger: the bit in the Occupancy attribute " +
                "will be 1 for the duration of the PIR signal exceeding the threshold plus HoldTime. The bottom half " +
                "of the figure shows the case of multiple triggers: the second trigger starts before the HoldTime of " +
                "the first trigger has expired; this results in a single period of the bit in the Occupancy attribute " +
                "being 1. The bit in the Occupancy attribute will be set to 1 from the start of the first period " +
                "where the PIR signal exceeds the threshold until HoldTime after the last moment where the PIR " +
                "exceeded the threshold."
        }),

        Attribute({
            name: "HoldTimeLimits", id: 0x4, type: "HoldTimeLimitsStruct", access: "R V",
            conformance: "HoldTime", quality: "F", xref: "cluster§2.7.6.4",
            details: "Indicates the server’s limits, and default value, for the HoldTime attribute."
        }),

        Attribute({
            name: "PirOccupiedToUnoccupiedDelay", id: 0x10, type: "uint16", access: "RW VM",
            conformance: "[HoldTime & (PIR | !PIR & !US & !PHY)], D", default: 0, quality: "N",
            xref: "cluster§2.7.6.6",
            details: "This attribute shall specify the time delay, in seconds, before the PIR sensor changes to its " +
                "unoccupied state after the last detection of occupancy in the sensed area."
        }),

        Attribute({
            name: "PirUnoccupiedToOccupiedDelay", id: 0x11, type: "uint16", access: "RW VM",
            conformance: "HoldTime & (PIR | !PIR & !US & !PHY) & PirUnoccupiedToOccupiedThreshold, [HoldTime & (PIR | !PIR & !US & !PHY)], D",
            default: 0, quality: "N", xref: "cluster§2.7.6.7",
            details: "This attribute shall specify the time delay, in seconds, before the PIR sensor changes to its " +
                "occupied state after the first detection of occupancy in the sensed area."
        }),

        Attribute({
            name: "PirUnoccupiedToOccupiedThreshold", id: 0x12, type: "uint8", access: "RW VM",
            conformance: "HoldTime & (PIR | !PIR & !US & !PHY) & PirUnoccupiedToOccupiedDelay, [HoldTime & (PIR | !PIR & !US & !PHY)], D",
            constraint: "1 to 254", default: 1, quality: "N", xref: "cluster§2.7.6.8",
            details: "This attribute shall specify the number of occupancy detection events that must occur in the period " +
                "PIRUnoccupiedToOccupiedDelay, before the PIR sensor changes to its occupied state."
        }),

        Attribute({
            name: "UltrasonicOccupiedToUnoccupiedDelay", id: 0x20, type: "uint16", access: "RW VM",
            conformance: "[HoldTime & US], D", default: 0, quality: "N", xref: "cluster§2.7.6.9",
            details: "This attribute shall specify the time delay, in seconds, before the Ultrasonic sensor changes to its " +
                "unoccupied state after the last detection of occupancy in the sensed area."
        }),

        Attribute({
            name: "UltrasonicUnoccupiedToOccupiedDelay", id: 0x21, type: "uint16", access: "RW VM",
            conformance: "HoldTime & US & UltrasonicUnoccupiedToOccupiedThreshold, [HoldTime & US], D",
            default: 0, quality: "N", xref: "cluster§2.7.6.10",
            details: "This attribute shall specify the time delay, in seconds, before the Ultrasonic sensor changes to its " +
                "occupied state after the first detection of occupancy in the sensed area."
        }),

        Attribute({
            name: "UltrasonicUnoccupiedToOccupiedThreshold", id: 0x22, type: "uint8", access: "RW VM",
            conformance: "HoldTime & US & UltrasonicUnoccupiedToOccupiedDelay, [HoldTime & US], D",
            constraint: "1 to 254", default: 1, quality: "N", xref: "cluster§2.7.6.11",
            details: "This attribute shall specify the number of occupancy detection events that must occur in the period " +
                "UltrasonicUnoccupiedToOccupiedDelay, before the Ultrasonic sensor changes to its occupied state."
        }),

        Attribute({
            name: "PhysicalContactOccupiedToUnoccupiedDelay", id: 0x30, type: "uint16", access: "RW VM",
            conformance: "[HoldTime & PHY], D", default: 0, quality: "N", xref: "cluster§2.7.6.12",
            details: "This attribute shall specify the time delay, in seconds, before the physical contact occupancy " +
                "sensor changes to its unoccupied state after detecting the unoccupied event."
        }),

        Attribute({
            name: "PhysicalContactUnoccupiedToOccupiedDelay", id: 0x31, type: "uint16", access: "RW VM",
            conformance: "HoldTime & PHY & PhysicalContactUnoccupiedToOccupiedThreshold, [HoldTime & PHY], D",
            default: 0, quality: "N", xref: "cluster§2.7.6.13",
            details: "This attribute shall specify the time delay, in seconds, before the physical contact sensor changes " +
                "to its occupied state after the first detection of the occupied event."
        }),

        Attribute({
            name: "PhysicalContactUnoccupiedToOccupiedThreshold", id: 0x32, type: "uint8", access: "RW VM",
            conformance: "HoldTime & PHY & PhysicalContactUnoccupiedToOccupiedDelay, [HoldTime & PHY], D",
            constraint: "1 to 254", default: 1, quality: "N", xref: "cluster§2.7.6.14",
            details: "This attribute shall specify the number of occupancy detection events that must occur in the period " +
                "PhysicalContactUnoccupiedToOccupiedDelay, before the PhysicalContact sensor changes to its occupied " +
                "state."
        }),

        Event(
            {
                name: "OccupancyChanged", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "cluster§2.7.7.1",
                details: "If this event is supported, it shall be generated when the Occupancy attribute changes."
            },
            Field({
                name: "Occupancy", id: 0x0, type: "OccupancyBitmap", conformance: "M", xref: "cluster§2.7.7.1.1",
                details: "This field shall indicate the new value of the Occupancy attribute."
            })
        ),

        Datatype(
            { name: "OccupancyBitmap", type: "map8", xref: "cluster§2.7.5.1" },

            Field({
                name: "Occupied", constraint: "0", description: "Indicates the sensed occupancy state",
                xref: "cluster§2.7.5.1.1",
                details: "If this bit is set, it shall indicate the occupied state else if the bit if not set, it shall " +
                    "indicate the unoccupied state."
            })
        ),

        Datatype(
            {
                name: "OccupancySensorTypeBitmap", type: "map8", xref: "cluster§2.7.5.2",
                details: "> [!NOTE]" +
                    "\n" +
                    "> This enum is as defined in ClusterRevision 4 and its definition shall NOT be extended; the feature " +
                    "  flags provide the sensor modality (or modalities) for later cluster revisions. See Backward " +
                    "  Compatibility section."
            },

            Field({ name: "Pir", constraint: "0", description: "Indicates a passive infrared sensor." }),
            Field({ name: "Ultrasonic", constraint: "1", description: "Indicates a ultrasonic sensor." }),
            Field({ name: "PhysicalContact", constraint: "2", description: "Indicates a physical contact sensor." })
        ),

        Datatype(
            {
                name: "OccupancySensorTypeEnum", type: "enum8", xref: "cluster§2.7.5.3",
                details: "> [!NOTE]" +
                    "\n" +
                    "> This enum is as defined in ClusterRevision 4 and its definition shall NOT be extended; the feature " +
                    "  flags provide the sensor modality (or modalities) for later cluster revisions. See Backward " +
                    "  Compatibility section."
            },

            Field({ name: "Pir", id: 0x0, conformance: "M", description: "Indicates a passive infrared sensor." }),
            Field({ name: "Ultrasonic", id: 0x1, conformance: "M", description: "Indicates a ultrasonic sensor." }),
            Field({
                name: "PirAndUltrasonic", id: 0x2, conformance: "M",
                description: "Indicates a passive infrared and ultrasonic sensor."
            }),
            Field({ name: "PhysicalContact", id: 0x3, conformance: "M", description: "Indicates a physical contact sensor." })
        ),

        Datatype(
            {
                name: "HoldTimeLimitsStruct", type: "struct", xref: "cluster§2.7.5.4",
                details: "This structure provides information on the server’s supported values for the HoldTime attribute."
            },

            Field({
                name: "HoldTimeMin", id: 0x0, type: "uint16", conformance: "M", constraint: "min 1",
                xref: "cluster§2.7.5.4.1",
                details: "This field shall specify the minimum value of the server’s supported value for the HoldTime " +
                    "attribute, in seconds."
            }),

            Field({
                name: "HoldTimeMax", id: 0x1, type: "uint16", conformance: "M",
                constraint: "min maxOf(holdTimeMin, 10)", xref: "cluster§2.7.5.4.2",
                details: "This field shall specify the maximum value of the server’s supported value for the HoldTime " +
                    "attribute, in seconds."
            }),

            Field({
                name: "HoldTimeDefault", id: 0x2, type: "uint16", conformance: "M",
                constraint: "holdTimeMin to holdTimeMax", xref: "cluster§2.7.5.4.3",
                details: "This field shall specify the (manufacturer-determined) default value of the server’s HoldTime " +
                    "attribute, in seconds. This is the value that a client who wants to reset the settings to a valid " +
                    "default SHOULD use."
            })
        )
    ),

    Cluster(
        {
            name: "ResourceMonitoring", classification: "application", pics: "REPM", xref: "cluster§2.8",

            details: "This generic cluster provides an interface to the current condition of a resource. A resource is a " +
                "component of a device that is designed to be replaced, refilled, or emptied when exhausted or full. " +
                "Examples of resources include filters, cartridges, and water tanks. While batteries fit this " +
                "definition they are not intended to be used with this cluster. Use the power source cluster for " +
                "batteries instead." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> This cluster is not meant to be used for monitoring of the system resources, such as processing, " +
                "  memory utilization, networking properties, etc." +
                "\n" +
                "This cluster shall be used via an alias to a specific resource type (see Cluster IDs)."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.8.4" },
            Field({
                name: "CON", conformance: "O", constraint: "0", title: "Condition",
                details: "Supports monitoring the condition of the resource in percentage"
            }),
            Field({
                name: "WRN", conformance: "O", constraint: "1", title: "Warning",
                details: "Supports warning indication"
            }),
            Field({
                name: "REP", conformance: "O", constraint: "2", title: "ReplacementProductList",
                details: "Supports specifying the list of replacement products"
            })
        ),

        Attribute({
            name: "Condition", id: 0x0, type: "percent", access: "R V", conformance: "CON",
            xref: "cluster§2.8.6.1",
            details: "Indicates the current condition of the resource in percent."
        }),

        Attribute({
            name: "DegradationDirection", id: 0x1, type: "DegradationDirectionEnum", access: "R V",
            conformance: "CON", constraint: "desc", quality: "F", xref: "cluster§2.8.6.2",
            details: "Indicates the direction of change for the condition of the resource over time, which helps to " +
                "determine whether a higher or lower condition value is considered optimal."
        }),

        Attribute({
            name: "ChangeIndication", id: 0x2, type: "ChangeIndicationEnum", access: "R V", conformance: "M",
            xref: "cluster§2.8.6.3",
            details: "This attribute shall be populated with a value from ChangeIndicationEnum that is indicative of the " +
                "current requirement to change the resource."
        }),

        Attribute({
            name: "InPlaceIndicator", id: 0x3, type: "bool", access: "R V", conformance: "O",
            xref: "cluster§2.8.6.4",
            details: "Indicates whether a resource is currently installed. A value of true shall indicate that a resource " +
                "is installed. A value of false shall indicate that a resource is not installed."
        }),

        Attribute({
            name: "LastChangedTime", id: 0x4, type: "epoch-s", access: "RW VO", conformance: "O", default: null,
            quality: "X N", xref: "cluster§2.8.6.5",
            details: "This attribute may indicates the time at which the resource has been changed, if supported by the " +
                "server. The attribute shall be null if it was never set or is unknown."
        }),

        Attribute(
            {
                name: "ReplacementProductList", id: 0x5, type: "list", access: "R V", conformance: "REP",
                constraint: "max 5", quality: "F", xref: "cluster§2.8.6.6",
                details: "Indicates the list of supported products that may be used as replacements for the current resource. " +
                    "Each item in this list represents a unique ReplacementProductStruct."
            },

            Field({ name: "entry", type: "ReplacementProductStruct" })
        ),

        Command({
            name: "ResetCondition", id: 0x0, access: "O", conformance: "O", direction: "request",
            response: "status", xref: "cluster§2.8.7.1",
            details: "Upon receipt, the device shall reset the Condition and ChangeIndicator attributes, indicating full " +
                "resource availability and readiness for use, as initially configured. Invocation of this command may " +
                "cause the LastChangedTime to be updated automatically based on the clock of the server, if the " +
                "server supports setting the attribute."
        }),

        Datatype(
            {
                name: "DegradationDirectionEnum", type: "enum8", xref: "cluster§2.8.5.1",
                details: "Indicates the direction in which the condition of the resource changes over time."
            },
            Field({
                name: "Up", id: 0x0, conformance: "M",
                description: "The degradation of the resource is indicated by an upwards moving/increasing value"
            }),
            Field({
                name: "Down", id: 0x1, conformance: "M",
                description: "The degradation of the resource is indicated by a downwards moving/decreasing value"
            })
        ),

        Datatype(
            { name: "ChangeIndicationEnum", type: "enum8", xref: "cluster§2.8.5.2" },
            Field({
                name: "Ok", id: 0x0, conformance: "M",
                description: "Resource is in good condition, no intervention required"
            }),
            Field({
                name: "Warning", id: 0x1, conformance: "WRN",
                description: "Resource will be exhausted soon, intervention will shortly be required"
            }),
            Field({
                name: "Critical", id: 0x2, conformance: "M",
                description: "Resource is exhausted, immediate intervention is required"
            })
        ),

        Datatype(
            {
                name: "ProductIdentifierTypeEnum", type: "enum8", xref: "cluster§2.8.5.3",
                details: "Indicate the type of identifier used to describe the product. Devices SHOULD use globally-recognized " +
                    "IDs over OEM specific ones."
            },
            Field({ name: "Upc", id: 0x0, conformance: "M", description: "12-digit Universal Product Code" }),
            Field({ name: "Gtin8", id: 0x1, conformance: "M", description: "8-digit Global Trade Item Number" }),
            Field({ name: "Ean", id: 0x2, conformance: "M", description: "13-digit European Article Number" }),
            Field({ name: "Gtin14", id: 0x3, conformance: "M", description: "14-digit Global Trade Item Number" }),
            Field({ name: "Oem", id: 0x4, conformance: "M", description: "Original Equipment Manufacturer part number" })
        ),

        Datatype(
            {
                name: "ReplacementProductStruct", type: "struct", xref: "cluster§2.8.5.4",
                details: "Indicates the product identifier that can be used as a replacement for the resource."
            },
            Field({
                name: "ProductIdentifierType", id: 0x0, type: "ProductIdentifierTypeEnum", conformance: "M",
                constraint: "desc"
            }),
            Field({ name: "ProductIdentifierValue", id: 0x1, type: "string", conformance: "M", constraint: "max 20" })
        )
    ),

    Cluster({ name: "HepaFilterMonitoring", id: 0x71, type: "ResourceMonitoring", pics: "HEPAFREMON" }),
    Cluster({ name: "ActivatedCarbonFilterMonitoring", id: 0x72, type: "ResourceMonitoring", pics: "ACFREMON" }),
    Cluster({ name: "WaterTankLevelMonitoring", id: 0x79, type: "ResourceMonitoring", pics: "WTLREPMON" }),

    Cluster(
        {
            name: "AirQuality", id: 0x5b, classification: "application", pics: "AIRQUAL", xref: "cluster§2.9",
            details: "This cluster provides an interface to air quality classification using distinct levels with " +
                "human-readable labels."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.9.4" },
            Field({
                name: "FAIR", conformance: "O", constraint: "0", title: "Fair",
                details: "Cluster supports the Fair air quality level"
            }),
            Field({
                name: "MOD", conformance: "O", constraint: "1", title: "Moderate",
                details: "Cluster supports the Moderate air quality level"
            }),
            Field({
                name: "VPOOR", conformance: "O", constraint: "2", title: "VeryPoor",
                details: "Cluster supports the Very poor air quality level"
            }),
            Field({
                name: "XPOOR", conformance: "O", constraint: "3", title: "ExtremelyPoor",
                details: "Cluster supports the Extremely poor air quality level"
            })
        ),

        Attribute({
            name: "AirQuality", id: 0x0, type: "AirQualityEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§2.9.6.1",
            details: "Indicates a value from AirQualityEnum that is indicative of the currently measured air quality."
        }),

        Datatype(
            {
                name: "AirQualityEnum", type: "enum8", xref: "cluster§2.9.5.1",
                details: "The AirQualityEnum provides a representation of the quality of the analyzed air. It is up to the " +
                    "device manufacturer to determine the mapping between the measured values and their corresponding " +
                    "enumeration values."
            },

            Field({ name: "Unknown", id: 0x0, conformance: "M", description: "The air quality is unknown." }),
            Field({ name: "Good", id: 0x1, conformance: "M", description: "The air quality is good." }),
            Field({ name: "Fair", id: 0x2, conformance: "FAIR", description: "The air quality is fair." }),
            Field({ name: "Moderate", id: 0x3, conformance: "MOD", description: "The air quality is moderate." }),
            Field({ name: "Poor", id: 0x4, conformance: "M", description: "The air quality is poor." }),
            Field({ name: "VeryPoor", id: 0x5, conformance: "VPOOR", description: "The air quality is very poor." }),
            Field({ name: "ExtremelyPoor", id: 0x6, conformance: "XPOOR", description: "The air quality is extremely poor." })
        )
    ),

    Cluster(
        {
            name: "ConcentrationMeasurement", classification: "application", pics: "CONC", xref: "cluster§2.10",
            details: "The server cluster provides an interface to concentration measurement functionality. This cluster " +
                "shall to be used via an alias to a specific substance (see Cluster IDs)."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.10.4" },
            Field({
                name: "MEA", conformance: "O.a+", constraint: "0", title: "NumericMeasurement",
                details: "Cluster supports numeric measurement of substance"
            }),
            Field({
                name: "LEV", conformance: "O.a+", constraint: "1", title: "LevelIndication",
                details: "Cluster supports basic level indication for substance using the ConcentrationLevel enum"
            }),
            Field({
                name: "MED", conformance: "[LEV]", constraint: "2", title: "MediumLevel",
                details: "Cluster supports the Medium Concentration Level"
            }),
            Field({
                name: "CRI", conformance: "[LEV]", constraint: "3", title: "CriticalLevel",
                details: "Cluster supports the Critical Concentration Level"
            }),
            Field({
                name: "PEA", conformance: "[MEA]", constraint: "4", title: "PeakMeasurement",
                details: "Cluster supports peak numeric measurement of substance"
            }),
            Field({
                name: "AVG", conformance: "[MEA]", constraint: "5", title: "AverageMeasurement",
                details: "Cluster supports average numeric measurement of substance"
            })
        ),

        Attribute({
            name: "MeasuredValue", id: 0x0, type: "single", access: "R V", conformance: "MEA",
            constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.10.6.1",
            details: "Indicates the most recent measurement as a single-precision floating-point number. MeasuredValue’s " +
                "unit is represented by MeasurementUnit." +
                "\n" +
                "A value of null indicates that the measurement is unknown or outside the valid range. " +
                "MinMeasuredValue and MaxMeasuredValue define the valid range for MeasuredValue."
        }),

        Attribute({
            name: "MinMeasuredValue", id: 0x1, type: "single", access: "R V", conformance: "MEA", quality: "X",
            xref: "cluster§2.10.6.2",
            details: "Indicates the minimum value of MeasuredValue that is capable of being measured. A MinMeasuredValue " +
                "of null indicates that the MinMeasuredValue is not defined."
        }),

        Attribute({
            name: "MaxMeasuredValue", id: 0x2, type: "single", access: "R V", conformance: "MEA",
            constraint: "min minMeasuredValue", quality: "X", xref: "cluster§2.10.6.3",
            details: "Indicates the maximum value of MeasuredValue that is capable of being measured. A MaxMeasuredValue " +
                "of null indicates that the MaxMeasuredValue is not defined."
        }),

        Attribute({
            name: "PeakMeasuredValue", id: 0x3, type: "single", access: "R V", conformance: "PEA",
            constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.10.6.4",
            details: "Indicates the maximum value of MeasuredValue that has been measured during the " +
                "PeakMeasuredValueWindow. If this attribute is provided, the PeakMeasuredValueWindow attribute shall " +
                "also be provided."
        }),

        Attribute({
            name: "PeakMeasuredValueWindow", id: 0x4, type: "elapsed-s", access: "R V", conformance: "PEA",
            constraint: "max 604800", quality: "P", xref: "cluster§2.10.6.5",
            details: "Indicates the window of time used for determining the PeakMeasuredValue. The value is in seconds."
        }),

        Attribute({
            name: "AverageMeasuredValue", id: 0x5, type: "single", access: "R V", conformance: "AVG",
            constraint: "minMeasuredValue to maxMeasuredValue", quality: "X P", xref: "cluster§2.10.6.6",
            details: "Indicates the average value of MeasuredValue that has been measured during the " +
                "AverageMeasuredValueWindow. If this attribute is provided, the AverageMeasuredValueWindow attribute " +
                "shall also be provided."
        }),

        Attribute({
            name: "AverageMeasuredValueWindow", id: 0x6, type: "elapsed-s", access: "R V", conformance: "AVG",
            constraint: "max 604800", quality: "P", xref: "cluster§2.10.6.7",
            details: "Indicates the window of time used for determining the AverageMeasuredValue. The value is in seconds."
        }),

        Attribute({
            name: "Uncertainty", id: 0x7, type: "single", access: "R V", conformance: "[MEA]", constraint: "ms",
            xref: "cluster§2.10.6.8",
            details: "Indicates the range of error or deviation that can be found in MeasuredValue and PeakMeasuredValue. " +
                "This is considered a +/- value and should be considered to be in MeasurementUnit."
        }),

        Attribute({
            name: "MeasurementUnit", id: 0x8, type: "MeasurementUnitEnum", access: "R V", conformance: "MEA",
            quality: "F", xref: "cluster§2.10.6.9",
            details: "Indicates the unit of MeasuredValue. See MeasurementUnitEnum."
        }),

        Attribute({
            name: "MeasurementMedium", id: 0x9, type: "MeasurementMediumEnum", access: "R V", conformance: "M",
            quality: "F", xref: "cluster§2.10.6.10",
            details: "Indicates the medium in which MeasuredValue or LevelValue is being measured. See " +
                "MeasurementMediumEnum."
        }),

        Attribute({
            name: "LevelValue", id: 0xa, type: "LevelValueEnum", access: "R V", conformance: "LEV",
            xref: "cluster§2.10.6.11",
            details: "Indicates the level of the substance detected. See LevelValueEnum."
        }),

        Datatype(
            {
                name: "MeasurementUnitEnum", type: "enum8", xref: "cluster§2.10.5.1",
                details: "Where mentioned, Billion refers to 10, Trillion refers to 1012 (short scale)."
            },
            Field({ name: "Ppm", id: 0x0, conformance: "MEA", description: "Parts per Million (10)" }),
            Field({ name: "Ppb", id: 0x1, conformance: "MEA", description: "Parts per Billion (10)" }),
            Field({ name: "Ppt", id: 0x2, conformance: "MEA", description: "Parts per Trillion (1012)" }),
            Field({ name: "Mgm3", id: 0x3, conformance: "MEA", description: "Milligram per m" }),
            Field({ name: "Ugm3", id: 0x4, conformance: "MEA", description: "Microgram per m" }),
            Field({ name: "Ngm3", id: 0x5, conformance: "MEA", description: "Nanogram per m" }),
            Field({ name: "Pm3", id: 0x6, conformance: "MEA", description: "Particles per m" }),
            Field({ name: "Bqm3", id: 0x7, conformance: "MEA", description: "Becquerel per m" })
        ),

        Datatype(
            { name: "MeasurementMediumEnum", type: "enum8", xref: "cluster§2.10.5.2" },
            Field({ name: "Air", id: 0x0, conformance: "M", description: "The measurement is being made in Air" }),
            Field({ name: "Water", id: 0x1, conformance: "M", description: "The measurement is being made in Water" }),
            Field({ name: "Soil", id: 0x2, conformance: "M", description: "The measurement is being made in Soil" })
        ),

        Datatype(
            { name: "LevelValueEnum", type: "enum8", xref: "cluster§2.10.5.3" },
            Field({ name: "Unknown", id: 0x0, conformance: "M", description: "The level is Unknown" }),
            Field({ name: "Low", id: 0x1, conformance: "M", description: "The level is considered Low" }),
            Field({ name: "Medium", id: 0x2, conformance: "MED", description: "The level is considered Medium" }),
            Field({ name: "High", id: 0x3, conformance: "M", description: "The level is considered High" }),
            Field({ name: "Critical", id: 0x4, conformance: "CRI", description: "The level is considered Critical" })
        )
    ),

    Cluster({ name: "CarbonMonoxideConcentrationMeasurement", id: 0x40c, type: "ConcentrationMeasurement", pics: "CMOCONC" }),
    Cluster(
        { name: "CarbonDioxideConcentrationMeasurement", id: 0x40d, type: "ConcentrationMeasurement", pics: "CDOCONC" }
    ),
    Cluster({ name: "NitrogenDioxideConcentrationMeasurement", id: 0x413, type: "ConcentrationMeasurement", pics: "NDOCONC" }),
    Cluster({ name: "OzoneConcentrationMeasurement", id: 0x415, type: "ConcentrationMeasurement", pics: "OZCONC" }),
    Cluster({ name: "Pm25ConcentrationMeasurement", id: 0x42a, type: "ConcentrationMeasurement", pics: "PMICONC" }),
    Cluster({ name: "FormaldehydeConcentrationMeasurement", id: 0x42b, type: "ConcentrationMeasurement", pics: "FLDCONC" }),
    Cluster({ name: "Pm1ConcentrationMeasurement", id: 0x42c, type: "ConcentrationMeasurement", pics: "PMHCONC" }),
    Cluster({ name: "Pm10ConcentrationMeasurement", id: 0x42d, type: "ConcentrationMeasurement", pics: "PMKCONC" }),
    Cluster({
        name: "TotalVolatileOrganicCompoundsConcentrationMeasurement", id: 0x42e,
        type: "ConcentrationMeasurement", pics: "TVOCCONC"
    }),
    Cluster({ name: "RadonConcentrationMeasurement", id: 0x42f, type: "ConcentrationMeasurement", pics: "RNCONC" }),

    Cluster(
        {
            name: "SmokeCoAlarm", id: 0x5c, classification: "application", pics: "SMOKECO",
            xref: "cluster§2.11",
            details: "This cluster provides an interface for observing and managing the state of smoke and CO alarms."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.11.4" },
            Field({
                name: "SMOKE", conformance: "O.a+", constraint: "0", title: "SmokeAlarm",
                details: "Supports Smoke alarm"
            }),
            Field({ name: "CO", conformance: "O.a+", constraint: "1", title: "CoAlarm", details: "Supports CO alarm" })
        ),

        Attribute({
            name: "ExpressedState", id: 0x0, type: "ExpressedStateEnum", access: "R V", conformance: "M",
            quality: "N", xref: "cluster§2.11.6.1",

            details: "Indicates the visibly- and audibly-expressed state of the alarm. When multiple alarm conditions are " +
                "being reflected in the server, this attribute shall indicate the condition with the highest " +
                "priority. Priority order of conditions is determined by the manufacturer and shall be supplied as a " +
                "part of certification procedure. If the value of ExpressedState is not Normal, the attribute " +
                "corresponding to the value shall NOT be Normal. For example, if the ExpressedState is set to " +
                "SmokeAlarm, the value of the SmokeState will indicate the severity of the alarm (Warning or " +
                "Critical). Clients SHOULD also read the other attributes to be aware of further alarm conditions " +
                "beyond the one indicated in ExpressedState." +
                "\n" +
                "Visible expression is typically a LED light pattern. Audible expression is a horn or speaker " +
                "pattern. Audible expression shall BE suppressed if the DeviceMuted attribute is supported and set to " +
                "Muted."
        }),

        Attribute({
            name: "SmokeState", id: 0x1, type: "AlarmStateEnum", access: "R V", conformance: "SMOKE",
            quality: "N", xref: "cluster§2.11.6.2",
            details: "Indicates whether the device’s smoke sensor is currently triggering a smoke alarm."
        }),
        Attribute({
            name: "CoState", id: 0x2, type: "AlarmStateEnum", access: "R V", conformance: "CO", quality: "N",
            xref: "cluster§2.11.6.3",
            details: "Indicates whether the device’s CO sensor is currently triggering a CO alarm."
        }),

        Attribute({
            name: "BatteryAlert", id: 0x3, type: "AlarmStateEnum", access: "R V", conformance: "M",
            quality: "N", xref: "cluster§2.11.6.4",
            details: "Indicates whether the power resource fault detection mechanism is currently triggered at the device. " +
                "If the detection mechanism is triggered, this attribute shall be set to Warning or Critical, " +
                "otherwise it shall be set to Normal. The battery state shall also be reflected in the Power Source " +
                "cluster representing the device’s battery using the appropriate supported attributes and events."
        }),

        Attribute({
            name: "DeviceMuted", id: 0x4, type: "MuteStateEnum", access: "R V", conformance: "O", quality: "N",
            xref: "cluster§2.11.6.5",
            details: "Indicates the whether the audible expression of the device is currently muted. Audible expression is " +
                "typically a horn or speaker pattern."
        }),

        Attribute({
            name: "TestInProgress", id: 0x5, type: "bool", access: "R V", conformance: "M",
            xref: "cluster§2.11.6.6",
            details: "Indicates whether the device self-test is currently activated. If the device self-test is activated, " +
                "this attribute shall be set to True, otherwise it shall be set to False."
        }),

        Attribute({
            name: "HardwareFaultAlert", id: 0x6, type: "bool", access: "R V", conformance: "M", quality: "N",
            xref: "cluster§2.11.6.7",
            details: "Indicates whether the hardware fault detection mechanism is currently triggered. If the detection " +
                "mechanism is triggered, this attribute shall be set to True, otherwise it shall be set to False."
        }),

        Attribute({
            name: "EndOfServiceAlert", id: 0x7, type: "EndOfServiceEnum", access: "R V", conformance: "M",
            quality: "N", xref: "cluster§2.11.6.8",
            details: "Indicates whether the end-of-service has been triggered at the device. This attribute shall be set " +
                "to Expired when the device reaches the end-of-service."
        }),

        Attribute({
            name: "InterconnectSmokeAlarm", id: 0x8, type: "AlarmStateEnum", access: "R V", conformance: "O",
            xref: "cluster§2.11.6.9",
            details: "Indicates whether the interconnected smoke alarm is currently triggering by branching devices. When " +
                "the interconnected smoke alarm is being triggered, this attribute shall be set to Warning or " +
                "Critical, otherwise it shall be set to Normal."
        }),

        Attribute({
            name: "InterconnectCoAlarm", id: 0x9, type: "AlarmStateEnum", access: "R V", conformance: "O",
            xref: "cluster§2.11.6.10",
            details: "Indicates whether the interconnected CO alarm is currently triggering by branching devices. When the " +
                "interconnected CO alarm is being triggered, this attribute shall be set to Warning or Critical, " +
                "otherwise it shall be set to Normal."
        }),

        Attribute({
            name: "ContaminationState", id: 0xa, type: "ContaminationStateEnum", access: "R V",
            conformance: "[SMOKE]", xref: "cluster§2.11.6.11",
            details: "Indicates the contamination level of the smoke sensor."
        }),
        Attribute({
            name: "SmokeSensitivityLevel", id: 0xb, type: "SensitivityEnum", access: "RW VM",
            conformance: "[SMOKE]", xref: "cluster§2.11.6.12",
            details: "Indicates the sensitivity level of the smoke sensor configured on the device."
        }),

        Attribute({
            name: "ExpiryDate", id: 0xc, type: "epoch-s", access: "R V", conformance: "O", quality: "F",
            xref: "cluster§2.11.6.13",
            details: "Indicates the date when the device reaches its stated expiry date. After the ExpiryDate has been " +
                "reached, the EndOfServiceAlert shall start to be triggered. To account for better customer " +
                "experience across time zones, the EndOfServiceAlert may be delayed by up to 24 hours after the " +
                "ExpiryDate. Similarly, clients may delay any actions based on the ExpiryDate by up to 24 hours to " +
                "best align with the local time zone."
        }),

        Event(
            {
                name: "SmokeAlarm", id: 0x0, access: "V", conformance: "SMOKE", priority: "critical",
                xref: "cluster§2.11.8.1",
                details: "This event shall be generated when SmokeState attribute changes to either Warning or Critical state."
            },
            Field({
                name: "AlarmSeverityLevel", id: 0x0, type: "AlarmStateEnum", conformance: "M",
                xref: "cluster§2.11.8.1.1",
                details: "This field shall indicate the current value of the SmokeState attribute."
            })
        ),

        Event(
            {
                name: "CoAlarm", id: 0x1, access: "V", conformance: "CO", priority: "critical",
                xref: "cluster§2.11.8.2",
                details: "This event shall be generated when COState attribute changes to either Warning or Critical state."
            },
            Field({
                name: "AlarmSeverityLevel", id: 0x0, type: "AlarmStateEnum", conformance: "M",
                xref: "cluster§2.11.8.2.1",
                details: "This field shall indicate the current value of the COState attribute."
            })
        ),

        Event(
            {
                name: "LowBattery", id: 0x2, access: "V", conformance: "M", priority: "info",
                xref: "cluster§2.11.8.3",
                details: "This event shall be generated when BatteryAlert attribute changes to either Warning or Critical " +
                    "state."
            },

            Field({
                name: "AlarmSeverityLevel", id: 0x0, type: "AlarmStateEnum", conformance: "M",
                xref: "cluster§2.11.8.3.1",
                details: "This field shall indicate the current value of the BatteryAlert attribute."
            })
        ),

        Event({
            name: "HardwareFault", id: 0x3, access: "V", conformance: "M", priority: "info",
            xref: "cluster§2.11.8.4",
            details: "This event shall be generated when the device detects a hardware fault that leads to setting " +
                "HardwareFaultAlert to True."
        }),

        Event({
            name: "EndOfService", id: 0x4, access: "V", conformance: "M", priority: "info",
            xref: "cluster§2.11.8.5",
            details: "This event shall be generated when the EndOfServiceAlert is set to Expired."
        }),

        Event({
            name: "SelfTestComplete", id: 0x5, access: "V", conformance: "M", priority: "info",
            xref: "cluster§2.11.8.6",
            details: "This event shall be generated when the SelfTest completes, and the attribute TestInProgress changes " +
                "to False."
        }),

        Event({
            name: "AlarmMuted", id: 0x6, access: "V", conformance: "O", priority: "info",
            xref: "cluster§2.11.8.7",
            details: "This event shall be generated when the DeviceMuted attribute changes to Muted."
        }),
        Event({
            name: "MuteEnded", id: 0x7, access: "V", conformance: "O", priority: "info",
            xref: "cluster§2.11.8.8",
            details: "This event shall be generated when DeviceMuted attribute changes to NotMuted."
        }),

        Event(
            {
                name: "InterconnectSmokeAlarm", id: 0x8, access: "V", conformance: "[SMOKE]", priority: "critical",
                xref: "cluster§2.11.8.9",
                details: "This event shall be generated when the device hosting the server receives a smoke alarm from an " +
                    "interconnected sensor."
            },

            Field({
                name: "AlarmSeverityLevel", id: 0x0, type: "AlarmStateEnum", conformance: "M",
                xref: "cluster§2.11.8.9.1",
                details: "This field shall indicate the current value of the InterconnectSmokeAlarm attribute."
            })
        ),

        Event(
            {
                name: "InterconnectCoAlarm", id: 0x9, access: "V", conformance: "[CO]", priority: "critical",
                xref: "cluster§2.11.8.10",
                details: "This event shall be generated when the device hosting the server receives a CO alarm from an " +
                    "interconnected sensor."
            },

            Field({
                name: "AlarmSeverityLevel", id: 0x0, type: "AlarmStateEnum", conformance: "M",
                xref: "cluster§2.11.8.10.1",
                details: "This field shall indicate the current value of the InterconnectCOAlarm attribute."
            })
        ),

        Event({
            name: "AllClear", id: 0xa, access: "V", conformance: "M", priority: "info",
            xref: "cluster§2.11.8.11",
            details: "This event shall be generated when ExpressedState attribute returns to Normal state."
        }),

        Command({
            name: "SelfTestRequest", id: 0x0, access: "O", conformance: "O", direction: "request",
            response: "status", xref: "cluster§2.11.7.1",

            details: "This command shall initiate a device self-test. The return status shall indicate whether the test " +
                "was successfully initiated. Only one SelfTestRequest may be processed at a time. When the value of " +
                "the ExpressedState attribute is any of SmokeAlarm, COAlarm, Testing, InterconnectSmoke, " +
                "InterconnectCO, the device shall NOT execute the self-test, and shall return status code BUSY." +
                "\n" +
                "Upon successful acceptance of SelfTestRequest, the TestInProgress attribute shall be set to True and " +
                "ExpressedState attribute shall be set to Testing. Any faults identified during the test shall be " +
                "reflected in the appropriate attributes and events. Upon completion of the self test procedure, the " +
                "SelfTestComplete event shall be generated, the TestInProgress attribute shall be set to False and " +
                "ExpressedState attribute shall be updated to reflect the current state of the server."
        }),

        Datatype(
            { name: "AlarmStateEnum", type: "enum8", xref: "cluster§2.11.5.1" },
            Field({
                name: "Normal", id: 0x0, conformance: "M", description: "Nominal state, the device is not alarming",
                xref: "cluster§2.11.5.1.1",
                details: "This value shall indicate that this alarm is not alarming."
            }),

            Field({
                name: "Warning", id: 0x1, conformance: "O", description: "Warning state",
                xref: "cluster§2.11.5.1.2",
                details: "This value shall indicate that this alarm is in a warning state. Alarms in this state SHOULD be " +
                    "subject to being muted via physical interaction."
            }),

            Field({
                name: "Critical", id: 0x2, conformance: "M", description: "Critical state",
                xref: "cluster§2.11.5.1.3",
                details: "This value shall indicate that this alarm is in a critical state. Alarms in this state shall NOT be " +
                    "subject to being muted via physical interaction."
            })
        ),

        Datatype(
            { name: "SensitivityEnum", type: "enum8", xref: "cluster§2.11.5.2" },
            Field({ name: "High", id: 0x0, conformance: "O", description: "High sensitivity" }),
            Field({ name: "Standard", id: 0x1, conformance: "M", description: "Standard Sensitivity" }),
            Field({ name: "Low", id: 0x2, conformance: "O", description: "Low sensitivity" })
        ),

        Datatype(
            {
                name: "ExpressedStateEnum", type: "enum8", xref: "cluster§2.11.5.3",
                details: "This value shall indicate that this alarm is not alarming."
            },
            Field({ name: "Normal", id: 0x0, conformance: "M", description: "Nominal state, the device is not alarming" }),

            Field({
                name: "SmokeAlarm", id: 0x1, conformance: "SMOKE", description: "Smoke Alarm state",
                xref: "cluster§2.11.5.3.2",
                details: "This value shall indicate that this alarm is currently expressing visual indication of Smoke Alarm. " +
                    "This value shall indicate that the alarm is currently expressing audible indication of Smoke Alarm " +
                    "unless the DeviceMuted attribute is supported and set to Muted."
            }),

            Field({
                name: "CoAlarm", id: 0x2, conformance: "CO", description: "CO Alarm state",
                xref: "cluster§2.11.5.3.3",
                details: "This value shall indicate that this alarm is currently expressing visual indication of CO Alarm. " +
                    "This value shall indicate that the alarm is currently expressing audible indication of CO Alarm " +
                    "unless the DeviceMuted attribute is supported and set to Muted."
            }),

            Field({
                name: "BatteryAlert", id: 0x3, conformance: "M", description: "Battery Alert State",
                xref: "cluster§2.11.5.3.4",
                details: "This value shall indicate that this alarm is currently expressing visual indication of Critical Low " +
                    "Battery. This value shall indicate that the alarm is currently expressing audible indication of " +
                    "Critical Low Battery unless the DeviceMuted attribute is supported and set to Muted."
            }),

            Field({
                name: "Testing", id: 0x4, conformance: "M", description: "Test in Progress",
                xref: "cluster§2.11.5.3.5",
                details: "This value shall indicate that this alarm is currently expressing visual and audible indication of " +
                    "SelfTest."
            }),

            Field({
                name: "HardwareFault", id: 0x5, conformance: "M", description: "Hardware Fault Alert State",
                xref: "cluster§2.11.5.3.6",
                details: "This value shall indicate that this alarm is currently expressing visual indication of Hardware " +
                    "Fault. This value shall indicate that the alarm is currently expressing audible indication of " +
                    "Hardware Fault unless the DeviceMuted attribute is supported and set to Muted."
            }),

            Field({
                name: "EndOfService", id: 0x6, conformance: "M", description: "End of Service Alert State",
                xref: "cluster§2.11.5.3.7",
                details: "This value shall indicate that this alarm is currently expressing visual indication of End Of " +
                    "Service. This value shall indicate that the alarm is currently expressing audible indication of End " +
                    "of Service unless the DeviceMuted attribute is supported and set to Muted."
            }),

            Field({
                name: "InterconnectSmoke", id: 0x7, conformance: "O",
                description: "Interconnected Smoke Alarm State", xref: "cluster§2.11.5.3.8",
                details: "This value shall indicate that this alarm is currently expressing visual indication of Smoke Alarm " +
                    "caused by Interconnect. This value shall indicate that the alarm is currently expressing audible " +
                    "indication of Smoke Alarm caused by Interconnect unless the DeviceMuted attribute is supported and " +
                    "set to Muted."
            }),

            Field({
                name: "InterconnectCo", id: 0x8, conformance: "O", description: "Interconnected CO Alarm State",
                xref: "cluster§2.11.5.3.9",
                details: "This value shall indicate that this alarm is currently expressing visual indication of CO Alarm " +
                    "caused by Interconnect. This value shall indicate that the alarm is currently expressing audible " +
                    "indication of CO Alarm caused by Interconnect unless the DeviceMuted attribute is supported and set " +
                    "to Muted."
            })
        ),

        Datatype(
            { name: "MuteStateEnum", type: "enum8", xref: "cluster§2.11.5.4" },
            Field({
                name: "NotMuted", id: 0x0, conformance: "M", description: "Not Muted", xref: "cluster§2.11.5.4.1",
                details: "This value shall indicate that the device is not muted."
            }),
            Field({
                name: "Muted", id: 0x1, conformance: "M", description: "Muted", xref: "cluster§2.11.5.4.2",
                details: "This value shall indicate that the device is muted."
            })
        ),

        Datatype(
            { name: "EndOfServiceEnum", type: "enum8", xref: "cluster§2.11.5.5" },

            Field({
                name: "Normal", id: 0x0, conformance: "M", description: "Device has not expired",
                xref: "cluster§2.11.5.5.2",
                details: "This value shall indicate that the device has not yet reached its end of service, and does not need " +
                    "to be imminently replaced."
            }),

            Field({
                name: "Expired", id: 0x1, conformance: "M", description: "Device has reached its end of service",
                xref: "cluster§2.11.5.5.1",
                details: "This value shall indicate that the device has reached its end of service, and needs to be replaced."
            })
        ),

        Datatype(
            {
                name: "ContaminationStateEnum", type: "enum8", xref: "cluster§2.11.5.6",
                details: "This value shall indicate that the smoke sensor has nominal contamination levels, no customer action " +
                    "is required."
            },
            Field({ name: "Normal", id: 0x0, conformance: "M", description: "Nominal state, the sensor is not contaminated" }),

            Field({
                name: "Low", id: 0x1, conformance: "O", description: "Low contamination",
                xref: "cluster§2.11.5.6.2",
                details: "This value shall indicate that the smoke sensor has detectable contamination levels, but the " +
                    "contamination is too low to cause a visible or audible alarm."
            }),

            Field({
                name: "Warning", id: 0x2, conformance: "O", description: "Warning state",
                xref: "cluster§2.11.5.6.3",
                details: "This value shall indicate that the smoke sensor has contamination levels in a warning state. At this " +
                    "level, the contamination may cause a visible or audible alarm. User intervention is suggested."
            }),

            Field({
                name: "Critical", id: 0x3, conformance: "M",
                description: "Critical state, will cause nuisance alarms", xref: "cluster§2.11.5.6.4",
                details: "This value shall indicate that the smoke sensor has contamination levels in a critical state. At " +
                    "this level, the contamination should cause a visible or audible alarm. User intervention is " +
                    "required. Critical contamination of the sensor shall also be reflected as a HardwareFault."
            })
        )
    ),

    Cluster(
        {
            name: "ElectricalEnergyMeasurement", id: 0x91, classification: "application", pics: "EEM",
            xref: "cluster§2.12",
            details: "This cluster provides a mechanism for querying data about the electrical energy imported or provided " +
                "by the server."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.12.4" },
            Field({
                name: "IMPE", conformance: "O.a+", constraint: "0", title: "ImportedEnergy",
                xref: "cluster§2.12.4.1",
                details: "The feature indicates the server is capable of measuring how much energy is imported by the server."
            }),
            Field({
                name: "EXPE", conformance: "O.a+", constraint: "1", title: "ExportedEnergy",
                xref: "cluster§2.12.4.2",
                details: "The feature indicates the server is capable of measuring how much energy is exported by the server."
            }),

            Field({
                name: "CUME", conformance: "O.b+", constraint: "2", title: "CumulativeEnergy",
                xref: "cluster§2.12.4.3",
                details: "The feature indicates the server is capable of measuring how much energy has been imported or " +
                    "exported by the server over the device’s lifetime. This measurement may start from when a device’s " +
                    "firmware is updated to include this feature, when a device’s firmware is updated to correct " +
                    "measurement errors, or when a device is factory reset."
            }),

            Field({
                name: "PERE", conformance: "O.b+", constraint: "3", title: "PeriodicEnergy",
                xref: "cluster§2.12.4.4",
                details: "The feature indicates the server is capable of measuring how much energy has been imported or " +
                    "exported by the server during a certain period of time. The start and end times for measurement " +
                    "periods shall be determined by the server, and may represent overlapping periods."
            })
        ),

        Attribute({
            name: "Accuracy", id: 0x0, type: "MeasurementAccuracyStruct", access: "R V", conformance: "M",
            quality: "F", xref: "cluster§2.12.6.1",
            details: "Indicates the accuracy of energy measurement by this server. The value of the MeasurementType field " +
                "on this MeasurementAccuracyStruct shall be ElectricalEnergy."
        }),

        Attribute({
            name: "CumulativeEnergyImported", id: 0x1, type: "EnergyMeasurementStruct", access: "R V",
            conformance: "IMPE & CUME", quality: "X Q", xref: "cluster§2.12.6.2",

            details: "Indicates the most recent measurement of cumulative energy imported by the server over the lifetime " +
                "of the device, and the timestamp of when the measurement was recorded." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the cumulative energy imported cannot currently be determined, a value of null shall be returned."
        }),

        Attribute({
            name: "CumulativeEnergyExported", id: 0x2, type: "EnergyMeasurementStruct", access: "R V",
            conformance: "EXPE & CUME", quality: "X Q", xref: "cluster§2.12.6.3",

            details: "Indicates the most recent measurement of cumulative energy exported by the server over the lifetime " +
                "of the device, and the timestamp of when the measurement was recorded." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the cumulative energy exported cannot currently be determined, a value of null shall be returned."
        }),

        Attribute({
            name: "PeriodicEnergyImported", id: 0x3, type: "EnergyMeasurementStruct", access: "R V",
            conformance: "IMPE & PERE", quality: "X Q", xref: "cluster§2.12.6.4",

            details: "Indicates the most recent measurement of energy imported by the server and the period during which " +
                "it was measured." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the periodic energy imported cannot currently be determined, a value of null shall be returned."
        }),

        Attribute({
            name: "PeriodicEnergyExported", id: 0x4, type: "EnergyMeasurementStruct", access: "R V",
            conformance: "EXPE & PERE", quality: "X Q", xref: "cluster§2.12.6.5",

            details: "Indicates the most recent measurement of energy exported by the server and the period during which " +
                "it was measured." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the periodic energy exported cannot currently be determined, a value of null shall be returned."
        }),

        Attribute({
            name: "CumulativeEnergyReset", id: 0x5, type: "CumulativeEnergyResetStruct", access: "R V",
            conformance: "[CUME]", default: null, quality: "X", xref: "cluster§2.12.6.6",
            details: "Indicates when cumulative measurements were most recently zero."
        }),

        Event(
            {
                name: "CumulativeEnergyMeasured", id: 0x0, access: "V", conformance: "CUME", priority: "info",
                xref: "cluster§2.12.7.1",
                details: "This event shall be generated when the server takes a snapshot of the cumulative energy imported by " +
                    "the server, exported from the server, or both, but not more frequently than the rate mentioned in " +
                    "the description above of the related attribute."
            },

            Field({
                name: "EnergyImported", id: 0x0, type: "EnergyMeasurementStruct", conformance: "CUME & IMPE",
                xref: "cluster§2.12.7.1.1",
                details: "This field shall be the value of CumulativeEnergyImported attribute at the timestamp indicated in " +
                    "its EndTimestamp field, EndSystime field, or both."
            }),

            Field({
                name: "EnergyExported", id: 0x1, type: "EnergyMeasurementStruct", conformance: "CUME & EXPE",
                xref: "cluster§2.12.7.1.2",
                details: "This field shall be the value of CumulativeEnergyExported attribute at the timestamp indicated in " +
                    "its EndTimestamp field, EndSystime field, or both."
            })
        ),

        Event(
            {
                name: "PeriodicEnergyMeasured", id: 0x1, access: "V", conformance: "PERE", priority: "info",
                xref: "cluster§2.12.7.2",
                details: "This event shall be generated when the server reaches the end of a reporting period for imported " +
                    "energy, exported energy, or both."
            },

            Field({
                name: "EnergyImported", id: 0x0, type: "EnergyMeasurementStruct", conformance: "PERE & IMPE",
                xref: "cluster§2.12.7.2.1",
                details: "This field shall be the value of PeriodicEnergyImported attribute at the timestamp indicated in its " +
                    "EndTimestamp field, EndSystime field, or both."
            }),

            Field({
                name: "EnergyExported", id: 0x1, type: "EnergyMeasurementStruct", conformance: "PERE & EXPE",
                xref: "cluster§2.12.7.2.2",
                details: "This field shall be the value of PeriodicEnergyExported attribute at the timestamp indicated in its " +
                    "EndTimestamp field, EndSystime field, or both."
            })
        ),

        Datatype(
            { name: "MeasurementTypeEnum", type: "enum16", xref: "cluster§2.12.5.1" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M" }),
            Field({ name: "Voltage", id: 0x1, conformance: "M", description: "Voltage in millivolts (mV)" }),
            Field({ name: "ActiveCurrent", id: 0x2, conformance: "M", description: "Active current in milliamps (mA)" }),
            Field({ name: "ReactiveCurrent", id: 0x3, conformance: "M", description: "Reactive current in milliamps (mA)" }),
            Field({ name: "ApparentCurrent", id: 0x4, conformance: "M", description: "Apparent current in milliamps (mA)" }),
            Field({ name: "ActivePower", id: 0x5, conformance: "M", description: "Active power in milliwatts (mW)" }),
            Field({
                name: "ReactivePower", id: 0x6, conformance: "M",
                description: "Reactive power in millivolt-amps reactive (mVAR)"
            }),
            Field({ name: "ApparentPower", id: 0x7, conformance: "M", description: "Apparent power in millivolt-amps (mVA)" }),
            Field({
                name: "RmsVoltage", id: 0x8, conformance: "M",
                description: "Root mean squared voltage in millivolts (mV)"
            }),
            Field({
                name: "RmsCurrent", id: 0x9, conformance: "M",
                description: "Root mean squared current in milliamps (mA)"
            }),
            Field({ name: "RmsPower", id: 0xa, conformance: "M", description: "Root mean squared power in milliwatts (mW)" }),
            Field({ name: "Frequency", id: 0xb, conformance: "M", description: "AC frequency in millihertz (mHz)" }),
            Field({
                name: "PowerFactor", id: 0xc, conformance: "M",
                description: "Power Factor ratio in+/- 1/100ths of a percent."
            }),
            Field({ name: "NeutralCurrent", id: 0xd, conformance: "M", description: "AC neutral current in milliamps (mA)" }),
            Field({
                name: "ElectricalEnergy", id: 0xe, conformance: "M",
                description: "Electrical energy in milliwatt-hours (mWh)"
            }),
            Field({
                name: "ReactiveEnergy", id: 0xf, conformance: "M",
                description: "Reactive power in millivolt-amp-hours reactive (mVARh)"
            }),
            Field({
                name: "ApparentEnergy", id: 0x10, conformance: "M",
                description: "Apparent power in millivolt-amp-hours (mVAh)"
            })
        ),

        Datatype(
            {
                name: "EnergyMeasurementStruct", type: "struct", xref: "cluster§2.12.5.2",

                details: "This struct shall indicate the amount of energy measured during a given measurement period." +
                    "\n" +
                    "A server which does not have the ability to determine the time in UTC, or has not yet done so, shall " +
                    "use the system time fields to specify the measurement period and observation times." +
                    "\n" +
                    "A server which has determined the time in UTC shall use the timestamp fields to specify the " +
                    "measurement period. Such a server may also include the systime fields to indicate how many seconds " +
                    "had passed since boot for a given timestamp; this allows for client-side resolution of UTC time for " +
                    "previous reports that only included systime." +
                    "\n" +
                    "Elements using this data type shall indicate whether it represents cumulative or periodic energy, " +
                    "e.g. in the name or in the element description."
            },

            Field({
                name: "Energy", id: 0x0, type: "energy-mWh", conformance: "M", constraint: "min 0",
                xref: "cluster§2.12.5.2.1",

                details: "This field shall be the reported energy." +
                    "\n" +
                    "If the EnergyMeasurementStruct represents cumulative energy, then this shall represent the " +
                    "cumulative energy recorded at either the value of the EndTimestamp field or the value of the " +
                    "EndSystime field, or both." +
                    "\n" +
                    "If the EnergyMeasurementStruct represents periodic energy, then this shall represent the energy " +
                    "recorded during the period specified by either the StartTimestamp and EndTimestamp fields, the " +
                    "period specified by the StartSystime and EndSystime fields, or both."
            }),

            Field({
                name: "StartTimestamp", id: 0x1, type: "epoch-s", conformance: "desc", xref: "cluster§2.12.5.2.2",

                details: "This field shall indicate the timestamp in UTC of the beginning of the period during which the value " +
                    "of the Energy field was measured." +
                    "\n" +
                    "If this EnergyMeasurementStruct represents cumulative energy, this field shall be omitted." +
                    "\n" +
                    "Otherwise, if the server had determined the time in UTC at or before the beginning of the " +
                    "measurement period, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had not yet determined the time in UTC at or before the beginning of the " +
                    "measurement period, or does not have the capability of determining the time in UTC, this field shall " +
                    "be omitted."
            }),

            Field({
                name: "EndTimestamp", id: 0x2, type: "epoch-s", conformance: "desc",
                constraint: "min startTimestamp + 1", xref: "cluster§2.12.5.2.3",

                details: "This field shall indicate the timestamp in UTC of the end of the period during which the value of " +
                    "the Energy field was measured." +
                    "\n" +
                    "If the server had determined the time in UTC by the end of the measurement period, this field shall " +
                    "be indicated." +
                    "\n" +
                    "Otherwise, if the server had not yet determined the time in UTC by the end of the measurement " +
                    "period, or does not have the capability of determining the time in UTC, this field shall be omitted."
            }),

            Field({
                name: "StartSystime", id: 0x3, type: "systime-ms", conformance: "desc", xref: "cluster§2.12.5.2.4",

                details: "This field shall indicate the time elapsed since boot at the beginning of the period during which " +
                    "the value of the Energy field was measured." +
                    "\n" +
                    "If this EnergyMeasurementStruct represents cumulative energy, this field shall be omitted." +
                    "\n" +
                    "Otherwise, if the server had not yet determined the time in UTC at the start of the measurement " +
                    "period, or does not have the capability of determining the time in UTC, this field shall be " +
                    "indicated." +
                    "\n" +
                    "Otherwise, if the server had determined the time in UTC at or before the beginning of the " +
                    "measurement period, this field may be omitted; if it is indicated, its value shall be the time " +
                    "elapsed since boot at the UTC time indicated in StartTimestamp."
            }),

            Field({
                name: "EndSystime", id: 0x4, type: "systime-ms", conformance: "desc",
                constraint: "min startSystime + 1", xref: "cluster§2.12.5.2.5",

                details: "This field shall indicate the time elapsed since boot at the end of the period during which the " +
                    "value of the Energy field was measured." +
                    "\n" +
                    "If the server had not yet determined the time in UTC by the end of the measurement period, or does " +
                    "not have the capability of determining the time in UTC, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had determined the time in UTC by the end of the measurement period, this " +
                    "field may be omitted; if it is indicated, its value shall be the time elapsed since boot at the UTC " +
                    "time indicated in EndTimestamp."
            })
        ),

        Datatype(
            {
                name: "CumulativeEnergyResetStruct", type: "struct", xref: "cluster§2.12.5.3",
                details: "This struct shall represent the times at which cumulative measurements were last zero, either due to " +
                    "initialization of the device, or an internal reset of the cumulative value."
            },

            Field({
                name: "ImportedResetTimestamp", id: 0x0, type: "epoch-s", conformance: "[IMPE]", default: null,
                quality: "X", xref: "cluster§2.12.5.3.1",

                details: "This field shall indicate the timestamp in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyImported attribute was most recently zero." +
                    "\n" +
                    "If the server had determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyImported attribute was most recently zero, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had not yet determined the time in UTC when the value of the Energy field " +
                    "on the CumulativeEnergyImported attribute was most recently zero, or does not have the capability of " +
                    "determining the time in UTC, this field shall be omitted." +
                    "\n" +
                    "If the timestamp in UTC when the value of the Energy field on the CumulativeEnergyImported attribute " +
                    "was most recently zero cannot currently be determined, a value of null shall be returned."
            }),

            Field({
                name: "ExportedResetTimestamp", id: 0x1, type: "epoch-s", conformance: "[EXPE]", default: null,
                quality: "X", xref: "cluster§2.12.5.3.2",

                details: "This field shall indicate the timestamp in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyExported attribute was most recently zero." +
                    "\n" +
                    "If the server had determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyExported attribute was most recently zero, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had not yet determined the time in UTC when the value of the Energy field " +
                    "on the CumulativeEnergyExported attribute was most recently zero, or does not have the capability of " +
                    "determining the time in UTC, this field shall be omitted." +
                    "\n" +
                    "If the timestamp in UTC when the value of the Energy field on the CumulativeEnergyExported attribute " +
                    "was most recently zero cannot currently be determined, a value of null shall be returned."
            }),

            Field({
                name: "ImportedResetSystime", id: 0x2, type: "systime-ms", conformance: "[IMPE]", default: null,
                quality: "X", xref: "cluster§2.12.5.3.3",

                details: "This field shall indicate the time elapsed since boot when the value of the Energy field on the " +
                    "CumulativeEnergyImported attribute was most recently zero." +
                    "\n" +
                    "If the server had not yet determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyImported attribute was most recently zero, or does not have the capability of " +
                    "determining the time in UTC, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyImported attribute was most recently zero, this field may be omitted; if it is " +
                    "indicated, its value shall be the time elapsed since boot at the UTC time indicated in " +
                    "ImportedResetTimestamp."
            }),

            Field({
                name: "ExportedResetSystime", id: 0x3, type: "systime-ms", conformance: "[EXPE]", default: null,
                quality: "X", xref: "cluster§2.12.5.3.4",

                details: "This field shall indicate the time elapsed since boot when the value of the Energy field on the " +
                    "CumulativeEnergyExported attribute was most recently zero." +
                    "\n" +
                    "If the server had not yet determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyExported attribute was most recently zero, or does not have the capability of " +
                    "determining the time in UTC, this field shall be indicated." +
                    "\n" +
                    "Otherwise, if the server had determined the time in UTC when the value of the Energy field on the " +
                    "CumulativeEnergyExported attribute was most recently zero, this field may be omitted; if it is " +
                    "indicated, its value shall be the time elapsed since boot at the UTC time indicated in " +
                    "ImportedResetTimestamp."
            })
        )
    ),

    Cluster(
        {
            name: "ElectricalPowerMeasurement", id: 0x90, classification: "application", pics: "EPM",
            xref: "cluster§2.13",
            details: "This cluster provides a mechanism for querying data about electrical power as measured by the " +
                "server."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§2.13.4" },
            Field({
                name: "DIRC", conformance: "O.a+", constraint: "0", title: "DirectCurrent",
                xref: "cluster§2.13.4.1",
                details: "This feature indicates the cluster can measure a direct current."
            }),
            Field({
                name: "ALTC", conformance: "O.a+", constraint: "1", title: "AlternatingCurrent",
                xref: "cluster§2.13.4.2",
                details: "This feature indicates the cluster can measure an alternating current."
            }),

            Field({
                name: "POLY", conformance: "[ALTC]", constraint: "2", title: "PolyphasePower",
                xref: "cluster§2.13.4.3",
                details: "This feature indicates the cluster represents the collective measurements for a Polyphase power " +
                    "supply."
            }),

            Field({
                name: "HARM", conformance: "[ALTC]", constraint: "3", title: "Harmonics", xref: "cluster§2.13.4.4",
                details: "This feature indicates the cluster can measure the harmonics of an alternating current."
            }),
            Field({
                name: "PWRQ", conformance: "[ALTC]", constraint: "4", title: "PowerQuality",
                xref: "cluster§2.13.4.5",
                details: "This feature indicates the cluster can measure the harmonic phases of an alternating current."
            })
        ),

        Attribute({
            name: "PowerMode", id: 0x0, type: "PowerModeEnum", access: "R V", conformance: "M",
            xref: "cluster§2.13.6.1",
            details: "This shall indicate the current mode of the server. For some servers, such as an EV, this may change " +
                "depending on the mode of charging or discharging."
        }),

        Attribute({
            name: "NumberOfMeasurementTypes", id: 0x1, type: "uint8", access: "R V", conformance: "M",
            constraint: "max 32", quality: "F", xref: "cluster§2.13.6.2",
            details: "This shall indicate the maximum number of measurement types the server is capable of reporting."
        }),

        Attribute(
            {
                name: "Accuracy", id: 0x2, type: "list", access: "R V", conformance: "M",
                constraint: "1 to numberOfMeasurementTypes", quality: "F", xref: "cluster§2.13.6.3",
                details: "This shall indicate a list of accuracy specifications for the measurement types supported by the " +
                    "server. There shall be an entry for ActivePower, as well as any other measurement types implemented " +
                    "by this server."
            },

            Field({ name: "entry", type: "MeasurementAccuracyStruct" })
        ),

        Attribute(
            {
                name: "Ranges", id: 0x3, type: "list", access: "R V", conformance: "O",
                constraint: "0 to numberOfMeasurementTypes", default: [], quality: "Q", xref: "cluster§2.13.6.4",

                details: "This shall indicate a list of measured ranges for different measurement types. Each measurement type " +
                    "shall have at most one entry in this list, representing the range of measurements in the most recent " +
                    "measurement period." +
                    "\n" +
                    "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                    "omit publication of deltas considered not meaningful." +
                    "\n" +
                    "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                    "recently than 1 second ago." +
                    "\n" +
                    "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                    "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds."
            },

            Field({ name: "entry", type: "MeasurementRangeStruct" })
        ),

        Attribute({
            name: "Voltage", id: 0x4, type: "voltage-mV", access: "R V", conformance: "O", default: null,
            quality: "X Q", xref: "cluster§2.13.6.5",

            details: "This shall indicate the most recent Voltage reading in millivolts (mV)." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the voltage cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "ActiveCurrent", id: 0x5, type: "amperage-mA", access: "R V", conformance: "O", default: null,
            quality: "X Q", xref: "cluster§2.13.6.6",

            details: "This shall indicate the most recent ActiveCurrent reading in milliamps (mA)." +
                "\n" +
                "A positive value represents current flowing into the server, while a negative value represents " +
                "current flowing out of the server." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the current cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "ReactiveCurrent", id: 0x6, type: "amperage-mA", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.7",

            details: "This shall indicate the most recent ReactiveCurrent reading in milliamps (mA)." +
                "\n" +
                "A positive value represents current flowing into the server, while a negative value represents " +
                "current flowing out of the server." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the current cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "ApparentCurrent", id: 0x7, type: "amperage-mA", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.8",

            details: "This shall indicate the most recent ApparentCurrent (square root sum of the squares of active and " +
                "reactive currents) reading in milliamps (mA)." +
                "\n" +
                "A positive value represents current flowing into the server, while a negative value represents " +
                "current flowing out of the server." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the active or reactive currents cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "ActivePower", id: 0x8, type: "power-mW", access: "R V", conformance: "M", quality: "X Q",
            xref: "cluster§2.13.6.9",

            details: "This shall indicate the most recent ActivePower reading in milliwatts (mW). If the power cannot be " +
                "measured, a value of null shall be returned." +
                "\n" +
                "A positive value represents power imported, while a negative value represents power exported." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the Polyphase Power feature is set, this value represents the combined active power imported or " +
                "exported."
        }),

        Attribute({
            name: "ReactivePower", id: 0x9, type: "power-mVAR", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.10",

            details: "This shall indicate the most recent ReactivePower reading in millivolt-amps reactive (mVAR). A " +
                "positive value represents power imported, while a negative value represents power exported." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the reactive power cannot be measured, a value of null shall be returned." +
                "\n" +
                "If the Polyphase Power feature is supported, this value represents the combined reactive power " +
                "imported or exported."
        }),

        Attribute({
            name: "ApparentPower", id: 0xa, type: "power-mVA", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.11",

            details: "This shall indicate the most recent ApparentPower reading in millivolt-amps (mVA)." +
                "\n" +
                "A positive value represents power imported, while a negative value represents power exported." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the apparent power cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "RmsVoltage", id: 0xb, type: "voltage-mV", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.12",

            details: "This shall indicate the most recent RMSVoltage reading in millivolts (mV)." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the RMS voltage cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "RmsCurrent", id: 0xc, type: "amperage-mA", access: "R V", conformance: "[ALTC]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.13",

            details: "This shall indicate the most recent RMSCurrent reading in milliamps (mA)." +
                "\n" +
                "A positive value represents current flowing into the server, while a negative value represents " +
                "current flowing out of the server." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the RMS current cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "RmsPower", id: 0xd, type: "power-mW", access: "R V", conformance: "[ALTC]", default: null,
            quality: "X Q", xref: "cluster§2.13.6.14",

            details: "This shall indicate the most recent RMSPower reading in milliwatts (mW)." +
                "\n" +
                "A positive value represents power imported, while a negative value represents power exported." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the RMS power cannot be measured, a value of null shall be returned."
        }),

        Attribute({
            name: "Frequency", id: 0xe, type: "int64", access: "R V", conformance: "[ALTC]",
            constraint: "0 to 1000000", default: null, quality: "X Q", xref: "cluster§2.13.6.15",

            details: "This shall indicate the most recent Frequency reading in millihertz (mHz)." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds." +
                "\n" +
                "If the frequency cannot be measured, a value of null shall be returned."
        }),

        Attribute(
            {
                name: "HarmonicCurrents", id: 0xf, type: "list", access: "R V", conformance: "HARM",
                constraint: "max 25", quality: "X Q", xref: "cluster§2.13.6.16",

                details: "This shall indicate a list of HarmonicMeasurementStruct values, with each HarmonicMeasurementStruct " +
                    "representing the harmonic current reading for the harmonic order specified by Order." +
                    "\n" +
                    "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                    "omit publication of deltas considered not meaningful." +
                    "\n" +
                    "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                    "recently than 1 second ago." +
                    "\n" +
                    "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                    "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds."
            },

            Field({ name: "entry", type: "HarmonicMeasurementStruct" })
        ),

        Attribute(
            {
                name: "HarmonicPhases", id: 0x10, type: "list", access: "R V", conformance: "PWRQ",
                constraint: "max 25", quality: "X Q", xref: "cluster§2.13.6.17",

                details: "This shall indicate a list of HarmonicMeasurementStruct values, with each HarmonicMeasurementStruct " +
                    "representing the most recent phase of the harmonic current reading for the harmonic order specified " +
                    "by Order." +
                    "\n" +
                    "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                    "omit publication of deltas considered not meaningful." +
                    "\n" +
                    "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                    "recently than 1 second ago." +
                    "\n" +
                    "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                    "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds."
            },

            Field({ name: "entry", type: "HarmonicMeasurementStruct" })
        ),

        Attribute({
            name: "PowerFactor", id: 0x11, type: "int64", access: "R V", conformance: "[ALTC]",
            constraint: "-10000 to 10000", default: null, quality: "X Q", xref: "cluster§2.13.6.18",

            details: "This shall indicate the Power Factor ratio in +/- 1/100ths of a percent." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds."
        }),

        Attribute({
            name: "NeutralCurrent", id: 0x12, type: "amperage-mA", access: "R V", conformance: "[POLY]",
            default: null, quality: "X Q", xref: "cluster§2.13.6.19",

            details: "This shall indicate the most recent NeutralCurrent reading in milliamps (mA). Typically this is a " +
                "derived value, taking the magnitude of the vector sum of phase currents." +
                "\n" +
                "If the neutral current cannot be measured or derived, a value of null shall be returned." +
                "\n" +
                "A positive value represents an imbalance between the phase currents when power is imported. A " +
                "negative value represents an imbalance between the phase currents when power is exported." +
                "\n" +
                "The reporting interval of this attribute shall be manufacturer dependent. The server may choose to " +
                "omit publication of deltas considered not meaningful." +
                "\n" +
                "The server shall NOT mark this attribute ready for report if the last time this was done was more " +
                "recently than 1 second ago." +
                "\n" +
                "The server may delay marking this attribute ready for report for longer periods if needed, however " +
                "the server shall NOT delay marking this attribute as ready for report for longer than 60 seconds."
        }),

        Event(
            {
                name: "MeasurementPeriodRanges", id: 0x0, access: "V", conformance: "Ranges", priority: "info",
                xref: "cluster§2.13.7.1",
                details: "If supported, this event shall be generated at the end of a measurement period. The start and end " +
                    "times for measurement periods shall be determined by the server, and may represent overlapping " +
                    "periods."
            },

            Field(
                {
                    name: "Ranges", id: 0x0, type: "list", conformance: "M",
                    constraint: "1 to numberOfMeasurementTypes", xref: "cluster§2.13.7.1.1",
                    details: "This shall indicate the value of the Ranges attribute at the time of event generation."
                },
                Field({ name: "entry", type: "MeasurementRangeStruct" })
            )
        ),

        Datatype(
            { name: "PowerModeEnum", type: "enum8", xref: "cluster§2.13.5.1" },
            Field({ name: "Unknown", id: 0x0, conformance: "M" }),
            Field({ name: "Dc", id: 0x1, conformance: "M", description: "Direct current" }),
            Field({
                name: "Ac", id: 0x2, conformance: "M",
                description: "Alternating current, either single-phase or polyphase"
            })
        ),

        Datatype(
            { name: "MeasurementTypeEnum", type: "enum16", xref: "cluster§2.13.5.2" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M" }),
            Field({ name: "Voltage", id: 0x1, conformance: "M", description: "Voltage in millivolts (mV)" }),
            Field({ name: "ActiveCurrent", id: 0x2, conformance: "M", description: "Active current in milliamps (mA)" }),
            Field({ name: "ReactiveCurrent", id: 0x3, conformance: "M", description: "Reactive current in milliamps (mA)" }),
            Field({ name: "ApparentCurrent", id: 0x4, conformance: "M", description: "Apparent current in milliamps (mA)" }),
            Field({ name: "ActivePower", id: 0x5, conformance: "M", description: "Active power in milliwatts (mW)" }),
            Field({
                name: "ReactivePower", id: 0x6, conformance: "M",
                description: "Reactive power in millivolt-amps reactive (mVAR)"
            }),
            Field({ name: "ApparentPower", id: 0x7, conformance: "M", description: "Apparent power in millivolt-amps (mVA)" }),
            Field({
                name: "RmsVoltage", id: 0x8, conformance: "M",
                description: "Root mean squared voltage in millivolts (mV)"
            }),
            Field({
                name: "RmsCurrent", id: 0x9, conformance: "M",
                description: "Root mean squared current in milliamps (mA)"
            }),
            Field({ name: "RmsPower", id: 0xa, conformance: "M", description: "Root mean squared power in milliwatts (mW)" }),
            Field({ name: "Frequency", id: 0xb, conformance: "M", description: "AC frequency in millihertz (mHz)" }),
            Field({
                name: "PowerFactor", id: 0xc, conformance: "M",
                description: "Power Factor ratio in+/- 1/100ths of a percent."
            }),
            Field({ name: "NeutralCurrent", id: 0xd, conformance: "M", description: "AC neutral current in milliamps (mA)" }),
            Field({
                name: "ElectricalEnergy", id: 0xe, conformance: "M",
                description: "Electrical energy in milliwatt-hours (mWh)"
            }),
            Field({
                name: "ReactiveEnergy", id: 0xf, conformance: "M",
                description: "Reactive power in millivolt-amp-hours reactive (mVARh)"
            }),
            Field({
                name: "ApparentEnergy", id: 0x10, conformance: "M",
                description: "Apparent power in millivolt-amp-hours (mVAh)"
            })
        ),

        Datatype(
            {
                name: "MeasurementRangeStruct", type: "struct", xref: "cluster§2.13.5.3",

                details: "This struct shall indicate the maximum and minimum values of a given measurement type during a " +
                    "measurement period, along with the observation times of these values." +
                    "\n" +
                    "A server which does not have the ability to determine the time in UTC, or has not yet done so, shall " +
                    "use the system time fields to specify the measurement period and observation times." +
                    "\n" +
                    "A server which has determined the time in UTC shall use the timestamp fields to specify the " +
                    "measurement period and observation times. Such a server may also include the systime fields to " +
                    "indicate how many seconds had passed since boot for a given timestamp; this allows for client-side " +
                    "resolution of UTC time for previous reports that only included systime."
            },

            Field({
                name: "MeasurementType", id: 0x0, type: "MeasurementTypeEnum", conformance: "M",
                xref: "cluster§2.13.5.3.1",
                details: "This field shall be the type of measurement for the range provided."
            }),

            Field({
                name: "Min", id: 0x1, type: "int64", conformance: "M", xref: "cluster§2.13.5.3.2",
                details: "This field shall be the smallest measured value for the associated measurement over either the " +
                    "period between StartTimestamp and EndTimestamp, or the period between StartSystime and EndSystime, " +
                    "or both."
            }),

            Field({
                name: "Max", id: 0x2, type: "int64", conformance: "M", xref: "cluster§2.13.5.3.3",
                details: "This field shall be the largest measured value for the associated measurement over the period " +
                    "between either StartTimestamp and EndTimestamp or the period between StartSystime and EndSystime, or " +
                    "both."
            }),

            Field({
                name: "StartTimestamp", id: 0x3, type: "epoch-s", conformance: "EndTimestamp",
                xref: "cluster§2.13.5.3.4",
                details: "This field shall be the timestamp in UTC of the beginning of the measurement period." +
                    "\n" +
                    "If the server had not yet determined the time in UTC at or before the beginning of the measurement " +
                    "period, or does not have the capability of determining the time in UTC, this field shall be omitted."
            }),

            Field({
                name: "EndTimestamp", id: 0x4, type: "epoch-s", conformance: "desc",
                constraint: "min startTimestamp + 1", xref: "cluster§2.13.5.3.5",
                details: "This field shall be the timestamp in UTC of the end of the measurement period." +
                    "\n" +
                    "If the server had not yet determined the time in UTC at or before the beginning of the measurement " +
                    "period, or does not have the capability of determining the time in UTC, this field shall be omitted."
            }),

            Field({
                name: "MinTimestamp", id: 0x5, type: "epoch-s", conformance: "EndTimestamp",
                xref: "cluster§2.13.5.3.6",
                details: "This field shall be the most recent timestamp in UTC that the value in the Min field was measured." +
                    "\n" +
                    "This field shall be greater than or equal to the value of the StartTimestamp field. This field shall " +
                    "be less than or equal to the value of the EndTimestamp field."
            }),

            Field({
                name: "MaxTimestamp", id: 0x6, type: "epoch-s", conformance: "EndTimestamp",
                constraint: "min minTimestamp + 1", xref: "cluster§2.13.5.3.7",
                details: "This field shall be the most recent timestamp in UTC of the value in the Max field. This field shall " +
                    "be greater than or equal to the value of the StartTimestamp field. This field shall be less than or " +
                    "equal to the value of the EndTimestamp field."
            }),

            Field({
                name: "StartSystime", id: 0x7, type: "systime-ms", conformance: "EndSystime",
                xref: "cluster§2.13.5.3.8",
                details: "This field shall be the time since boot of the beginning of the measurement period." +
                    "\n" +
                    "If the server had determined the time in UTC at or before the start of the measurement period, this " +
                    "field may be omitted along with the EndSystime, MinSystime, and MaxSystime fields."
            }),

            Field({
                name: "EndSystime", id: 0x8, type: "systime-ms", conformance: "desc",
                constraint: "min startSystime + 1", xref: "cluster§2.13.5.3.9",
                details: "This field shall be the time since boot of the end of the measurement period." +
                    "\n" +
                    "If the server had determined the time in UTC at the end of the measurement period, this field may be " +
                    "omitted along with the StartSystime field, MinSystime, and MaxSystime fields."
            }),

            Field({
                name: "MinSystime", id: 0x9, type: "systime-ms", conformance: "EndSystime",
                xref: "cluster§2.13.5.3.10",
                details: "This field shall be the measurement time since boot of the value in the Min field was measured. This " +
                    "field shall be greater than or equal to the value of the StartSystime field." +
                    "\n" +
                    "This field shall be less than or equal to the value of the EndSystime field."
            }),

            Field({
                name: "MaxSystime", id: 0xa, type: "systime-ms", conformance: "EndSystime",
                constraint: "min minSystime + 1", xref: "cluster§2.13.5.3.11",
                details: "This field shall be the measurement time since boot of the value in the Max field. This field shall " +
                    "be greater than or equal to the value of the StartSystime field." +
                    "\n" +
                    "This field shall be less than or equal to the value of the EndSystime field."
            })
        ),

        Datatype(
            { name: "HarmonicMeasurementStruct", type: "struct", xref: "cluster§2.13.5.4" },

            Field({
                name: "Order", id: 0x0, type: "uint8", conformance: "M", constraint: "min 1",
                xref: "cluster§2.13.5.4.1",
                details: "This field shall be the order of the harmonic being measured. Typically this is an odd number, but " +
                    "servers may choose to report even harmonics."
            }),

            Field({
                name: "Measurement", id: 0x1, type: "int64", conformance: "M", quality: "X",
                xref: "cluster§2.13.5.4.2",

                details: "This field shall be the measured value for the given harmonic order." +
                    "\n" +
                    "For the Harmonic Currents attribute, this value is the most recently measured harmonic current " +
                    "reading in milliamps (mA). A positive value indicates that the measured harmonic current is " +
                    "positive, and a negative value indicates that the measured harmonic current is negative." +
                    "\n" +
                    "For the Harmonic Phases attribute, this value is the most recent phase of the given harmonic order " +
                    "in millidegrees (mDeg). A positive value indicates that the measured phase is leading, and a " +
                    "negative value indicates that the measured phase is lagging." +
                    "\n" +
                    "If this measurement is not currently available, a value of null shall be returned."
            })
        )
    ),

    Cluster(
        {
            name: "ColorControl", id: 0x300, classification: "application", pics: "CC", xref: "cluster§3.2",

            details: "This cluster provides an interface for changing the color of a light. Color is specified according " +
                "to the CIE 1931 Color space. Color control is carried out in terms of x,y values, as defined by this " +
                "specification." +
                "\n" +
                "Additionally, color may optionally be controlled in terms of color temperature, or as hue and " +
                "saturation values based on optionally variable RGB and W color points. It is recommended that the " +
                "hue and saturation are interpreted according to the HSV (a.k.a. HSB) color model." +
                "\n" +
                "Control over luminance is not included, as this is provided by means of the Level Control for " +
                "Lighting cluster. It is recommended that the level provided by this cluster be interpreted as " +
                "representing a proportion of the maximum intensity achievable at the current color."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 7 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§3.2.4" },
            Field({
                name: "HS", conformance: "EHUE, O", constraint: "0", title: "HueSaturation",
                details: "Supports color specification via hue/saturation."
            }),
            Field({
                name: "EHUE", conformance: "CL, O", constraint: "1", title: "EnhancedHue",
                details: "Enhanced hue is supported."
            }),
            Field({ name: "CL", conformance: "O", constraint: "2", title: "ColorLoop", details: "Color loop is supported." }),
            Field({
                name: "XY", conformance: "O", constraint: "3", title: "Xy",
                details: "Supports color specification via XY."
            }),
            Field({
                name: "CT", conformance: "O", constraint: "4", title: "ColorTemperature",
                details: "Supports specification of color temperature."
            })
        ),

        Attribute(
            {
                name: "CurrentHue", id: 0x0, type: "uint8", access: "R V", conformance: "HS", constraint: "max 254",
                quality: "N P Q", xref: "cluster§3.2.7.2",

                details: "The CurrentHue attribute contains the current hue value of the light. It is updated as fast as " +
                    "practical during commands that change the hue." +
                    "\n" +
                    "The hue in degrees shall be related to the CurrentHue attribute by the relationship:" +
                    "\n" +
                    "Hue = \"CurrentHue\" * 360 / 254" +
                    "\n" +
                    "where CurrentHue is in the range from 0 to 254 inclusive." +
                    "\n" +
                    "Changes to this attribute shall only be marked as reportable in the following cases:" +
                    "\n" +
                    "  • At most once per second or" +
                    "\n" +
                    "  • At the end of the movement/transition."
            }
        ),

        Attribute(
            {
                name: "CurrentSaturation", id: 0x1, type: "uint8", access: "R V", conformance: "HS",
                constraint: "max 254", quality: "N S P Q", xref: "cluster§3.2.7.3",

                details: "Indicates the current saturation value of the light. It is updated as fast as practical during " +
                    "commands that change the saturation." +
                    "\n" +
                    "The saturation (on a scale from 0.0 to 1.0) shall be related to the CurrentSaturation attribute by " +
                    "the relationship:" +
                    "\n" +
                    "Saturation = \"CurrentSaturation\" / 254" +
                    "\n" +
                    "where CurrentSaturation is in the range from 0 to 254 inclusive." +
                    "\n" +
                    "Changes to this attribute shall only be marked as reportable in the following cases:" +
                    "\n" +
                    "  • At most once per second or" +
                    "\n" +
                    "  • At the end of the movement/transition."
            }
        ),

        Attribute({
            name: "RemainingTime", id: 0x2, type: "uint16", access: "R V", conformance: "O",
            constraint: "max 65534", default: 0, quality: "Q", xref: "cluster§3.2.7.4",

            details: "Indicates the time remaining, in 1/10ths of a second, until transitions due to the currently active " +
                "command will be complete." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • When it changes from 0 to any value higher than 10, or" +
                "\n" +
                "  • When it changes, with a delta larger than 10, caused by the invoke of a command, or" +
                "\n" +
                "  • When it changes to 0." +
                "\n" +
                "For commands with a transition time or changes to the transition time less than 1 second, changes to " +
                "this attribute shall NOT be reported." +
                "\n" +
                "As this attribute is not being reported during a regular countdown, clients SHOULD NOT rely on the " +
                "reporting of this attribute in order to keep track of the remaining duration."
        }),

        Attribute(
            {
                name: "CurrentX", id: 0x3, type: "uint16", access: "R V", conformance: "XY",
                constraint: "max 65279", quality: "N S P Q", xref: "cluster§3.2.7.5",

                details: "Indicates the current value of the normalized chromaticity value x, as defined in the CIE xyY Color " +
                    "Space. It is updated as fast as practical during commands that change the color." +
                    "\n" +
                    "The value of x shall be related to the CurrentX attribute by the relationship" +
                    "\n" +
                    "x = \"CurrentX\" / 65536" +
                    "\n" +
                    "where CurrentX is in the range from 0 to 65279 inclusive." +
                    "\n" +
                    "Changes to this attribute shall only be marked as reportable in the following cases:" +
                    "\n" +
                    "  • At most once per second or" +
                    "\n" +
                    "  • At the end of the movement/transition."
            }
        ),

        Attribute(
            {
                name: "CurrentY", id: 0x4, type: "uint16", access: "R V", conformance: "XY",
                constraint: "max 65279", quality: "N S P Q", xref: "cluster§3.2.7.6",

                details: "Indicates the current value of the normalized chromaticity value y, as defined in the CIE xyY Color " +
                    "Space. It is updated as fast as practical during commands that change the color." +
                    "\n" +
                    "The value of y shall be related to the CurrentY attribute by the relationship" +
                    "\n" +
                    "y = \"CurrentY\" / 65536" +
                    "\n" +
                    "where CurrentY is in the range from 0 to 65279 inclusive." +
                    "\n" +
                    "Changes to this attribute shall only be marked as reportable in the following cases:" +
                    "\n" +
                    "  • At most once per second or" +
                    "\n" +
                    "  • At the end of the movement/transition."
            }
        ),

        Attribute({
            name: "DriftCompensation", id: 0x5, type: "DriftCompensationEnum", access: "R V", conformance: "O",
            xref: "cluster§3.2.7.7",
            details: "Indicates what mechanism, if any, is in use for compensation for color/intensity drift over time."
        }),

        Attribute({
            name: "CompensationText", id: 0x6, type: "string", access: "R V", conformance: "O",
            constraint: "max 254", xref: "cluster§3.2.7.8",
            details: "This attribute shall contain a textual indication of what mechanism, if any, is in use to compensate " +
                "for color/intensity drift over time."
        }),

        Attribute(
            {
                name: "ColorTemperatureMireds", id: 0x7, type: "uint16", access: "R V", conformance: "CT",
                constraint: "max 65279", quality: "N S P Q", xref: "cluster§3.2.7.9",

                details: "Indicates a scaled inverse of the current value of the color temperature. The unit of " +
                    "ColorTemperatureMireds is the mired (micro reciprocal degree), a.k.a. mirek (micro reciprocal " +
                    "kelvin). It is updated as fast as practical during commands that change the color." +
                    "\n" +
                    "Changes to this attribute shall only be marked as reportable in the following cases:" +
                    "\n" +
                    "  • At most once per second or" +
                    "\n" +
                    "  • At the end of the movement/transition." +
                    "\n" +
                    "The color temperature value in kelvins shall be related to the ColorTemperatureMireds attribute in " +
                    "mired by the relationship" +
                    "\n" +
                    "\"Color temperature [K]\" = \"1,000,000\" / \"ColorTemperatureMireds\"" +
                    "\n" +
                    "where ColorTemperatureMireds is in the range from 1 to 65279 inclusive, giving a color temperature " +
                    "range from 1,000,000 K to 15.32 K." +
                    "\n" +
                    "If this attribute is implemented then the ColorMode attribute shall also be implemented."
            }
        ),

        Attribute({
            name: "ColorMode", id: 0x8, type: "ColorModeEnum", access: "R V", conformance: "M", quality: "N",
            xref: "cluster§3.2.7.10",
            details: "Indicates which attributes are currently determining the color of the device." +
                "\n" +
                "The value of the ColorMode attribute cannot be written directly - it is set upon reception of any " +
                "command in section Commands to the appropriate mode for that command."
        }),

        Attribute({
            name: "Options", id: 0xf, type: "OptionsBitmap", access: "RW VO", conformance: "M",
            constraint: "desc", xref: "cluster§3.2.7.11",

            details: "Indicates a bitmap that determines the default behavior of some cluster commands. Each command that " +
                "is dependent on the Options attribute shall first construct a temporary Options bitmap that is in " +
                "effect during the command processing. The temporary Options bitmap has the same format and meaning " +
                "as the Options attribute, but includes any bits that may be overridden by command fields." +
                "\n" +
                "This attribute is meant to be changed only during commissioning." +
                "\n" +
                "Below is the format and description of the Options attribute and temporary Options bitmap and the " +
                "effect on dependent commands." +
                "\n" +
                "Command execution shall NOT continue beyond the Options processing if all of these criteria are " +
                "true:" +
                "\n" +
                "  • The On/Off cluster exists on the same endpoint as this cluster." +
                "\n" +
                "  • The OnOff attribute of the On/Off cluster, on this endpoint, is FALSE." +
                "\n" +
                "  • The value of the ExecuteIfOff bit is 0."
        }),

        Attribute({
            name: "NumberOfPrimaries", id: 0x10, type: "uint8", access: "R V", conformance: "M",
            constraint: "max 6", quality: "X F", xref: "cluster§3.2.7.24",

            details: "Indicates the number of color primaries implemented on this device. A value of null shall indicate " +
                "that the number of primaries is unknown." +
                "\n" +
                "Where this attribute is implemented, the attributes below for indicating the “x” and “y” color " +
                "values of the primaries shall also be implemented for each of the primaries from 1 to " +
                "NumberOfPrimaries, without leaving gaps. Implementation of the Primary1Intensity attribute and " +
                "subsequent intensity attributes is optional."
        }),

        Attribute(
            {
                name: "Primary1X", id: 0x11, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 0, O",
                constraint: "max 65279", quality: "F", xref: "cluster§3.2.7.25",
                details: "Indicates the normalized chromaticity value x for this primary, as defined in the CIE xyY Color " +
                    "Space." +
                    "\n" +
                    "The value of x shall be related to the Primary1X attribute by the relationship x = Primary1X / 65536 " +
                    "(Primary1X in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute(
            {
                name: "Primary1Y", id: 0x12, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 0, O",
                constraint: "max 65279", quality: "F", xref: "cluster§3.2.7.26",
                details: "Indicates the normalized chromaticity value y for this primary, as defined in the CIE xyY Color " +
                    "Space." +
                    "\n" +
                    "The value of y shall be related to the Primary1Y attribute by the relationship y = Primary1Y / 65536 " +
                    "(Primary1Y in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute({
            name: "Primary1Intensity", id: 0x13, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 0, O", quality: "X F", xref: "cluster§3.2.7.27",

            details: "Indicates a representation of the maximum intensity of this primary as defined in Section 3.1.3, " +
                "“The Dimming Light Curve”, normalized such that the primary with the highest maximum intensity " +
                "contains the value 254." +
                "\n" +
                "A value of null shall indicate that this primary is not available." +
                "\n" +
                "3.2.7.28. Primary2X, Primary2Y, Primary2Intensity, Primary3X, Primary3Y, Primary3Intensity, " +
                "Primary4X, Primary4Y, Primary4Intensity, Primary5X, Primary5Y, Primary5Intensity, Primary6X, " +
                "Primary6Y and Primary6Intensity Attributes These attributes shall represent the capabilities of the " +
                "2nd, 3rd, 4th, 5th and 6th primaries, where present, in the same way as for the Primary1X, Primary1Y " +
                "and Primary1Intensity attributes."
        }),

        Attribute({
            name: "Primary2X", id: 0x15, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 1, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary2Y", id: 0x16, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 1, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary2Intensity", id: 0x17, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 1, O", quality: "X F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary3X", id: 0x19, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 2, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary3Y", id: 0x1a, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 2, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary3Intensity", id: 0x1b, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 2, O", quality: "X F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary4X", id: 0x20, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 3, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary4Y", id: 0x21, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 3, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary4Intensity", id: 0x22, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 3, O", quality: "X F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary5X", id: 0x24, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 4, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary5Y", id: 0x25, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 4, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary5Intensity", id: 0x26, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 4, O", quality: "X F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary6X", id: 0x28, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 5, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary6Y", id: 0x29, type: "uint16", access: "R V", conformance: "NumberOfPrimaries > 5, O",
            constraint: "max 65279", quality: "F", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "Primary6Intensity", id: 0x2a, type: "uint8", access: "R V",
            conformance: "NumberOfPrimaries > 5, O", quality: "X F", xref: "cluster§3.2.7"
        }),

        Attribute(
            {
                name: "WhitePointX", id: 0x30, type: "uint16", access: "RW VM", conformance: "O",
                constraint: "max 65279", xref: "cluster§3.2.7.29",
                details: "Indicates the normalized chromaticity value x, as defined in the CIE xyY Color Space, of the current " +
                    "white point of the device." +
                    "\n" +
                    "The value of x shall be related to the WhitePointX attribute by the relationship x = WhitePointX / " +
                    "65536 (WhitePointX in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute(
            {
                name: "WhitePointY", id: 0x31, type: "uint16", access: "RW VM", conformance: "O",
                constraint: "max 65279", xref: "cluster§3.2.7.30",
                details: "Indicates the normalized chromaticity value y, as defined in the CIE xyY Color Space, of the current " +
                    "white point of the device." +
                    "\n" +
                    "The value of y shall be related to the WhitePointY attribute by the relationship y = WhitePointY / " +
                    "65536 (WhitePointY in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute(
            {
                name: "ColorPointRx", id: 0x32, type: "uint16", access: "RW VM", conformance: "O",
                constraint: "max 65279", xref: "cluster§3.2.7.31",
                details: "Indicates the normalized chromaticity value x, as defined in the CIE xyY Color Space, of the red " +
                    "color point of the device." +
                    "\n" +
                    "The value of x shall be related to the ColorPointRX attribute by the relationship x = ColorPointRX / " +
                    "65536 (ColorPointRX in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute(
            {
                name: "ColorPointRy", id: 0x33, type: "uint16", access: "RW VM", conformance: "O",
                constraint: "max 65279", xref: "cluster§3.2.7.32",
                details: "Indicates the normalized chromaticity value y, as defined in the CIE xyY Color Space, of the red " +
                    "color point of the device." +
                    "\n" +
                    "The value of y shall be related to the ColorPointRY attribute by the relationship y = ColorPointRY / " +
                    "65536 (ColorPointRY in the range 0 to 65279 inclusive)"
            }
        ),

        Attribute({
            name: "ColorPointRIntensity", id: 0x34, type: "uint8", access: "RW VM", conformance: "O",
            quality: "X", xref: "cluster§3.2.7.33",

            details: "Indicates a representation of the relative intensity of the red color point as defined in Section " +
                "3.1.3, “The Dimming Light Curve”, normalized such that the color point with the highest relative " +
                "intensity contains the value 254." +
                "\n" +
                "A value of null shall indicate an invalid value." +
                "\n" +
                "3.2.7.34. ColorPointGX, ColorPointGY, ColorPointGIntensity, ColorPointBX, ColorPointBY and " +
                "ColorPointBIntensity Attributes These attributes shall represent the chromaticity values and " +
                "intensities of the green and blue color points, in the same way as for the ColorPointRX, " +
                "ColorPointRY and ColorPointRIntensity attributes." +
                "\n" +
                "If any one of these red, green or blue color point attributes is implemented then they shall all be " +
                "implemented."
        }),

        Attribute({
            name: "ColorPointGx", id: 0x36, type: "uint16", access: "RW VM", conformance: "O",
            constraint: "max 65279", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "ColorPointGy", id: 0x37, type: "uint16", access: "RW VM", conformance: "O",
            constraint: "max 65279", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "ColorPointGIntensity", id: 0x38, type: "uint8", access: "RW VM", conformance: "O",
            quality: "X", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "ColorPointBx", id: 0x3a, type: "uint16", access: "RW VM", conformance: "O",
            constraint: "max 65279", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "ColorPointBy", id: 0x3b, type: "uint16", access: "RW VM", conformance: "O",
            constraint: "max 65279", xref: "cluster§3.2.7"
        }),
        Attribute({
            name: "ColorPointBIntensity", id: 0x3c, type: "uint8", access: "RW VM", conformance: "O",
            quality: "X", xref: "cluster§3.2.7"
        }),

        Attribute({
            name: "EnhancedCurrentHue", id: 0x4000, type: "uint16", access: "R V", conformance: "EHUE",
            quality: "N S Q", xref: "cluster§3.2.7.12",

            details: "Indicates the non-equidistant steps along the CIE 1931 color triangle, and it provides 16-bits " +
                "precision." +
                "\n" +
                "The upper 8 bits of this attribute shall be used as an index in the implementation specific XY " +
                "lookup table to provide the non-equidistant steps. The lower 8 bits shall be used to interpolate " +
                "between these steps in a linear way in order to provide color zoom for the user." +
                "\n" +
                "To provide compatibility with clients not supporting EHUE, the CurrentHue attribute shall contain a " +
                "hue value in the range 0 to 254, calculated from the EnhancedCurrentHue attribute." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once per second or" +
                "\n" +
                "  • At the end of the movement/transition."
        }),

        Attribute({
            name: "EnhancedColorMode", id: 0x4001, type: "EnhancedColorModeEnum", access: "R V",
            conformance: "M", quality: "N S", xref: "cluster§3.2.7.13",

            details: "Indicates which attributes are currently determining the color of the device." +
                "\n" +
                "To provide compatibility with clients not supporting EHUE, the original ColorMode attribute shall " +
                "indicate CurrentHue and CurrentSaturation when the light uses the EnhancedCurrentHue attribute. If " +
                "the ColorMode attribute is changed, its new value shall be copied to the EnhancedColorMode " +
                "attribute."
        }),

        Attribute({
            name: "ColorLoopActive", id: 0x4002, type: "uint8", access: "R V", conformance: "CL",
            constraint: "max 1", quality: "N S", xref: "cluster§3.2.7.14",
            details: "Indicates the current active status of the color loop. If this attribute has the value 0, the color " +
                "loop shall NOT be active. If this attribute has the value 1, the color loop shall be active."
        }),

        Attribute({
            name: "ColorLoopDirection", id: 0x4003, type: "ColorLoopDirectionEnum", access: "R V",
            conformance: "CL", quality: "N S", xref: "cluster§3.2.7.15",
            details: "Indicates the current direction of the color loop. If this attribute has the value Decrement, the " +
                "EnhancedCurrentHue attribute shall be decremented. If this attribute has the value Increment, the " +
                "EnhancedCurrentHue attribute shall be incremented."
        }),

        Attribute({
            name: "ColorLoopTime", id: 0x4004, type: "uint16", access: "R V", conformance: "CL", quality: "N S",
            xref: "cluster§3.2.7.16",
            details: "Indicates the number of seconds it shall take to perform a full color loop, i.e., to cycle all " +
                "values of the EnhancedCurrentHue attribute (between 0 and 65534)."
        }),

        Attribute({
            name: "ColorLoopStartEnhancedHue", id: 0x4005, type: "uint16", access: "R V", conformance: "CL",
            xref: "cluster§3.2.7.17",
            details: "Indicates the value of the EnhancedCurrentHue attribute from which the color loop shall be started."
        }),

        Attribute({
            name: "ColorLoopStoredEnhancedHue", id: 0x4006, type: "uint16", access: "R V", conformance: "CL",
            xref: "cluster§3.2.7.18",
            details: "Indicates the value of the EnhancedCurrentHue attribute before the color loop was started. Once the " +
                "color loop is complete, the EnhancedCurrentHue attribute shall be restored to this value."
        }),

        Attribute({
            name: "ColorCapabilities", id: 0x400a, type: "ColorCapabilitiesBitmap", access: "R V",
            conformance: "M", constraint: "max 31", xref: "cluster§3.2.7.19",
            details: "Indicates the color control capabilities of the device." +
                "\n" +
                "Bits 0-4 of the ColorCapabilities attribute shall have the same values as the corresponding bits of " +
                "the FeatureMap attribute. All other bits in ColorCapabilities shall be 0."
        }),

        Attribute({
            name: "ColorTempPhysicalMinMireds", id: 0x400b, type: "uint16", access: "R V", conformance: "CT",
            constraint: "1 to 65279", xref: "cluster§3.2.7.20",
            details: "Indicates the minimum mired value supported by the hardware. ColorTempPhysicalMinMireds corresponds " +
                "to the maximum color temperature in kelvins supported by the hardware." +
                "\n" +
                "ColorTempPhysicalMinMireds <= ColorTemperatureMireds."
        }),

        Attribute({
            name: "ColorTempPhysicalMaxMireds", id: 0x400c, type: "uint16", access: "R V", conformance: "CT",
            constraint: "max 65279", xref: "cluster§3.2.7.21",
            details: "Indicates the maximum mired value supported by the hardware. ColorTempPhysicalMaxMireds corresponds " +
                "to the minimum color temperature in kelvins supported by the hardware." +
                "\n" +
                "ColorTemperatureMireds <= ColorTempPhysicalMaxMireds."
        }),

        Attribute(
            {
                name: "CoupleColorTempToLevelMinMireds", id: 0x400d, type: "uint16", access: "R V",
                conformance: "CT", constraint: "colorTempPhysicalMinMireds to colorTemperatureMireds",
                xref: "cluster§3.2.7.22",

                details: "Indicates a lower bound on the value of the ColorTemperatureMireds attribute for the purposes of " +
                    "coupling the ColorTemperatureMireds attribute to the CurrentLevel attribute when the " +
                    "CoupleColorTempToLevel bit of the Options attribute of the Level Control cluster is equal to 1. When " +
                    "coupling the ColorTemperatureMireds attribute to the CurrentLevel attribute, this value shall " +
                    "correspond to a CurrentLevel value of 254 (100%)." +
                    "\n" +
                    "This attribute shall be set such that the following relationship exists: ColorTempPhysicalMinMireds " +
                    "<= CoupleColorTempToLevelMinMireds <= ColorTemperatureMireds" +
                    "\n" +
                    "Note that since this attribute is stored as a micro reciprocal degree (mired) value (i.e. color " +
                    "temperature in kelvins = 1,000,000 / CoupleColorTempToLevelMinMireds), the " +
                    "CoupleColorTempToLevelMinMireds attribute corresponds to an upper bound on the value of the color " +
                    "temperature" +
                    "\n" +
                    "in kelvins supported by the device."
            }
        ),

        Attribute({
            name: "StartUpColorTemperatureMireds", id: 0x4010, type: "uint16", access: "RW VM",
            conformance: "CT", constraint: "1 to 65279", quality: "X N", xref: "cluster§3.2.7.23",
            details: "Indicates the desired startup color temperature value the light shall use when it is supplied with " +
                "power and this value shall be reflected in the ColorTemperatureMireds attribute. In addition, the " +
                "ColorMode and EnhancedColorMode attributes shall be set to 2 (ColorTemperatureMireds). The values of " +
                "the StartUpColorTemperatureMireds attribute are listed in the table below,"
        }),

        Command(
            {
                name: "MoveToHue", id: 0x0, access: "O", conformance: "HS", direction: "request",
                response: "status", xref: "cluster§3.2.8.4"
            },
            Field({
                name: "Hue", id: 0x0, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§3.2.8.4.1",
                details: "This field shall indicate the hue to be moved to."
            }),
            Field({
                name: "Direction", id: 0x1, type: "DirectionEnum", conformance: "M", xref: "cluster§3.2.8.4.2",
                details: "This field shall indicate the movement direction."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.4.3",
                details: "This field shall indicate, in 1/10ths of a second, the time that shall be taken to move to the new " +
                    "hue."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveHue", id: 0x1, access: "O", conformance: "HS", direction: "request", response: "status",
                xref: "cluster§3.2.8.5"
            },
            Field({
                name: "MoveMode", id: 0x0, type: "MoveModeEnum", conformance: "M", xref: "cluster§3.2.8.5.1",
                details: "This field shall indicate the mode of movement."
            }),
            Field({
                name: "Rate", id: 0x1, type: "uint8", conformance: "M", xref: "cluster§3.2.8.5.2",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the " +
                    "device’s hue of one unit."
            }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "StepHue", id: 0x2, access: "O", conformance: "HS", direction: "request", response: "status",
                xref: "cluster§3.2.8.6"
            },
            Field({
                name: "StepMode", id: 0x0, type: "StepModeEnum", conformance: "M", xref: "cluster§3.2.8.6.1",
                details: "This field shall indicate the mode of the step to be performed."
            }),
            Field({
                name: "StepSize", id: 0x1, type: "uint8", conformance: "M", xref: "cluster§3.2.8.6.2",
                details: "This field shall indicate the change to be added to (or subtracted from) the current value of the " +
                    "device’s hue."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint8", conformance: "M", xref: "cluster§3.2.8.6.3",

                details: "This field shall indicate, in 1/10ths of a second, the time that shall be taken to perform the step. " +
                    "A step is a change in the device’s hue of Step size units." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Here the TransitionTime data field is of data type uint8, where uint16 is more common for " +
                    "  TransitionTime data fields in other clusters / commands."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveToSaturation", id: 0x3, access: "O", conformance: "HS", direction: "request",
                response: "status", xref: "cluster§3.2.8.7"
            },
            Field({ name: "Saturation", id: 0x0, type: "uint8", conformance: "M", constraint: "max 254" }),
            Field({ name: "TransitionTime", id: 0x1, type: "uint16", conformance: "M", constraint: "max 65534" }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveSaturation", id: 0x4, access: "O", conformance: "HS", direction: "request",
                response: "status", xref: "cluster§3.2.8.8"
            },
            Field({
                name: "MoveMode", id: 0x0, type: "MoveModeEnum", conformance: "M", xref: "cluster§3.2.8.8.1",
                details: "This field shall indicate the mode of movement, as described in the MoveHue command."
            }),
            Field({
                name: "Rate", id: 0x1, type: "uint8", conformance: "M", xref: "cluster§3.2.8.8.2",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the " +
                    "device’s saturation of one unit."
            }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "StepSaturation", id: 0x5, access: "O", conformance: "HS", direction: "request",
                response: "status", xref: "cluster§3.2.8.9"
            },
            Field({
                name: "StepMode", id: 0x0, type: "StepModeEnum", conformance: "M", xref: "cluster§3.2.8.9.1",
                details: "This field shall indicate the mode of the step to be performed, as described in the StepHue command."
            }),
            Field({
                name: "StepSize", id: 0x1, type: "uint8", conformance: "M", xref: "cluster§3.2.8.9.2",
                details: "This field shall indicate the change to be added to (or subtracted from) the current value of the " +
                    "device’s saturation."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint8", conformance: "M", xref: "cluster§3.2.8.9.3",

                details: "This field shall indicate, in 1/10ths of a second, the time that shall be taken to perform the step. " +
                    "A step is a change in the device’s saturation of Step size units." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Here the TransitionTime data field is of data type uint8, where uint16 is more common for " +
                    "  TransitionTime data fields in other clusters / commands."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveToHueAndSaturation", id: 0x6, access: "O", conformance: "HS", direction: "request",
                response: "status", xref: "cluster§3.2.8.10"
            },
            Field({ name: "Hue", id: 0x0, type: "uint8", conformance: "M", constraint: "max 254" }),
            Field({ name: "Saturation", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254" }),
            Field({ name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534" }),
            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveToColor", id: 0x7, access: "O", conformance: "XY", direction: "request",
                response: "status", xref: "cluster§3.2.8.11"
            },
            Field({ name: "ColorX", id: 0x0, type: "uint16", conformance: "M", constraint: "max 65279" }),
            Field({ name: "ColorY", id: 0x1, type: "uint16", conformance: "M", constraint: "max 65279" }),
            Field({ name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534" }),
            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveColor", id: 0x8, access: "O", conformance: "XY", direction: "request",
                response: "status", xref: "cluster§3.2.8.12"
            },
            Field({
                name: "RateX", id: 0x0, type: "int16", conformance: "M", xref: "cluster§3.2.8.12.1",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the " +
                    "device’s CurrentX attribute of one unit."
            }),
            Field({
                name: "RateY", id: 0x1, type: "int16", conformance: "M", xref: "cluster§3.2.8.12.2",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the " +
                    "device’s CurrentY attribute of one unit."
            }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "StepColor", id: 0x9, access: "O", conformance: "XY", direction: "request",
                response: "status", xref: "cluster§3.2.8.13"
            },
            Field({ name: "StepX", id: 0x0, type: "int16", conformance: "M" }),
            Field({ name: "StepY", id: 0x1, type: "int16", conformance: "M" }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.13.2",
                details: "The field shall indicate, in 1/10ths of a second, the time that shall be taken to perform the color " +
                    "change."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveToColorTemperature", id: 0xa, access: "O", conformance: "CT", direction: "request",
                response: "status", xref: "cluster§3.2.8.14"
            },
            Field({ name: "ColorTemperatureMireds", id: 0x0, type: "uint16", conformance: "M", constraint: "max 65279" }),
            Field({ name: "TransitionTime", id: 0x1, type: "uint16", conformance: "M", constraint: "max 65534" }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "EnhancedMoveToHue", id: 0x40, access: "O", conformance: "EHUE", direction: "request",
                response: "status", xref: "cluster§3.2.8.15",
                details: "This command allows the light to be moved in a smooth continuous transition from their current hue " +
                    "to a target hue."
            },

            Field({
                name: "EnhancedHue", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§3.2.8.15.1",
                details: "This field shall indicate the target extended hue for the light."
            }),
            Field({
                name: "Direction", id: 0x1, type: "DirectionEnum", conformance: "M", xref: "cluster§3.2.8.15.2",
                details: "This field shall indicate the movement direction."
            }),
            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.15.3",
                details: "This field shall indicate the transition time, as described in the MoveToHue command."
            }),
            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "EnhancedMoveHue", id: 0x41, access: "O", conformance: "EHUE", direction: "request",
                response: "status", xref: "cluster§3.2.8.16",
                details: "This command allows the light to start a continuous transition starting from their current hue."
            },
            Field({
                name: "MoveMode", id: 0x0, type: "MoveModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§3.2.8.16.1",
                details: "This field shall indicate the mode of movement, as described in the MoveHue command."
            }),
            Field({
                name: "Rate", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§3.2.8.16.2",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the " +
                    "extended hue of a device by one unit."
            }),
            Field({ name: "OptionsMask", id: 0x2, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "EnhancedStepHue", id: 0x42, access: "O", conformance: "EHUE", direction: "request",
                response: "status", xref: "cluster§3.2.8.17",
                details: "This command allows the light to be moved in a stepped transition from their current hue, resulting " +
                    "in a linear transition through XY space."
            },

            Field({
                name: "StepMode", id: 0x0, type: "StepModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§3.2.8.17.1",
                details: "This field shall indicate the mode of the step to be performed, as described in the StepHue command."
            }),
            Field({
                name: "StepSize", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§3.2.8.17.2",
                details: "This field shall indicate the change to be added to (or subtracted from) the current value of the " +
                    "device’s enhanced hue."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.17.3",

                details: "The field shall indicate, in units of 1/10ths of a second, the time that shall be taken to perform " +
                    "the step. A step is a change to the device’s enhanced hue of a magnitude corresponding to the " +
                    "StepSize field." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Here TransitionTime data field is of data type uint16, while the TransitionTime data field of the " +
                    "  StepHue command is of data type uint8."
            }),

            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "EnhancedMoveToHueAndSaturation", id: 0x43, access: "O", conformance: "EHUE",
                direction: "request", response: "status", xref: "cluster§3.2.8.18",
                details: "This command allows the light to be moved in a smooth continuous transition from their current hue " +
                    "to a target hue and from their current saturation to a target saturation."
            },

            Field({
                name: "EnhancedHue", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§3.2.8.18.1",
                details: "This field shall indicate the target extended hue for the light."
            }),
            Field({
                name: "Saturation", id: 0x1, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§3.2.8.18.2",
                details: "This field shall indicate the saturation, as described in the MoveToHueAndSaturation command."
            }),
            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.18.3",
                details: "This field shall indicate the transition time, as described in the MoveToHue command."
            }),
            Field({ name: "OptionsMask", id: 0x3, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "ColorLoopSet", id: 0x44, access: "O", conformance: "CL", direction: "request",
                response: "status", xref: "cluster§3.2.8.19",
                details: "This command allows a color loop to be activated such that the color light cycles through its range " +
                    "of hues."
            },

            Field({
                name: "UpdateFlags", id: 0x0, type: "UpdateFlagsBitmap", conformance: "M",
                xref: "cluster§3.2.8.19.1",
                details: "This field shall indicate which color loop attributes to update (from the values supplied in the " +
                    "other fields, see field descriptions below) before the color loop is started."
            }),

            Field({
                name: "Action", id: 0x1, type: "ColorLoopActionEnum", conformance: "M", xref: "cluster§3.2.8.19.2",
                details: "This field shall indicate the action to take for the color loop."
            }),
            Field({
                name: "Direction", id: 0x2, type: "ColorLoopDirectionEnum", conformance: "M",
                xref: "cluster§3.2.8.19.3",
                details: "This field shall indicate the direction for the color loop."
            }),
            Field({
                name: "Time", id: 0x3, type: "uint16", conformance: "M", xref: "cluster§3.2.8.19.4",
                details: "This field shall indicate the number of seconds over which to perform a full color loop."
            }),
            Field({ name: "StartHue", id: 0x4, type: "uint16", conformance: "M" }),
            Field({ name: "OptionsMask", id: 0x5, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x6, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "StopMoveStep", id: 0x47, access: "O", conformance: "HS | XY | CT", direction: "request",
                response: "status", xref: "cluster§3.2.8.20",
                details: "This command is provided to allow MoveTo and Step commands to be stopped." +
                    "\n" +
                    "NOTE This automatically provides symmetry to the Level Control cluster." +
                    "\n" +
                    "NOTE The StopMoveStep command has no effect on an active color loop."
            },

            Field({ name: "OptionsMask", id: 0x0, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x1, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "MoveColorTemperature", id: 0x4b, access: "O", conformance: "CT", direction: "request",
                response: "status", xref: "cluster§3.2.8.21",
                details: "This command allows the color temperature of the light to be moved at a specified rate."
            },
            Field({
                name: "MoveMode", id: 0x0, type: "MoveModeEnum", conformance: "M", xref: "cluster§3.2.8.21.1",
                details: "This field shall indicate the mode of movement, as described in the MoveHue command."
            }),
            Field({
                name: "Rate", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§3.2.8.21.2",
                details: "This field shall indicate the rate of movement in steps per second. A step is a change in the color " +
                    "temperature of a device by one unit."
            }),

            Field({
                name: "ColorTemperatureMinimumMireds", id: 0x2, type: "uint16", conformance: "M",
                constraint: "max 65279", xref: "cluster§3.2.8.21.3",

                details: "This field shall indicate a lower bound on the ColorTemperatureMireds attribute (≡ an upper bound on " +
                    "the color temperature in kelvins) for the current move operation" +
                    "\n" +
                    "ColorTempPhysicalMinMireds <= ColorTemperatureMinimumMireds field <= ColorTemperatureMireds As such " +
                    "if the move operation takes the ColorTemperatureMireds attribute towards the value of the " +
                    "ColorTemperatureMinimumMireds field it shall be clipped so that the above invariant is satisfied. If " +
                    "the ColorTemperatureMinimumMireds field is set to 0, ColorTempPhysicalMinMireds shall be used as the " +
                    "lower bound for the ColorTemperatureMireds attribute."
            }),

            Field({
                name: "ColorTemperatureMaximumMireds", id: 0x3, type: "uint16", conformance: "M",
                constraint: "max 65279", xref: "cluster§3.2.8.21.4",

                details: "This field shall indicate an upper bound on the ColorTemperatureMireds attribute (≡ a lower bound on " +
                    "the color temperature in kelvins) for the current move operation" +
                    "\n" +
                    "ColorTemperatureMireds <= ColorTemperatureMaximumMireds field <= ColorTempPhysicalMaxMireds As such " +
                    "if the move operation takes the ColorTemperatureMireds attribute towards the value of the " +
                    "ColorTemperatureMaximumMireds field it shall be clipped so that the above invariant is satisfied. If " +
                    "the ColorTemperatureMaximumMireds field is set to 0, ColorTempPhysicalMaxMireds shall be used as the " +
                    "upper bound for the ColorTemperatureMireds attribute."
            }),

            Field({ name: "OptionsMask", id: 0x4, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x5, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "StepColorTemperature", id: 0x4c, access: "O", conformance: "CT", direction: "request",
                response: "status", xref: "cluster§3.2.8.22",
                details: "This command allows the color temperature of the light to be stepped with a specified step size."
            },
            Field({
                name: "StepMode", id: 0x0, type: "StepModeEnum", conformance: "M", xref: "cluster§3.2.8.22.1",
                details: "This field shall indicate the mode of the step to be performed, as described in the StepHue command."
            }),
            Field({
                name: "StepSize", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§3.2.8.22.2",
                details: "This field shall indicate the change to be added to (or subtracted from) the current value of the " +
                    "device’s color temperature."
            }),

            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", constraint: "max 65534",
                xref: "cluster§3.2.8.22.3",
                details: "This field shall indicate, in units of 1/10ths of a second, the time that shall be taken to perform " +
                    "the step. A step is a change to the device’s color temperature of a magnitude corresponding to the " +
                    "StepSize field."
            }),

            Field({
                name: "ColorTemperatureMinimumMireds", id: 0x3, type: "uint16", conformance: "M",
                constraint: "max 65279", xref: "cluster§3.2.8.22.4",

                details: "This field shall indicate a lower bound on the ColorTemperatureMireds attribute (≡ an upper bound on " +
                    "the color temperature in kelvins) for the current step operation" +
                    "\n" +
                    "ColorTempPhysicalMinMireds <= ColorTemperatureMinimumMireds field <= ColorTemperatureMireds As such " +
                    "if the step operation takes the ColorTemperatureMireds attribute towards the value of the " +
                    "ColorTemperatureMinimumMireds field it shall be clipped so that the above invariant is satisfied. If " +
                    "the ColorTemperatureMinimumMireds field is set to 0, ColorTempPhysicalMinMireds shall be used as the " +
                    "lower bound for the ColorTemperatureMireds attribute."
            }),

            Field({
                name: "ColorTemperatureMaximumMireds", id: 0x4, type: "uint16", conformance: "M",
                constraint: "max 65279", xref: "cluster§3.2.8.22.5",

                details: "This field shall indicate an upper bound on the ColorTemperatureMireds attribute (≡ a lower bound on " +
                    "the color temperature in kelvins) for the current step operation" +
                    "\n" +
                    "ColorTemperatureMireds ≤ ColorTemperatureMaximumMireds field ≤ ColorTempPhysicalMaxMireds As such if " +
                    "the step operation takes the ColorTemperatureMireds attribute towards the value of the " +
                    "ColorTemperatureMaximumMireds field it shall be clipped so that the above invariant is satisfied. If " +
                    "the ColorTemperatureMaximumMireds field is set to 0, ColorTempPhysicalMaxMireds shall be used as the " +
                    "upper bound for the ColorTemperatureMireds attribute."
            }),

            Field({ name: "OptionsMask", id: 0x5, type: "OptionsBitmap", conformance: "M", constraint: "desc" }),
            Field({ name: "OptionsOverride", id: 0x6, type: "OptionsBitmap", conformance: "M", constraint: "desc" })
        ),

        Datatype(
            { name: "ColorCapabilitiesBitmap", type: "map16", xref: "cluster§3.2.6.1" },
            Field({ name: "HueSaturation", constraint: "0", description: "Supports color specification via hue/saturation." }),
            Field({ name: "EnhancedHue", constraint: "1", description: "Enhanced hue is supported." }),
            Field({ name: "ColorLoop", constraint: "2", description: "Color loop is supported." }),
            Field({ name: "Xy", constraint: "3", description: "Supports color specification via XY." }),
            Field({
                name: "ColorTemperature", constraint: "4",
                description: "Supports color specification via color temperature."
            })
        ),

        Datatype(
            { name: "OptionsBitmap", type: "map8", xref: "cluster§3.2.6.2" },
            Field({
                name: "ExecuteIfOff", constraint: "0", description: "Dependency on On/Off cluster",
                xref: "cluster§3.2.6.2.1",
                details: "This bit shall indicate if this cluster server instance has a dependency with the On/Off cluster."
            })
        ),

        Datatype(
            {
                name: "UpdateFlagsBitmap", type: "map8", xref: "cluster§3.2.6.3",
                details: "This data type is derived from map8 and is used in the ColorLoopSet command."
            },

            Field(
                {
                    name: "UpdateAction", constraint: "0",
                    description: "Device adheres to the associated action field.", xref: "cluster§3.2.6.3.1",

                    details: "This bit shall indicate whether the server adheres to the Action field in order to process the " +
                        "command." +
                        "\n" +
                        "  • 0 = Device shall ignore the Action field." +
                        "\n" +
                        "  • 1 = Device shall adhere to the Action field."
                }
            ),

            Field(
                {
                    name: "UpdateDirection", constraint: "1",
                    description: "Device updates the associated direction attribute.", xref: "cluster§3.2.6.3.2",

                    details: "This bit shall indicate whether the device updates the ColorLoopDirection attribute with the " +
                        "Direction field." +
                        "\n" +
                        "  • 0 = Device shall ignore the Direction field." +
                        "\n" +
                        "  • 1 = Device shall update the ColorLoopDirection attribute with the value of the Direction field."
                }
            ),

            Field(
                {
                    name: "UpdateTime", constraint: "2", description: "Device updates the associated time attribute.",
                    xref: "cluster§3.2.6.3.3",

                    details: "This bit shall indicate whether the device updates the ColorLoopTime attribute with the Time field." +
                        "\n" +
                        "  • 0 = Device shall ignore the Time field." +
                        "\n" +
                        "  • 1 = Device shall update the value of the ColorLoopTime attribute with the value of the Time " +
                        "    field."
                }
            ),

            Field(
                {
                    name: "UpdateStartHue", constraint: "3",
                    description: "Device updates the associated start hue attribute.", xref: "cluster§3.2.6.3.4",

                    details: "This bit shall indicate whether the device updates the ColorLoopStartEnhancedHue attribute with the " +
                        "value of the StartHue field." +
                        "\n" +
                        "  • 0 = Device shall ignore the StartHue field." +
                        "\n" +
                        "  • 1 = Device shall update the value of the ColorLoopStartEnhancedHue attribute with the value of " +
                        "    the StartHue field."
                }
            )
        ),

        Datatype(
            { name: "DriftCompensationEnum", type: "enum8", xref: "cluster§3.2.6.4" },
            Field({ name: "None", id: 0x0, conformance: "M", description: "There is no compensation." }),
            Field({
                name: "OtherOrUnknown", id: 0x1, conformance: "M",
                description: "The compensation is based on other or unknown mechanism."
            }),
            Field({
                name: "TemperatureMonitoring", id: 0x2, conformance: "M",
                description: "The compensation is based on temperature monitoring."
            }),
            Field({
                name: "OpticalLuminanceMonitoringAndFeedback", id: 0x3, conformance: "M",
                description: "The compensation is based on optical luminance monitoring and feedback."
            }),
            Field({
                name: "OpticalColorMonitoringAndFeedback", id: 0x4, conformance: "M",
                description: "The compensation is based on optical color monitoring and feedback."
            })
        ),

        Datatype(
            { name: "ColorModeEnum", type: "enum8", xref: "cluster§3.2.6.5" },
            Field({
                name: "CurrentHueAndCurrentSaturation", id: 0x0, conformance: "M",
                description: "The current hue and saturation attributes determine the color."
            }),
            Field({
                name: "CurrentXAndCurrentY", id: 0x1, conformance: "M",
                description: "The current X and Y attributes determine the color."
            }),
            Field({
                name: "ColorTemperatureMireds", id: 0x2, conformance: "M",
                description: "The color temperature attribute determines the color."
            })
        ),

        Datatype(
            { name: "EnhancedColorModeEnum", type: "enum8", xref: "cluster§3.2.6.6" },
            Field({
                name: "CurrentHueAndCurrentSaturation", id: 0x0, conformance: "M",
                description: "The current hue and saturation attributes determine the color."
            }),
            Field({
                name: "CurrentXAndCurrentY", id: 0x1, conformance: "M",
                description: "The current X and Y attributes determine the color."
            }),
            Field({
                name: "ColorTemperatureMireds", id: 0x2, conformance: "M",
                description: "The color temperature attribute determines the color."
            }),
            Field({
                name: "EnhancedCurrentHueAndCurrentSaturation", id: 0x3, conformance: "M",
                description: "The enhanced current hue and saturation attributes determine the color."
            })
        ),

        Datatype(
            { name: "DirectionEnum", type: "enum8", xref: "cluster§3.2.6.7" },
            Field({ name: "Shortest", id: 0x0, conformance: "M", description: "Shortest distance" }),
            Field({ name: "Longest", id: 0x1, conformance: "M", description: "Longest distance" }),
            Field({ name: "Up", id: 0x2, conformance: "M", description: "Up" }),
            Field({ name: "Down", id: 0x3, conformance: "M", description: "Down" })
        ),

        Datatype(
            { name: "MoveModeEnum", type: "enum8", xref: "cluster§3.2.6.8" },
            Field({ name: "Stop", id: 0x0, conformance: "M", description: "Stop the movement" }),
            Field({ name: "Up", id: 0x1, conformance: "M", description: "Move in an upwards direction" }),
            Field({ name: "Down", id: 0x3, conformance: "M", description: "Move in a downwards direction" })
        ),

        Datatype(
            { name: "StepModeEnum", type: "enum8", xref: "cluster§3.2.6.9" },
            Field({ name: "Up", id: 0x1, conformance: "M", description: "Step in an upwards direction" }),
            Field({ name: "Down", id: 0x3, conformance: "M", description: "Step in a downwards direction" })
        ),

        Datatype(
            { name: "ColorLoopActionEnum", type: "enum8", xref: "cluster§3.2.6.10" },
            Field({ name: "Deactivate", id: 0x0, conformance: "M", description: "De-activate the color loop." }),
            Field({
                name: "ActivateFromColorLoopStartEnhancedHue", id: 0x1, conformance: "M",
                description: "Activate the color loop from the value in the ColorLoopStartEnhancedHue field."
            }),
            Field({
                name: "ActivateFromEnhancedCurrentHue", id: 0x2, conformance: "M",
                description: "Activate the color loop from the value of the EnhancedCurrentHue attribute."
            })
        ),

        Datatype(
            { name: "ColorLoopDirectionEnum", type: "enum8", xref: "cluster§3.2.6.11" },
            Field({ name: "Decrement", id: 0x0, conformance: "M", description: "Decrement the hue in the color loop." }),
            Field({ name: "Increment", id: 0x1, conformance: "M", description: "Increment the hue in the color loop." })
        )
    ),

    Cluster(
        {
            name: "PumpConfigurationAndControl", id: 0x200, classification: "application", pics: "PCC",
            xref: "cluster§4.2",

            details: "The Pump Configuration and Control cluster provides an interface for the setup and control of pump " +
                "devices, and the automatic reporting of pump status information. Note that control of pump speed is " +
                "not included – speed is controlled by the On/Off and Level Control clusters." +
                "\n" +
                "### Pump controller Pump" +
                "\n" +
                "C Pump configuration and control S C Level control S" +
                "\n" +
                "### C On/Off S" +
                "\n" +
                "C = Client S = Server" +
                "\n" +
                "Note: Device names are examples for illustration purposes only"
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 4 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§4.2.4" },
            Field({
                name: "PRSCONST", conformance: "O.a+", constraint: "0", title: "ConstantPressure",
                details: "Supports operating in constant pressure mode"
            }),
            Field({
                name: "PRSCOMP", conformance: "O.a+", constraint: "1", title: "CompensatedPressure",
                details: "Supports operating in compensated pressure mode"
            }),
            Field({
                name: "FLW", conformance: "O.a+", constraint: "2", title: "ConstantFlow",
                details: "Supports operating in constant flow mode"
            }),
            Field({
                name: "SPD", conformance: "O.a+", constraint: "3", title: "ConstantSpeed",
                details: "Supports operating in constant speed mode"
            }),
            Field({
                name: "TEMP", conformance: "O.a+", constraint: "4", title: "ConstantTemperature",
                details: "Supports operating in constant temperature mode"
            }),
            Field({
                name: "AUTO", conformance: "O", constraint: "5", title: "Automatic",
                details: "Supports operating in automatic mode"
            }),
            Field({
                name: "LOCAL", conformance: "O", constraint: "6", title: "LocalOperation",
                details: "Supports operating using local settings"
            })
        ),

        Attribute({
            name: "MaxPressure", id: 0x0, type: "int16", access: "R V", conformance: "M", default: null,
            quality: "X F", xref: "cluster§4.2.7.1",
            details: "This attribute specifies the maximum pressure the pump can achieve. It is a physical limit, and does " +
                "not apply to any specific control mode or operation mode." +
                "\n" +
                "Valid range is -3,276.7 kPa to 3,276.7 kPa (steps of 0.1 kPa). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxSpeed", id: 0x1, type: "uint16", access: "R V", conformance: "M", default: null,
            quality: "X F", xref: "cluster§4.2.7.2",
            details: "This attribute specifies the maximum speed the pump can achieve. It is a physical limit, and does " +
                "not apply to any specific control mode or operation mode." +
                "\n" +
                "Valid range is 0 to 65,534 RPM (steps of 1 RPM). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxFlow", id: 0x2, type: "uint16", access: "R V", conformance: "M", default: null,
            quality: "X F", xref: "cluster§4.2.7.3",
            details: "This attribute specifies the maximum flow the pump can achieve. It is a physical limit, and does not " +
                "apply to any specific control mode or operation mode." +
                "\n" +
                "Valid range is 0 m/h to 6,553.4 m/h (steps of 0.1 m/h). Null if the value is invalid."
        }),

        Attribute({
            name: "MinConstPressure", id: 0x3, type: "int16", access: "R V", conformance: "PRSCONST, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.4",
            details: "This attribute specifies the minimum pressure the pump can achieve when it is working with the " +
                "ControlMode attribute set to ConstantPressure." +
                "\n" +
                "Valid range is –3,276.7 kPa to 3,276.7 kPa (steps of 0.1 kPa). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxConstPressure", id: 0x4, type: "int16", access: "R V", conformance: "PRSCONST, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.5",
            details: "This attribute specifies the maximum pressure the pump can achieve when it is working with the " +
                "ControlMode attribute set to ConstantPressure." +
                "\n" +
                "Valid range is –3,276.7 kPa to 3,276.7 kPa (steps of 0.1 kPa). Null if the value is invalid."
        }),

        Attribute({
            name: "MinCompPressure", id: 0x5, type: "int16", access: "R V", conformance: "PRSCOMP, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.6",
            details: "This attribute specifies the minimum compensated pressure the pump can achieve when it is working " +
                "with the ControlMode attribute set to ProportionalPressure." +
                "\n" +
                "Valid range is –3,276.7 kPa to 3,276.7 kPa (steps of 0.1 kPa). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxCompPressure", id: 0x6, type: "int16", access: "R V", conformance: "PRSCOMP, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.7",
            details: "This attribute specifies the maximum compensated pressure the pump can achieve when it is working " +
                "with the ControlMode attribute set to ProportionalPressure." +
                "\n" +
                "Valid range is –3,276.7 kPa to 3,276.7 kPa (steps of 0.1 kPa). Null if the value is invalid."
        }),

        Attribute({
            name: "MinConstSpeed", id: 0x7, type: "uint16", access: "R V", conformance: "SPD, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.8",
            details: "This attribute specifies the minimum speed the pump can achieve when it is working with the Con " +
                "trolMode attribute set to ConstantSpeed." +
                "\n" +
                "Valid range is 0 to 65,534 RPM (steps of 1 RPM). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxConstSpeed", id: 0x8, type: "uint16", access: "R V", conformance: "SPD, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.9",
            details: "This attribute specifies the maximum speed the pump can achieve when it is working with the " +
                "ControlMode attribute set to ConstantSpeed." +
                "\n" +
                "Valid range is 0 to 65,534 RPM (steps of 1 RPM). Null if the value is invalid."
        }),

        Attribute({
            name: "MinConstFlow", id: 0x9, type: "uint16", access: "R V", conformance: "FLW, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.10",
            details: "This attribute specifies the minimum flow the pump can achieve when it is working with the " +
                "ControlMode attribute set to ConstantFlow." +
                "\n" +
                "Valid range is 0 m/h to 6,553.4 m/h (steps of 0.1 m/h). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxConstFlow", id: 0xa, type: "uint16", access: "R V", conformance: "FLW, [AUTO]",
            default: null, quality: "X F", xref: "cluster§4.2.7.11",
            details: "This attribute specifies the maximum flow the pump can achieve when it is working with the " +
                "ControlMode attribute set to ConstantFlow." +
                "\n" +
                "Valid range is 0 m/h to 6,553.4 m/h (steps of 0.1 m/h). Null if the value is invalid."
        }),

        Attribute({
            name: "MinConstTemp", id: 0xb, type: "int16", access: "R V", conformance: "TEMP, [AUTO]",
            constraint: "min -27315", default: null, quality: "X F", xref: "cluster§4.2.7.12",
            details: "This attribute specifies the minimum temperature the pump can maintain in the system when it is " +
                "working with the ControlMode attribute set to ConstantTemperature." +
                "\n" +
                "Valid range is –273.15 °C to 327.67 °C (steps of 0.01 °C). Null if the value is invalid."
        }),

        Attribute({
            name: "MaxConstTemp", id: 0xc, type: "int16", access: "R V", conformance: "TEMP, [AUTO]",
            constraint: "min -27315", default: null, quality: "X F", xref: "cluster§4.2.7.13",

            details: "This attribute specifies the maximum temperature the pump can maintain in the system when it is " +
                "working with the ControlMode attribute set to ConstantTemperature." +
                "\n" +
                "MaxConstTemp shall be greater than or equal to MinConstTemp Valid range is –273.15 °C to 327.67 °C " +
                "(steps of 0.01 °C)." +
                "\n" +
                "Null if the value is invalid."
        }),

        Attribute({
            name: "PumpStatus", id: 0x10, type: "PumpStatusBitmap", access: "R V", conformance: "O",
            constraint: "desc", default: 0, quality: "P", xref: "cluster§4.2.7.14",
            details: "This attribute specifies the activity status of the pump functions as listed in PumpStatusBitmap. " +
                "Where a pump controller function is active, the corresponding bit shall be set to 1. Where a pump " +
                "controller function is not active, the corresponding bit shall be set to 0."
        }),

        Attribute({
            name: "EffectiveOperationMode", id: 0x11, type: "OperationModeEnum", access: "R V",
            conformance: "M", constraint: "desc", quality: "N", xref: "cluster§4.2.7.15",

            details: "This attribute specifies current effective operation mode of the pump as defined in " +
                "OperationModeEnum." +
                "\n" +
                "The value of the EffectiveOperationMode attribute is the same as the OperationMode attribute, unless " +
                "one of the following points are true:" +
                "\n" +
                "  • The pump is physically set to run with the local settings" +
                "\n" +
                "  • The LocalOverride bit in the PumpStatus attribute is set," +
                "\n" +
                "See OperationMode Attribute and ControlMode Attribute for a detailed description of the operation " +
                "and control of the pump."
        }),

        Attribute({
            name: "EffectiveControlMode", id: 0x12, type: "ControlModeEnum", access: "R V", conformance: "M",
            constraint: "desc", quality: "N", xref: "cluster§4.2.7.16",

            details: "This attribute specifies the current effective control mode of the pump as defined in " +
                "ControlModeEnum." +
                "\n" +
                "This attribute contains the control mode that currently applies to the pump. It will have the value " +
                "of the ControlMode attribute, unless one of the following points are true:" +
                "\n" +
                "  • The ControlMode attribute is set to Automatic. In this case, the value of the " +
                "    EffectiveControlMode shall match the behavior of the pump." +
                "\n" +
                "  • A remote sensor is used as the sensor for regulation of the pump. In this case, " +
                "    EffectiveControlMode will display ConstantPressure, ConstantFlow or ConstantTemperature if the " +
                "    remote sensor is a pressure sensor, a flow sensor or a temperature sensor respectively, " +
                "    regardless of the value of the ControlMode attribute." +
                "\n" +
                "In case the ControlMode attribute is not included on the device and no remote sensors are connected, " +
                "the value of the EffectiveControlMode shall match the vendor-specific behavior of the pump." +
                "\n" +
                "See OperationMode Attribute and ControlMode Attribute for detailed a description of the operation " +
                "and control of the pump."
        }),

        Attribute({
            name: "Capacity", id: 0x13, type: "int16", access: "R V", conformance: "M", default: null,
            quality: "X P", xref: "cluster§4.2.7.17",

            details: "This attribute specifies the actual capacity of the pump as a percentage of the effective maximum " +
                "setpoint value. It is updated dynamically as the speed of the pump changes." +
                "\n" +
                "If the value is not available (the measurement or estimation of the speed is done in the pump), this " +
                "attribute will indicate the null value." +
                "\n" +
                "Valid range is 0 % to 163.835% (0.005 % granularity). Although this attribute is a signed value, " +
                "values of capacity less than zero have no physical meaning."
        }),

        Attribute({
            name: "Speed", id: 0x14, type: "uint16", access: "R V", conformance: "O", default: null,
            quality: "X", xref: "cluster§4.2.7.18",

            details: "This attribute specifies the actual speed of the pump measured in RPM. It is updated dynamically as " +
                "the speed of the pump changes." +
                "\n" +
                "If the value is not available (the measurement or estimation of the speed is done in the pump), this " +
                "attribute will indicate the null value." +
                "\n" +
                "Valid range is 0 to 65,534 RPM."
        }),

        Attribute({
            name: "LifetimeRunningHours", id: 0x15, type: "uint24", access: "RW VM", conformance: "O",
            default: 0, quality: "X N", xref: "cluster§4.2.7.19",

            details: "This attribute specifies the accumulated number of hours that the pump has been powered and the " +
                "motor has been running. It is updated dynamically as it increases. It is preserved over power cycles " +
                "of the pump. If LifeTimeRunningHours rises above maximum value it “rolls over” and starts at 0 " +
                "(zero)." +
                "\n" +
                "This attribute is writeable, in order to allow setting to an appropriate value after maintenance. If " +
                "the value is not available, this attribute will indicate the null value." +
                "\n" +
                "Valid range is 0 to 16,777,214 hrs."
        }),

        Attribute({
            name: "Power", id: 0x16, type: "uint24", access: "R V", conformance: "O", default: null,
            quality: "X", xref: "cluster§4.2.7.20",

            details: "This attribute specifies the actual power consumption of the pump in Watts. The value of this " +
                "attribute is updated dynamically as the power consumption of the pump changes." +
                "\n" +
                "This attribute is read only. If the value is not available (the measurement of power consumption is " +
                "not done in the pump), this attribute will indicate the null value." +
                "\n" +
                "Valid range is 0 to 16,777,214 Watts."
        }),

        Attribute({
            name: "LifetimeEnergyConsumed", id: 0x17, type: "uint32", access: "RW VM", conformance: "O",
            default: 0, quality: "X N", xref: "cluster§4.2.7.21",

            details: "This attribute specifies the accumulated energy consumption of the pump through the entire lifetime " +
                "of the pump in kWh. The value of the LifetimeEnergyConsumed attribute is updated dynamically as the " +
                "energy consumption of the pump increases. If LifetimeEnergyConsumed rises above maximum value it " +
                "“rolls over” and starts at 0 (zero)." +
                "\n" +
                "This attribute is writeable, in order to allow setting to an appropriate value after maintenance. " +
                "Valid range is 0 kWh to 4,294,967,294 kWh." +
                "\n" +
                "Null if the value is unknown."
        }),

        Attribute({
            name: "OperationMode", id: 0x20, type: "OperationModeEnum", access: "RW VM", conformance: "M",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§4.2.7.22",

            details: "This attribute specifies the operation mode of the pump as defined in OperationModeEnum." +
                "\n" +
                "The actual operating mode of the pump is a result of the setting of the attributes OperationMode, " +
                "ControlMode and the optional connection of a remote sensor. The operation and control is prioritized " +
                "as shown in the scheme below:" +
                "\n" +
                "### Priority Scheme of Pump Operation and Control" +
                "\n" +
                "If this attribute is Maximum, Minimum or Local, the OperationMode attribute decides how the pump is " +
                "operated." +
                "\n" +
                "If this attribute is Normal and a remote sensor is connected to the pump, the type of the remote " +
                "sensor decides the control mode of the pump. A connected remote pressure sensor will make the pump " +
                "run in control mode Constant pressure and vice versa for flow and temperature type sensors. This is " +
                "regardless of the setting of the ControlMode attribute." +
                "\n" +
                "If this attribute is Normal and no remote sensor is connected, the control mode of the pump is " +
                "decided by the ControlMode attribute." +
                "\n" +
                "OperationMode may be changed at any time, even when the pump is running. The behavior of the pump at " +
                "the point of changing the value of this attribute is vendor-specific." +
                "\n" +
                "In the case a device does not support a specific operation mode, the write interaction to this " +
                "attribute with an unsupported operation mode value shall be ignored and a response containing the " +
                "status of CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({
            name: "ControlMode", id: 0x21, type: "ControlModeEnum", access: "RW VM", conformance: "O",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§4.2.7.23",

            details: "This attribute specifies the control mode of the pump as defined in ControlModeEnum." +
                "\n" +
                "See OperationMode Attribute for a detailed description of the operation and control of the pump." +
                "\n" +
                "ControlMode may be changed at any time, even when the pump is running. The behavior of the pump at " +
                "the point of changing is vendor-specific." +
                "\n" +
                "In the case a device does not support a specific control mode, the write interaction to this " +
                "attribute with an unsupported control mode value shall be ignored and a response containing the " +
                "status of CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({ name: "AlarmMask", id: 0x22, conformance: "D", xref: "cluster§4.2.7" }),
        Event({ name: "SupplyVoltageLow", id: 0x0, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "SupplyVoltageHigh", id: 0x1, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "PowerMissingPhase", id: 0x2, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "SystemPressureLow", id: 0x3, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "SystemPressureHigh", id: 0x4, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "DryRunning", id: 0x5, access: "V", conformance: "O", priority: "critical", xref: "cluster§4.2.8" }),
        Event({
            name: "MotorTemperatureHigh", id: 0x6, access: "V", conformance: "O", priority: "info",
            xref: "cluster§4.2.8"
        }),
        Event({
            name: "PumpMotorFatalFailure", id: 0x7, access: "V", conformance: "O", priority: "critical",
            xref: "cluster§4.2.8"
        }),
        Event({
            name: "ElectronicTemperatureHigh", id: 0x8, access: "V", conformance: "O", priority: "info",
            xref: "cluster§4.2.8"
        }),
        Event({ name: "PumpBlocked", id: 0x9, access: "V", conformance: "O", priority: "critical", xref: "cluster§4.2.8" }),
        Event({ name: "SensorFailure", id: 0xa, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({
            name: "ElectronicNonFatalFailure", id: 0xb, access: "V", conformance: "O", priority: "info",
            xref: "cluster§4.2.8"
        }),
        Event({
            name: "ElectronicFatalFailure", id: 0xc, access: "V", conformance: "O", priority: "critical",
            xref: "cluster§4.2.8"
        }),
        Event({ name: "GeneralFault", id: 0xd, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "Leakage", id: 0xe, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "AirDetection", id: 0xf, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),
        Event({ name: "TurbineOperation", id: 0x10, access: "V", conformance: "O", priority: "info", xref: "cluster§4.2.8" }),

        Datatype(
            { name: "PumpStatusBitmap", type: "map16", xref: "cluster§4.2.6.1" },
            Field({
                name: "DeviceFault", constraint: "0",
                description: "A fault related to the system or pump device is detected.", xref: "cluster§4.2.6.1.1",
                details: "If this bit is set, it may correspond to an event in the range 2-16, see Events."
            }),
            Field({
                name: "SupplyFault", constraint: "1",
                description: "A fault related to the supply to the pump is detected.", xref: "cluster§4.2.6.1.2",
                details: "If this bit is set, it may correspond to an event in the range 0-1 or 13, see Events."
            }),
            Field({ name: "SpeedLow", constraint: "2", description: "Setpoint is too low to achieve." }),
            Field({ name: "SpeedHigh", constraint: "3", description: "Setpoint is too high to achieve." }),

            Field({
                name: "LocalOverride", constraint: "4",
                description: "Device control is overridden by hardware, such as an external STOP button or via a local HMI.",
                xref: "cluster§4.2.6.1.3",
                details: "While this bit is set, the EffectiveOperationMode is adjusted to Local. Any request changing " +
                    "OperationMode shall generate a FAILURE error status until LocalOverride is cleared on the physical " +
                    "device. When LocalOverride is cleared, the device shall return to the operation mode set in " +
                    "OperationMode."
            }),

            Field({ name: "Running", constraint: "5", description: "Pump is currently running" }),

            Field({
                name: "RemotePressure", constraint: "6",
                description: "A remote pressure sensor is used as the sensor for the regulation of the pump.",
                xref: "cluster§4.2.6.1.4",
                details: "If this bit is set, EffectiveControlMode is ConstantPressure and the setpoint for the pump is " +
                    "interpreted as a percentage of the range of the remote sensor ([MinMeasuredValue – " +
                    "MaxMeasuredValue])."
            }),

            Field({
                name: "RemoteFlow", constraint: "7",
                description: "A remote flow sensor is used as the sensor for the regulation of the pump.",
                xref: "cluster§4.2.6.1.5",
                details: "If this bit is set, EffectiveControlMode is ConstantFlow, and the setpoint for the pump is " +
                    "interpreted as a percentage of the range of the remote sensor ([MinMeasuredValue – " +
                    "MaxMeasuredValue])."
            }),

            Field({
                name: "RemoteTemperature", constraint: "8",
                description: "A remote temperature sensor is used as the sensor for the regulation of the pump.",
                xref: "cluster§4.2.6.1.6",
                details: "If this bit is set, EffectiveControlMode is ConstantTemperature, and the setpoint for the pump is " +
                    "interpreted as a percentage of the range of the remote sensor ([MinMeasuredValue – " +
                    "MaxMeasuredValue])"
            })
        ),

        Datatype(
            { name: "OperationModeEnum", type: "enum8", xref: "cluster§4.2.6.2" },

            Field({
                name: "Normal", id: 0x0, conformance: "M",
                description: "The pump is controlled by a setpoint, as defined by a connected remote sensor or by the ControlMode attribute.",
                xref: "cluster§4.2.6.2.1",
                details: "If the pump is running in this operation mode the setpoint is an internal variable which may be " +
                    "controlled between 0% and 100%, e.g., by means of the Level Control cluster"
            }),

            Field({
                name: "Minimum", id: 0x1, conformance: "SPD",
                description: "This value sets the pump to run at the minimum possible speed it can without being stopped."
            }),
            Field({
                name: "Maximum", id: 0x2, conformance: "SPD",
                description: "This value sets the pump to run at its maximum possible speed."
            }),
            Field({
                name: "Local", id: 0x3, conformance: "LOCAL",
                description: "This value sets the pump to run with the local settings of the pump, regardless of what these are."
            })
        ),

        Datatype(
            { name: "ControlModeEnum", type: "enum8", xref: "cluster§4.2.6.3" },

            Field({
                name: "ConstantSpeed", id: 0x0, conformance: "SPD",
                description: "The pump is running at a constant speed.", xref: "cluster§4.2.6.3.1",
                details: "The setpoint is interpreted as a percentage of the range derived from the [MinConstSpeed – " +
                    "MaxConstSpeed] attributes."
            }),

            Field({
                name: "ConstantPressure", id: 0x1, conformance: "PRSCONST",
                description: "The pump will regulate its speed to maintain a constant differential pressure over its flanges.",
                xref: "cluster§4.2.6.3.2",
                details: "The setpoint is interpreted as a percentage of the range of the sensor used for this control mode. " +
                    "In case of the internal pressure sensor, this will be the range derived from the [MinConstPressure – " +
                    "MaxConstPressure] attributes. In case of a remote pressure sensor, this will be the range derived " +
                    "from the [MinMeasuredValue – MaxMeasuredValue] attributes of the remote pressure sensor."
            }),

            Field({
                name: "ProportionalPressure", id: 0x2, conformance: "PRSCOMP",
                description: "The pump will regulate its speed to maintain a constant differential pressure over its flanges.",
                xref: "cluster§4.2.6.3.3",
                details: "The setpoint is interpreted as a percentage of the range derived of the [MinCompPressure – Max " +
                    "CompPressure] attributes. The internal setpoint will be lowered (compensated) dependent on the flow " +
                    "in the pump (lower flow ⇒ lower internal setpoint)."
            }),

            Field({
                name: "ConstantFlow", id: 0x3, conformance: "FLW",
                description: "The pump will regulate its speed to maintain a constant flow through the pump.",
                xref: "cluster§4.2.6.3.4",
                details: "The setpoint is interpreted as a percentage of the range of the sensor used for this control mode. " +
                    "In case of the internal flow sensor, this will be the range derived from the [MinConstFlow – " +
                    "MaxConstFlow] attributes. In case of a remote flow sensor, this will be the range derived from the " +
                    "[MinMeasuredValue – MaxMeasuredValue] attributes of the remote flow sensor."
            }),

            Field({
                name: "ConstantTemperature", id: 0x5, conformance: "TEMP",
                description: "The pump will regulate its speed to maintain a constant temperature.",
                xref: "cluster§4.2.6.3.5",
                details: "The setpoint is interpreted as a percentage of the range of the sensor used for this control mode. " +
                    "In case of the internal temperature sensor, this will be the range derived from the [MinConstTemp – " +
                    "MaxConstTemp] attributes. In case of a remote temperature sensor, this will be the range derived " +
                    "from the [MinMeasuredValue – MaxMeasuredValue] attributes of the remote temperature sensor."
            }),

            Field({
                name: "Automatic", id: 0x7, conformance: "AUTO",
                description: "The operation of the pump is automatically optimized to provide the most suitable performance with respect to comfort and energy savings.",
                xref: "cluster§4.2.6.3.6",
                details: "This behavior is manufacturer defined. The pump can be stopped by setting the setpoint of the level " +
                    "control cluster to 0, or by using the On/Off cluster. If the pump is started (at any setpoint), the " +
                    "speed of the pump is entirely determined by the pump."
            })
        )
    ),

    Cluster(
        {
            name: "Thermostat", id: 0x201, classification: "application", pics: "TSTAT", xref: "cluster§4.3",
            details: "This cluster provides an interface to the functionality of a thermostat."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 9 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§4.3.4" },
            Field({
                name: "HEAT", conformance: "AUTO, O.a+", constraint: "0", title: "Heating",
                details: "Thermostat is capable of managing a heating device"
            }),
            Field({
                name: "COOL", conformance: "AUTO, O.a+", constraint: "1", title: "Cooling",
                details: "Thermostat is capable of managing a cooling device"
            }),
            Field({
                name: "OCC", conformance: "O", constraint: "2", title: "Occupancy",
                details: "Supports Occupied and Unoccupied setpoints"
            }),
            Field({
                name: "SCH", conformance: "O", constraint: "3", title: "ScheduleConfiguration",
                details: "Supports remote configuration of a weekly schedule of setpoint transitions"
            }),
            Field({
                name: "SB", conformance: "O", constraint: "4", title: "Setback",
                details: "Supports configurable setback (or span)"
            }),
            Field({
                name: "AUTO", conformance: "O", constraint: "5", title: "AutoMode",
                details: "Supports a System Mode of Auto"
            }),

            Field({
                name: "LTNE", conformance: "O", constraint: "6", title: "LocalTemperatureNotExposed",
                xref: "cluster§4.3.4.1",
                details: "This feature indicates that the Calculated Local Temperature used internally is unavailable to " +
                    "report externally, for example due to the temperature control being done by a separate subsystem " +
                    "which does not offer a view into the currently measured temperature, but allows setpoints to be " +
                    "provided."
            }),

            Field({
                name: "MSCH", conformance: "O", constraint: "7", title: "MatterScheduleConfiguration",
                xref: "cluster§4.3.4.2",
                details: "This feature indicates that the thermostat is capable of schedules. If this feature is supported, " +
                    "the thermostat shall support a mechanism to do time synchronization."
            }),

            Field({
                name: "PRES", conformance: "O", constraint: "8", title: "Presets",
                details: "Thermostat supports setpoint presets"
            })
        ),

        Attribute({
            name: "LocalTemperature", id: 0x0, type: "temperature", access: "R V", conformance: "M",
            quality: "X P", xref: "cluster§4.3.9.2",

            details: "Indicates the current Calculated Local Temperature, when available." +
                "\n" +
                "  • If the LTNE feature is not supported:" +
                "\n" +
                "    ◦ If the LocalTemperatureCalibration is invalid or currently unavailable, the attribute shall " +
                "      report null." +
                "\n" +
                "    ◦ If the LocalTemperatureCalibration is valid, the attribute shall report that value." +
                "\n" +
                "  • Otherwise, if the LTNE feature is supported, there is no feedback externally available for the " +
                "    LocalTemperatureCalibration. In that case, the LocalTemperature attribute shall always report " +
                "    null."
        }),

        Attribute({
            name: "OutdoorTemperature", id: 0x1, type: "temperature", access: "R V", conformance: "O",
            default: null, quality: "X", xref: "cluster§4.3.9.3",
            details: "Indicates the outdoor temperature, as measured locally or remotely (over the network)."
        }),

        Attribute({
            name: "Occupancy", id: 0x2, type: "OccupancyBitmap", access: "R V", conformance: "OCC", default: 1,
            xref: "cluster§4.3.9.4",
            details: "Indicates whether the heated/cooled space is occupied or not, as measured locally or remotely (over " +
                "the network)."
        }),

        Attribute({
            name: "AbsMinHeatSetpointLimit", id: 0x3, type: "temperature", access: "R V", conformance: "[HEAT]",
            constraint: "desc", default: { type: "celsius", value: 7 }, quality: "F", xref: "cluster§4.3.9.5",
            details: "Indicates the absolute minimum level that the heating setpoint may be set to. This is a limitation " +
                "imposed by the manufacturer." +
                "\n" +
                "### Refer to Setpoint Limits for constraints"
        }),

        Attribute({
            name: "AbsMaxHeatSetpointLimit", id: 0x4, type: "temperature", access: "R V", conformance: "[HEAT]",
            constraint: "desc", default: { type: "celsius", value: 30 }, quality: "F", xref: "cluster§4.3.9"
        }),
        Attribute({
            name: "AbsMinCoolSetpointLimit", id: 0x5, type: "temperature", access: "R V", conformance: "[COOL]",
            constraint: "desc", default: { type: "celsius", value: 16 }, quality: "F", xref: "cluster§4.3.9"
        }),

        Attribute({
            name: "AbsMaxCoolSetpointLimit", id: 0x6, type: "temperature", access: "R V", conformance: "[COOL]",
            constraint: "desc", default: { type: "celsius", value: 32 }, quality: "F", xref: "cluster§4.3.9.8",
            details: "Indicates the absolute maximum level that the cooling setpoint may be set to. This is a limitation " +
                "imposed by the manufacturer." +
                "\n" +
                "### Refer to Setpoint Limits for constraints"
        }),

        Attribute({
            name: "PiCoolingDemand", id: 0x7, type: "uint8", access: "R V", conformance: "[COOL]",
            constraint: "0% to 100%", quality: "P", xref: "cluster§4.3.9.9",
            details: "Indicates the level of cooling demanded by the PI (proportional integral) control loop in use by the " +
                "thermostat (if any), in percent. This value is 0 when the thermostat is in “off” or “heating” mode." +
                "\n" +
                "This attribute is reported regularly and may be used to control a cooling device."
        }),

        Attribute({
            name: "PiHeatingDemand", id: 0x8, type: "uint8", access: "R V", conformance: "[HEAT]",
            constraint: "0% to 100%", quality: "P", xref: "cluster§4.3.9.10",
            details: "Indicates the level of heating demanded by the PI loop in percent. This value is 0 when the " +
                "thermostat is in “off” or “cooling” mode." +
                "\n" +
                "This attribute is reported regularly and may be used to control a heating device."
        }),

        Attribute({
            name: "HvacSystemTypeConfiguration", id: 0x9, type: "HVACSystemTypeBitmap", access: "R[W] VM",
            conformance: "D", constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.11",
            details: "Indicates the HVAC system type controlled by the thermostat. If the thermostat uses physical DIP " +
                "switches to set these parameters, this information shall be available read-only from the DIP " +
                "switches. If these parameters are set via software, there shall be read/write access in order to " +
                "provide remote programming capability."
        }),

        Attribute({
            name: "LocalTemperatureCalibration", id: 0x10, type: "SignedTemperature", access: "RW VM",
            conformance: "[!LTNE]", default: { type: "celsius", value: 0 }, quality: "N",
            xref: "cluster§4.3.9.12",

            details: "Indicates the offset the Thermostat server shall make to the measured temperature (locally or " +
                "remotely) to adjust the Calculated Local Temperature prior to using, displaying or reporting it." +
                "\n" +
                "The purpose of this attribute is to adjust the calibration of the Thermostat server per the user’s " +
                "preferences (e.g., to match if there are multiple servers displaying different values for the same " +
                "HVAC area) or compensate for variability amongst temperature sensors." +
                "\n" +
                "If a Thermostat client attempts to write LocalTemperatureCalibration attribute to an unsupported " +
                "value (e.g., out of the range supported by the Thermostat server), the Thermostat server shall " +
                "respond with a status of SUCCESS and set the value of LocalTemperatureCalibration to the upper or " +
                "lower limit reached." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Prior to revision 8 of this cluster specification the value of this attribute was constrained to a " +
                "  range of -2.5°C to 2.5°C."
        }),

        Attribute({
            name: "OccupiedCoolingSetpoint", id: 0x11, type: "temperature", access: "RW VO",
            conformance: "COOL", constraint: "desc", default: { type: "celsius", value: 26 }, quality: "N",
            xref: "cluster§4.3.9.13",

            details: "Indicates the cooling mode setpoint when the room is occupied. Refer to Setpoint Limits for " +
                "constraints." +
                "\n" +
                "If an attempt is made to set this attribute to a value greater than MaxCoolSetpointLimit or less " +
                "than MinCoolSetpointLimit, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If this attribute is set to a value that is less than (OccupiedHeatingSetpoint + " +
                "MinSetpointDeadBand), the value of OccupiedHeatingSetpoint shall be adjusted to " +
                "(OccupiedCoolingSetpoint - MinSetpointDeadBand)." +
                "\n" +
                "If the occupancy status of the room is unknown, this attribute shall be used as the cooling mode " +
                "setpoint." +
                "\n" +
                "If a client changes the value of this attribute, the server supports the PRES feature, and the " +
                "server either does not support the OCC feature or the Occupied bit is set on the Occupancy " +
                "attribute, the value of the ActivePresetHandle attribute shall be set to null."
        }),

        Attribute({
            name: "OccupiedHeatingSetpoint", id: 0x12, type: "temperature", access: "RW VO",
            conformance: "HEAT", constraint: "desc", default: { type: "celsius", value: 20 }, quality: "N",
            xref: "cluster§4.3.9.14",

            details: "Indicates the heating mode setpoint when the room is occupied. Refer to Setpoint Limits for " +
                "constraints." +
                "\n" +
                "If an attempt is made to set this attribute to a value greater than MaxHeatSetpointLimit or less " +
                "than MinHeatSetpointLimit, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If this attribute is set to a value that is greater than (OccupiedCoolingSetpoint - " +
                "MinSetpointDeadBand), the value of OccupiedCoolingSetpoint shall be adjusted to " +
                "(OccupiedHeatingSetpoint + MinSetpointDeadBand)." +
                "\n" +
                "If the occupancy status of the room is unknown, this attribute shall be used as the heating mode " +
                "setpoint." +
                "\n" +
                "If a client changes the value of this attribute, the server supports the PRES feature, and the " +
                "server either does not support the OCC feature or the Occupied bit is set on the Occupancy " +
                "attribute, the value of the ActivePresetHandle attribute shall be set to null."
        }),

        Attribute({
            name: "UnoccupiedCoolingSetpoint", id: 0x13, type: "temperature", access: "RW VO",
            conformance: "COOL & OCC", constraint: "desc", default: { type: "celsius", value: 26 },
            quality: "N", xref: "cluster§4.3.9.15",

            details: "Indicates the cooling mode setpoint when the room is unoccupied. Refer to Setpoint Limits for " +
                "constraints." +
                "\n" +
                "If an attempt is made to set this attribute to a value greater than MaxCoolSetpointLimit or less " +
                "than MinCoolSetpointLimit, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If this attribute is set to a value that is less than (UnoccupiedHeatingSetpoint + " +
                "MinSetpointDeadBand), the value of UnoccupiedHeatingSetpoint shall be adjusted to " +
                "(UnoccupiedCoolingSetpoint - MinSetpointDeadBand)." +
                "\n" +
                "If the occupancy status of the room is unknown, this attribute shall NOT be used." +
                "\n" +
                "If a client changes the value of this attribute, the server supports the PRES and OCC features, and " +
                "the Occupied bit is not set on the Occupancy attribute, the value of the ActivePresetHandle " +
                "attribute shall be set to null."
        }),

        Attribute({
            name: "UnoccupiedHeatingSetpoint", id: 0x14, type: "temperature", access: "RW VO",
            conformance: "HEAT & OCC", constraint: "desc", default: { type: "celsius", value: 20 },
            quality: "N", xref: "cluster§4.3.9.16",

            details: "Indicates the heating mode setpoint when the room is unoccupied. Refer to Setpoint Limits for " +
                "constraints." +
                "\n" +
                "If an attempt is made to set this attribute to a value greater than MaxHeatSetpointLimit or less " +
                "than MinHeatSetpointLimit, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If this attribute is set to a value that is greater than (UnoccupiedCoolingSetpoint - " +
                "MinSetpointDeadBand), the value of UnoccupiedCoolingSetpoint shall be adjusted to" +
                "\n" +
                "+ MinSetpointDeadBand)." +
                "\n" +
                "If the occupancy status of the room is unknown, this attribute shall NOT be used." +
                "\n" +
                "If a client changes the value of this attribute, the server supports the PRES and OCC features, and " +
                "the Occupied bit is not set on the Occupancy attribute, the value of the ActivePresetHandle " +
                "attribute shall be set to null."
        }),

        Attribute({
            name: "MinHeatSetpointLimit", id: 0x15, type: "temperature", access: "RW VM", conformance: "[HEAT]",
            constraint: "desc", default: { type: "reference", name: "AbsMinHeatSetpointLimit" }, quality: "N",
            xref: "cluster§4.3.9.17",

            details: "Indicates the minimum level that the heating setpoint may be set to." +
                "\n" +
                "This attribute, and the following three attributes, allow the user to define setpoint limits more " +
                "constrictive than the manufacturer imposed ones. Limiting users (e.g., in a commercial building) to " +
                "such setpoint limits can help conserve power." +
                "\n" +
                "Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value " +
                "which conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to " +
                "permit this attribute to be set to the desired value. If an attempt is made to set this attribute to " +
                "a value which is not consistent with the constraints and cannot be resolved by modifying setpoints " +
                "then a response with the status code CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({
            name: "MaxHeatSetpointLimit", id: 0x16, type: "temperature", access: "RW VM", conformance: "[HEAT]",
            constraint: "desc", default: { type: "reference", name: "AbsMaxHeatSetpointLimit" }, quality: "N",
            xref: "cluster§4.3.9.18",

            details: "Indicates the maximum level that the heating setpoint may be set to." +
                "\n" +
                "Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value " +
                "which conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to " +
                "permit this attribute to be set to the desired value. If an attempt is made to set this attribute to " +
                "a value which is not consistent with the constraints and cannot be resolved by modifying setpoints " +
                "then a response with the status code CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({
            name: "MinCoolSetpointLimit", id: 0x17, type: "temperature", access: "RW VM", conformance: "[COOL]",
            constraint: "desc", default: { type: "reference", name: "AbsMinCoolSetpointLimit" }, quality: "N",
            xref: "cluster§4.3.9.19",

            details: "Indicates the minimum level that the cooling setpoint may be set to." +
                "\n" +
                "Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value " +
                "which conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to " +
                "permit this attribute to be set to the desired value. If an attempt is made to set this attribute to " +
                "a value which is not consistent with the constraints and cannot be resolved by modifying setpoints " +
                "then a response with the status code CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({
            name: "MaxCoolSetpointLimit", id: 0x18, type: "temperature", access: "RW VM", conformance: "[COOL]",
            constraint: "desc", default: { type: "reference", name: "AbsMaxCoolSetpointLimit" }, quality: "N",
            xref: "cluster§4.3.9.20",

            details: "Indicates the maximum level that the cooling setpoint may be set to." +
                "\n" +
                "Refer to Setpoint Limits for constraints. If an attempt is made to set this attribute to a value " +
                "which conflicts with setpoint values then those setpoints shall be adjusted by the minimum amount to " +
                "permit this attribute to be set to the desired value. If an attempt is made to set this attribute to " +
                "a value which is not consistent with the constraints and cannot be resolved by modifying setpoints " +
                "then a response with the status code CONSTRAINT_ERROR shall be returned."
        }),

        Attribute({
            name: "MinSetpointDeadBand", id: 0x19, type: "SignedTemperature", access: "R[W] VM",
            conformance: "AUTO", constraint: "0 to 12.7°C", default: { type: "celsius", value: 2 },
            quality: "N", xref: "cluster§4.3.9.21",

            details: "On devices which support the AUTO feature, this attribute shall indicate the minimum difference " +
                "between the Heat Setpoint and the Cool Setpoint." +
                "\n" +
                "Refer to Setpoint Limits for constraints." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Prior to revision 8 of this cluster specification the value of this attribute was constrained to a " +
                "  range of 0°C to 2.5°C." +
                "\n" +
                "For backwards compatibility, this attribute is optionally writeable. However any writes to this " +
                "attribute shall be silently ignored."
        }),

        Attribute({
            name: "RemoteSensing", id: 0x1a, type: "RemoteSensingBitmap", access: "RW VM", conformance: "O",
            default: 0, quality: "N", xref: "cluster§4.3.9.22",

            details: "Indicates when the local temperature, outdoor temperature and occupancy are being sensed by remote " +
                "networked sensors, rather than internal sensors." +
                "\n" +
                "If the LTNE feature is present in the server, the LocalTemperature RemoteSensing bit value shall " +
                "always report a value of 0." +
                "\n" +
                "If the LocalTemperature RemoteSensing bit is written with a value of 1 when the LTNE feature is " +
                "present, the write shall fail and the server shall report a CONSTRAINT_ERROR."
        }),

        Attribute({
            name: "ControlSequenceOfOperation", id: 0x1b, type: "ControlSequenceOfOperationEnum",
            access: "RW VM", conformance: "M", constraint: "desc", quality: "N", xref: "cluster§4.3.9.23",

            details: "Indicates the overall operating environment of the thermostat, and thus the possible system modes " +
                "that the thermostat can operate in." +
                "\n" +
                "If an attempt is made to write to this attribute, the server shall silently ignore the write and the " +
                "value of this attribute shall remain unchanged. This behavior is in place for backwards " +
                "compatibility with existing thermostats."
        }),

        Attribute({
            name: "SystemMode", id: 0x1c, type: "SystemModeEnum", access: "RW VM", conformance: "M",
            constraint: "desc", quality: "N", xref: "cluster§4.3.9.24",
            details: "Indicates the current operating mode of the thermostat. Its value shall be limited by the " +
                "ControlSequenceOfOperation attribute."
        }),

        Attribute({
            name: "ThermostatRunningMode", id: 0x1e, type: "ThermostatRunningModeEnum", access: "R V",
            conformance: "[AUTO]", constraint: "desc", default: 0, xref: "cluster§4.3.9.25",
            details: "Indicates the running mode of the thermostat. This attribute uses the same values as SystemModeEnum " +
                "but can only be Off, Cool or Heat. This attribute is intended to provide additional information when " +
                "the thermostat’s system mode is in auto mode."
        }),

        Attribute({
            name: "StartOfWeek", id: 0x20, type: "StartOfWeekEnum", access: "R V", conformance: "SCH",
            constraint: "desc", quality: "F", xref: "cluster§4.3.9.26",

            details: "Indicates the day of the week that this thermostat considers to be the start of week for weekly " +
                "setpoint scheduling." +
                "\n" +
                "This attribute may be able to be used as the base to determine if the device supports weekly " +
                "scheduling by reading the attribute. Successful response means that the weekly scheduling is " +
                "supported."
        }),

        Attribute({
            name: "NumberOfWeeklyTransitions", id: 0x21, type: "uint8", access: "R V", conformance: "SCH",
            default: 0, quality: "F", xref: "cluster§4.3.9.27",
            details: "Indicates how many weekly schedule transitions the thermostat is capable of handling."
        }),
        Attribute({
            name: "NumberOfDailyTransitions", id: 0x22, type: "uint8", access: "R V", conformance: "SCH",
            default: 0, quality: "F", xref: "cluster§4.3.9.28",
            details: "Indicates how many daily schedule transitions the thermostat is capable of handling."
        }),

        Attribute({
            name: "TemperatureSetpointHold", id: 0x23, type: "TemperatureSetpointHoldEnum", access: "RW VM",
            conformance: "O", constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.29",

            details: "Indicates the temperature hold status on the thermostat. If hold status is on, the thermostat SHOULD " +
                "maintain the temperature setpoint for the current mode until a system mode change. If hold status is " +
                "off, the thermostat SHOULD follow the setpoint transitions specified by its internal scheduling " +
                "program. If the thermostat supports setpoint hold for a specific duration, it SHOULD also implement " +
                "the TemperatureSetpointHoldDuration attribute." +
                "\n" +
                "If the server supports a setpoint hold for a specific duration, it SHOULD also implement the " +
                "SetpointHoldExpiryTimestamp attribute." +
                "\n" +
                "If this attribute is updated to SetpointHoldOn and the TemperatureSetpointHoldDuration has a " +
                "non-null value and the SetpointHoldExpiryTimestamp is supported, the server shall update the " +
                "SetpointHoldExpiryTimestamp with a value of current UTC timestamp, in seconds, plus the value in " +
                "TemperatureSetpointHoldDuration multiplied by 60." +
                "\n" +
                "If this attribute is updated to SetpointHoldOff and the SetpointHoldExpiryTimestamp is supported, " +
                "the server shall set the SetpointHoldExpiryTimestamp to null."
        }),

        Attribute({
            name: "TemperatureSetpointHoldDuration", id: 0x24, type: "uint16", access: "RW VM",
            conformance: "O", constraint: "max 1440", default: null, quality: "X N", xref: "cluster§4.3.9.30",

            details: "Indicates the period in minutes for which a setpoint hold is active. Thermostats that support hold " +
                "for a specified duration SHOULD implement this attribute. The null value indicates the field is " +
                "unused. All other values are reserved." +
                "\n" +
                "If this attribute is updated to a non-null value and the TemperatureSetpointHold is set to " +
                "SetpointHoldOn and the SetpointHoldExpiryTimestamp is supported, the server shall update " +
                "SetpointHoldExpiryTimestamp with a value of current UTC timestamp, in seconds, plus the new value of " +
                "this attribute multiplied by 60." +
                "\n" +
                "If this attribute is set to null and the SetpointHoldExpiryTimestamp is supported, the server shall " +
                "set the SetpointHoldExpiryTimestamp to null."
        }),

        Attribute({
            name: "ThermostatProgrammingOperationMode", id: 0x25, type: "ProgrammingOperationModeBitmap",
            access: "RW VM", conformance: "O", constraint: "desc", default: 0, quality: "P",
            xref: "cluster§4.3.9.31",

            details: "Indicates the operational state of the thermostat’s programming. The thermostat shall modify its " +
                "programming operation when this attribute is modified by a client and update this attribute when its " +
                "programming operation is modified locally by a user. The thermostat may support more than one active " +
                "ProgrammingOperationModeBitmap. For example, the thermostat may operate simultaneously in Schedule " +
                "Programming Mode and Recovery Mode." +
                "\n" +
                "Thermostats which contain a schedule may use this attribute to control how that schedule is used, " +
                "even if they do not support the ScheduleConfiguration feature." +
                "\n" +
                "When ScheduleActive is not set, the setpoint is altered only by manual up/down changes at the " +
                "thermostat or remotely, not by internal schedule programming." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Modifying the ScheduleActive bit does not clear or delete previous weekly schedule programming " +
                "  configurations."
        }),

        Attribute({
            name: "ThermostatRunningState", id: 0x29, type: "RelayStateBitmap", access: "R V", conformance: "O",
            constraint: "desc", xref: "cluster§4.3.9.32",
            details: "Indicates the current relay state of the heat, cool, and fan relays. Unimplemented outputs shall be " +
                "treated as if they were Off."
        }),

        Attribute({
            name: "SetpointChangeSource", id: 0x30, type: "SetpointChangeSourceEnum", access: "R V",
            conformance: "O", constraint: "desc", default: 0, xref: "cluster§4.3.9.33",

            details: "Indicates the source of the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint (i.e., " +
                "who or what determined the current setpoint)." +
                "\n" +
                "This attribute enables service providers to determine whether changes to setpoints were initiated " +
                "due to occupant comfort, scheduled programming or some other source (e.g., electric utility or other " +
                "service provider). Because automation services may initiate frequent setpoint changes, this " +
                "attribute clearly differentiates the source of setpoint changes made at the thermostat."
        }),

        Attribute({
            name: "SetpointChangeAmount", id: 0x31, type: "TemperatureDifference", access: "R V",
            conformance: "O", default: null, quality: "X", xref: "cluster§4.3.9.34",
            details: "Indicates the delta between the current active OccupiedCoolingSetpoint or OccupiedHeatingSetpoint " +
                "and the previous active setpoint. This attribute is meant to accompany the SetpointChangeSource " +
                "attribute; devices implementing SetpointChangeAmount SHOULD also implement SetpointChangeSource." +
                "\n" +
                "The null value indicates that the previous setpoint was unknown."
        }),

        Attribute({
            name: "SetpointChangeSourceTimestamp", id: 0x32, type: "epoch-s", access: "R V", conformance: "O",
            default: 0, xref: "cluster§4.3.9.35",
            details: "Indicates the time in UTC at which the SetpointChangeAmount attribute change was recorded."
        }),

        Attribute({
            name: "OccupiedSetback", id: 0x34, type: "UnsignedTemperature", access: "RW VM", conformance: "SB",
            constraint: "occupiedSetbackMin to occupiedSetbackMax", default: null, quality: "X N",
            xref: "cluster§4.3.9.36",

            details: "Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float " +
                "above the OccupiedCoolingSetpoint (i.e., OccupiedCoolingSetpoint + OccupiedSetback) or below the " +
                "OccupiedHeatingSetpoint setpoint (i.e., OccupiedHeatingSetpoint – OccupiedSetback) before initiating " +
                "a state change to bring the temperature back to the user’s desired setpoint. This attribute is " +
                "sometimes also referred to as the “span.”" +
                "\n" +
                "The purpose of this attribute is to allow remote configuration of the span between the desired " +
                "setpoint and the measured temperature to help prevent over-cycling and reduce energy bills, though " +
                "this may result in lower comfort on the part of some users." +
                "\n" +
                "The null value indicates the attribute is unused." +
                "\n" +
                "If the Thermostat client attempts to write OccupiedSetback to a value greater than " +
                "OccupiedSetbackMax, the Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMax " +
                "and shall send a Write Attribute Response command with a Status Code field enumeration of SUCCESS " +
                "response." +
                "\n" +
                "If the Thermostat client attempts to write OccupiedSetback to a value less than OccupiedSetbackMin, " +
                "the Thermostat server shall set its OccupiedSetback value to OccupiedSetbackMin and shall send a " +
                "Write Attribute Response command with a Status Code field enumeration of SUCCESS response."
        }),

        Attribute({
            name: "OccupiedSetbackMin", id: 0x35, type: "UnsignedTemperature", access: "R V", conformance: "SB",
            constraint: "max occupiedSetbackMax", default: null, quality: "X F", xref: "cluster§4.3.9.37",
            details: "Indicates the minimum value that the Thermostat server will allow the OccupiedSetback attribute to " +
                "be configured by a user." +
                "\n" +
                "The null value indicates the attribute is unused."
        }),

        Attribute({
            name: "OccupiedSetbackMax", id: 0x36, type: "UnsignedTemperature", access: "R V", conformance: "SB",
            constraint: "occupiedSetbackMin to 25.4°C", default: null, quality: "X F", xref: "cluster§4.3.9.38",
            details: "Indicates the maximum value that the Thermostat server will allow the OccupiedSetback attribute to " +
                "be configured by a user." +
                "\n" +
                "The null value indicates the attribute is unused."
        }),

        Attribute({
            name: "UnoccupiedSetback", id: 0x37, type: "UnsignedTemperature", access: "RW VM",
            conformance: "SB & OCC", constraint: "unoccupiedSetbackMin to unoccupiedSetbackMax", default: null,
            quality: "X N", xref: "cluster§4.3.9.39",

            details: "Indicates the amount that the Thermostat server will allow the Calculated Local Temperature to float " +
                "above the UnoccupiedCoolingSetpoint (i.e., UnoccupiedCoolingSetpoint + UnoccupiedSetback) or below " +
                "the UnoccupiedHeatingSetpoint setpoint (i.e., UnoccupiedHeatingSetpoint - UnoccupiedSetback) before " +
                "initiating a state change to bring the temperature back to the user’s desired setpoint. This " +
                "attribute is sometimes also referred to as the “span.”" +
                "\n" +
                "The purpose of this attribute is to allow remote configuration of the span between the desired " +
                "setpoint and the measured temperature to help prevent over-cycling and reduce energy bills, though " +
                "this may result in lower comfort on the part of some users." +
                "\n" +
                "The null value indicates the attribute is unused." +
                "\n" +
                "If the Thermostat client attempts to write UnoccupiedSetback to a value greater than " +
                "UnoccupiedSetbackMax, the Thermostat server shall set its UnoccupiedSetback value to " +
                "UnoccupiedSetbackMax and shall send a Write Attribute Response command with a Status Code field " +
                "enumeration of SUCCESS response." +
                "\n" +
                "If the Thermostat client attempts to write UnoccupiedSetback to a value less than " +
                "UnoccupiedSetbackMin, the Thermostat server shall set its UnoccupiedSetback value to " +
                "UnoccupiedSetbackMin and shall send a Write Attribute Response command with a Status Code field " +
                "enumeration of SUCCESS response."
        }),

        Attribute({
            name: "UnoccupiedSetbackMin", id: 0x38, type: "UnsignedTemperature", access: "R V",
            conformance: "SB & OCC", constraint: "max unoccupiedSetbackMax", default: null, quality: "X F",
            xref: "cluster§4.3.9.40",
            details: "Indicates the minimum value that the Thermostat server will allow the UnoccupiedSetback attribute to " +
                "be configured by a user." +
                "\n" +
                "The null value indicates the attribute is unused."
        }),

        Attribute({
            name: "UnoccupiedSetbackMax", id: 0x39, type: "UnsignedTemperature", access: "R V",
            conformance: "SB & OCC", constraint: "unoccupiedSetbackMin to 25.4°C", default: null,
            quality: "X F", xref: "cluster§4.3.9.41",
            details: "Indicates the maximum value that the Thermostat server will allow the UnoccupiedSetback attribute to " +
                "be configured by a user." +
                "\n" +
                "The null value indicates the attribute is unused."
        }),

        Attribute(
            {
                name: "EmergencyHeatDelta", id: 0x3a, type: "UnsignedTemperature", access: "RW VM",
                conformance: "O", default: { type: "celsius", value: 25 }, quality: "N", xref: "cluster§4.3.9.42",

                details: "Indicates the delta between the Calculated Local Temperature and the OccupiedHeatingSetpoint or " +
                    "UnoccupiedHeatingSetpoint attributes at which the Thermostat server will operate in emergency heat " +
                    "mode." +
                    "\n" +
                    "If the difference between the Calculated Local Temperature and OccupiedCoolingSetpoint or " +
                    "UnoccupiedCoolingSetpoint is greater than or equal to the EmergencyHeatDelta and the Thermostat " +
                    "server’s SystemMode attribute is in a heating-related mode, then the Thermostat server shall " +
                    "immediately switch to the SystemMode attribute value that provides the highest stage of heating " +
                    "(e.g., emergency heat) and continue operating in that running state until the " +
                    "OccupiedHeatingSetpoint value is reached. For example:" +
                    "\n" +
                    "  • Calculated Local Temperature = 10.0°C" +
                    "\n" +
                    "  • OccupiedHeatingSetpoint = 16.0°C" +
                    "\n" +
                    "  • EmergencyHeatDelta = 2.0°C" +
                    "\n" +
                    "⇒ OccupiedHeatingSetpoint - Calculated Local Temperature ≥? EmergencyHeatDelta" +
                    "\n" +
                    "⇒ 16°C - 10°C ≥? 2°C" +
                    "\n" +
                    "⇒ TRUE >>> Thermostat server changes its SystemMode to operate in 2nd stage or emergency heat mode" +
                    "\n" +
                    "The purpose of this attribute is to provide Thermostat clients the ability to configure rapid " +
                    "heating when a setpoint is of a specified amount greater than the measured temperature. This allows " +
                    "the heated space to be quickly heated to the desired level set by the user."
            }
        ),

        Attribute({
            name: "AcType", id: 0x40, type: "ACTypeEnum", access: "RW VM", conformance: "O", constraint: "desc",
            default: 0, quality: "N", xref: "cluster§4.3.9.43",
            details: "Indicates the type of Mini Split ACTypeEnum of Mini Split AC is defined depending on how Cooling and " +
                "Heating condition is achieved by Mini Split AC."
        }),

        Attribute({
            name: "AcCapacity", id: 0x41, type: "uint16", access: "RW VM", conformance: "O", default: 0,
            quality: "N", xref: "cluster§4.3.9.44",
            details: "Indicates capacity of Mini Split AC in terms of the format defined by the ACCapacityFormat attribute"
        }),
        Attribute({
            name: "AcRefrigerantType", id: 0x42, type: "ACRefrigerantTypeEnum", access: "RW VM",
            conformance: "O", constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.45",
            details: "Indicates type of refrigerant used within the Mini Split AC."
        }),
        Attribute({
            name: "AcCompressorType", id: 0x43, type: "ACCompressorTypeEnum", access: "RW VM", conformance: "O",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.46",
            details: "Indicates the type of compressor used within the Mini Split AC."
        }),
        Attribute({
            name: "AcErrorCode", id: 0x44, type: "ACErrorCodeBitmap", access: "RW VM", conformance: "O",
            default: 0, xref: "cluster§4.3.9.47",
            details: "Indicates the type of errors encountered within the Mini Split AC."
        }),
        Attribute({
            name: "AcLouverPosition", id: 0x45, type: "ACLouverPositionEnum", access: "RW VM", conformance: "O",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.48",
            details: "Indicates the position of Louver on the AC."
        }),
        Attribute({
            name: "AcCoilTemperature", id: 0x46, type: "temperature", access: "R V", conformance: "O",
            default: null, quality: "X", xref: "cluster§4.3.9.49",
            details: "Indicates the temperature of the AC coil, as measured locally or remotely (over the network)."
        }),
        Attribute({
            name: "AcCapacityFormat", id: 0x47, type: "ACCapacityFormatEnum", access: "RW VM", conformance: "O",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§4.3.9.50",
            details: "Indicates the format for the ACCapacity attribute."
        }),

        Attribute(
            {
                name: "PresetTypes", id: 0x48, type: "list", access: "R V", conformance: "PRES", constraint: "desc",
                quality: "F", xref: "cluster§4.3.9.51",
                details: "Indicates the supported PresetScenarioEnum values, limits on how many presets can be created for " +
                    "each PresetScenarioEnum, and whether or not a thermostat can transition automatically to a given " +
                    "scenario."
            },

            Field({ name: "entry", type: "PresetTypeStruct" })
        ),

        Attribute(
            {
                name: "ScheduleTypes", id: 0x49, type: "list", access: "R V", conformance: "MSCH",
                constraint: "desc", quality: "F", xref: "cluster§4.3.9.52",
                details: "Indicates the supported SystemMode values for Schedules, limits on how many schedules can be created " +
                    "for each SystemMode value, and whether or not a given SystemMode value supports transitions to " +
                    "Presets, target setpoints, or both."
            },

            Field({ name: "entry", type: "ScheduleTypeStruct" })
        ),

        Attribute({
            name: "NumberOfPresets", id: 0x4a, type: "uint8", access: "R V", conformance: "PRES", default: 0,
            quality: "F", xref: "cluster§4.3.9.53",
            details: "Indicates the maximum number of entries supported by the Presets attribute."
        }),
        Attribute({
            name: "NumberOfSchedules", id: 0x4b, type: "uint8", access: "R V", conformance: "MSCH", default: 0,
            quality: "F", xref: "cluster§4.3.9.54",
            details: "Indicates the maximum number of entries supported by the Schedules attribute."
        }),
        Attribute({
            name: "NumberOfScheduleTransitions", id: 0x4c, type: "uint8", access: "R V", conformance: "MSCH",
            default: 0, quality: "F", xref: "cluster§4.3.9.55",
            details: "Indicates the maximum number of transitions per Schedules attribute entry."
        }),
        Attribute({
            name: "NumberOfScheduleTransitionPerDay", id: 0x4d, type: "uint8", access: "R V",
            conformance: "MSCH", default: null, quality: "X F", xref: "cluster§4.3.9"
        }),

        Attribute({
            name: "ActivePresetHandle", id: 0x4e, type: "octstr", access: "R V", conformance: "PRES",
            constraint: "max 16", default: null, quality: "X N", xref: "cluster§4.3.9.57",
            details: "Indicates the PresetHandle of the active preset. If this attribute is null, then there is no active " +
                "preset."
        }),

        Attribute({
            name: "ActiveScheduleHandle", id: 0x4f, type: "octstr", access: "R V", conformance: "MSCH",
            constraint: "max 16", default: null, quality: "X N", xref: "cluster§4.3.9.58",
            details: "Indicates the ScheduleHandle of the active schedule. A null value in this attribute indicates that " +
                "there is no active schedule."
        }),

        Attribute(
            {
                name: "Presets", id: 0x50, type: "list", access: "RW VM", conformance: "PRES",
                constraint: "max numberOfPresets", default: [], quality: "N T", xref: "cluster§4.3.9.59",

                details: "This attribute shall contain the current list of configured presets. On receipt of a write request:" +
                    "\n" +
                    "  1. If the PresetHandle field is null, the PresetStruct shall be treated as an added preset, and " +
                    "     the device shall create a new unique value for the PresetHandle field." +
                    "\n" +
                    "    a. If the BuiltIn field is true, a response with the status code CONSTRAINT_ERROR shall be " +
                    "       returned." +
                    "\n" +
                    "  2. If the PresetHandle field is not null, the PresetStruct shall be treated as a modification of " +
                    "     an existing preset." +
                    "\n" +
                    "    a. If the value of the PresetHandle field does not match any of the existing presets, a response " +
                    "       with the status code NOT_FOUND shall be returned." +
                    "\n" +
                    "    b. If the value of the PresetHandle field is duplicated on multiple presets in the updated list, " +
                    "       a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    c. If the BuiltIn field is true, and the PresetStruct in the current value with a matching " +
                    "       PresetHandle field has a BuiltIn field set to false, a response with the status code " +
                    "       CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    d. If the BuiltIn field is false, and the PresetStruct in the current value with a matching " +
                    "       PresetHandle field has a BuiltIn field set to true, a response with the status code " +
                    "       CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "  3. If the specified PresetScenarioEnum value does not exist in PresetTypes, a response with the " +
                    "     status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "  4. If the Name is set, but the associated PresetTypeStruct does not have the SupportsNames bit " +
                    "     set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "  5. If appending the received PresetStruct to the pending list of Presets would cause the total " +
                    "     number of pending presets to exceed the value of the NumberOfPresets attribute, a response with " +
                    "     the status code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "  6. If appending the received PresetStruct to the pending list of Presets would cause the total " +
                    "     number of pending presets whose PresetScenario field matches the appended preset’s " +
                    "     PresetScenario field to exceed the value of the NumberOfPresets field on the PresetTypeStruct " +
                    "     whose PresetScenario matches the appended preset’s PresetScenario field, a response with the " +
                    "     status code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "  7. Otherwise, the write shall be pended until receipt of a commit request, and the status code " +
                    "     SUCCESS shall be returned." +
                    "\n" +
                    "    a. If the BuiltIn field is null:" +
                    "\n" +
                    "      i. If there is a PresetStruct in the current value with a matching PresetHandle field, the " +
                    "         BuiltIn field on the pending PresetStruct shall be set to the value of the BuiltIn on the " +
                    "         matching PresetStruct." +
                    "\n" +
                    "      ii. Otherwise, the BuiltIn field on the pending PresetStruct shall be set to false." +
                    "\n" +
                    "On an attempt to commit, the status of this attribute shall be determined as follows:" +
                    "\n" +
                    "  1. For all existing presets:" +
                    "\n" +
                    "    a. If, after applying all pending changes, the updated value of the Presets attribute would not " +
                    "       contain a PresetStruct with a matching PresetHandle field, indicating the removal of the " +
                    "       PresetStruct, the server shall check for invalid removal of the PresetStruct:" +
                    "\n" +
                    "      i. If the BuiltIn field is true on the removed PresetStruct, the attribute status shall be " +
                    "         CONSTRAINT_ERROR." +
                    "\n" +
                    "      ii. If the MSCH feature is supported and the removed PresetHandle would be referenced by any " +
                    "          PresetHandle on any ScheduleTransitionStruct on any ScheduleStruct in the updated value of " +
                    "          the Schedules attribute, the attribute status shall be INVALID_IN_STATE." +
                    "\n" +
                    "      iii. If the removed PresetHandle is equal to the value of the ActivePresetHandle attribute, " +
                    "           the attribute status shall be INVALID_IN_STATE." +
                    "\n" +
                    "  2. Otherwise, the attribute status shall be SUCCESS."
            },

            Field({ name: "entry", type: "PresetStruct" })
        ),

        Attribute(
            {
                name: "Schedules", id: 0x51, type: "list", access: "RW VM", conformance: "MSCH", constraint: "desc",
                default: [], quality: "N T", xref: "cluster§4.3.9.60",

                details: "This attribute shall contain a list of ScheduleStructs. On receipt of a write request:" +
                    "\n" +
                    "  1. For all schedules in the write request:" +
                    "\n" +
                    "    a. If the ScheduleHandle field is null, the ScheduleStruct shall be treated as an added " +
                    "       schedule, and the device shall create a new unique value for the ScheduleHandle field." +
                    "\n" +
                    "      i. If the BuiltIn field is true, a response with the status code CONSTRAINT_ERROR shall be " +
                    "         returned." +
                    "\n" +
                    "    b. Otherwise, if the ScheduleHandle field is not null, the ScheduleStruct shall be treated as a " +
                    "       modification of an existing schedule." +
                    "\n" +
                    "      i. If the value of the ScheduleHandle field does not match any of the existing schedules, a " +
                    "         response with the status code NOT_FOUND shall be returned." +
                    "\n" +
                    "      ii. If the BuiltIn field is true, and the ScheduleStruct in the current value with a matching " +
                    "          ScheduleHandle field has a BuiltIn field set to false, a response with the status code " +
                    "          CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "      iii. If the BuiltIn field is false, and the ScheduleStruct in the current value with a " +
                    "           matching ScheduleHandle field has a BuiltIn field set to true, a response with the status " +
                    "           code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    c. If the specified SystemMode does not exist in ScheduleTypes, a response with the status code " +
                    "       CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    d. If the number of transitions exceeds the NumberOfScheduleTransitions value, a response with " +
                    "       the status code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "    e. If the value of the NumberOfScheduleTransitionsPerDay attribute is not null, and the number " +
                    "       of transitions on any single day of the week exceeds the NumberOfScheduleTransitionsPerDay " +
                    "       value, a response with the status code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "    f. If the PresetHandle field is present, but the associated ScheduleTypeStruct does not have the " +
                    "       SupportsPresets bit set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    g. If the PresetHandle field is present, but after applying all pending changes, the Presets " +
                    "       attribute would not contain a PresetStruct whose PresetHandle field matches the value of the " +
                    "       PresetHandle field, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    h. If the Name is set, but the associated ScheduleTypeStruct does not have the SupportsNames bit " +
                    "       set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "      i. For all transitions in all schedules in the write request:" +
                    "\n" +
                    "      i. If the PresetHandle field is present, but the ScheduleTypeStruct matching the value of the " +
                    "         SystemMode field on the encompassing ScheduleStruct does not have the SupportsPresets bit " +
                    "         set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    j. If the PresetHandle field is present, but after applying all pending changes, the Presets " +
                    "       attribute would not contain a PresetStruct whose PresetHandle field matches the value of the " +
                    "       PresetHandle field, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "      i. If the SystemMode field is present, but the ScheduleTypeStruct matching the value of the " +
                    "         SystemMode field on the encompassing ScheduleStruct does not have the SupportsSetpoints bit " +
                    "         set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "      ii. If the SystemMode field is has a value of SystemModeOff, but the ScheduleTypeStruct " +
                    "          matching the value of the SystemMode field on the encompassing ScheduleStruct does not " +
                    "          have the SupportsOff bit set, a response with the status code CONSTRAINT_ERROR shall be " +
                    "          returned." +
                    "\n" +
                    "    k. If the HeatingSetpoint field is present, but the ScheduleTypeStruct matching the value of the " +
                    "       SystemMode field on the encompassing ScheduleStruct does not have the SupportsSetpoints bit " +
                    "       set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "    l. If the CoolingSetpoint field is present, but the ScheduleTypeStruct matching the value of the " +
                    "       SystemMode field on the encompassing ScheduleStruct does not have the SupportsSetpoints bit " +
                    "       set, a response with the status code CONSTRAINT_ERROR shall be returned." +
                    "\n" +
                    "  2. If appending the received ScheduleStruct to the pending list of Schedules would cause the total " +
                    "     number of pending schedules to exceed the value of the NumberOfSchedules attribute, a response " +
                    "     with the status code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "  3. If appending the received ScheduleStruct to the pending list of Schedules would cause the total " +
                    "     number of pending schedules whose SystemMode field matches the appended schedule’s SystemMode " +
                    "     field to exceed the value of the NumberOfSchedules field on the ScheduleTypeStruct whose " +
                    "     SystemMode field matches the appended schedule’s SystemMode field, a response with the status " +
                    "     code RESOURCE_EXHAUSTED shall be returned." +
                    "\n" +
                    "  4. Otherwise, the write shall be pended until receipt of a commit request, and the attribute " +
                    "     status shall be SUCCESS." +
                    "\n" +
                    "    a. If the BuiltIn field is null:" +
                    "\n" +
                    "      i. If there is a ScheduleStruct in the current value with a matching ScheduleHandle field, the " +
                    "         BuiltIn field on the pending ScheduleStruct shall be set to the value of the BuiltIn on the " +
                    "         matching ScheduleStruct." +
                    "\n" +
                    "      ii. Otherwise, the BuiltIn field on the pending ScheduleStruct shall be set to false." +
                    "\n" +
                    "On an attempt to commit, the status of this attribute shall be determined as follows:" +
                    "\n" +
                    "  1. For all existing schedules:" +
                    "\n" +
                    "    a. If, after applying all pending changes, the updated value of the Schedules attribute would " +
                    "       not contain a ScheduleStruct with a matching ScheduleHandle field, indicating the removal of " +
                    "       the ScheduleStruct, the server shall check for invalid removal of the ScheduleStruct:" +
                    "\n" +
                    "      i. If the BuiltIn field is true on the removed ScheduleStruct, the attribute status shall be " +
                    "         CONSTRAINT_ERROR." +
                    "\n" +
                    "      ii. If the removed ScheduleHandle is equal to the value of the ActiveScheduleHandle attribute, " +
                    "          the attribute status shall be INVALID_IN_STATE." +
                    "\n" +
                    "  2. Otherwise, the attribute status shall be SUCCESS."
            },

            Field({ name: "entry", type: "ScheduleStruct" })
        ),

        Attribute({
            name: "SetpointHoldExpiryTimestamp", id: 0x52, type: "epoch-s", access: "R V", conformance: "O",
            default: null, quality: "X N", xref: "cluster§4.3.9.61",

            details: "If there is a known time when the TemperatureSetpointHold shall be cleared, this attribute shall " +
                "contain the timestamp in UTC indicating when that will happen. If there is no such known time, this " +
                "attribute shall be null." +
                "\n" +
                "If the TemperatureSetpointHold is set to SetpointHoldOn and the TemperatureSetpointHoldDuration is " +
                "set to null, this attribute shall be set to null indicating there is a hold on the Thermostat " +
                "without a duration." +
                "\n" +
                "If the TemperatureSetpointHold is set to SetpointHoldOff, this attribute shall be set to null " +
                "indicating there is no hold on the Thermostat."
        }),

        Command(
            {
                name: "SetpointRaiseLower", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§4.3.10.1"
            },
            Field({
                name: "Mode", id: 0x0, type: "SetpointRaiseLowerModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.10.1.1",
                details: "The field shall specify which setpoints are to be adjusted."
            }),
            Field({
                name: "Amount", id: 0x1, type: "int8", conformance: "M", xref: "cluster§4.3.10.1.2",
                details: "This field shall indicate the amount (possibly negative) that should be added to the setpoint(s), in " +
                    "steps of 0.1°C."
            })
        ),

        Command(
            {
                name: "SetWeeklySchedule", id: 0x1, access: "M", conformance: "SCH", direction: "request",
                response: "status", xref: "cluster§4.3.10.2",

                details: "This command is used to update the thermostat weekly setpoint schedule from a management system. If " +
                    "the thermostat already has a weekly setpoint schedule programmed, then it SHOULD replace each daily " +
                    "setpoint set as it receives the updates from the management system. For example, if the thermostat " +
                    "has 4 setpoints for every day of the week and is sent a SetWeeklySchedule command with one setpoint " +
                    "for Saturday then the thermostat SHOULD remove all 4 setpoints for Saturday and replace those with " +
                    "the updated setpoint but leave all other days unchanged. If the schedule is larger than what fits in " +
                    "one frame or contains more than 10 transitions, the schedule shall then be sent using multiple " +
                    "SetWeeklySchedule Commands."
            },

            Field({
                name: "NumberOfTransitionsForSequence", id: 0x0, type: "uint8", conformance: "M",
                xref: "cluster§4.3.10.2.1",
                details: "This field shall indicate how many individual transitions to expect for this sequence of commands. " +
                    "If a device supports more than 10 transitions in its schedule they can send this by sending more " +
                    "than 1 “Set Weekly Schedule” command, each containing the separate information that the device needs " +
                    "to set."
            }),

            Field({
                name: "DayOfWeekForSequence", id: 0x1, type: "ScheduleDayOfWeekBitmap", conformance: "M",
                constraint: "desc", xref: "cluster§4.3.10.2.2",

                details: "This field shall represent the day of the week at which all the transitions within the payload of " +
                    "the command SHOULD be associated to. This field is a bitmap and therefore the associated setpoint " +
                    "could overlap onto multiple days (you could set one transition time for all “week days” or whatever " +
                    "combination of days the implementation requests)." +
                    "\n" +
                    "Each setpoint transition will begin with the day of week for this transition. There can be up to 10 " +
                    "transitions for each command."
            }),

            Field({
                name: "ModeForSequence", id: 0x2, type: "ScheduleModeBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.10.2.3",

                details: "This field shall indicate how the application decodes the setpoint fields of each transition in the " +
                    "Transitions list." +
                    "\n" +
                    "If the HeatSetpointPresent bit is On, the HeatSetpoint field shall NOT be null in every entry of the " +
                    "Transitions list." +
                    "\n" +
                    "If the HeatSetpointPresent bit is Off, the HeatSetpoint field shall be null in every entry of the " +
                    "Transitions list." +
                    "\n" +
                    "If the CoolSetpointPresent bit is On, the CoolSetpoint field shall NOT be null in every entry of the " +
                    "Transitions list." +
                    "\n" +
                    "If the CoolSetpointPresent bit is Off, the CoolSetpoint field shall be null in every entry of the " +
                    "Transitions list." +
                    "\n" +
                    "At least one of the bits in the Mode For Sequence byte shall be on." +
                    "\n" +
                    "Both bits must be respected, even if the HEAT or COOL feature is not supported, to ensure the " +
                    "command is decoded and handled correctly."
            }),

            Field(
                {
                    name: "Transitions", id: 0x3, type: "list", conformance: "M", constraint: "max 10",
                    xref: "cluster§4.3.10.2.4",
                    details: "This field shall contain the list of setpoint transitions used to update the specified daily " +
                        "schedules"
                },

                Field({ name: "entry", type: "WeeklyScheduleTransitionStruct" })
            )
        ),

        Command(
            {
                name: "GetWeeklySchedule", id: 0x2, access: "O", conformance: "SCH", direction: "request",
                response: "GetWeeklyScheduleResponse", xref: "cluster§4.3.10.3"
            },

            Field({
                name: "DaysToReturn", id: 0x0, type: "ScheduleDayOfWeekBitmap", conformance: "M",
                constraint: "desc", xref: "cluster§4.3.10.3.1",
                details: "This field shall indicate the number of days the client would like to return the setpoint values for " +
                    "and could be any combination of single days or the entire week."
            }),

            Field({
                name: "ModeToReturn", id: 0x1, type: "ScheduleModeBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.10.3.2",
                details: "This field shall indicate the mode the client would like to return the set point values for and " +
                    "could be any combination of heat only, cool only or heat & cool."
            })
        ),

        Command(
            {
                name: "GetWeeklyScheduleResponse", id: 0x0, conformance: "SCH", direction: "response",
                xref: "cluster§4.3.10.4",
                details: "This command has the same payload format as the Set Weekly Schedule."
            },
            Field({ name: "NumberOfTransitionsForSequence", id: 0x0, type: "uint8", conformance: "M" }),
            Field({
                name: "DayOfWeekForSequence", id: 0x1, type: "ScheduleDayOfWeekBitmap", conformance: "M",
                constraint: "desc"
            }),
            Field({ name: "ModeForSequence", id: 0x2, type: "ScheduleModeBitmap", conformance: "M", constraint: "desc" }),
            Field(
                { name: "Transitions", id: 0x3, type: "list", conformance: "M", constraint: "max 10" },
                Field({ name: "entry", type: "WeeklyScheduleTransitionStruct" })
            )
        ),

        Command({
            name: "ClearWeeklySchedule", id: 0x3, access: "M", conformance: "SCH", direction: "request",
            response: "status", xref: "cluster§4.3.10.5",
            details: "This command is used to clear the weekly schedule. The Clear weekly schedule has no payload." +
                "\n" +
                "Upon receipt, all transitions currently stored shall be cleared and a default response of SUCCESS " +
                "shall be sent in response. There are no error responses to this command."
        }),

        Command(
            {
                name: "GetRelayStatusLogResponse", id: 0x1, conformance: "GetRelayStatusLog", direction: "response",
                xref: "cluster§4.3.10.7",
                details: "This command is sent from the thermostat cluster server in response to the Get Relay Status Log. " +
                    "After the Relay Status Entry is sent over the air to the requesting client, the specific entry will " +
                    "be cleared from the thermostat internal log."
            },

            Field({
                name: "TimeOfDay", id: 0x0, type: "uint16", conformance: "M", constraint: "max 1439",
                xref: "cluster§4.3.10.7.1",
                details: "This field shall indicate the sample time of the day, in minutes since midnight, when the relay " +
                    "status was captured for this associated log entry. For example, 6am will be represented by 360 " +
                    "minutes since midnight and 11:30pm will be represented by 1410 minutes since midnight."
            }),

            Field({
                name: "RelayStatus", id: 0x1, type: "RelayStateBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.10.7.2",
                details: "This field shall indicate the relay status for thermostat when the log is captured. Each bit " +
                    "represents one relay used by the thermostat. If the bit is on, the associated relay is on and " +
                    "active. Each thermostat manufacturer can create its own mapping between the bitmap and the " +
                    "associated relay."
            }),

            Field({
                name: "LocalTemperature", id: 0x2, type: "temperature", conformance: "M", quality: "X",
                xref: "cluster§4.3.10.7.3",
                details: "This field shall indicate the LocalTemperature when the log is captured. The null value indicates " +
                    "that LocalTemperature was invalid or unavailable."
            }),

            Field({
                name: "HumidityInPercentage", id: 0x3, type: "uint8", conformance: "M", constraint: "0% to 100%",
                quality: "X"
            }),
            Field({
                name: "Setpoint", id: 0x4, type: "temperature", conformance: "M", xref: "cluster§4.3.10.7.5",
                details: "This field shall indicate the target setpoint temperature when the log is captured."
            }),
            Field({
                name: "UnreadEntries", id: 0x5, type: "uint16", conformance: "M", xref: "cluster§4.3.10.7.6",
                details: "This field shall indicate the number of unread entries within the thermostat internal log system."
            })
        ),

        Command(
            {
                name: "SetActiveScheduleRequest", id: 0x5, access: "O", conformance: "MSCH", direction: "request",
                response: "status", xref: "cluster§4.3.10.8"
            },

            Field({
                name: "ScheduleHandle", id: 0x0, type: "octstr", conformance: "M", constraint: "max 16",
                xref: "cluster§4.3.10.8.1",
                details: "This field shall specify the value of the ScheduleHandle field on the ScheduleStruct to be made " +
                    "active."
            })
        ),

        Command(
            {
                name: "SetActivePresetRequest", id: 0x6, access: "O", conformance: "PRES", direction: "request",
                response: "status", xref: "cluster§4.3.10.9"
            },

            Field({
                name: "PresetHandle", id: 0x0, type: "octstr", conformance: "M", constraint: "max 16", quality: "X",
                xref: "cluster§4.3.10.9.1",
                details: "This field shall specify the value of the PresetHandle field on the PresetStruct to be made active. " +
                    "If the field is set to null, that indicates there should be no active preset."
            })
        ),

        Datatype(
            {
                name: "TemperatureDifference", type: "int16", xref: "cluster§4.3.8.1",

                details: "This data type is derived from int16 and represents a temperature difference with a resolution of " +
                    "0.01°C." +
                    "\n" +
                    "  • value = (temperature in °C) x 100" +
                    "\n" +
                    "  • -4°C ⇒ -400" +
                    "\n" +
                    "  • 123.45°C ⇒ 12345" +
                    "\n" +
                    "The full (non-null) range of -327.67°C to 327.67°C may be used."
            }
        ),

        Datatype(
            {
                name: "SignedTemperature", type: "int8", xref: "cluster§4.3.8.2",

                details: "This data type is derived from int8 and represents a temperature from -12.7°C to 12.7°C with a " +
                    "resolution of 0.1°C." +
                    "\n" +
                    "  • value = (temperature in °C) x 10" +
                    "\n" +
                    "  • -4°C ⇒ -40" +
                    "\n" +
                    "  • 12.3°C ⇒ 123" +
                    "\n" +
                    "This type is employed where compactness of representation is important and where the resolution and " +
                    "range are still satisfactory."
            }
        ),

        Datatype(
            {
                name: "UnsignedTemperature", type: "uint8", xref: "cluster§4.3.8.3",

                details: "This data type is derived from uint8 and represents a temperature from 0°C to 25.5°C with a " +
                    "resolution of 0.1°C." +
                    "\n" +
                    "  • value = (temperature in °C) x 10" +
                    "\n" +
                    "  • 4°C ⇒ 40" +
                    "\n" +
                    "  • 12.3°C ⇒ 123" +
                    "\n" +
                    "This type is employed where compactness of representation is important and where the resolution and " +
                    "range are still satisfactory."
            }
        ),

        Datatype(
            { name: "ACErrorCodeBitmap", type: "map32", xref: "cluster§4.3.8.4" },
            Field({ name: "CompressorFail", constraint: "0", description: "Compressor Failure or Refrigerant Leakage" }),
            Field({ name: "RoomSensorFail", constraint: "1", description: "Room Temperature Sensor Failure" }),
            Field({ name: "OutdoorSensorFail", constraint: "2", description: "Outdoor Temperature Sensor Failure" }),
            Field({ name: "CoilSensorFail", constraint: "3", description: "Indoor Coil Temperature Sensor Failure" }),
            Field({ name: "FanFail", constraint: "4", description: "Fan Failure" })
        ),

        Datatype(
            { name: "HVACSystemTypeBitmap", type: "map8", xref: "cluster§4.3.8.5" },

            Field(
                {
                    name: "CoolingStage", constraint: "0 to 1",
                    description: "Stage of cooling the HVAC system is using.", xref: "cluster§4.3.8.5.1",

                    details: "These bits shall indicate what stage of cooling the HVAC system is using." +
                        "\n" +
                        "  • 00 = Cool Stage 1" +
                        "\n" +
                        "  • 01 = Cool Stage 2" +
                        "\n" +
                        "  • 10 = Cool Stage 3" +
                        "\n" +
                        "  • 11 = Reserved"
                }
            ),

            Field(
                {
                    name: "HeatingStage", constraint: "2 to 3",
                    description: "Stage of heating the HVAC system is using.", xref: "cluster§4.3.8.5.2",

                    details: "These bits shall indicate what stage of heating the HVAC system is using." +
                        "\n" +
                        "  • 00 = Heat Stage 1" +
                        "\n" +
                        "  • 01 = Heat Stage 2" +
                        "\n" +
                        "  • 10 = Heat Stage 3" +
                        "\n" +
                        "  • 11 = Reserved"
                }
            ),

            Field(
                {
                    name: "HeatingIsHeatPump", constraint: "4", description: "Is the heating type Heat Pump.",
                    xref: "cluster§4.3.8.5.3",
                    details: "This bit shall indicate whether the HVAC system is conventional or a heat pump." +
                        "\n" +
                        "  • 0 = Conventional" +
                        "\n" +
                        "  • 1 = Heat Pump"
                }
            ),

            Field(
                {
                    name: "HeatingUsesFuel", constraint: "5", description: "Does the HVAC system use fuel.",
                    xref: "cluster§4.3.8.5.4",
                    details: "This bit shall indicate whether the HVAC system uses fuel." +
                        "\n" +
                        "  • 0 = Does not use fuel" +
                        "\n" +
                        "  • 1 = Uses fuel"
                }
            )
        ),

        Datatype(
            { name: "OccupancyBitmap", type: "map8", xref: "cluster§4.3.8.6" },

            Field({
                name: "Occupied", constraint: "0", description: "Indicates the occupancy state",
                xref: "cluster§4.3.8.6.1",
                details: "If this bit is set, it shall indicate the occupied state else if the bit if not set, it shall " +
                    "indicate the unoccupied state."
            })
        ),

        Datatype(
            { name: "PresetTypeFeaturesBitmap", type: "map16", xref: "cluster§4.3.8.7" },
            Field({
                name: "Automatic", constraint: "0",
                description: "Preset may be automatically activated by the thermostat"
            }),
            Field({ name: "SupportsNames", constraint: "1", description: "Preset supports user-provided names" })
        ),

        Datatype(
            { name: "ProgrammingOperationModeBitmap", type: "map8", xref: "cluster§4.3.8.8" },
            Field({
                name: "ScheduleActive", constraint: "0",
                description: "Schedule programming mode. This enables any programmed weekly schedule configurations."
            }),
            Field({ name: "AutoRecovery", constraint: "1", description: "Auto/recovery mode" }),
            Field({ name: "Economy", constraint: "2", description: "Economy/EnergyStar mode" })
        ),

        Datatype(
            { name: "RelayStateBitmap", type: "map16", xref: "cluster§4.3.8.9" },
            Field({ name: "Heat", constraint: "0", description: "Heat Stage On" }),
            Field({ name: "Cool", constraint: "1", description: "Cool Stage On" }),
            Field({ name: "Fan", constraint: "2", description: "Fan Stage On" }),
            Field({ name: "HeatStage2", constraint: "3", description: "Heat 2nd Stage On" }),
            Field({ name: "CoolStage2", constraint: "4", description: "Cool 2nd Stage On" }),
            Field({ name: "FanStage2", constraint: "5", description: "Fan 2nd Stage On" }),
            Field({ name: "FanStage3", constraint: "6", description: "Fan 3rd Stage On" })
        ),

        Datatype(
            { name: "RemoteSensingBitmap", type: "map8", xref: "cluster§4.3.8.10" },
            Field({
                name: "LocalTemperature", constraint: "0",
                description: "Calculated Local Temperature is derived from a remote node"
            }),
            Field({
                name: "OutdoorTemperature", constraint: "1",
                description: "OutdoorTemperature is derived from a remote node"
            }),
            Field({ name: "Occupancy", constraint: "2", description: "Occupancy is derived from a remote node" })
        ),

        Datatype(
            { name: "ScheduleTypeFeaturesBitmap", type: "map16", xref: "cluster§4.3.8.11" },

            Field({
                name: "SupportsPresets", constraint: "0", description: "Supports presets",
                xref: "cluster§4.3.8.11.1",
                details: "This bit shall indicate that any ScheduleStruct with a SystemMode field whose value matches the " +
                    "SystemMode field on the encompassing ScheduleTypeStruct supports specifying presets on " +
                    "ScheduleTransitionStructs contained in its Transitions field."
            }),

            Field({
                name: "SupportsSetpoints", constraint: "1", description: "Supports setpoints",
                xref: "cluster§4.3.8.11.2",
                details: "This bit shall indicate that any ScheduleStruct with a SystemMode field whose value matches the " +
                    "SystemMode field on the encompassing ScheduleTypeStruct supports specifying setpoints on " +
                    "ScheduleTransitionStructs contained in its Transitions field."
            }),

            Field({
                name: "SupportsNames", constraint: "2", description: "Supports user-provided names",
                xref: "cluster§4.3.8.11.3",
                details: "This bit shall indicate that any ScheduleStruct with a SystemMode field whose value matches the " +
                    "SystemMode field on the encompassing ScheduleTypeStruct supports setting the value of the Name " +
                    "field."
            }),

            Field({
                name: "SupportsOff", constraint: "3", description: "Supports transitioning to SystemModeOff",
                xref: "cluster§4.3.8.11.4",
                details: "This bit shall indicate that any ScheduleStruct with a SystemMode field whose value matches the " +
                    "SystemMode field on the encompassing ScheduleTypeStruct supports setting its SystemMode field to " +
                    "Off."
            })
        ),

        Datatype(
            { name: "ScheduleDayOfWeekBitmap", type: "map8", xref: "cluster§4.3.8.12" },
            Field({ name: "Sunday", constraint: "0", description: "Sunday" }),
            Field({ name: "Monday", constraint: "1", description: "Monday" }),
            Field({ name: "Tuesday", constraint: "2", description: "Tuesday" }),
            Field({ name: "Wednesday", constraint: "3", description: "Wednesday" }),
            Field({ name: "Thursday", constraint: "4", description: "Thursday" }),
            Field({ name: "Friday", constraint: "5", description: "Friday" }),
            Field({ name: "Saturday", constraint: "6", description: "Saturday" }),
            Field({ name: "Away", constraint: "7", description: "Away or Vacation" })
        ),

        Datatype(
            { name: "ScheduleModeBitmap", type: "map8", xref: "cluster§4.3.8.13" },
            Field({ name: "HeatSetpointPresent", constraint: "0", description: "Adjust Heat Setpoint" }),
            Field({ name: "CoolSetpointPresent", constraint: "1", description: "Adjust Cool Setpoint" })
        ),
        Datatype(
            { name: "ACCapacityFormatEnum", type: "enum8", xref: "cluster§4.3.8.14" },
            Field({ name: "BtUh", id: 0x0, conformance: "O", description: "British Thermal Unit per Hour" })
        ),

        Datatype(
            { name: "ACCompressorTypeEnum", type: "enum8", xref: "cluster§4.3.8.15" },
            Field({ name: "Unknown", id: 0x0, conformance: "O", description: "Unknown compressor type" }),
            Field({ name: "T1", id: 0x1, conformance: "O", description: "Max working ambient 43 °C" }),
            Field({ name: "T2", id: 0x2, conformance: "O", description: "Max working ambient 35 °C" }),
            Field({ name: "T3", id: 0x3, conformance: "O", description: "Max working ambient 52 °C" })
        ),

        Datatype(
            { name: "ACLouverPositionEnum", type: "enum8", xref: "cluster§4.3.8.16" },
            Field({ name: "Closed", id: 0x1, conformance: "O", description: "Fully Closed" }),
            Field({ name: "Open", id: 0x2, conformance: "O", description: "Fully Open" }),
            Field({ name: "Quarter", id: 0x3, conformance: "O", description: "Quarter Open" }),
            Field({ name: "Half", id: 0x4, conformance: "O", description: "Half Open" }),
            Field({ name: "ThreeQuarters", id: 0x5, conformance: "O", description: "Three Quarters Open" })
        ),

        Datatype(
            { name: "ACRefrigerantTypeEnum", type: "enum8", xref: "cluster§4.3.8.17" },
            Field({ name: "Unknown", id: 0x0, conformance: "O", description: "Unknown Refrigerant Type" }),
            Field({ name: "R22", id: 0x1, conformance: "O", description: "R22 Refrigerant" }),
            Field({ name: "R410A", id: 0x2, conformance: "O", description: "R410a Refrigerant" }),
            Field({ name: "R407C", id: 0x3, conformance: "O", description: "R407c Refrigerant" })
        ),

        Datatype(
            { name: "ACTypeEnum", type: "enum8", xref: "cluster§4.3.8.18" },
            Field({ name: "Unknown", id: 0x0, conformance: "O", description: "Unknown AC Type" }),
            Field({ name: "CoolingFixed", id: 0x1, conformance: "O", description: "Cooling and Fixed Speed" }),
            Field({ name: "HeatPumpFixed", id: 0x2, conformance: "O", description: "Heat Pump and Fixed Speed" }),
            Field({ name: "CoolingInverter", id: 0x3, conformance: "O", description: "Cooling and Inverter" }),
            Field({ name: "HeatPumpInverter", id: 0x4, conformance: "O", description: "Heat Pump and Inverter" })
        ),

        Datatype(
            { name: "SetpointRaiseLowerModeEnum", type: "enum8", xref: "cluster§4.3.8.19" },
            Field({ name: "Heat", id: 0x0, conformance: "HEAT", description: "Adjust Heat Setpoint" }),
            Field({ name: "Cool", id: 0x1, conformance: "COOL", description: "Adjust Cool Setpoint" }),
            Field({
                name: "Both", id: 0x2, conformance: "HEAT | COOL",
                description: "Adjust Heat Setpoint and Cool Setpoint"
            })
        ),

        Datatype(
            {
                name: "ControlSequenceOfOperationEnum", type: "enum8", xref: "cluster§4.3.8.20",

                details: "> [!NOTE]" +
                    "\n" +
                    "> CoolingAndHeating" +
                    "\n" +
                    "A thermostat indicating it supports CoolingAndHeating (or CoolingAndHeatingWithReheat) SHOULD be " +
                    "able to request heating or cooling on demand and will usually support the Auto SystemMode." +
                    "\n" +
                    "Systems which support cooling or heating, requiring external intervention to change modes or where " +
                    "the whole building must be in the same mode, SHOULD report CoolingOnly or HeatingOnly based on the " +
                    "current capability."
            },

            Field({ name: "CoolingOnly", id: 0x0, conformance: "[COOL]", description: "Heat and Emergency are not possible" }),
            Field({
                name: "CoolingWithReheat", id: 0x1, conformance: "[COOL]",
                description: "Heat and Emergency are not possible"
            }),
            Field({
                name: "HeatingOnly", id: 0x2, conformance: "[HEAT]",
                description: "Cool and precooling (see Terms) are not possible"
            }),
            Field({
                name: "HeatingWithReheat", id: 0x3, conformance: "[HEAT]",
                description: "Cool and precooling are not possible"
            }),
            Field({ name: "CoolingAndHeating", id: 0x4, conformance: "[HEAT & COOL]", description: "All modes are possible" }),
            Field({
                name: "CoolingAndHeatingWithReheat", id: 0x5, conformance: "[HEAT & COOL]",
                description: "All modes are possible"
            })
        ),

        Datatype(
            { name: "PresetScenarioEnum", type: "enum8", xref: "cluster§4.3.8.21" },

            Field({
                name: "Occupied", id: 0x1, conformance: "M",
                description: "The thermostat-controlled area is occupied", xref: "cluster§4.3.8.21.2",
                details: "This value shall indicate the preset for periods when the thermostat’s temperature-controlled area " +
                    "is occupied. It is intended for thermostats that can automatically determine occupancy."
            }),

            Field({
                name: "Unoccupied", id: 0x2, conformance: "M",
                description: "The thermostat-controlled area is unoccupied", xref: "cluster§4.3.8.21.3",
                details: "This value shall indicate the preset for periods when the thermostat’s temperature-controlled area " +
                    "is unoccupied. It is intended for thermostats that can automatically determine occupancy."
            }),

            Field({
                name: "Sleep", id: 0x3, conformance: "M", description: "Users are likely to be sleeping",
                xref: "cluster§4.3.8.21.4",
                details: "This value shall indicate the preset for periods when users are likely to be asleep."
            }),
            Field({
                name: "Wake", id: 0x4, conformance: "M", description: "Users are likely to be waking up",
                xref: "cluster§4.3.8.21.5",
                details: "This value shall indicate the preset for periods when users are likely to be waking up."
            }),

            Field({
                name: "Vacation", id: 0x5, conformance: "M", description: "Users are on vacation",
                xref: "cluster§4.3.8.21.6",
                details: "This value shall indicate the preset for periods when users are on vacation, or otherwise " +
                    "out-of-home for extended periods of time."
            }),

            Field({
                name: "GoingToSleep", id: 0x6, conformance: "M",
                description: "Users are likely to be going to sleep", xref: "cluster§4.3.8.21.7",
                details: "This value shall indicate the preset for periods when users are likely to be going to sleep."
            }),

            Field({
                name: "UserDefined", id: 0xfe, conformance: "M", description: "Custom presets",
                xref: "cluster§4.3.8.21.8",
                details: "This value shall indicate a free-form preset; when set, the Name field on PresetStruct shall NOT be " +
                    "null."
            })
        ),

        Datatype(
            { name: "SetpointChangeSourceEnum", type: "enum8", xref: "cluster§4.3.8.22" },
            Field({
                name: "Manual", id: 0x0, conformance: "O",
                description: "Manual, user-initiated setpoint change via the thermostat"
            }),
            Field({
                name: "Schedule", id: 0x1, conformance: "[SCH | MSCH]",
                description: "Schedule/internal programming-initiated setpoint change"
            }),
            Field({
                name: "External", id: 0x2, conformance: "O",
                description: "Externally-initiated setpoint change (e.g., DRLC cluster command, attribute write)"
            })
        ),

        Datatype(
            { name: "StartOfWeekEnum", type: "enum8", xref: "cluster§4.3.8.23" },
            Field({ name: "Sunday", id: 0x0, conformance: "M" }),
            Field({ name: "Monday", id: 0x1, conformance: "M" }),
            Field({ name: "Tuesday", id: 0x2, conformance: "M" }),
            Field({ name: "Wednesday", id: 0x3, conformance: "M" }),
            Field({ name: "Thursday", id: 0x4, conformance: "M" }),
            Field({ name: "Friday", id: 0x5, conformance: "M" }),
            Field({ name: "Saturday", id: 0x6, conformance: "M" })
        ),

        Datatype(
            {
                name: "SystemModeEnum", type: "enum8", xref: "cluster§4.3.8.24",
                details: "Table 9. Interpretation of Heat, Cool and Auto SystemModeEnum Values"
            },
            Field({
                name: "Off", id: 0x0, conformance: "O",
                description: "The Thermostat does not generate demand for Cooling or Heating"
            }),
            Field({
                name: "Auto", id: 0x1, conformance: "AUTO",
                description: "Demand is generated for either Cooling or Heating, as required"
            }),
            Field({ name: "Cool", id: 0x3, conformance: "[COOL]", description: "Demand is only generated for Cooling" }),
            Field({ name: "Heat", id: 0x4, conformance: "[HEAT]", description: "Demand is only generated for Heating" }),
            Field({
                name: "EmergencyHeat", id: 0x5, conformance: "[HEAT]",
                description: "2nd stage heating is in use to achieve desired temperature"
            }),
            Field({ name: "Precooling", id: 0x6, conformance: "[COOL]", description: "(see Terms)" }),
            Field({ name: "FanOnly", id: 0x7, conformance: "O" }),
            Field({ name: "Dry", id: 0x8, conformance: "O" }),
            Field({ name: "Sleep", id: 0x9, conformance: "O" })
        ),

        Datatype(
            { name: "ThermostatRunningModeEnum", type: "enum8", xref: "cluster§4.3.8.25" },
            Field({
                name: "Off", id: 0x0, conformance: "O",
                description: "The Thermostat does not generate demand for Cooling or Heating"
            }),
            Field({ name: "Cool", id: 0x3, conformance: "[COOL]", description: "Demand is only generated for Cooling" }),
            Field({ name: "Heat", id: 0x4, conformance: "[HEAT]", description: "Demand is only generated for Heating" })
        ),

        Datatype(
            { name: "TemperatureSetpointHoldEnum", type: "enum8", xref: "cluster§4.3.8.26" },
            Field({ name: "SetpointHoldOff", id: 0x0, conformance: "M", description: "Follow scheduling program" }),
            Field({
                name: "SetpointHoldOn", id: 0x1, conformance: "M",
                description: "Maintain current setpoint, regardless of schedule transitions"
            })
        ),

        Datatype(
            { name: "PresetStruct", type: "struct", xref: "cluster§4.3.8.27" },

            Field({
                name: "PresetHandle", id: 0x0, type: "octstr", conformance: "M", constraint: "max 16", quality: "X",
                xref: "cluster§4.3.8.27.1",

                details: "This field shall indicate a device generated identifier for this preset. It shall be unique on the " +
                    "device, and shall NOT be reused after the associated preset has been deleted." +
                    "\n" +
                    "This field shall only be null when the encompassing PresetStruct is appended to the Presets " +
                    "attribute for the purpose of creating a new Preset. Refer to Presets for the creation of Preset " +
                    "handles."
            }),

            Field({
                name: "PresetScenario", id: 0x1, type: "PresetScenarioEnum", conformance: "M",
                xref: "cluster§4.3.8.27.2",
                details: "This field shall indicate the associated PresetScenarioEnum value for this preset."
            }),

            Field({
                name: "Name", id: 0x2, type: "string", conformance: "O", constraint: "max 64", default: null,
                quality: "X", xref: "cluster§4.3.8.27.3",
                details: "This field shall indicate a name provided by a user. The null value shall indicate no name." +
                    "\n" +
                    "Within each subset of presets sharing the same PresetScenario field value, there shall NOT be any " +
                    "presets with the same value, including null as a value, in the Name field."
            }),

            Field({
                name: "CoolingSetpoint", id: 0x3, type: "temperature", conformance: "COOL", constraint: "desc",
                default: { type: "celsius", value: 26 }, xref: "cluster§4.3.8.27.4",
                details: "This field shall indicate the cooling setpoint for the preset. Refer to Setpoint Limits for value " +
                    "constraints."
            }),

            Field({
                name: "HeatingSetpoint", id: 0x4, type: "temperature", conformance: "HEAT", constraint: "desc",
                default: { type: "celsius", value: 20 }, xref: "cluster§4.3.8.27.5",
                details: "This field shall indicate the heating setpoint for the preset. Refer to Setpoint Limits for value " +
                    "constraints."
            }),

            Field({
                name: "BuiltIn", id: 0x5, type: "bool", conformance: "M", default: false, quality: "X",
                xref: "cluster§4.3.8.27.6",
                details: "This field shall indicate whether the preset is marked as \"built-in\", meaning that it can be " +
                    "modified, but it cannot be deleted."
            })
        ),

        Datatype(
            { name: "PresetTypeStruct", type: "struct", xref: "cluster§4.3.8.28" },
            Field({
                name: "PresetScenario", id: 0x0, type: "PresetScenarioEnum", conformance: "M",
                xref: "cluster§4.3.8.28.1",
                details: "This field shall specify a PresetScenarioEnum value supported by this thermostat."
            }),
            Field({
                name: "NumberOfPresets", id: 0x1, type: "uint8", conformance: "M", default: 0,
                xref: "cluster§4.3.8.28.2",
                details: "This field shall specify a limit for the number of presets for this PresetScenarioEnum."
            }),
            Field({
                name: "PresetTypeFeatures", id: 0x2, type: "PresetTypeFeaturesBitmap", conformance: "M", default: 0,
                xref: "cluster§4.3.8.28.3",
                details: "This field shall specify a bitmap of features for this PresetTypeStruct."
            })
        ),

        Datatype(
            {
                name: "WeeklyScheduleTransitionStruct", type: "struct", xref: "cluster§4.3.8.29",
                details: "This represents a single transition in a Thermostat schedule"
            },

            Field({
                name: "TransitionTime", id: 0x0, type: "uint16", conformance: "M", constraint: "max 1439",
                xref: "cluster§4.3.8.29.1",
                details: "This field shall represent the start time of the schedule transition during the associated day. The " +
                    "time will be represented by a 16 bits unsigned integer to designate the minutes since midnight. For " +
                    "example, 6am will be represented by 360 minutes since midnight and 11:30pm will be represented by " +
                    "1410 minutes since midnight."
            }),

            Field({
                name: "HeatSetpoint", id: 0x1, type: "temperature", conformance: "M", quality: "X",
                xref: "cluster§4.3.8.29.2",
                details: "This field shall represent the heat setpoint to be applied at this associated transition start time."
            }),
            Field({
                name: "CoolSetpoint", id: 0x2, type: "temperature", conformance: "M", quality: "X",
                xref: "cluster§4.3.8.29.3",
                details: "This field shall represent the cool setpoint to be applied at this associated transition start time."
            })
        ),

        Datatype(
            { name: "ScheduleStruct", type: "struct", xref: "cluster§4.3.8.30" },

            Field({
                name: "ScheduleHandle", id: 0x0, type: "octstr", conformance: "M", constraint: "max 16",
                quality: "X", xref: "cluster§4.3.8.30.1",

                details: "This field shall indicate a device generated identifier for this schedule. It shall be unique on the " +
                    "device, and shall NOT be reused after the associated schedule has been deleted." +
                    "\n" +
                    "This field shall only be null when the encompassing ScheduleStruct is appended to the Schedules " +
                    "attribute for the purpose of creating a new Schedule. Refer to Schedules for the creation of " +
                    "Schedule handles."
            }),

            Field({
                name: "SystemMode", id: 0x1, type: "SystemModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.8.30.2",
                details: "This field shall specify the default thermostat system mode for transitions in this schedule. The " +
                    "only valid values for this field shall be Auto, Heat, and Cool."
            }),

            Field({
                name: "Name", id: 0x2, type: "string", conformance: "O", constraint: "max 64",
                xref: "cluster§4.3.8.30.3",
                details: "This field shall specify a name for the ScheduleStruct."
            }),
            Field({
                name: "PresetHandle", id: 0x3, type: "octstr", conformance: "O", constraint: "max 16",
                xref: "cluster§4.3.8.30.4",
                details: "This field shall indicate the default PresetHandle value for transitions in this schedule."
            }),

            Field(
                {
                    name: "Transitions", id: 0x4, type: "list", conformance: "M",
                    constraint: "1 to numberOfScheduleTransitions", default: [], xref: "cluster§4.3.8.30.5",

                    details: "This field shall specify a list of transitions for the schedule." +
                        "\n" +
                        "This field shall NOT contain more than one ScheduleStruct with the same TransitionTime field and " +
                        "overlapping DayOfWeek fields; i.e. there shall be no duplicate transitions." +
                        "\n" +
                        "If the NumberOfScheduleTransitionsPerDay attribute is not null, then for each bit in " +
                        "ScheduleDayOfWeekBitmap, the number of transitions with that bit set in DayOfWeek shall NOT be " +
                        "greater than the value of the NumberOfScheduleTransitionsPerDay attribute." +
                        "\n" +
                        "For the purposes of determining which ScheduleStruct in this list is currently active, the current " +
                        "time shall be the number of minutes past midnight in the display value of the current time, not the " +
                        "actual number of minutes that have elapsed since midnight. On days which transition into or out of " +
                        "daylight saving time, certain values may repeat or not occur during the transition period." +
                        "\n" +
                        "A ScheduleTransitionStruct in this list shall be active if the current day of the week matches its " +
                        "DayOfWeek field and the current time is greater than or equal to the TransitionTime, but less than " +
                        "the TransitionTime on any other ScheduleTransitionStruct in the Transitions field whose DayOfWeek " +
                        "field also matches the current day of the week." +
                        "\n" +
                        "If the current time is less than every ScheduleTransitionStruct whose DayOfWeek field also matches " +
                        "the current day of the week, the server shall attempt the same process to identify the active " +
                        "ScheduleTransitionStruct for the day preceding the previously attempted day of the week, repeating " +
                        "until an active ScheduleTransitionStruct is found or the attempted day is the current day of the " +
                        "week again. If no active ScheduleTransitionStruct is found, then the active ScheduleTransitionStruct " +
                        "shall be the ScheduleTransitionStruct with the largest TransitionTime field from the set of " +
                        "ScheduleTransitionStructs whose DayOfWeek field matches the current day of the week."
                },

                Field({ name: "entry", type: "ScheduleTransitionStruct" })
            ),

            Field({
                name: "BuiltIn", id: 0x5, type: "bool", conformance: "M", default: false, quality: "X",
                xref: "cluster§4.3.8.30.6",
                details: "This field shall indicate whether the schedule is marked as \"built-in\", meaning that it can be " +
                    "modified, but it cannot be deleted."
            })
        ),

        Datatype(
            {
                name: "ScheduleTransitionStruct", type: "struct", xref: "cluster§4.3.8.31",

                details: "This struct provides a time of day and a set of days of the week for a state transition within a " +
                    "schedule. The thermostat shall use the following order of precedence for determining a new setpoint " +
                    "at the time of transition:" +
                    "\n" +
                    "  1. If the PresetHandle field is provided, then the setpoint for the PresetStruct in the Presets " +
                    "     attribute with that identifier shall be used" +
                    "\n" +
                    "  2. If either the HeatingSetpoint or CoolingSetpoint is provided, then it shall be used" +
                    "\n" +
                    "    a. If the SystemMode field is provided, the HeatingSetpoint and CoolingSetpoint fields shall be " +
                    "       interpreted using the SystemMode field" +
                    "\n" +
                    "    b. If the SystemMode field is not provided, the HeatingSetpoint and CoolingSetpoint fields shall " +
                    "       be interpreted using the SystemMode field on the parent ScheduleStruct" +
                    "\n" +
                    "  3. If neither the PresetHandle field or any Setpoint field is provided, then the PresetHandle " +
                    "     field on the parent ScheduleStruct shall be used to determine the active PresetStruct" +
                    "\n" +
                    "  4. If the PresetHandle is not indicated and no setpoint is provided for the current SystemMode, " +
                    "     the server shall use a default value for the current SystemMode." +
                    "\n" +
                    "If the setpoint was derived from a preset, then the ActivePresetHandle shall be set to the " +
                    "PresetHandle of that preset." +
                    "\n" +
                    "If a CoolingSetpoint was used to determine the cooling setpoint:" +
                    "\n" +
                    "  • If the server supports the OCC feature, and the Occupied bit is not set on the Occupancy " +
                    "    attribute, then the UnoccupiedCoolingSetpoint attribute shall be set to the CoolingSetpoint" +
                    "\n" +
                    "  • Otherwise, the OccupiedCoolingSetpoint attribute shall be set to the CoolingSetpoint If a " +
                    "    HeatingSetpoint was used to determine the heating setpoint:" +
                    "\n" +
                    "  • If the server supports the OCC feature, and the Occupied bit is not set on the Occupancy " +
                    "    attribute, then the UnoccupiedHeatingSetpoint attribute shall be set to the HeatingSetpoint" +
                    "\n" +
                    "  • Otherwise, the OccupiedHeatingSetpoint attribute shall be set to the HeatingSetpoint The " +
                    "    ScheduleTransitionStruct shall be invalid if all the following are true:" +
                    "\n" +
                    "  • The HeatingSetpoint field is not provided" +
                    "\n" +
                    "  • The PresetHandle field is not provided" +
                    "\n" +
                    "  • The PresetHandle field on the encompassing ScheduleStruct is not provided" +
                    "\n" +
                    "  • The SystemMode field is provided and has the value Heat or Auto, or the SystemMode field on the " +
                    "    parent ScheduleStruct has the value Heat or Auto The ScheduleTransitionStruct shall be invalid " +
                    "    if all the following are true:" +
                    "\n" +
                    "  • The CoolingSetpoint field is not provided" +
                    "\n" +
                    "  • The PresetHandle field is not provided" +
                    "\n" +
                    "  • The PresetHandle field on the encompassing ScheduleStruct is not provided" +
                    "\n" +
                    "  • The SystemMode field is provided and has the value Cool or Auto, or the SystemMode field on the " +
                    "    parent ScheduleStruct has the value Cool or Auto"
            },

            Field({
                name: "DayOfWeek", id: 0x0, type: "ScheduleDayOfWeekBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.8.31.1",
                details: "This field shall specify a bitmask of days of the week that the transition applies to. The Vacation " +
                    "bit shall NOT be set; vacation schedules shall be set via the vacation preset."
            }),

            Field({
                name: "TransitionTime", id: 0x1, type: "uint16", conformance: "M", constraint: "max 1439",
                xref: "cluster§4.3.8.31.2",
                details: "This shall specify the time of day at which the transition becomes active, in terms of minutes " +
                    "within the day representing the wall clock, where 0 is 00:00:00, 1 is 00:01:00 and 1439 is 23:59:00." +
                    "\n" +
                    "Handling of transitions during the changeover of Daylight Saving Time is implementation-dependent."
            }),

            Field({
                name: "PresetHandle", id: 0x2, type: "octstr", conformance: "[PRES]", constraint: "max 16",
                xref: "cluster§4.3.8.31.3",
                details: "This field shall specify the preset used at the TransitionTime. If this field is provided, then the " +
                    "SystemMode, CoolingSetpoint and HeatingSetpoint fields shall NOT be provided."
            }),

            Field({
                name: "SystemMode", id: 0x3, type: "SystemModeEnum", conformance: "O", constraint: "desc",
                xref: "cluster§4.3.8.31.4",
                details: "This shall specify the default mode to which the thermostat will switch for this transition, " +
                    "overriding the default for the schedule. The only valid values for this field shall be Auto, Heat, " +
                    "Cool and Off. This field shall only be included when the required system mode differs from the " +
                    "schedule’s default SystemMode."
            }),

            Field({
                name: "CoolingSetpoint", id: 0x4, type: "temperature", conformance: "[COOL]", constraint: "desc",
                xref: "cluster§4.3.8.31.5",
                details: "This field shall specify the cooling setpoint for the transition. If PresetHandle is set, this field " +
                    "shall NOT be included. Refer to Setpoint Limits for value constraints."
            }),

            Field({
                name: "HeatingSetpoint", id: 0x5, type: "temperature", conformance: "[HEAT]", constraint: "desc",
                xref: "cluster§4.3.8.31.6",
                details: "This field shall specify the cooling setpoint for the transition. If PresetHandle is set, this field " +
                    "shall NOT be included. Refer to Setpoint Limits for value constraints."
            })
        ),

        Datatype(
            { name: "ScheduleTypeStruct", type: "struct", xref: "cluster§4.3.8.32" },

            Field({
                name: "SystemMode", id: 0x0, type: "SystemModeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§4.3.8.32.1",
                details: "This field shall specify a SystemModeEnum supported by this thermostat for Schedules. The only valid " +
                    "values for this field shall be Auto, Heat, and Cool."
            }),

            Field({
                name: "NumberOfSchedules", id: 0x1, type: "uint8", conformance: "M",
                constraint: "max numberOfSchedules", default: 0, xref: "cluster§4.3.8.32.2",
                details: "This field shall specify a limit for the number of Schedules for this SystemMode."
            }),

            Field({
                name: "ScheduleTypeFeatures", id: 0x2, type: "ScheduleTypeFeaturesBitmap", conformance: "M",
                constraint: "desc", default: 0, xref: "cluster§4.3.8.32.3",
                details: "This field shall specify a bitmap of features for this schedule entry. At least one of " +
                    "SupportsPresets and SupportsSetpoints shall be set."
            })
        )
    ),

    Cluster(
        {
            name: "FanControl", id: 0x202, classification: "application", pics: "FAN", xref: "cluster§4.4",
            details: "This cluster specifies an interface to control the speed of a fan."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 5 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§4.4.4" },

            Field({
                name: "SPD", conformance: "O", constraint: "0", title: "MultiSpeed", xref: "cluster§4.4.4.1",

                details: "Legacy Fan Control cluster revision 0-1 defined 3 speeds (low, medium and high) plus automatic speed " +
                    "control but left it up to the implementer to decide what was supported. Therefore, it is assumed " +
                    "that legacy client implementations are capable of determining, from the server, the number of speeds " +
                    "supported between 1, 2, or 3, and whether automatic speed control is supported." +
                    "\n" +
                    "The MultiSpeed feature includes attributes that support a running fan speed value from 0 to " +
                    "SpeedMax." +
                    "\n" +
                    "See Section 4.4.6.6.1, “Speed Rules” for more details."
            }),

            Field({
                name: "AUT", conformance: "O", constraint: "1", title: "Auto",
                details: "Automatic mode supported for fan speed"
            }),
            Field({ name: "RCK", conformance: "O", constraint: "2", title: "Rocking", details: "Rocking movement supported" }),
            Field({ name: "WND", conformance: "O", constraint: "3", title: "Wind", details: "Wind emulation supported" }),
            Field({ name: "STEP", conformance: "O", constraint: "4", title: "Step", details: "Step command supported" }),
            Field({
                name: "DIR", conformance: "O", constraint: "5", title: "AirflowDirection",
                details: "Airflow Direction attribute is supported"
            })
        ),

        Attribute({
            name: "FanMode", id: 0x0, type: "FanModeEnum", access: "RW VO", conformance: "M",
            constraint: "desc", quality: "N", xref: "cluster§4.4.6.1",

            details: "Indicates the current speed mode of the fan." +
                "\n" +
                "This attribute shall be set to one of the values in FanModeEnum supported by the server as indicated " +
                "in the FanModeSequence attribute. The Low value shall be supported if and only if the " +
                "FanModeSequence attribute value is less than 4. The Medium value shall be supported if and only if " +
                "the FanModeSequence attribute value is 0 or 2." +
                "\n" +
                "This attribute may be written by a client to request a different fan mode. The server shall return " +
                "INVALID_IN_STATE to indicate that the fan is not in a state where this attribute can be changed to " +
                "the requested value." +
                "\n" +
                "The server may have values that this attribute can never be set to or that will be ignored by the " +
                "server. For example, where this cluster appears on the same or another endpoint as other clusters " +
                "with a system dependency, for example the Thermostat cluster, attempting to set this attribute to " +
                "Off may not be allowed by the system." +
                "\n" +
                "If an attempt is made to set this attribute to a value not supported by the server as indicated in " +
                "the FanModeSequence attribute, the server shall respond with CONSTRAINT_ERROR." +
                "\n" +
                "When this attribute is successfully written to, the PercentSetting and SpeedSetting (if present) " +
                "attributes shall be set to appropriate values, as defined by Section 4.4.6.3.1, “Percent Rules” and " +
                "Section 4.4.6.6.1, “Speed Rules” respectively, unless otherwise specified below." +
                "\n" +
                "When this attribute is set to any valid value, the PercentCurrent and SpeedCurrent (if present) " +
                "attributes shall indicate the actual currently operating fan speed, unless otherwise specified " +
                "below."
        }),

        Attribute({
            name: "FanModeSequence", id: 0x1, type: "FanModeSequenceEnum", access: "R V", conformance: "M",
            quality: "F", xref: "cluster§4.4.6.2",
            details: "This attribute indicates the fan speed ranges that shall be supported by the server."
        }),

        Attribute({
            name: "PercentSetting", id: 0x2, type: "percent", access: "RW VO", conformance: "M",
            constraint: "max 100", quality: "X", xref: "cluster§4.4.6.3",

            details: "Indicates the speed setting for the fan with a value of 0 indicating that the fan is off and a value " +
                "of 100 indicating that the fan is set to run at its maximum speed. If the FanMode attribute is set " +
                "to Auto, the value of this attribute shall be set to null." +
                "\n" +
                "This attribute may be written to by a client to indicate a new fan speed. If a client writes null to " +
                "this attribute, the attribute value shall NOT change. If the fan is in a state where this attribute " +
                "cannot be changed to the requested value, the server shall return INVALID_IN_STATE." +
                "\n" +
                "When this attribute is successfully written, the server shall set the value of the FanMode and " +
                "SpeedSetting (if present) attributes to values that abide by the mapping requirements listed below."
        }),

        Attribute({
            name: "PercentCurrent", id: 0x3, type: "percent", access: "R V", conformance: "M",
            constraint: "max 100", xref: "cluster§4.4.6.4",

            details: "Indicates the actual currently operating fan speed, or zero to indicate that the fan is off. There " +
                "may be a temporary mismatch between the value of this attribute and the value of the PercentSetting " +
                "attribute due to other system requirements or constraints that would not allow the fan to operate at " +
                "the requested setting." +
                "\n" +
                "For example, if the value of this attribute is currently 50%, and the PercentSetting attribute is " +
                "newly set to 25%, the value of this attribute may stay above 25% for a period necessary to dissipate " +
                "internal heat, maintain product operational safety, etc." +
                "\n" +
                "When the value of the FanMode attribute is AUTO, the value of this attribute may vary across the " +
                "range over time." +
                "\n" +
                "See Section 4.4.6.3.1, “Percent Rules” for more details."
        }),

        Attribute({
            name: "SpeedMax", id: 0x4, type: "uint8", access: "R V", conformance: "SPD", constraint: "1 to 100",
            quality: "F", xref: "cluster§4.4.6.5",
            details: "Indicates the maximum value to which the SpeedSetting attribute can be set."
        }),

        Attribute({
            name: "SpeedSetting", id: 0x5, type: "uint8", access: "RW VO", conformance: "SPD",
            constraint: "max speedMax", quality: "X", xref: "cluster§4.4.6.6",

            details: "Indicates the speed setting for the fan. This attribute may be written by a client to indicate a new " +
                "fan speed. If the FanMode attribute is set to Auto, the value of this attribute shall be set to " +
                "null." +
                "\n" +
                "The server shall support all values between 0 and SpeedMax." +
                "\n" +
                "If a client writes null to this attribute, the attribute value shall NOT change. If the fan is in a " +
                "state where this attribute cannot be changed to the requested value, the server shall return " +
                "INVALID_IN_STATE." +
                "\n" +
                "When this attribute is successfully written to, the server shall set the value of the FanMode and " +
                "PercentSetting attributes to values that abide by the mapping requirements listed below."
        }),

        Attribute({
            name: "SpeedCurrent", id: 0x6, type: "uint8", access: "R V", conformance: "SPD",
            constraint: "max speedMax", quality: "P", xref: "cluster§4.4.6.7",

            details: "Indicates the actual currently operating fan speed, or zero to indicate that the fan is off. There " +
                "may be a temporary mismatch between the value of this attribute and the value of the SpeedSetting " +
                "attribute due to other system requirements or constraints that would not allow the fan to operate at " +
                "the requested setting." +
                "\n" +
                "For example, if the value of this attribute is currently 5, and the SpeedSetting attribute is newly " +
                "set to 2, the value of this attribute may stay above 2 for a period necessary to dissipate internal " +
                "heat, maintain product operational safety, etc." +
                "\n" +
                "When the value of the FanMode attribute is AUTO, the value of this attribute may vary across the " +
                "range over time." +
                "\n" +
                "See Section 4.4.6.6.1, “Speed Rules” for more details."
        }),

        Attribute({
            name: "RockSupport", id: 0x7, type: "RockBitmap", access: "R V", conformance: "RCK",
            constraint: "min 1", quality: "F", xref: "cluster§4.4.6.8",
            details: "This attribute is a bitmap that indicates the rocking motions that are supported by the server. If " +
                "this attribute is supported by the server, at least one bit shall be set in this attribute."
        }),

        Attribute({
            name: "RockSetting", id: 0x8, type: "RockBitmap", access: "RW VO", conformance: "RCK",
            constraint: "desc", quality: "P", xref: "cluster§4.4.6.9",

            details: "This attribute is a bitmap that indicates the currently active fan rocking motion setting. Each bit " +
                "shall only be set to 1, if the corresponding bit in the RockSupport attribute is set to 1, otherwise " +
                "a status code of CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If a combination of supported bits is set by a client, and the server does not support the " +
                "combination, the lowest supported single bit in the combination shall be set and active, and all " +
                "other bits shall indicate zero." +
                "\n" +
                "For example: If RockUpDown and RockRound are both set, but this combination is not possible, then " +
                "only RockUpDown becomes active."
        }),

        Attribute({
            name: "WindSupport", id: 0x9, type: "WindBitmap", access: "R V", conformance: "WND",
            constraint: "min 1", quality: "F", xref: "cluster§4.4.6.10",
            details: "This attribute is a bitmap that indicates what wind modes are supported by the server. If this " +
                "attribute is supported by the server, at least one bit shall be set in this attribute."
        }),

        Attribute({
            name: "WindSetting", id: 0xa, type: "WindBitmap", access: "RW VO", conformance: "WND",
            constraint: "desc", quality: "P", xref: "cluster§4.4.6.11",

            details: "This attribute is a bitmap that indicates the current active fan wind feature settings. Each bit " +
                "shall only be set to 1, if the corresponding bit in the WindSupport attribute is set to 1, otherwise " +
                "a status code of CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If a combination of supported bits is set by a client, and the server does not support the " +
                "combination, the lowest supported single bit in the combination shall be set and active, and all " +
                "other bits shall indicate zero." +
                "\n" +
                "For example: If Sleep Wind and Natural Wind are set, but this combination is not possible, then only " +
                "Sleep Wind becomes active."
        }),

        Attribute({
            name: "AirflowDirection", id: 0xb, type: "AirflowDirectionEnum", access: "RW VO",
            conformance: "DIR", quality: "P", xref: "cluster§4.4.6.12",
            details: "Indicates the current airflow direction of the fan. This attribute may be written by a client to " +
                "indicate a new airflow direction for the fan. This attribute shall be set to one of the values in " +
                "the AirflowDirectionEnum table."
        }),

        Command(
            {
                name: "Step", id: 0x0, access: "O", conformance: "STEP", direction: "request", response: "status",
                xref: "cluster§4.4.7.1",

                details: "This command indirectly changes the speed-oriented attributes of the fan in steps rather than using " +
                    "the speed-oriented attributes, FanMode, PercentSetting, or SpeedSetting, directly. This command " +
                    "supports, for example, a user-operated and wall-mounted toggle switch that can be used to increase " +
                    "or decrease the speed of the fan by pressing the toggle switch up or down until the desired fan " +
                    "speed is reached. How this command is interpreted by the server and how it affects the values of the " +
                    "speed-oriented attributes is implementation specific." +
                    "\n" +
                    "For example, a fan supports this command, and the value of the FanModeSequence attribute is 0. The " +
                    "current value of the FanMode attribute is 2, or Medium. This command is received with the Direction " +
                    "field set to Increase. As per it’s specific implementation, the server reacts to the command by " +
                    "setting the value of the FanMode attribute to 3, or High, which in turn sets the PercentSetting and " +
                    "SpeedSetting (if present) attributes to appropriate values, as defined by Section 4.4.6.3.1, " +
                    "“Percent Rules” and Section 4.4.6.6.1, “Speed Rules” respectively." +
                    "\n" +
                    "This command supports these fields:"
            },

            Field({
                name: "Direction", id: 0x0, type: "StepDirectionEnum", conformance: "M", xref: "cluster§4.4.7.1.1",
                details: "This field shall indicate whether the speed-oriented attributes increase or decrease to the next " +
                    "step value."
            }),
            Field({
                name: "Wrap", id: 0x1, type: "bool", conformance: "O", default: false, xref: "cluster§4.4.7.1.2",
                details: "This field shall indicate if the speed-oriented attributes wrap between highest and lowest step " +
                    "value."
            }),

            Field({
                name: "LowestOff", id: 0x2, type: "bool", conformance: "O", default: true,
                xref: "cluster§4.4.7.1.3",
                details: "This field shall indicate that the fan being off" +
                    "\n" +
                    "= 0) is included as a step value."
            })
        ),

        Datatype(
            { name: "RockBitmap", type: "map8", xref: "cluster§4.4.5.1" },
            Field({ name: "RockLeftRight", constraint: "0", description: "Indicate rock left to right" }),
            Field({ name: "RockUpDown", constraint: "1", description: "Indicate rock up and down" }),
            Field({ name: "RockRound", constraint: "2", description: "Indicate rock around" })
        ),

        Datatype(
            { name: "WindBitmap", type: "map8", xref: "cluster§4.4.5.2" },
            Field({
                name: "SleepWind", constraint: "0", description: "Indicate sleep wind", xref: "cluster§4.4.5.2.1",
                details: "The fan speed, based on current settings, shall gradually slow down to a final minimum speed. For " +
                    "this process, the sequence, speeds and duration are MS."
            }),

            Field({
                name: "NaturalWind", constraint: "1", description: "Indicate natural wind",
                xref: "cluster§4.4.5.2.2",
                details: "The fan speed shall vary to emulate natural wind. For this setting, the sequence, speeds and " +
                    "duration are MS."
            })
        ),

        Datatype(
            { name: "StepDirectionEnum", type: "enum8", xref: "cluster§4.4.5.3" },
            Field({ name: "Increase", id: 0x0, conformance: "M", description: "Step moves in increasing direction" }),
            Field({ name: "Decrease", id: 0x1, conformance: "M", description: "Step moves in decreasing direction" })
        ),
        Datatype(
            { name: "AirflowDirectionEnum", type: "enum8", xref: "cluster§4.4.5.4" },
            Field({ name: "Forward", id: 0x0, conformance: "M", description: "Airflow is in the forward direction" }),
            Field({ name: "Reverse", id: 0x1, conformance: "M", description: "Airflow is in the reverse direction" })
        ),

        Datatype(
            { name: "FanModeEnum", type: "enum8", xref: "cluster§4.4.5.5" },
            Field({ name: "Off", id: 0x0, conformance: "M", description: "Fan is off" }),
            Field({ name: "Low", id: 0x1, conformance: "O", description: "Fan using low speed" }),
            Field({ name: "Medium", id: 0x2, conformance: "[Low]", description: "Fan using medium speed" }),
            Field({ name: "High", id: 0x3, conformance: "M", description: "Fan using high speed" }),
            Field({ name: "On", id: 0x4, conformance: "D" }),
            Field({ name: "Auto", id: 0x5, conformance: "AUT", description: "Fan is using auto mode" }),
            Field({ name: "Smart", id: 0x6, conformance: "D", description: "Fan is using smart mode" })
        ),

        Datatype(
            { name: "FanModeSequenceEnum", type: "enum8", xref: "cluster§4.4.5.6" },
            Field({
                name: "OffLowMedHigh", id: 0x0, conformance: "[!AUT].a",
                description: "Fan is capable of off, low, medium and high modes"
            }),
            Field({
                name: "OffLowHigh", id: 0x1, conformance: "[!AUT].a",
                description: "Fan is capable of off, low and high modes"
            }),
            Field({
                name: "OffLowMedHighAuto", id: 0x2, conformance: "[AUT].b",
                description: "Fan is capable of off, low, medium, high and auto modes"
            }),
            Field({
                name: "OffLowHighAuto", id: 0x3, conformance: "[AUT].b",
                description: "Fan is capable of off, low, high and auto modes"
            }),
            Field({
                name: "OffHighAuto", id: 0x4, conformance: "[AUT].b",
                description: "Fan is capable of off, high and auto modes"
            }),
            Field({ name: "OffHigh", id: 0x5, conformance: "[!AUT].a", description: "Fan is capable of off and high modes" })
        )
    ),

    Cluster(
        {
            name: "ThermostatUserInterfaceConfiguration", id: 0x204, classification: "application",
            pics: "TSUIC", xref: "cluster§4.5",
            details: "This cluster provides an interface to allow configuration of the user interface for a thermostat, or " +
                "a thermostat controller device, that supports a keypad and LCD screen."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),
        Attribute({
            name: "TemperatureDisplayMode", id: 0x0, type: "TemperatureDisplayModeEnum", access: "RW VO",
            conformance: "M", xref: "cluster§4.5.6.1",
            details: "Indicates the units of the temperature displayed on the thermostat screen."
        }),
        Attribute({
            name: "KeypadLockout", id: 0x1, type: "KeypadLockoutEnum", access: "RW VM", conformance: "M",
            xref: "cluster§4.5.6.2",
            details: "Indicates the level of functionality that is available to the user via the keypad."
        }),

        Attribute({
            name: "ScheduleProgrammingVisibility", id: 0x2, type: "ScheduleProgrammingVisibilityEnum",
            access: "RW VM", conformance: "O", default: 0, xref: "cluster§4.5.6.3",

            details: "This attribute is used to hide the weekly schedule programming functionality or menu on a thermostat " +
                "from a user to prevent local user programming of the weekly schedule. The schedule programming may " +
                "still be performed via a remote interface, and the thermostat may operate in schedule programming " +
                "mode." +
                "\n" +
                "This attribute is designed to prevent local tampering with or disabling of schedules that may have " +
                "been programmed by users or service providers via a more capable remote interface. The programming " +
                "schedule shall continue to run even though it is not visible to the user locally at the thermostat."
        }),

        Datatype(
            { name: "TemperatureDisplayModeEnum", type: "enum8", xref: "cluster§4.5.5.1" },
            Field({ name: "Celsius", id: 0x0, conformance: "M", description: "Temperature displayed in °C" }),
            Field({ name: "Fahrenheit", id: 0x1, conformance: "M", description: "Temperature displayed in °F" })
        ),

        Datatype(
            {
                name: "KeypadLockoutEnum", type: "enum8", xref: "cluster§4.5.5.2",
                details: "The interpretation of the various levels is device-dependent."
            },
            Field({ name: "NoLockout", id: 0x0, conformance: "M", description: "All functionality available to the user" }),
            Field({ name: "Lockout1", id: 0x1, conformance: "M", description: "Level 1 reduced functionality" }),
            Field({ name: "Lockout2", id: 0x2, conformance: "M", description: "Level 2 reduced functionality" }),
            Field({ name: "Lockout3", id: 0x3, conformance: "M", description: "Level 3 reduced functionality" }),
            Field({ name: "Lockout4", id: 0x4, conformance: "M", description: "Level 4 reduced functionality" }),
            Field({ name: "Lockout5", id: 0x5, conformance: "M", description: "Least functionality available to the user" })
        ),

        Datatype(
            { name: "ScheduleProgrammingVisibilityEnum", type: "enum8", xref: "cluster§4.5.5.3" },
            Field({
                name: "ScheduleProgrammingPermitted", id: 0x0, conformance: "M",
                description: "Local schedule programming functionality is enabled at the thermostat"
            }),
            Field({
                name: "ScheduleProgrammingDenied", id: 0x1, conformance: "M",
                description: "Local schedule programming functionality is disabled at the thermostat"
            })
        )
    ),

    Cluster(
        {
            name: "ValveConfigurationAndControl", id: 0x81, classification: "application", pics: "VALCC",
            xref: "cluster§4.6",
            details: "This cluster is used to configure a valve."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§4.6.4" },

            Field({
                name: "TS", conformance: "desc", constraint: "0", title: "TimeSync", xref: "cluster§4.6.4.1",
                details: "This feature shall indicate that the valve uses Time Synchronization and UTC time to indicate " +
                    "duration and auto close time." +
                    "\n" +
                    "This feature shall NOT be supported unless the device supports the Time Synchronization cluster."
            }),

            Field({
                name: "LVL", conformance: "O", constraint: "1", title: "Level", xref: "cluster§4.6.4.2",
                details: "This feature shall indicate that the valve is capable of being adjusted to a specific position, as a " +
                    "percentage, of its full range of motion."
            })
        ),

        Attribute({
            name: "OpenDuration", id: 0x0, type: "elapsed-s", access: "R V", conformance: "M",
            constraint: "min 1", quality: "X", xref: "cluster§4.6.7.1",
            details: "Indicates the total duration, in seconds, for which the valve will remain open for this current " +
                "opening." +
                "\n" +
                "A value of null shall indicate the duration is not set, meaning that the valve will remain open " +
                "until closed by the user or some other automation."
        }),

        Attribute({
            name: "DefaultOpenDuration", id: 0x1, type: "elapsed-s", access: "RW VO", conformance: "M",
            constraint: "min 1", quality: "X N", xref: "cluster§4.6.7.2",
            details: "Indicates the default duration, in seconds, for which the valve will remain open, if the " +
                "OpenDuration field is not present in the Open command." +
                "\n" +
                "A value of null shall indicate the duration is not set, meaning that the valve will remain open " +
                "until closed by the user or some other automation."
        }),

        Attribute({
            name: "AutoCloseTime", id: 0x2, type: "epoch-us", access: "R V", conformance: "TS", quality: "X",
            xref: "cluster§4.6.7.3",

            details: "Indicates the UTC time when the valve will close, depending on value of the OpenDuration attribute." +
                "\n" +
                "Null:" +
                "\n" +
                "  • When OpenDuration is null, or" +
                "\n" +
                "  • When the valve does not have a synchronized UTCTime in the Time Synchronization cluster, or" +
                "\n" +
                "  • When the valve is closed." +
                "\n" +
                "When the value of this attribute is earlier or equal to the current UTC time, the valve shall " +
                "automatically transition to its closed position. The behavior of transitioning to the closed " +
                "position, shall match the behavior described in the Close command." +
                "\n" +
                "If this attribute is not null and the Time Synchronization cluster receives a SetUTCTime command, " +
                "modifying the current UTC time of the device, the value of this attribute shall be adjusted to match " +
                "the new UTC time plus the value of the RemainingDuration attribute."
        }),

        Attribute({
            name: "RemainingDuration", id: 0x3, type: "elapsed-s", access: "R V", conformance: "M",
            quality: "X Q", xref: "cluster§4.6.7.4",

            details: "Indicates the remaining duration, in seconds, until the valve closes. Null:" +
                "\n" +
                "  • When OpenDuration is null, or" +
                "\n" +
                "  • When the valve is closed." +
                "\n" +
                "The value of this attribute shall only be reported in the following cases:" +
                "\n" +
                "  • When it changes from null to any other value and vice versa, or" +
                "\n" +
                "  • When it changes to 0, or" +
                "\n" +
                "  • When it increases, or" +
                "\n" +
                "  • When the closing time changes." +
                "\n" +
                "Meaning that clients SHOULD NOT rely on the reporting of this attribute in order to keep track of " +
                "the remaining duration, due to this attribute not being reported during regular countdown." +
                "\n" +
                "When reading this attribute it shall return the remaining duration, in seconds, until the valve " +
                "closes." +
                "\n" +
                "When the value of this attribute counts down to 0, the valve shall automatically transition to its " +
                "closed position. The behavior of transitioning to the closed position shall match the behavior " +
                "described in the Close command."
        }),

        Attribute({
            name: "CurrentState", id: 0x4, type: "ValveStateEnum", access: "R V", conformance: "M",
            quality: "X", xref: "cluster§4.6.7.5",
            details: "Indicates the current state of the valve." +
                "\n" +
                "A value of null shall indicate that the current state is not known."
        }),

        Attribute({
            name: "TargetState", id: 0x5, type: "ValveStateEnum", access: "R V", conformance: "M", quality: "X",
            xref: "cluster§4.6.7.6",
            details: "Indicates the target state, while changing the state, of the valve." +
                "\n" +
                "A value of null shall indicate that no target position is set, since the change in state is either " +
                "done or failed."
        }),

        Attribute({
            name: "CurrentLevel", id: 0x6, type: "percent", access: "R V", conformance: "LVL", quality: "X",
            xref: "cluster§4.6.7.7",

            details: "Indicates the current level of the valve as a percentage value, between fully closed and fully open. " +
                "During a transition from one level to another level, the valve SHOULD keep this attribute updated to " +
                "the best of its ability, in order to represent the actual level of the valve during the movement." +
                "\n" +
                "A value of 100 percent shall indicate the fully open position. A value of 0 percent shall indicate " +
                "the fully closed position." +
                "\n" +
                "A value of null shall indicate that the current state is not known."
        }),

        Attribute({
            name: "TargetLevel", id: 0x7, type: "percent", access: "R V", conformance: "LVL", quality: "X",
            xref: "cluster§4.6.7.8",

            details: "Indicates the target level of the valve as a percentage value, between fully closed and fully open." +
                "\n" +
                "The interpretation of the percentage value is the same as for the CurrentLevel attribute." +
                "\n" +
                "A value of null shall indicate that no target position is set, since the change of level is either " +
                "done or failed."
        }),

        Attribute({
            name: "DefaultOpenLevel", id: 0x8, type: "percent", access: "RW VO", conformance: "[LVL]",
            constraint: "1 to 100", default: 100, quality: "N", xref: "cluster§4.6.7.9",

            details: "Indicates the default value used for the TargetLevel attribute, when a valve transitions from the " +
                "closed to the open state, caused by an Open command, if a TargetLevel field is not present in the " +
                "Open command." +
                "\n" +
                "If the LevelStep attribute is present and the value of a write interaction to this attribute field " +
                "is not 100, the value shall be a supported value as defined by the LevelStep attribute, such that " +
                "(Value received in the write interaction) % (Value of LevelStep attribute) equals 0. If the " +
                "resulting value is not 0, the requested DefaultOpenLevel value is considered an unsupported value " +
                "and a CONSTRAINT_ERROR status shall be returned."
        }),

        Attribute({
            name: "ValveFault", id: 0x9, type: "ValveFaultBitmap", access: "R V", conformance: "O", default: 0,
            xref: "cluster§4.6.7.10",
            details: "Indicates any faults registered by the valve."
        }),

        Attribute({
            name: "LevelStep", id: 0xa, type: "uint8", access: "R V", conformance: "[LVL]",
            constraint: "1 to 50", default: 1, quality: "F", xref: "cluster§4.6.7.11",

            details: "Indicates the step size the valve can support." +
                "\n" +
                "The step size defined by this attribute is counted from 0 and the final step towards 100 may be " +
                "different than what is defined in this attribute. For example, if the value of this attribute is 15, " +
                "it results in these target values being supported; 0, 15, 30, 45, 60, 75, 90 and 100." +
                "\n" +
                "The values of 0 and 100 shall always be supported, regardless of the value of this attribute."
        }),

        Event(
            {
                name: "ValveStateChanged", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "cluster§4.6.9.1",
                details: "This event shall be generated when the valve state changed. For level changes, after the end of " +
                    "movement, for state changes when the new state has been reached."
            },

            Field({
                name: "ValveState", id: 0x0, type: "ValveStateEnum", conformance: "M", xref: "cluster§4.6.9.1.1",
                details: "This field shall indicate the new state of the valve."
            }),
            Field({
                name: "ValveLevel", id: 0x1, type: "percent", conformance: "LVL", xref: "cluster§4.6.9.1.2",
                details: "This field shall indicate the new level of the valve."
            })
        ),

        Event(
            {
                name: "ValveFault", id: 0x1, access: "V", conformance: "O", priority: "info",
                xref: "cluster§4.6.9.2",
                details: "This event shall be generated when the valve registers or clears a fault, e.g. not being able to " +
                    "transition to the requested target level or state."
            },

            Field({
                name: "ValveFault", id: 0x0, type: "ValveFaultBitmap", conformance: "M", xref: "cluster§4.6.9.2.1",
                details: "This field shall indicate the value of the ValveFault attribute, at the time this event is " +
                    "generated."
            })
        ),

        Command(
            {
                name: "Open", id: 0x0, access: "O", conformance: "M", direction: "request", response: "status",
                xref: "cluster§4.6.8.1",
                details: "This command is used to set the valve to its open position."
            },

            Field({
                name: "OpenDuration", id: 0x0, type: "elapsed-s", conformance: "O", constraint: "min 1",
                quality: "X", xref: "cluster§4.6.8.1.1",
                details: "This field shall indicate the duration that the valve will remain open for this specific Open " +
                    "command." +
                    "\n" +
                    "A value of null shall indicate the duration is not set, meaning that the valve will remain open " +
                    "until closed by the user or some other automation."
            }),

            Field({
                name: "TargetLevel", id: 0x1, type: "percent", conformance: "[LVL]", constraint: "min 1",
                xref: "cluster§4.6.8.1.2",
                details: "This field shall indicate the target level used for this specific Open command."
            })
        ),

        Command({
            name: "Close", id: 0x1, access: "O", conformance: "M", direction: "request", response: "status",
            xref: "cluster§4.6.8.2",
            details: "This command is used to set the valve to its closed position."
        }),

        Datatype(
            { name: "ValveFaultBitmap", type: "map16", xref: "cluster§4.6.5.1" },
            Field({ name: "GeneralFault", constraint: "0", description: "Unspecified fault detected" }),
            Field({ name: "Blocked", constraint: "1", description: "Valve is blocked" }),
            Field({ name: "Leaking", constraint: "2", description: "Valve has detected a leak" }),
            Field({ name: "NotConnected", constraint: "3", description: "No valve is connected to controller" }),
            Field({ name: "ShortCircuit", constraint: "4", description: "Short circuit is detected" }),
            Field({ name: "CurrentExceeded", constraint: "5", description: "The available current has been exceeded" })
        ),

        Datatype(
            { name: "ValveStateEnum", type: "enum8", xref: "cluster§4.6.5.2" },
            Field({ name: "Closed", id: 0x0, conformance: "M", description: "Valve is in closed position" }),
            Field({ name: "Open", id: 0x1, conformance: "M", description: "Valve is in open position" }),
            Field({
                name: "Transitioning", id: 0x2, conformance: "M",
                description: "Valve is transitioning between closed and open positions or between levels"
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "cluster§4.6.6.1" },
            Field({
                name: "FailureDueToFault", id: 0x2, conformance: "M",
                description: "The requested action could not be performed due to a fault on the valve."
            })
        )
    ),

    Cluster(
        {
            name: "DoorLock", id: 0x101, classification: "application", pics: "DRLK", xref: "cluster§5.2",
            details: "The door lock cluster provides an interface to a generic way to secure a door. The physical object " +
                "that provides the locking functionality is abstracted from the cluster. The cluster has a small list " +
                "of mandatory attributes and functions and a list of optional features."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 9 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§5.2.4" },

            Field({
                name: "PIN", conformance: "O", constraint: "0", title: "PinCredential", xref: "cluster§5.2.4.1",

                details: "If the User Feature is also supported then any PIN Code stored in the lock shall be associated with " +
                    "a User." +
                    "\n" +
                    "A lock may support multiple credential types so if the User feature is supported the UserType, " +
                    "UserStatus and Schedules are all associated with a User index and not directly with a PIN index. A " +
                    "User index may have several credentials associated with it."
            }),

            Field({
                name: "RID", conformance: "O", constraint: "1", title: "RfidCredential", xref: "cluster§5.2.4.2",

                details: "If the User Feature is also supported then any RFID credential stored in the lock shall be " +
                    "associated with a User." +
                    "\n" +
                    "A lock may support multiple credential types so if the User feature is supported the UserType, " +
                    "UserStatus and Schedules are all associated with a User index and not directly with a RFID index. A " +
                    "User Index may have several credentials associated with it."
            }),

            Field({
                name: "FGP", conformance: "P, O", constraint: "2", title: "FingerCredentials",
                xref: "cluster§5.2.4.3",

                details: "Currently the cluster only defines the metadata format for notifications when a fingerprint/ finger " +
                    "vein credential is used to access the lock and doesn’t describe how to create fingerprint/finger " +
                    "vein credentials. If the Users feature is also supported then the User that a fingerprint/finger " +
                    "vein is associated with can also have its UserType, UserStatus and Schedule modified." +
                    "\n" +
                    "A lock may support multiple credential types so if the User feature is supported the UserType, " +
                    "UserStatus and Schedules are all associated with a User index and not directly with a Finger index. " +
                    "A User Index may have several credentials associated with it."
            }),

            Field({
                name: "WDSCH", conformance: "O", constraint: "4", title: "WeekDayAccessSchedules",
                xref: "cluster§5.2.4.4",

                details: "If the User feature is supported then Week Day Schedules are applied to a User and not a credential." +
                    "\n" +
                    "Week Day Schedules are used to restrict access to a specified time window on certain days of the " +
                    "week. The schedule is repeated each week." +
                    "\n" +
                    "The lock may automatically adjust the UserType when a schedule is created or cleared." +
                    "\n" +
                    "Support for WeekDayAccessSchedules requires that the lock has the capability of keeping track of " +
                    "local time."
            }),

            Field({
                name: "DPS", conformance: "O", constraint: "5", title: "DoorPositionSensor",
                xref: "cluster§5.2.4.5",
                details: "If this feature is supported this indicates that the lock has the ability to determine the position " +
                    "of the door which is separate from the state of the lock."
            }),

            Field({
                name: "FACE", conformance: "P, O", constraint: "6", title: "FaceCredentials",
                xref: "cluster§5.2.4.6",

                details: "Currently the cluster only defines the metadata format for notifications when a face recognition, " +
                    "iris, or retina credential is used to access the lock and doesn’t describe how to create face " +
                    "recognition, iris, or retina credentials. If the Users feature is also supported then the User that " +
                    "a face recognition, iris, or retina credential is associated with can also have its UserType, " +
                    "UserStatus and Schedule modified." +
                    "\n" +
                    "A lock may support multiple credential types so if the User feature is supported the UserType, " +
                    "UserStatus and Schedules are all associated with a User and not directly with a credential."
            }),

            Field({
                name: "COTA", conformance: "O", constraint: "7", title: "CredentialOverTheAirAccess",
                xref: "cluster§5.2.4.7",
                details: "If this feature is supported then the lock supports the ability to verify a credential provided in a " +
                    "lock/unlock command. Currently the cluster only supports providing the PIN credential to the " +
                    "lock/unlock commands. If this feature is supported then the PIN Credential feature shall also be " +
                    "supported."
            }),

            Field({
                name: "USR", conformance: "ALIRO, [PIN | RID | FGP | FACE]", constraint: "8", title: "User",
                xref: "cluster§5.2.4.8",
                details: "If the User Feature is supported then a lock employs a User database. A User within the User " +
                    "database is used to associate credentials and schedules to single user record within the lock. This " +
                    "also means the UserType and UserStatus fields are associated with a User and not a credential."
            }),

            Field({
                name: "YDSCH", conformance: "O", constraint: "10", title: "YearDayAccessSchedules",
                xref: "cluster§5.2.4.9",

                details: "If the User feature is supported then Year Day Schedules are applied to a User and not a credential. " +
                    "Year Day Schedules are used to restrict access to a specified date and time window." +
                    "\n" +
                    "The lock may automatically adjust the UserType when a schedule is created or cleared." +
                    "\n" +
                    "Support for YearDayAccessSchedules requires that the lock has the capability of keeping track of " +
                    "local time."
            }),

            Field({
                name: "HDSCH", conformance: "O", constraint: "11", title: "HolidaySchedules",
                xref: "cluster§5.2.4.10",
                details: "This feature is used to setup Holiday Schedule in the lock device. A Holiday Schedule sets a start " +
                    "and stop end date/time for the lock to use the specified operating mode set by the Holiday Schedule." +
                    "\n" +
                    "Support for HolidaySchedules requires that the lock has the capability of keeping track of local " +
                    "time."
            }),

            Field({
                name: "UBOLT", conformance: "O", constraint: "12", title: "Unbolting", xref: "cluster§5.2.4.11",
                details: "Locks that support this feature differentiate between unbolting and unlocking. The Unbolt Door " +
                    "command retracts the bolt without pulling the latch. The Unlock Door command fully unlocks the door " +
                    "by retracting the bolt and briefly pulling the latch. While the latch is pulled, the lock state " +
                    "changes to Unlatched. Locks without unbolting support don’t differentiate between unbolting and " +
                    "unlocking and perform the same operation for both commands."
            }),

            Field({
                name: "ALIRO", conformance: "O", constraint: "13", title: "AliroProvisioning",
                xref: "cluster§5.2.4.12",
                details: "Locks that support this feature implement the Aliro specification as defined in [Aliro] and support " +
                    "Matter as a method for provisioning Aliro credentials."
            }),

            Field({
                name: "ALBU", conformance: "[ALIRO]", constraint: "14", title: "AliroBleuwb",
                xref: "cluster§5.2.4.13",
                details: "Locks that support this feature implement the Bluetooth LE + UWB Access Control Flow as defined in " +
                    "[Aliro]."
            })
        ),

        Attribute({
            name: "LockState", id: 0x0, type: "LockStateEnum", access: "R V", conformance: "M",
            constraint: "desc", quality: "X P", xref: "cluster§5.2.9.1",

            details: "This attribute may be NULL if the lock hardware does not currently know the status of the locking " +
                "mechanism. For example, a lock may not know the LockState status after a power cycle until the first " +
                "lock actuation is completed." +
                "\n" +
                "The Not Fully Locked value is used by a lock to indicate that the state of the lock is somewhere " +
                "between Locked and Unlocked so it is only partially secured. For example, a deadbolt could be " +
                "partially extended and not in a dead latched state."
        }),

        Attribute({
            name: "LockType", id: 0x1, type: "LockTypeEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§5.2.9.2",
            details: "Indicates the type of door lock as defined in LockTypeEnum."
        }),

        Attribute({
            name: "ActuatorEnabled", id: 0x2, type: "bool", access: "R V", conformance: "M",
            xref: "cluster§5.2.9.3",
            details: "Indicates if the lock is currently able to (Enabled) or not able to (Disabled) process remote Lock, " +
                "Unlock, or Unlock with Timeout commands."
        }),

        Attribute({
            name: "DoorState", id: 0x3, type: "DoorStateEnum", access: "R V", conformance: "DPS",
            constraint: "desc", quality: "X P", xref: "cluster§5.2.9.4",
            details: "Indicates the current door state as defined in DoorStateEnum." +
                "\n" +
                "Null only if an internal error prevents the retrieval of the current door state."
        }),

        Attribute({
            name: "DoorOpenEvents", id: 0x4, type: "uint32", access: "RW VM", conformance: "[DPS]",
            xref: "cluster§5.2.9.5",
            details: "This attribute shall hold the number of door open events that have occurred since it was last " +
                "zeroed."
        }),

        Attribute({
            name: "DoorClosedEvents", id: 0x5, type: "uint32", access: "RW VM", conformance: "[DPS]",
            xref: "cluster§5.2.9.6",
            details: "This attribute shall hold the number of door closed events that have occurred since it was last " +
                "zeroed."
        }),

        Attribute({
            name: "OpenPeriod", id: 0x6, type: "uint16", access: "RW VM", conformance: "[DPS]",
            xref: "cluster§5.2.9.7",
            details: "This attribute shall hold the number of minutes the door has been open since the last time it " +
                "transitioned from closed to open."
        }),

        Attribute({
            name: "NumberOfTotalUsersSupported", id: 0x11, type: "uint16", access: "R V", conformance: "USR",
            quality: "F", xref: "cluster§5.2.9.8",
            details: "Indicates the number of total users supported by the lock."
        }),
        Attribute({
            name: "NumberOfPinUsersSupported", id: 0x12, type: "uint16", access: "R V", conformance: "PIN",
            quality: "F", xref: "cluster§5.2.9.9",
            details: "Indicates the number of PIN users supported."
        }),
        Attribute({
            name: "NumberOfRfidUsersSupported", id: 0x13, type: "uint16", access: "R V", conformance: "RID",
            quality: "F", xref: "cluster§5.2.9.10",
            details: "Indicates the number of RFID users supported."
        }),
        Attribute({
            name: "NumberOfWeekDaySchedulesSupportedPerUser", id: 0x14, type: "uint8", access: "R V",
            conformance: "WDSCH", constraint: "max 253", quality: "F", xref: "cluster§5.2.9.11",
            details: "Indicates the number of configurable week day schedule supported per user."
        }),
        Attribute({
            name: "NumberOfYearDaySchedulesSupportedPerUser", id: 0x15, type: "uint8", access: "R V",
            conformance: "YDSCH", constraint: "max 253", quality: "F", xref: "cluster§5.2.9.12",
            details: "Indicates the number of configurable year day schedule supported per user."
        }),
        Attribute({
            name: "NumberOfHolidaySchedulesSupported", id: 0x16, type: "uint8", access: "R V",
            conformance: "HDSCH", constraint: "max 253", quality: "F", xref: "cluster§5.2.9.13",
            details: "Indicates the number of holiday schedules supported for the entire door lock device."
        }),
        Attribute({
            name: "MaxPinCodeLength", id: 0x17, type: "uint8", access: "R V", conformance: "PIN", quality: "F",
            xref: "cluster§5.2.9.14",
            details: "Indicates the maximum length in bytes of a PIN Code on this device."
        }),
        Attribute({
            name: "MinPinCodeLength", id: 0x18, type: "uint8", access: "R V", conformance: "PIN", quality: "F",
            xref: "cluster§5.2.9.15",
            details: "Indicates the minimum length in bytes of a PIN Code on this device."
        }),

        Attribute({
            name: "MaxRfidCodeLength", id: 0x19, type: "uint8", access: "R V", conformance: "RID", quality: "F",
            xref: "cluster§5.2.9.16",
            details: "Indicates the maximum length in bytes of a RFID Code on this device. The value depends on the RFID " +
                "code range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID " +
                "code, a value of 20 (equals 10 Byte ISO 14443A UID) is recommended."
        }),

        Attribute({
            name: "MinRfidCodeLength", id: 0x1a, type: "uint8", access: "R V", conformance: "RID", quality: "F",
            xref: "cluster§5.2.9.17",
            details: "Indicates the minimum length in bytes of a RFID Code on this device. The value depends on the RFID " +
                "code range specified by the manufacturer, if media anti-collision identifiers (UID) are used as RFID " +
                "code, a value of 8 (equals 4 Byte ISO 14443A UID) is recommended."
        }),

        Attribute({
            name: "CredentialRulesSupport", id: 0x1b, type: "CredentialRulesBitmap", access: "R V",
            conformance: "USR", quality: "F", xref: "cluster§5.2.9.18",
            details: "This attribute shall contain a bitmap with the bits set for the values of CredentialRuleEnum " +
                "supported on this device."
        }),

        Attribute({
            name: "NumberOfCredentialsSupportedPerUser", id: 0x1c, type: "uint8", access: "R V",
            conformance: "USR", quality: "F", xref: "cluster§5.2.9.19",

            details: "Indicates the number of credentials that could be assigned for each user." +
                "\n" +
                "Depending on the value of NumberOfRFIDUsersSupported and NumberOfPINUsersSupported it may not be " +
                "possible to assign that number of credentials for a user." +
                "\n" +
                "For example, if the device supports only PIN and RFID credential types, " +
                "NumberOfCredentialsSupportedPerUser is set to 10, NumberOfPINUsersSupported is set to 5 and " +
                "NumberOfRFIDUsersSupported is set to 3, it will not be possible to actually assign 10 credentials " +
                "for a user because maximum number of credentials in the database is 8."
        }),

        Attribute({
            name: "Language", id: 0x21, type: "string", access: "R[W] VM", conformance: "O",
            constraint: "max 3", quality: "P", xref: "cluster§5.2.9.20",
            details: "Indicates the language for the on-screen or audible user interface using a 2- byte language code " +
                "from ISO-639-1."
        }),

        Attribute({
            name: "LedSettings", id: 0x22, type: "LEDSettingEnum", access: "R[W] VM", conformance: "O",
            default: 0, quality: "P", xref: "cluster§5.2.9.21",
            details: "Indicates the settings for the LED support, as defined by LEDSettingEnum."
        }),

        Attribute({
            name: "AutoRelockTime", id: 0x23, type: "uint32", access: "R[W] VM", conformance: "O", quality: "P",
            xref: "cluster§5.2.9.22",
            details: "Indicates the number of seconds to wait after unlocking a lock before it automatically locks again. " +
                "0=disabled. If set, unlock operations from any source will be timed. For one time unlock with " +
                "timeout use the specific command."
        }),

        Attribute({
            name: "SoundVolume", id: 0x24, type: "SoundVolumeEnum", access: "R[W] VM", conformance: "O",
            default: 0, quality: "P", xref: "cluster§5.2.9.23",
            details: "Indicates the sound volume on a door lock as defined by SoundVolumeEnum."
        }),
        Attribute({
            name: "OperatingMode", id: 0x25, type: "OperatingModeEnum", access: "R[W] VM", conformance: "M",
            constraint: "desc", quality: "P", xref: "cluster§5.2.9.24",
            details: "Indicates the current operating mode of the lock as defined in OperatingModeEnum."
        }),

        Attribute({
            name: "SupportedOperatingModes", id: 0x26, type: "OperatingModesBitmap", access: "R V",
            conformance: "M", quality: "F", xref: "cluster§5.2.9.25",

            details: "This attribute shall contain a bitmap with all operating bits of the OperatingMode attribute " +
                "supported by the lock." +
                "\n" +
                "A bit position set to zero shall indicate that the mode is supported. A bit position set to one " +
                "shall indicate that the mode is not supported." +
                "\n" +
                "Any bit that is not yet defined in OperatingModesBitmap shall be set to 1." +
                "\n" +
                "The values considered valid to read or write in the OperatingMode attribute shall be the enum values " +
                "from DoorLockOperatingModeEnum whose equivalent same-named bit from OperatingModesBitmap is set to " +
                "zero in this attribute. WARNING: This is the opposite of most other semantically similar bitmaps in " +
                "this specification."
        }),

        Attribute({
            name: "DefaultConfigurationRegister", id: 0x27, type: "ConfigurationRegisterBitmap", access: "R V",
            conformance: "O", default: 0, quality: "P", xref: "cluster§5.2.9.26",

            details: "Indicates the default configurations as they are physically set on the device (example: hardware dip " +
                "switch setting, etc…) and represents the default setting for some of the attributes within this " +
                "cluster (for example: LED, Auto Lock, Sound Volume, and Operating Mode attributes)." +
                "\n" +
                "This is a read-only attribute and is intended to allow clients to determine what changes may need to " +
                "be made without having to query all the included attributes. It may be beneficial for the clients to " +
                "know what the device’s original settings were in the event that the device needs to be restored to " +
                "factory default settings." +
                "\n" +
                "If the Client device would like to query and modify the door lock server’s operating settings, it " +
                "SHOULD send read and write attribute requests to the specific attributes." +
                "\n" +
                "For example, the Sound Volume attribute default value is Silent Mode. However, it is possible that " +
                "the current Sound Volume is High Volume. Therefore, if the client wants to query/modify the current " +
                "Sound Volume setting on the server, the client SHOULD read/write to the Sound Volume attribute."
        }),

        Attribute({
            name: "EnableLocalProgramming", id: 0x28, type: "bool", access: "R[W] VA", conformance: "O",
            default: true, quality: "P", xref: "cluster§5.2.9.27",
            details: "This attribute shall enable/disable local programming on the door lock of certain features (see " +
                "LocalProgrammingFeatures attribute). If this value is set to TRUE then local programming is enabled " +
                "on the door lock for all features. If it is set to FALSE then local programming is disabled on the " +
                "door lock for those features whose bit is set to 0 in the LocalProgrammingFeatures attribute. Local " +
                "programming shall be enabled by default."
        }),

        Attribute({
            name: "EnableOneTouchLocking", id: 0x29, type: "bool", access: "RW VM", conformance: "O",
            default: true, quality: "P", xref: "cluster§5.2.9.28",
            details: "This attribute shall enable/disable the ability to lock the door lock with a single touch on the " +
                "door lock."
        }),

        Attribute({
            name: "EnableInsideStatusLed", id: 0x2a, type: "bool", access: "RW VM", conformance: "O",
            default: true, quality: "P", xref: "cluster§5.2.9.29",
            details: "This attribute shall enable/disable an inside LED that allows the user to see at a glance if the " +
                "door is locked."
        }),

        Attribute({
            name: "EnablePrivacyModeButton", id: 0x2b, type: "bool", access: "RW VM", conformance: "O",
            default: true, quality: "P", xref: "cluster§5.2.9.30",
            details: "This attribute shall enable/disable a button inside the door that is used to put the lock into " +
                "privacy mode. When the lock is in privacy mode it cannot be manipulated from the outside."
        }),

        Attribute({
            name: "LocalProgrammingFeatures", id: 0x2c, type: "LocalProgrammingFeaturesBitmap",
            access: "R[W] VA", conformance: "O", default: 0, quality: "P", xref: "cluster§5.2.9.31",

            details: "Indicates the local programming features that will be disabled when EnableLocalProgramming attribute " +
                "is set to False. If a door lock doesn’t support disabling one aspect of local programming it shall " +
                "return CONSTRAINT_ERROR during a write operation of this attribute. If the EnableLocalProgramming " +
                "attribute is set to True then all local programming features shall be enabled regardless of the bits " +
                "set to 0 in this attribute." +
                "\n" +
                "The features that can be disabled from local programming are defined in " +
                "LocalProgrammingFeaturesBitmap."
        }),

        Attribute({
            name: "WrongCodeEntryLimit", id: 0x30, type: "uint8", access: "R[W] VA", conformance: "PIN | RID",
            constraint: "1 to 255", quality: "P", xref: "cluster§5.2.9.32",

            details: "Indicates the number of incorrect Pin codes or RFID presentment attempts a user is allowed to enter " +
                "before the lock will enter a lockout state. The value of this attribute is compared to all failing " +
                "forms of credential presentation, including Pin codes used in an Unlock Command when " +
                "RequirePINforRemoteOperation is set to true. Valid range is 1-255 incorrect attempts. The lockout " +
                "state will be for the duration of UserCodeTemporaryDisableTime. If the attribute accepts writes and " +
                "an attempt to write the value 0 is made, the device shall respond with CONSTRAINT_ERROR." +
                "\n" +
                "The lock may reset the counter used to track incorrect credential presentations as required by " +
                "internal logic, environmental events, or other reasons. The lock shall reset the counter if a valid " +
                "credential is presented."
        }),

        Attribute({
            name: "UserCodeTemporaryDisableTime", id: 0x31, type: "uint8", access: "R[W] VA",
            conformance: "PIN | RID", constraint: "1 to 255", quality: "P", xref: "cluster§5.2.9.33",
            details: "Indicates the number of seconds that the lock shuts down following wrong code entry. Valid range is " +
                "1-255 seconds. Device can shut down to lock user out for specified amount of time. (Makes it " +
                "difficult to try and guess a PIN for the device.) If the attribute accepts writes and an attempt to " +
                "write the attribute to 0 is made, the device shall respond with CONSTRAINT_ERROR."
        }),

        Attribute({
            name: "SendPinOverTheAir", id: 0x32, type: "bool", access: "R[W] VA", conformance: "[!USR & PIN]",
            default: true, quality: "P", xref: "cluster§5.2.9.34",

            details: "Indicates the door locks ability to send PINs over the air. If the attribute is True it is ok for " +
                "the door lock server to send PINs over the air. This attribute determines the behavior of the " +
                "server’s TX operation. If it is false, then it is not ok for the device to send PIN in any messages " +
                "over the air." +
                "\n" +
                "The PIN field within any door lock cluster message shall keep the first octet unchanged and masks " +
                "the actual code by replacing with 0xFF. For example (PIN \"1234\" ): If the attribute value is True, " +
                "0x04 0x31 0x32 0x33 0x34 shall be used in the PIN field in any door lock cluster message payload. If " +
                "the attribute value is False, 0x04 0xFF 0xFF 0xFF 0xFF shall be used."
        }),

        Attribute({
            name: "RequirePinForRemoteOperation", id: 0x33, type: "bool", access: "R[W] VA",
            conformance: "COTA & PIN", quality: "P", xref: "cluster§5.2.9.35",
            details: "Indicates if the door lock requires an optional PIN. If this attribute is set to True, the door lock " +
                "server requires that an optional PINs be included in the payload of remote lock operation events " +
                "like Lock, Unlock, Unlock with Timeout and Toggle in order to function."
        }),

        Attribute(
            { name: "SecurityLevel", id: 0x34, access: "R V", conformance: "D", default: "0", xref: "cluster§5.2.9" }
        ),

        Attribute({
            name: "ExpiringUserTimeout", id: 0x35, type: "uint16", access: "R[W] VA", conformance: "[USR]",
            constraint: "1 to 2880", quality: "P", xref: "cluster§5.2.9.36",
            details: "Indicates the number of minutes a PIN, RFID, Fingerprint, or other credential associated with a user " +
                "of type ExpiringUser shall remain valid after its first use before expiring. When the credential " +
                "expires the UserStatus for the corresponding user record shall be set to OccupiedDisabled."
        }),

        Attribute({
            name: "AliroReaderVerificationKey", id: 0x80, type: "octstr", access: "R A", conformance: "ALIRO",
            constraint: "65", quality: "X", xref: "cluster§5.2.9.37",

            details: "Indicates the verification key component of the Reader’s key pair as defined in [Aliro]. The value, " +
                "if not null, shall be an uncompressed elliptic curve public key as defined in section 2.3.3 of SEC " +
                "1." +
                "\n" +
                "Null if no Reader key pair has been configured on the lock. See Section 5.2.10.42, " +
                "“SetAliroReaderConfig Command”."
        }),

        Attribute({
            name: "AliroReaderGroupIdentifier", id: 0x81, type: "octstr", access: "R A", conformance: "ALIRO",
            constraint: "16", quality: "X", xref: "cluster§5.2.9.38",
            details: "Indicates the reader_group_identifier as defined in [Aliro]." +
                "\n" +
                "Null if no reader_group_identifier has been configured on the lock. See Section 5.2.10.42, " +
                "“SetAliroReaderConfig Command”."
        }),

        Attribute({
            name: "AliroReaderGroupSubIdentifier", id: 0x82, type: "octstr", access: "R A",
            conformance: "ALIRO", constraint: "16", quality: "F", xref: "cluster§5.2.9.39",
            details: "Indicates the reader_group_sub_identifier as defined in [Aliro]."
        }),

        Attribute(
            {
                name: "AliroExpeditedTransactionSupportedProtocolVersions", id: 0x83, type: "list", access: "R A",
                conformance: "ALIRO", constraint: "max 16[2]", quality: "F", xref: "cluster§5.2.9.40",
                details: "Indicates the list of protocol versions supported for expedited transactions as defined in [Aliro]."
            },
            Field({ name: "entry", type: "octstr" })
        ),

        Attribute({
            name: "AliroGroupResolvingKey", id: 0x84, type: "octstr", access: "R A", conformance: "ALBU",
            constraint: "16", quality: "X", xref: "cluster§5.2.9.41",
            details: "Indicates the Group Resolving Key as defined in [Aliro]." +
                "\n" +
                "Null if no group resolving key has been configured on the lock. See Section 5.2.10.42, " +
                "“SetAliroReaderConfig Command”."
        }),

        Attribute(
            {
                name: "AliroSupportedBleuwbProtocolVersions", id: 0x85, type: "list", access: "R A",
                conformance: "ALBU", constraint: "max 16[2]", quality: "F", xref: "cluster§5.2.9.42",
                details: "Indicates the list of protocol versions supported for the Bluetooth LE + UWB Access Control Flow as " +
                    "defined in [Aliro]."
            },

            Field({ name: "entry", type: "octstr" })
        ),

        Attribute({
            name: "AliroBleAdvertisingVersion", id: 0x86, type: "uint8", access: "R A", conformance: "ALBU",
            quality: "F", xref: "cluster§5.2.9.43",
            details: "Indicates the version of the Bluetooth LE advertisement as defined in [Aliro]."
        }),
        Attribute({
            name: "NumberOfAliroCredentialIssuerKeysSupported", id: 0x87, type: "uint16", access: "R V",
            conformance: "ALIRO", quality: "F", xref: "cluster§5.2.9.44",
            details: "Indicates the maximum number of AliroCredentialIssuerKey credentials that can be stored on the lock."
        }),

        Attribute({
            name: "NumberOfAliroEndpointKeysSupported", id: 0x88, type: "uint16", access: "R V",
            conformance: "ALIRO", quality: "F", xref: "cluster§5.2.9.45",

            details: "Indicates the maximum number of endpoint key credentials that can be stored on the lock. This limit " +
                "applies to the sum of the number of AliroEvictableEndpointKey credentials and the number of " +
                "AliroNonEvictableEndpointKey credentials." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> The credential indices used for these two credential types are independent of each other, similar " +
                "  to all other credential types. As long as NumberOfAliroEndpointKeysSupported is at least 2 a " +
                "  client could add a credential of type AliroEvictableEndpointKey at any index from 1 to " +
                "  NumberOfAliroEndpointKeysSupported and also add a credential of type AliroNonEvictableEndpointKey " +
                "  at the same index, and both credentials would exist on the server."
        }),

        Event(
            {
                name: "DoorLockAlarm", id: 0x0, access: "V", conformance: "M", priority: "critical",
                xref: "cluster§5.2.11.1",
                details: "The door lock server provides several alarms which can be sent when there is a critical state on the " +
                    "door lock. The alarms available for the door lock server are listed in AlarmCodeEnum."
            },

            Field({
                name: "AlarmCode", id: 0x0, type: "AlarmCodeEnum", conformance: "M", xref: "cluster§5.2.11.1.1",
                details: "This field shall indicate the alarm code of the event that has happened."
            })
        ),

        Event(
            {
                name: "DoorStateChange", id: 0x1, access: "V", conformance: "DPS", priority: "critical",
                xref: "cluster§5.2.11.2",
                details: "The door lock server sends out a DoorStateChange event when the door lock door state changes."
            },
            Field({
                name: "DoorState", id: 0x0, type: "DoorStateEnum", conformance: "M", xref: "cluster§5.2.11.2.1",
                details: "This field shall indicate the new door state for this door event."
            })
        ),

        Event(
            {
                name: "LockOperation", id: 0x2, access: "V", conformance: "M", priority: "critical",
                xref: "cluster§5.2.11.3",

                details: "The door lock server sends out a LockOperation event when the event is triggered by the various lock " +
                    "operation sources." +
                    "\n" +
                    "  • If the door lock server supports the Unbolt Door command, it shall generate a LockOperation " +
                    "    event with LockOperationType set to Unlock after an Unbolt Door command succeeds." +
                    "\n" +
                    "  • If the door lock server supports the Unbolting feature and an Unlock Door command is performed, " +
                    "    it shall generate a LockOperation event with LockOperationType set to Unlatch when the unlatched " +
                    "    state is reached and a LockOperation event with LockOperationType set to Unlock when the lock " +
                    "    successfully completes the unlock → hold latch → release latch and return to unlock state " +
                    "    operation." +
                    "\n" +
                    "  • If the command fails during holding or releasing the latch but after passing the unlocked state, " +
                    "    the door lock server shall generate a LockOperationError event with LockOperationType set to " +
                    "    Unlatch and a LockOperation event with LockOperationType set to Unlock." +
                    "\n" +
                    "    ◦ If it fails before reaching the unlocked state, the door lock server shall generate only a " +
                    "      LockOperationError event with LockOperationType set to Unlock." +
                    "\n" +
                    "  • Upon manual actuation, a door lock server that supports the Unbolting feature:" +
                    "\n" +
                    "    ◦ shall generate a LockOperation event of LockOperationType Unlatch when it is actuated from the " +
                    "      outside." +
                    "\n" +
                    "    ◦ may generate a LockOperation event of LockOperationType Unlatch when it is actuated" +
                    "\n" +
                    "from the inside."
            },

            Field({
                name: "LockOperationType", id: 0x0, type: "LockOperationTypeEnum", conformance: "M",
                xref: "cluster§5.2.11.3.1",
                details: "This field shall indicate the type of the lock operation that was performed."
            }),
            Field({
                name: "OperationSource", id: 0x1, type: "OperationSourceEnum", conformance: "M",
                xref: "cluster§5.2.11.3.2",
                details: "This field shall indicate the source of the lock operation that was performed."
            }),

            Field({
                name: "UserIndex", id: 0x2, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.3.3",
                details: "This field shall indicate the UserIndex who performed the lock operation. This shall be null if " +
                    "there is no user index that can be determined for the given operation source. This shall NOT be null " +
                    "if a user index can be determined. In particular, this shall NOT be null if the operation was " +
                    "associated with a valid credential."
            }),

            Field({
                name: "FabricIndex", id: 0x3, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.3.4",
                details: "This field shall indicate the fabric index of the fabric that performed the lock operation. This " +
                    "shall be null if there is no fabric that can be determined for the given operation source. This " +
                    "shall NOT be null if the operation source is \"Remote\"."
            }),

            Field({
                name: "SourceNode", id: 0x4, type: "node-id", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.3.5",
                details: "This field shall indicate the Node ID of the node that performed the lock operation. This shall be " +
                    "null if there is no Node associated with the given operation source. This shall NOT be null if the " +
                    "operation source is \"Remote\"."
            }),

            Field(
                {
                    name: "Credentials", id: 0x5, type: "list", conformance: "[USR]",
                    constraint: "1 to numberOfCredentialsSupportedPerUser", quality: "X", xref: "cluster§5.2.11.3.6",
                    details: "This field shall indicate the list of credentials used in performing the lock operation. This shall " +
                        "be null if no credentials were involved."
                },

                Field({ name: "entry", type: "CredentialStruct" })
            )
        ),

        Event(
            {
                name: "LockOperationError", id: 0x3, access: "V", conformance: "M", priority: "critical",
                xref: "cluster§5.2.11.4",
                details: "The door lock server sends out a LockOperationError event when a lock operation fails for various " +
                    "reasons."
            },

            Field({
                name: "LockOperationType", id: 0x0, type: "LockOperationTypeEnum", conformance: "M",
                xref: "cluster§5.2.11.4.1",
                details: "This field shall indicate the type of the lock operation that was performed."
            }),
            Field({
                name: "OperationSource", id: 0x1, type: "OperationSourceEnum", conformance: "M",
                xref: "cluster§5.2.11.4.2",
                details: "This field shall indicate the source of the lock operation that was performed."
            }),
            Field({
                name: "OperationError", id: 0x2, type: "OperationErrorEnum", conformance: "M",
                xref: "cluster§5.2.11.4.3",
                details: "This field shall indicate the lock operation error triggered when the operation was performed."
            }),

            Field({
                name: "UserIndex", id: 0x3, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.4.4",
                details: "This field shall indicate the lock UserIndex who performed the lock operation. This shall be null if " +
                    "there is no user id that can be determined for the given operation source."
            }),

            Field({
                name: "FabricIndex", id: 0x4, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.4.5",
                details: "This field shall indicate the fabric index of the fabric that performed the lock operation. This " +
                    "shall be null if there is no fabric that can be determined for the given operation source. This " +
                    "shall NOT be null if the operation source is \"Remote\"."
            }),

            Field({
                name: "SourceNode", id: 0x5, type: "node-id", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.4.6",
                details: "This field shall indicate the Node ID of the node that performed the lock operation. This shall be " +
                    "null if there is no Node associated with the given operation source. This shall NOT be null if the " +
                    "operation source is \"Remote\"."
            }),

            Field(
                {
                    name: "Credentials", id: 0x6, type: "list", conformance: "[USR]",
                    constraint: "1 to numberOfCredentialsSupportedPerUser", quality: "X", xref: "cluster§5.2.11.4.7",
                    details: "This field shall indicate the list of credentials used in performing the lock operation. This shall " +
                        "be null if no credentials were involved."
                },

                Field({ name: "entry", type: "CredentialStruct" })
            )
        ),

        Event(
            {
                name: "LockUserChange", id: 0x4, access: "V", conformance: "USR", priority: "info",
                xref: "cluster§5.2.11.5",
                details: "The door lock server sends out a LockUserChange event when a lock user, schedule, or credential " +
                    "change has occurred."
            },

            Field({
                name: "LockDataType", id: 0x0, type: "LockDataTypeEnum", conformance: "M",
                xref: "cluster§5.2.11.5.1",
                details: "This field shall indicate the lock data type that was changed."
            }),
            Field({
                name: "DataOperationType", id: 0x1, type: "DataOperationTypeEnum", conformance: "M",
                xref: "cluster§5.2.11.5.2",
                details: "This field shall indicate the data operation performed on the lock data type changed."
            }),
            Field({
                name: "OperationSource", id: 0x2, type: "OperationSourceEnum", conformance: "M",
                constraint: "aliro, unspecified, keypad, remote", xref: "cluster§5.2.11.5.3",
                details: "This field shall indicate the source of the user data change."
            }),

            Field({
                name: "UserIndex", id: 0x3, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.5.4",
                details: "This field shall indicate the lock UserIndex associated with the change (if any). This shall be null " +
                    "if there is no specific user associated with the data operation. This shall be 0xFFFE if all users " +
                    "are affected (e.g. Clear Users)."
            }),

            Field({
                name: "FabricIndex", id: 0x4, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.5.5",
                details: "This field shall indicate the fabric index of the fabric that performed the change (if any). This " +
                    "shall be null if there is no fabric that can be determined to have caused the change. This shall NOT " +
                    "be null if the operation source is \"Remote\"."
            }),

            Field({
                name: "SourceNode", id: 0x5, type: "node-id", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.5.6",
                details: "This field shall indicate the Node ID that performed the change (if any). The Node ID of the node " +
                    "that performed the change. This shall be null if there was no Node involved in the change. This " +
                    "shall NOT be null if the operation source is \"Remote\"."
            }),

            Field({
                name: "DataIndex", id: 0x6, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§5.2.11.5.7",
                details: "This field shall indicate the index of the specific item that was changed (e.g. schedule, PIN, RFID, " +
                    "etc.) in the list of items identified by LockDataType. This shall be null if the LockDataType does " +
                    "not correspond to a list that can be indexed into (e.g. ProgrammingUser). This shall be 0xFFFE if " +
                    "all indices are affected (e.g. ClearPINCode, ClearRFIDCode, ClearWeekDaySchedule, " +
                    "ClearYearDaySchedule, etc.)."
            })
        ),

        Command(
            {
                name: "LockDoor", id: 0x0, access: "O T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§5.2.10.1",
                details: "This command causes the lock device to lock the door. This command includes an optional code for the " +
                    "lock. The door lock may require a PIN depending on the value of the RequirePINForRemoteOperation " +
                    "attribute."
            },

            Field({
                name: "PinCode", id: 0x0, type: "octstr", conformance: "[COTA & PIN]", xref: "cluster§5.2.10.1.1",

                details: "If the RequirePINforRemoteOperation attribute is True then PINCode field shall be provided and the " +
                    "door lock shall NOT grant access if it is not provided." +
                    "\n" +
                    "If the PINCode field is provided, the door lock shall verify PINCode before granting access " +
                    "regardless of the value of RequirePINForRemoteOperation attribute." +
                    "\n" +
                    "When the PINCode field is provided an invalid PIN will count towards the WrongCodeEntryLimit and the " +
                    "UserCodeTemporaryDisableTime will be triggered if the WrongCodeEntryLimit is exceeded. The lock " +
                    "shall ignore any attempts to lock/unlock the door until the UserCodeTemporaryDisableTime expires."
            })
        ),

        Command(
            {
                name: "UnlockDoor", id: 0x1, access: "O T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§5.2.10.2",

                details: "This command causes the lock device to unlock the door. This command includes an optional code for " +
                    "the lock. The door lock may require a code depending on the value of the " +
                    "RequirePINForRemoteOperation attribute." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> If the attribute AutoRelockTime is supported the lock will transition to the locked state when the " +
                    "  auto relock time has expired."
            },

            Field({
                name: "PinCode", id: 0x0, type: "octstr", conformance: "[COTA & PIN]", xref: "cluster§5.2.10.2.1",
                details: "See Section 5.2.10.1.1, “PINCode Field”."
            })
        ),

        Command({
            name: "Toggle", id: 0x2, access: "O T", conformance: "X", direction: "request", response: "status",
            xref: "cluster§5.2.10"
        }),

        Command(
            {
                name: "UnlockWithTimeout", id: 0x3, access: "O T", conformance: "O", direction: "request",
                response: "status", xref: "cluster§5.2.10.3",
                details: "This command causes the lock device to unlock the door with a timeout parameter. After the time in " +
                    "seconds specified in the timeout field, the lock device will relock itself automatically. This " +
                    "timeout parameter is only temporary for this message transition and overrides the default relock " +
                    "time as specified in the AutoRelockTime attribute. If the door lock device is not capable of or does " +
                    "not want to support temporary Relock Timeout, it SHOULD NOT support this optional command."
            },

            Field({
                name: "Timeout", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§5.2.10.3.1",
                details: "This field shall indicate the timeout in seconds to wait before relocking the door lock. This value " +
                    "is independent of the AutoRelockTime attribute value."
            }),
            Field({
                name: "PinCode", id: 0x1, type: "octstr", conformance: "[COTA & PIN]", xref: "cluster§5.2.10.3.2",
                details: "See Section 5.2.10.1.1, “PINCode Field”."
            })
        ),

        Command(
            {
                name: "SetPinCode", id: 0x5, access: "A T", conformance: "!USR & PIN", direction: "request",
                response: "status", xref: "cluster§5.2.10.4",
                details: "Set a PIN Code into the lock." +
                    "\n" +
                    "Return status is a global status code or a cluster-specific status code from the Status Codes table " +
                    "and shall be one of the following values:"
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.4.1",
                details: "This field shall indicate the user ID. The value of the UserID field shall be between 0 and the " +
                    "value of the NumberOfPINUsersSupported attribute."
            }),

            Field({
                name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.4.2",
                details: "This field shall indicate the user status. Only the values 1 (Occupied/Enabled) and 3 " +
                    "(Occupied/Disabled) are allowed for UserStatus."
            }),

            Field({ name: "UserType", id: 0x2, type: "UserTypeEnum", conformance: "M", quality: "X" }),
            Field({ name: "Pin", id: 0x3, type: "octstr", conformance: "M" })
        ),

        Command(
            {
                name: "GetPinCode", id: 0x6, access: "A", conformance: "!USR & PIN", direction: "request",
                response: "GetPinCodeResponse", xref: "cluster§5.2.10.5",
                details: "Retrieve a PIN Code."
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.5.1",
                details: "This field shall indicate the user ID. The value of the UserID field shall be between 0 and the " +
                    "value of the NumberOfPINUsersSupported attribute."
            })
        ),

        Command(
            {
                name: "GetPinCodeResponse", id: 0x6, conformance: "!USR & PIN", direction: "response",
                xref: "cluster§5.2.10.6",

                details: "Returns the PIN for the specified user ID." +
                    "\n" +
                    "If the requested UserID is valid and the Code doesn’t exist, Get RFID Code Response shall have the " +
                    "following format:" +
                    "\n" +
                    "UserID = requested User ID UserStatus = 0 (Available) UserType = Null (Not supported) PINCode = 0 " +
                    "(zero length)" +
                    "\n" +
                    "If the requested UserID is invalid, send Default Response with an error status. The error status " +
                    "shall be equal to CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and " +
                    "NOT_FOUND if greater than or equal to the max number of users supported."
            },

            Field({ name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
            Field({ name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", constraint: "desc", quality: "X" }),
            Field({ name: "UserType", id: 0x2, type: "UserTypeEnum", conformance: "M", constraint: "desc", quality: "X" }),
            Field({ name: "PinCode", id: 0x3, type: "octstr", conformance: "M", quality: "X" })
        ),

        Command(
            {
                name: "ClearPinCode", id: 0x7, access: "A T", conformance: "!USR & PIN", direction: "request",
                response: "status", xref: "cluster§5.2.10.7",
                details: "Clear a PIN code or all PIN codes." +
                    "\n" +
                    "For each PIN Code cleared whose user doesn’t have a RFID Code or other credential type, then " +
                    "corresponding user record’s UserStatus value shall be set to Available, and UserType value shall be " +
                    "set to UnrestrictedUser and all schedules shall be cleared."
            },

            Field({
                name: "PinSlotIndex", id: 0x0, type: "uint16", conformance: "M",
                constraint: "1 to numberOfPinUsersSupported, 65534", xref: "cluster§5.2.10.7.1",
                details: "This field shall specify a valid PIN code slot index or 0xFFFE to indicate all PIN code slots shall " +
                    "be cleared."
            })
        ),

        Command({
            name: "ClearAllPinCodes", id: 0x8, access: "A T", conformance: "!USR & PIN", direction: "request",
            response: "status", xref: "cluster§5.2.10.8",

            details: "Clear out all PINs on the lock." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> On the server, the clear all PIN codes command SHOULD have the same effect as the ClearPINCode " +
                "  command with respect to the setting of user status, user type and schedules."
        }),

        Command(
            {
                name: "SetUserStatus", id: 0x9, access: "A", conformance: "!USR & (PIN | RID | FGP)",
                direction: "request", response: "status", xref: "cluster§5.2.10.9",
                details: "Set the status of a user ID."
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.9.1",
                details: "This field shall indicate the user ID. The value of the UserID field shall be between 0 and the " +
                    "value of the NumberOfPINUsersSupported attribute."
            }),

            Field({
                name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.9.2",
                details: "UserStatus value of Available is not allowed. In order to clear a user id, the ClearUser Command " +
                    "shall be used. For user status value please refer to UserStatusEnum."
            })
        ),

        Command(
            {
                name: "GetUserStatus", id: 0xa, access: "A", conformance: "!USR & (PIN | RID | FGP)",
                direction: "request", response: "GetUserStatusResponse", xref: "cluster§5.2.10.10",
                details: "Get the status of a user."
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.10.1",
                details: "This field shall indicate the user ID. The value of the UserID field shall be between 0 and the " +
                    "value of the NumberOfPINUsersSupported attribute."
            })
        ),

        Command(
            {
                name: "GetUserStatusResponse", id: 0xa, conformance: "!USR", direction: "response",
                xref: "cluster§5.2.10.11",
                details: "Returns the user status for the specified user ID."
            },
            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.11.1",
                details: "This field shall indicate the user ID provided in the request."
            }),
            Field({
                name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", xref: "cluster§5.2.10.11.2",
                details: "This field shall indicate the current status of the requested user ID."
            })
        ),

        Command(
            {
                name: "SetWeekDaySchedule", id: 0xb, access: "A", conformance: "WDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.12",

                details: "Set a weekly repeating schedule for a specified user." +
                    "\n" +
                    "The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Week Day " +
                    "schedule is set." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "WeekDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfWeekDaySchedulesSupportedPerUser", xref: "cluster§5.2.10.12.1",
                details: "This field shall indicate the index of the Week Day schedule."
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.12.2",
                details: "This field shall indicate the user ID."
            }),
            Field({
                name: "DaysMask", id: 0x2, type: "DaysMaskBitmap", conformance: "M", xref: "cluster§5.2.10.12.3",
                details: "This field shall indicate which week days the schedule is active."
            }),
            Field({
                name: "StartHour", id: 0x3, type: "uint8", conformance: "M", constraint: "max 23",
                xref: "cluster§5.2.10.12.4",
                details: "This field shall indicate the starting hour for the Week Day schedule."
            }),
            Field({
                name: "StartMinute", id: 0x4, type: "uint8", conformance: "M", constraint: "max 59",
                xref: "cluster§5.2.10.12.5",
                details: "This field shall indicate the starting minute for the Week Day schedule."
            }),

            Field({
                name: "EndHour", id: 0x5, type: "uint8", conformance: "M", constraint: "max 23",
                xref: "cluster§5.2.10.12.6",
                details: "This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or " +
                    "greater than StartHour."
            }),

            Field({
                name: "EndMinute", id: 0x6, type: "uint8", conformance: "M", constraint: "max 59",
                xref: "cluster§5.2.10.12.7",
                details: "This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to " +
                    "StartHour then EndMinute shall be greater than StartMinute." +
                    "\n" +
                    "If the EndHour is equal to 23 and the EndMinute is equal to 59 the Lock shall grant access to the " +
                    "user up until 23:59:59."
            })
        ),

        Command(
            {
                name: "GetWeekDaySchedule", id: 0xc, access: "A", conformance: "WDSCH", direction: "request",
                response: "GetWeekDayScheduleResponse", xref: "cluster§5.2.10.13",
                details: "Retrieve the specific weekly schedule for the specific user."
            },
            Field({
                name: "WeekDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfWeekDaySchedulesSupportedPerUser"
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported"
            })
        ),

        Command(
            {
                name: "GetWeekDayScheduleResponse", id: 0xc, conformance: "WDSCH", direction: "response",
                xref: "cluster§5.2.10.14",
                details: "Returns the weekly repeating schedule data for the specified schedule index."
            },
            Field({
                name: "WeekDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfWeekDaySchedulesSupportedPerUser", xref: "cluster§5.2.10.14.1",
                details: "This field shall indicate the index of the Week Day schedule."
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.14.2",
                details: "This field shall indicate the user ID."
            }),

            Field({
                name: "Status", id: 0x2, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.14.3",

                details: "Status shall be one of the following values:" +
                    "\n" +
                    "  • SUCCESS if both WeekDayIndex and UserIndex are valid and there is a corresponding schedule " +
                    "    entry." +
                    "\n" +
                    "  • INVALID_COMMAND if either WeekDayIndex and/or UserIndex values are not within valid range" +
                    "\n" +
                    "  • NOT_FOUND if no corresponding schedule entry found for WeekDayIndex." +
                    "\n" +
                    "  • NOT_FOUND if no corresponding user entry found for UserIndex." +
                    "\n" +
                    "If this field is SUCCESS, the optional fields for this command shall be present. For other (error) " +
                    "status values, only the fields up to the status field shall be present."
            }),

            Field({ name: "DaysMask", id: 0x3, type: "DaysMaskBitmap", conformance: "O" }),
            Field({
                name: "StartHour", id: 0x4, type: "uint8", conformance: "O", constraint: "max 23",
                xref: "cluster§5.2.10.14.4",
                details: "This field shall indicate the starting hour for the Week Day schedule."
            }),
            Field({
                name: "StartMinute", id: 0x5, type: "uint8", conformance: "O", constraint: "max 59",
                xref: "cluster§5.2.10.14.5",
                details: "This field shall indicate the starting minute for the Week Day schedule."
            }),

            Field({
                name: "EndHour", id: 0x6, type: "uint8", conformance: "O", constraint: "max 23",
                xref: "cluster§5.2.10.14.6",
                details: "This field shall indicate the ending hour for the Week Day schedule. EndHour shall be equal to or " +
                    "greater than StartHour."
            }),

            Field({
                name: "EndMinute", id: 0x7, type: "uint8", conformance: "O", constraint: "max 59",
                xref: "cluster§5.2.10.14.7",
                details: "This field shall indicate the ending minute for the Week Day schedule. If EndHour is equal to " +
                    "StartHour then EndMinute shall be greater than StartMinute."
            })
        ),

        Command(
            {
                name: "ClearWeekDaySchedule", id: 0xd, access: "A", conformance: "WDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.15",
                details: "Clear the specific weekly schedule or all weekly schedules for the specific user." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "WeekDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfWeekDaySchedulesSupportedPerUser, 254", xref: "cluster§5.2.10.15.1",
                details: "This field shall indicate the Week Day schedule index to clear or 0xFE to clear all Week Day " +
                    "schedules for the specified user."
            }),

            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.15.2",
                details: "This field shall indicate the user ID."
            })
        ),

        Command(
            {
                name: "SetYearDaySchedule", id: 0xe, access: "A", conformance: "YDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.16",

                details: "Set a time-specific schedule ID for a specified user." +
                    "\n" +
                    "The associated UserType may be changed to ScheduleRestrictedUser by the lock when a Year Day " +
                    "schedule is set." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "YearDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfYearDaySchedulesSupportedPerUser", xref: "cluster§5.2.10.16.1",
                details: "This field shall indicate the index of the Year Day schedule."
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.16.2",
                details: "This field shall indicate the user ID."
            }),
            Field({
                name: "LocalStartTime", id: 0x2, type: "epoch-s", conformance: "M", xref: "cluster§5.2.10.16.3",
                details: "This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value."
            }),

            Field({
                name: "LocalEndTime", id: 0x3, type: "epoch-s", conformance: "M", xref: "cluster§5.2.10.16.4",
                details: "This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "LocalEndTime shall be greater than LocalStartTime."
            })
        ),

        Command(
            {
                name: "GetYearDaySchedule", id: 0xf, access: "A", conformance: "YDSCH", direction: "request",
                response: "GetYearDayScheduleResponse", xref: "cluster§5.2.10.17",
                details: "Retrieve the specific year day schedule for the specific schedule and user indexes."
            },
            Field({
                name: "YearDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfYearDaySchedulesSupportedPerUser"
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported"
            })
        ),

        Command(
            {
                name: "GetYearDayScheduleResponse", id: 0xf, conformance: "YDSCH", direction: "response",
                xref: "cluster§5.2.10.18",
                details: "Returns the year day schedule data for the specified schedule and user indexes."
            },
            Field({
                name: "YearDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfYearDaySchedulesSupportedPerUser", xref: "cluster§5.2.10.18.1",
                details: "This field shall indicate the index of the Year Day schedule."
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.18.2",
                details: "This field shall indicate the user ID."
            }),

            Field({
                name: "Status", id: 0x2, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.18.3",

                details: "Status shall be one of the following values:" +
                    "\n" +
                    "  • SUCCESS if both YearDayIndex and UserIndex are valid and there is a corresponding schedule " +
                    "    entry." +
                    "\n" +
                    "  • INVALID_COMMAND if either YearDayIndex and/or UserIndex values are not within valid range" +
                    "\n" +
                    "  • NOT_FOUND if no corresponding schedule entry found for YearDayIndex." +
                    "\n" +
                    "  • NOT_FOUND if no corresponding user entry found for UserIndex." +
                    "\n" +
                    "If this field is SUCCESS, the optional fields for this command shall be present. For other (error) " +
                    "status values, only the fields up to the status field shall be present."
            }),

            Field({
                name: "LocalStartTime", id: 0x3, type: "epoch-s", conformance: "O", xref: "cluster§5.2.10.18.4",
                details: "This field shall indicate the starting time for the Year Day schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "This shall be null if the schedule is not set for the YearDayIndex and UserIndex provided."
            }),

            Field({
                name: "LocalEndTime", id: 0x4, type: "epoch-s", conformance: "O", xref: "cluster§5.2.10.18.5",
                details: "This field shall indicate the ending time for the Year Day schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "LocalEndTime shall be greater than LocalStartTime. This shall be null if the schedule is not set for " +
                    "the YearDayIndex and UserIndex provided."
            })
        ),

        Command(
            {
                name: "ClearYearDaySchedule", id: 0x10, access: "A", conformance: "YDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.19",
                details: "Clears the specific year day schedule or all year day schedules for the specific user." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "YearDayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfYearDaySchedulesSupportedPerUser, 254", xref: "cluster§5.2.10.19.1",
                details: "This field shall indicate the Year Day schedule index to clear or 0xFE to clear all Year Day " +
                    "schedules for the specified user."
            }),

            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.19.2",
                details: "This field shall indicate the user ID."
            })
        ),

        Command(
            {
                name: "SetHolidaySchedule", id: 0x11, access: "A", conformance: "HDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.20",
                details: "Set the holiday Schedule by specifying local start time and local end time with respect to any Lock " +
                    "Operating Mode." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "HolidayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfHolidaySchedulesSupported", xref: "cluster§5.2.10.20.1",
                details: "This field shall indicate the index of the Holiday schedule."
            }),

            Field({
                name: "LocalStartTime", id: 0x1, type: "epoch-s", conformance: "M", xref: "cluster§5.2.10.20.2",
                details: "This field shall indicate the starting time for the Holiday Day schedule in Epoch Time in Seconds " +
                    "with local time offset based on the local timezone and DST offset on the day represented by the " +
                    "value."
            }),

            Field({
                name: "LocalEndTime", id: 0x2, type: "epoch-s", conformance: "M", xref: "cluster§5.2.10.20.3",
                details: "This field shall indicate the ending time for the Holiday Day schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "LocalEndTime shall be greater than LocalStartTime."
            }),

            Field({
                name: "OperatingMode", id: 0x3, type: "OperatingModeEnum", conformance: "M",
                xref: "cluster§5.2.10.20.4",
                details: "This field shall indicate the operating mode to use during this Holiday schedule start/end time."
            })
        ),

        Command(
            {
                name: "GetHolidaySchedule", id: 0x12, access: "A", conformance: "HDSCH", direction: "request",
                response: "GetHolidayScheduleResponse", xref: "cluster§5.2.10.21",
                details: "Get the holiday schedule for the specified index."
            },
            Field({
                name: "HolidayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfHolidaySchedulesSupported"
            })
        ),

        Command(
            {
                name: "GetHolidayScheduleResponse", id: 0x12, conformance: "HDSCH", direction: "response",
                xref: "cluster§5.2.10.22",
                details: "Returns the Holiday Schedule Entry for the specified Holiday ID."
            },
            Field({
                name: "HolidayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfHolidaySchedulesSupported", xref: "cluster§5.2.10.22.1",
                details: "This field shall indicate the index of the Holiday schedule."
            }),

            Field({
                name: "Status", id: 0x1, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.22.2",

                details: "Status shall be one of the following values:" +
                    "\n" +
                    "  • FAILURE if the attribute NumberOfHolidaySchedulesSupported is zero." +
                    "\n" +
                    "  • SUCCESS if the HolidayIndex is valid and there is a corresponding schedule entry." +
                    "\n" +
                    "  • INVALID_COMMAND if the HolidayIndex is not within valid range" +
                    "\n" +
                    "  • NOT_FOUND if the HolidayIndex is within the valid range, however, there is not corresponding " +
                    "    schedule entry found." +
                    "\n" +
                    "If this field is SUCCESS, the optional fields for this command shall be present. For other (error) " +
                    "status values, only the fields up to the status field shall be present."
            }),

            Field({
                name: "LocalStartTime", id: 0x2, type: "epoch-s", conformance: "O", quality: "X",
                xref: "cluster§5.2.10.22.3",
                details: "This field shall indicate the starting time for the Holiday schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "This shall be null if the schedule is not set for the HolidayIndex provided."
            }),

            Field({
                name: "LocalEndTime", id: 0x3, type: "epoch-s", conformance: "O", quality: "X",
                xref: "cluster§5.2.10.22.4",
                details: "This field shall indicate the ending time for the Holiday schedule in Epoch Time in Seconds with " +
                    "local time offset based on the local timezone and DST offset on the day represented by the value. " +
                    "LocalEndTime shall be greater than LocalStartTime. This shall be null if the schedule is not set for " +
                    "the HolidayIndex provided."
            }),

            Field({
                name: "OperatingMode", id: 0x4, type: "OperatingModeEnum", conformance: "O", quality: "X",
                xref: "cluster§5.2.10.22.5",
                details: "This field shall indicate the operating mode to use during this Holiday schedule start/end time. " +
                    "This shall be null if the schedule is not set for the HolidayIndex provided."
            })
        ),

        Command(
            {
                name: "ClearHolidaySchedule", id: 0x13, access: "A", conformance: "HDSCH", direction: "request",
                response: "status", xref: "cluster§5.2.10.23",
                details: "Clears the holiday schedule or all holiday schedules."
            },

            Field({
                name: "HolidayIndex", id: 0x0, type: "uint8", conformance: "M",
                constraint: "1 to numberOfHolidaySchedulesSupported, 254", xref: "cluster§5.2.10.23.1",
                details: "This field shall indicate the Holiday schedule index to clear or 0xFE to clear all Holiday " +
                    "schedules."
            })
        ),

        Command(
            {
                name: "SetUserType", id: 0x14, access: "A", conformance: "!USR & (PIN | RID | FGP)",
                direction: "request", response: "status", xref: "cluster§5.2.10.24",
                details: "Set the user type for a specified user." +
                    "\n" +
                    "For user type value please refer to User Type Value." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.24.1",
                details: "This field shall indicate the user ID."
            }),
            Field({
                name: "UserType", id: 0x1, type: "UserTypeEnum", conformance: "M", xref: "cluster§5.2.10.24.2",
                details: "This field shall indicate the user type."
            })
        ),

        Command(
            {
                name: "GetUserType", id: 0x15, access: "A", conformance: "!USR & (PIN | RID | FGP)",
                direction: "request", response: "GetUserTypeResponse", xref: "cluster§5.2.10.25",
                details: "Retrieve the user type for a specific user."
            },
            Field({ name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "GetUserTypeResponse", id: 0x15, conformance: "!USR", direction: "response",
                xref: "cluster§5.2.10.26",
                details: "Returns the user type for the specified user ID. If the requested User ID is invalid, send Default " +
                    "Response with an error status equal to FAILURE."
            },

            Field({ name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
            Field({ name: "UserType", id: 0x1, type: "UserTypeEnum", conformance: "M" })
        ),

        Command(
            {
                name: "SetRfidCode", id: 0x16, access: "A T", conformance: "!USR & RID", direction: "request",
                response: "status", xref: "cluster§5.2.10.27",
                details: "Set an ID for RFID access into the lock." +
                    "\n" +
                    "Return status is a global status code or a cluster-specific status code from the Status Codes table " +
                    "and shall be one of the following values:"
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.27.1",
                details: "This field shall indicate the user ID." +
                    "\n" +
                    "The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSup ported " +
                    "attribute."
            }),

            Field({
                name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.27.2",
                details: "This field shall indicate what the status is for a specific user ID. The values are according to " +
                    "“Set PIN” while not all are supported." +
                    "\n" +
                    "Only the values 1 (Occupied/Enabled) and 3 (Occupied/Disabled) are allowed for UserStatus."
            }),

            Field({
                name: "UserType", id: 0x2, type: "UserTypeEnum", conformance: "M", constraint: "desc", quality: "X",
                xref: "cluster§5.2.10.27.3",
                details: "The values are the same as used for SetPINCode command."
            }),
            Field({ name: "RfidCode", id: 0x3, type: "octstr", conformance: "M" })
        ),

        Command(
            {
                name: "GetRfidCode", id: 0x17, access: "A", conformance: "!USR & RID", direction: "request",
                response: "GetRfidCodeResponse", xref: "cluster§5.2.10.28",
                details: "Retrieve an RFID code."
            },

            Field({
                name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.28.1",
                details: "This field shall indicate the user ID." +
                    "\n" +
                    "The value of the UserID field shall be between 0 and the value of the NumberOfRFIDUsersSupported " +
                    "attribute."
            })
        ),

        Command(
            {
                name: "GetRfidCodeResponse", id: 0x17, conformance: "!USR & RID", direction: "response",
                xref: "cluster§5.2.10.29",

                details: "Returns the RFID code for the specified user ID." +
                    "\n" +
                    "If the requested User ID is valid and the Code doesn’t exist, Get RFID Code Response shall have the " +
                    "following format:" +
                    "\n" +
                    "User ID = requested User ID UserStatus = 0 (available) UserType = 0xFF (not supported)" +
                    "\n" +
                    "RFID Code = 0 (zero length)" +
                    "\n" +
                    "If requested User ID is invalid, send Default Response with an error status. The error status shall " +
                    "be equal to CONSTRAINT_ERROR when User_ID is less than the max number of users supported, and " +
                    "NOT_FOUND if greater than or equal to the max number of users supported."
            },

            Field({ name: "UserId", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
            Field({ name: "UserStatus", id: 0x1, type: "UserStatusEnum", conformance: "M", constraint: "desc", quality: "X" }),
            Field({ name: "UserType", id: 0x2, type: "UserTypeEnum", conformance: "M", constraint: "desc", quality: "X" }),
            Field({ name: "RfidCode", id: 0x3, type: "octstr", conformance: "M", quality: "X" })
        ),

        Command(
            {
                name: "ClearRfidCode", id: 0x18, access: "A T", conformance: "!USR & RID", direction: "request",
                response: "status", xref: "cluster§5.2.10.30",
                details: "Clear an RFID code or all RFID codes." +
                    "\n" +
                    "For each RFID Code cleared whose user doesn’t have a PIN Code or other credential type, then the " +
                    "corresponding user record’s UserStatus value shall be set to Available, and UserType value shall be " +
                    "set to UnrestrictedUser and all schedules shall be cleared."
            },

            Field({
                name: "RfidSlotIndex", id: 0x0, type: "uint16", conformance: "M",
                constraint: "1 to numberOfRfidUsersSupported, 65534", xref: "cluster§5.2.10.30.1",
                details: "This field shall indicate a valid RFID code slot index or 0xFFFE to indicate all RFID code slots " +
                    "shall be cleared."
            })
        ),

        Command({
            name: "ClearAllRfidCodes", id: 0x19, access: "A T", conformance: "!USR & RID", direction: "request",
            response: "status", xref: "cluster§5.2.10.31",
            details: "Clear out all RFIDs on the lock. If you clear all RFID codes and this user didn’t have a PIN code, " +
                "the user status has to be set to \"0 Available\", the user type has to be set to the default value, " +
                "and all schedules which are supported have to be set to the default values."
        }),

        Command(
            {
                name: "SetUser", id: 0x1a, access: "A T", conformance: "USR", direction: "request",
                response: "status", xref: "cluster§5.2.10.32",

                details: "Set user into the lock." +
                    "\n" +
                    "Fields used for different use cases:" +
                    "\n" +
                    "Return status is a global status code or a cluster-specific status code from the Status Codes table " +
                    "and shall be one of the following values:" +
                    "\n" +
                    "  • SUCCESS, if setting User was successful." +
                    "\n" +
                    "  • FAILURE, if some unexpected internal error occurred setting User." +
                    "\n" +
                    "  • OCCUPIED, if OperationType is Add and UserIndex points to an occupied slot." +
                    "\n" +
                    "  • INVALID_COMMAND, if one or more fields violate constraints or are invalid or if OperationType is " +
                    "    Modify and UserIndex points to an available slot."
            },

            Field({
                name: "OperationType", id: 0x0, type: "DataOperationTypeEnum", conformance: "M",
                constraint: "add, modify", xref: "cluster§5.2.10.32.1",
                details: "This field shall indicate the type of operation."
            }),
            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.32.2",
                details: "This field shall indicate the user ID."
            }),

            Field({
                name: "UserName", id: 0x2, type: "string", conformance: "M", constraint: "max 10", quality: "X",
                xref: "cluster§5.2.10.32.3",

                details: "This field shall contain a string to use as a human readable identifier for the user. If UserName is " +
                    "null then:" +
                    "\n" +
                    "  • If the OperationType is Add, the UserName in the resulting user record shall be set to an empty " +
                    "    string." +
                    "\n" +
                    "  • If the OperationType is Modify, the UserName in the user record shall NOT be changed from the " +
                    "    current value." +
                    "\n" +
                    "If UserName is not null, the UserName in the user record shall be set to the provided value."
            }),

            Field({
                name: "UserUniqueId", id: 0x3, type: "uint32", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.32.4",

                details: "This field shall indicate the fabric assigned number to use for connecting this user to other users " +
                    "on other devices from the fabric’s perspective." +
                    "\n" +
                    "If UserUniqueID is null then:" +
                    "\n" +
                    "  • If the OperationType is Add, the UserUniqueID in the resulting user record shall be set to " +
                    "    default value specified above." +
                    "\n" +
                    "  • If the OperationType is Modify, the UserUniqueID in the user record shall NOT be changed from " +
                    "    the current value." +
                    "\n" +
                    "If UserUniqueID is not null, the UserUniqueID in the user record shall be set to the provided value."
            }),

            Field({
                name: "UserStatus", id: 0x4, type: "UserStatusEnum", conformance: "M",
                constraint: "occupiedEnabled, occupiedDisabled", quality: "X", xref: "cluster§5.2.10.32.5",

                details: "This field shall indicate the UserStatus to assign to this user when created or modified. If " +
                    "UserStatus is null then:" +
                    "\n" +
                    "  • If the OperationType is Add, the UserStatus in the resulting user record shall be set to default " +
                    "    value specified above." +
                    "\n" +
                    "  • If the OperationType is Modify, the UserStatus in the user record shall NOT be changed from the " +
                    "    current value." +
                    "\n" +
                    "If UserStatus is not null, the UserStatus in the user record shall be set to the provided value."
            }),

            Field({
                name: "UserType", id: 0x5, type: "UserTypeEnum", conformance: "M",
                constraint: "unrestrictedUser, nonAccessUser, forcedUser, disposableUser, expiringUser, scheduleRestrictedUser, remoteOnlyUser",
                quality: "X", xref: "cluster§5.2.10.32.6",

                details: "This field shall indicate the UserType to assign to this user when created or modified. If UserType " +
                    "is null then:" +
                    "\n" +
                    "  • If the OperationType is Add, the UserType in the resulting user record shall be set to default " +
                    "    value specified above." +
                    "\n" +
                    "  • If the OperationType is Modify, the UserType in the user record shall NOT be changed from the " +
                    "    current value." +
                    "\n" +
                    "If UserType is not null, the UserType in the user record shall be set to the provided value."
            }),

            Field({
                name: "CredentialRule", id: 0x6, type: "CredentialRuleEnum", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.32.7",

                details: "This field shall indicate the CredentialRule to use for this user." +
                    "\n" +
                    "The valid CredentialRule enumeration values depends on the bits in the CredentialRulesBitmap map. " +
                    "Each bit in the map identifies a valid CredentialRule that can be used." +
                    "\n" +
                    "If CredentialRule is null then:" +
                    "\n" +
                    "  • If the OperationType is Add, the CredentialRule in the resulting user record shall be set to " +
                    "    default value specified above." +
                    "\n" +
                    "  • If the OperationType is Modify, the CredentialRule in the user record shall NOT be changed from " +
                    "    the current value." +
                    "\n" +
                    "If CredentialRule is not null, the CredentialRule in the user record shall be set to the provided " +
                    "value."
            })
        ),

        Command(
            {
                name: "GetUser", id: 0x1b, access: "A", conformance: "USR", direction: "request",
                response: "GetUserResponse", xref: "cluster§5.2.10.33",
                details: "Retrieve user." +
                    "\n" +
                    "An InvokeResponse command shall be sent with an appropriate error (e.g. FAILURE, INVALID_ COMMAND, " +
                    "etc.) as needed otherwise the GetUserResponse Command shall be sent implying a status of SUCCESS."
            },

            Field({
                name: "UserIndex", id: 0x0, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported"
            })
        ),

        Command(
            {
                name: "GetUserResponse", id: 0x1c, conformance: "USR", direction: "response",
                xref: "cluster§5.2.10.34",
                details: "Returns the user for the specified UserIndex." +
                    "\n" +
                    "If the requested UserIndex is valid and the UserStatus is Available for the requested UserIndex then " +
                    "UserName, UserUniqueID, UserStatus, UserType, CredentialRule, Credentials, CreatorFabricIndex, and " +
                    "LastModifiedFabricIndex shall all be null in the response."
            },

            Field({
                name: "UserIndex", id: 0x0, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", xref: "cluster§5.2.10.34.1",
                details: "This field shall indicate the user ID."
            }),
            Field({
                name: "UserName", id: 0x1, type: "string", conformance: "M", constraint: "max 10", quality: "X",
                xref: "cluster§5.2.10.34.2",
                details: "This field shall contain a string to use as a human readable identifier for the user."
            }),
            Field({
                name: "UserUniqueId", id: 0x2, type: "uint32", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.34.3",
                details: "See UserUniqueID."
            }),
            Field({
                name: "UserStatus", id: 0x3, type: "UserStatusEnum", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.34.4",
                details: "This field shall indicate the UserStatus assigned to the user when created or modified."
            }),
            Field({
                name: "UserType", id: 0x4, type: "UserTypeEnum", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.34.5",
                details: "This field shall indicate the UserType assigned to this user when created or modified."
            }),
            Field({
                name: "CredentialRule", id: 0x5, type: "CredentialRuleEnum", conformance: "M", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.34.6",
                details: "This field shall indicate the CredentialRule set for this user."
            }),

            Field(
                {
                    name: "Credentials", id: 0x6, type: "list", conformance: "M",
                    constraint: "0 to numberOfCredentialsSupportedPerUser", quality: "X", xref: "cluster§5.2.10.34.7",
                    details: "This field shall contain a list of credentials for this user."
                },
                Field({ name: "entry", type: "CredentialStruct" })
            ),

            Field({
                name: "CreatorFabricIndex", id: 0x7, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.34.8",
                details: "This field shall indicate the user’s creator fabric index. CreatorFabricIndex shall be null if " +
                    "UserStatus is set to Available or when the creator fabric cannot be determined (for example, when " +
                    "user was created outside the Interaction Model) and shall NOT be null otherwise. This value shall be " +
                    "set to 0 if the original creator fabric was deleted."
            }),

            Field({
                name: "LastModifiedFabricIndex", id: 0x8, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.34.9",
                details: "This field shall indicate the user’s last modifier fabric index. LastModifiedFabricIndex shall be " +
                    "null if UserStatus is set to Available or when the modifier fabric cannot be determined (for " +
                    "example, when user was modified outside the Interaction Model) and shall NOT be null otherwise. This " +
                    "value shall be set to 0 if the last modifier fabric was deleted."
            }),

            Field({
                name: "NextUserIndex", id: 0x9, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", quality: "X", xref: "cluster§5.2.10.34.10",
                details: "This field shall indicate the next occupied UserIndex in the database which is useful for quickly " +
                    "identifying occupied user slots in the database. This shall NOT be null if there is at least one " +
                    "occupied entry after the requested UserIndex in the User database and shall be null if there are no " +
                    "more occupied entries."
            })
        ),

        Command(
            {
                name: "ClearUser", id: 0x1d, access: "A T", conformance: "USR", direction: "request",
                response: "status", xref: "cluster§5.2.10.35",

                details: "Clears a user or all Users." +
                    "\n" +
                    "For each user to clear, all associated credentials (e.g. PIN, RFID, fingerprint, etc.) shall be " +
                    "cleared and the user entry values shall be reset to their default values (e.g. UserStatus shall be " +
                    "Available, UserType shall be UnrestrictedUser) and all associated schedules shall be cleared." +
                    "\n" +
                    "A LockUserChange event with the provided UserIndex shall be generated after successfully clearing " +
                    "users."
            },

            Field({
                name: "UserIndex", id: 0x0, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported, 65534", xref: "cluster§5.2.10.35.1",
                details: "This field shall specify a valid User index or 0xFFFE to indicate all user slots shall be cleared."
            })
        ),

        Command(
            {
                name: "SetCredential", id: 0x22, access: "A T", conformance: "USR", direction: "request",
                response: "SetCredentialResponse", xref: "cluster§5.2.10.36",
                details: "Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or " +
                    "ProgrammingUser." +
                    "\n" +
                    "Fields used for different use cases:"
            },

            Field({
                name: "OperationType", id: 0x0, type: "DataOperationTypeEnum", conformance: "M",
                constraint: "add, modify", xref: "cluster§5.2.10.36.1",
                details: "This field shall indicate the set credential operation type requested."
            }),

            Field({
                name: "Credential", id: 0x1, type: "CredentialStruct", conformance: "M",
                xref: "cluster§5.2.10.36.2",
                details: "This field shall contain a credential structure that contains the CredentialTypeEnum and the " +
                    "credential index (if applicable or 0 if not) to set."
            }),

            Field({
                name: "CredentialData", id: 0x2, type: "octstr", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.36.3",
                details: "This field shall indicate the credential data to set for the credential being added or modified. The " +
                    "length of the credential data shall conform to the limits of the CredentialType specified in the " +
                    "Credential structure otherwise an INVALID_COMMAND status shall be returned in the " +
                    "SetCredentialResponse command."
            }),

            Field({
                name: "UserIndex", id: 0x3, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", quality: "X", xref: "cluster§5.2.10.36.4",
                details: "This field shall indicate the user index to the user record that corresponds to the credential being " +
                    "added or modified. This shall be null if OperationType is add and a new credential and user is being " +
                    "added at the same time."
            }),

            Field({
                name: "UserStatus", id: 0x4, type: "UserStatusEnum", conformance: "M",
                constraint: "occupiedEnabled, occupiedDisabled", quality: "X", xref: "cluster§5.2.10.36.5",
                details: "This field shall indicate the user status to use in the new user record if a new user is being " +
                    "created. This shall be null if OperationType is Modify. This may be null when adding a new " +
                    "credential and user."
            }),

            Field({
                name: "UserType", id: 0x5, type: "UserTypeEnum", conformance: "M",
                constraint: "unrestrictedUser, programmingUser, nonAccessUser, forcedUser, disposableUser, expiringUser, remoteOnlyUser",
                quality: "X", xref: "cluster§5.2.10.36.6",
                details: "This field shall indicate the user type to use in the new user record if a new user is being " +
                    "created. This shall be null if OperationType is Modify. This may be null when adding a new " +
                    "credential and user."
            })
        ),

        Command(
            {
                name: "SetCredentialResponse", id: 0x23, conformance: "USR", direction: "response",
                xref: "cluster§5.2.10.37",
                details: "Returns the status for setting the specified credential."
            },

            Field({
                name: "Status", id: 0x0, type: "status", conformance: "M", constraint: "desc",
                xref: "cluster§5.2.10.37.1",

                details: "Status comes from the Status Codes table and shall be one of the following values:" +
                    "\n" +
                    "  • SUCCESS, if setting user credential was successful." +
                    "\n" +
                    "  • FAILURE, if some unexpected internal error occurred setting user credential." +
                    "\n" +
                    "  • OCCUPIED, if OperationType is Add and CredentialIndex in Credential structure points to an " +
                    "    occupied slot." +
                    "\n" +
                    "  • OCCUPIED, if OperationType is Modify and CredentialIndex in Credential structure does not match " +
                    "    the CredentialIndex that is already associated with the provided UserIndex." +
                    "\n" +
                    "  • DUPLICATE, if CredentialData provided is a duplicate of another credential with the same " +
                    "    CredentialType (e.g. duplicate PIN code)." +
                    "\n" +
                    "  • RESOURCE_EXHAUSTED, if OperationType is Add and the new credential cannot be added due to " +
                    "    resource constraints such as:" +
                    "\n" +
                    "    ◦ The user referred to by UserIndex already has NumberOfCredentialsSupportedPerUser credentials " +
                    "      associated." +
                    "\n" +
                    "    ◦ The credential is of type AliroEvictableEndpointKey or AliroNonEvictableEndpointKey, and " +
                    "      adding it would cause the total number of credentials of those two types to exceed " +
                    "      NumberOfAliroEndpointKeysSupported." +
                    "\n" +
                    "  • INVALID_COMMAND, if one or more fields violate constraints or are invalid." +
                    "\n" +
                    "  • INVALID_COMMAND, if the CredentialIndex in the Credential provided exceeds the number of " +
                    "    credentials of the provided CredentialType supported by the lock." +
                    "\n" +
                    "  • INVALID_COMMAND, if OperationType is Modify and UserIndex points to an available slot."
            }),

            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", quality: "X", xref: "cluster§5.2.10.37.2",
                details: "This field shall indicate the user index that was created with the new credential. If the status " +
                    "being returned is not success then this shall be null. This shall be null if OperationType was " +
                    "Modify; if the OperationType was Add and a new User was created this shall NOT be null and shall " +
                    "provide the UserIndex created. If the OperationType was Add and an existing User was associated with " +
                    "the new credential then this shall be null."
            }),

            Field({
                name: "NextCredentialIndex", id: 0x2, type: "uint16", conformance: "O", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.37.3",

                details: "This field shall indicate the next available index in the database for the credential type set, " +
                    "which is useful for quickly identifying available credential slots in the database. This shall NOT " +
                    "be null if there is at least one available entry after the requested credential index in the " +
                    "corresponding database and shall be null if there are no more available entries. The " +
                    "NextCredentialIndex reported shall NOT exceed the maximum number of credentials for a particular " +
                    "credential type."
            })
        ),

        Command(
            {
                name: "GetCredentialStatus", id: 0x24, access: "A", conformance: "USR", direction: "request",
                response: "GetCredentialStatusResponse", xref: "cluster§5.2.10.38",
                details: "Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index." +
                    "\n" +
                    "An InvokeResponse command shall be sent with an appropriate error (e.g. FAILURE, INVALID_COMMAND, " +
                    "etc.) as needed otherwise the GetCredentialStatusResponse command shall be sent implying a status of " +
                    "SUCCESS."
            },

            Field({
                name: "Credential", id: 0x0, type: "CredentialStruct", conformance: "M",
                xref: "cluster§5.2.10.38.1",
                details: "This field shall contain a credential structure that contains the CredentialTypeEnum and the " +
                    "credential index (if applicable or 0 if not) to retrieve the status for."
            })
        ),

        Command(
            {
                name: "GetCredentialStatusResponse", id: 0x25, conformance: "USR", direction: "response",
                xref: "cluster§5.2.10.39",
                details: "Returns the status for the specified credential."
            },
            Field({
                name: "CredentialExists", id: 0x0, type: "bool", conformance: "M", xref: "cluster§5.2.10.39.1",
                details: "This field shall indicate if the requested credential type and index exists and is populated for the " +
                    "requested user index."
            }),

            Field({
                name: "UserIndex", id: 0x1, type: "uint16", conformance: "M",
                constraint: "1 to numberOfTotalUsersSupported", quality: "X", xref: "cluster§5.2.10.39.2",
                details: "This field shall indicate the credential’s corresponding user index value if the credential exists. " +
                    "If CredentialType requested was ProgrammingPIN then UserIndex shall be null; otherwise, UserIndex " +
                    "shall be null if CredentialExists is set to False and shall NOT be null if CredentialExists is set " +
                    "to True."
            }),

            Field({
                name: "CreatorFabricIndex", id: 0x2, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.39.3",
                details: "This field shall indicate the credential’s creator fabric index. CreatorFabricIndex shall be null if " +
                    "CredentialExists is set to False or when the creator fabric cannot be determined (for example, when " +
                    "credential was created outside the Interaction Model) and shall NOT be null otherwise. This value " +
                    "shall be set to 0 if the original creator fabric was deleted."
            }),

            Field({
                name: "LastModifiedFabricIndex", id: 0x3, type: "fabric-idx", conformance: "M", quality: "X",
                xref: "cluster§5.2.10.39.4",
                details: "This field shall indicate the credential’s last modifier fabric index. LastModifiedFabricIndex shall " +
                    "be null if CredentialExists is set to False or when the modifier fabric cannot be determined (for " +
                    "example, when credential was modified outside the Interaction Model) and shall NOT be null " +
                    "otherwise. This value shall be set to 0 if the last modifier fabric was deleted."
            }),

            Field({
                name: "NextCredentialIndex", id: 0x4, type: "uint16", conformance: "O", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.39.5",

                details: "This field shall indicate the next occupied index in the database for the credential type requested, " +
                    "which is useful for quickly identifying occupied credential slots in the database. This shall NOT be " +
                    "null if there is at least one occupied entry after the requested credential index in the " +
                    "corresponding database and shall be null if there are no more occupied entries. The " +
                    "NextCredentialIndex reported shall NOT exceed the maximum number of credentials for a particular " +
                    "credential type."
            }),

            Field({
                name: "CredentialData", id: 0x5, type: "octstr", conformance: "[ALIRO]", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.39.6",

                details: "This field shall indicate the credential data for the requested user index." +
                    "\n" +
                    "If the CredentialType in the GetCredentialStatus command was not AliroCredentialIssuerKey, " +
                    "AliroEvictableEndpointKey, or AliroNonEvictableEndpointKey, this field shall NOT be included." +
                    "\n" +
                    "Otherwise, if CredentialExists is false this field shall be null." +
                    "\n" +
                    "Otherwise, the value of this field shall be the value of the relevant credential, as a 65-byte " +
                    "uncompressed elliptic curve public key as defined in section 2.3.3 of SEC 1." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Since the Aliro credentials are public keys, there is no security risk in allowing them to be " +
                    "  read. Possession of the credential octet string does not allow operating the lock."
            })
        ),

        Command(
            {
                name: "ClearCredential", id: 0x26, access: "A T", conformance: "USR", direction: "request",
                response: "status", xref: "cluster§5.2.10.40",

                details: "Clear one, one type, or all credentials except ProgrammingPIN credential." +
                    "\n" +
                    "Fields used for different use cases:" +
                    "\n" +
                    "For each credential cleared whose user doesn’t have another valid credential, the corresponding user " +
                    "record shall be reset back to default values and its UserStatus value shall be set to Available and " +
                    "UserType value shall be set to UnrestrictedUser and all schedules shall be cleared. In this case a " +
                    "LockUserChange event shall be generated for the user being cleared." +
                    "\n" +
                    "Return status shall be one of the following values:"
            },

            Field({
                name: "Credential", id: 0x0, type: "CredentialStruct", conformance: "M", constraint: "desc",
                quality: "X", xref: "cluster§5.2.10.40.1",
                details: "This field shall contain a credential structure that contains the CredentialTypeEnum and the " +
                    "credential index (0xFFFE for all credentials or 0 if not applicable) to clear. This shall be null if " +
                    "clearing all credential types otherwise it shall NOT be null."
            })
        ),

        Command(
            {
                name: "UnboltDoor", id: 0x27, access: "O T", conformance: "UBOLT", direction: "request",
                response: "status", xref: "cluster§5.2.10.41",

                details: "This command causes the lock device to unlock the door without pulling the latch. This command " +
                    "includes an optional code for the lock. The door lock may require a code depending on the value of " +
                    "the RequirePINForRemoteOperation attribute." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> If the attribute AutoRelockTime is supported, the lock will transition to the locked state when " +
                    "  the auto relock time has expired."
            },

            Field({
                name: "PinCode", id: 0x0, type: "octstr", conformance: "[COTA & PIN]", xref: "cluster§5.2.10.41.1",
                details: "See Section 5.2.10.1.1, “PINCode Field”."
            })
        ),

        Command(
            {
                name: "SetAliroReaderConfig", id: 0x28, access: "A T", conformance: "ALIRO", direction: "request",
                response: "status", xref: "cluster§5.2.10.42",
                details: "This command allows communicating an Aliro Reader configuration, as defined in [Aliro], to the lock."
            },
            Field({
                name: "SigningKey", id: 0x0, type: "octstr", conformance: "M", constraint: "32",
                xref: "cluster§5.2.10.42.1",
                details: "This field shall indicate the signing key component of the Reader’s key pair."
            }),

            Field({
                name: "VerificationKey", id: 0x1, type: "octstr", conformance: "M", constraint: "65",
                xref: "cluster§5.2.10.42.2",
                details: "This field shall indicate the verification key component of the Reader’s key pair. This shall be an " +
                    "uncompressed elliptic curve public key as defined in section 2.3.3 of SEC 1."
            }),

            Field({
                name: "GroupIdentifier", id: 0x2, type: "octstr", conformance: "M", constraint: "16",
                xref: "cluster§5.2.10.42.3",
                details: "This field shall indicate the reader group identifier for the lock."
            }),
            Field({
                name: "GroupResolvingKey", id: 0x3, type: "octstr", conformance: "ALBU", constraint: "16",
                xref: "cluster§5.2.10.42.4",
                details: "This field shall indicate the group resolving key for the lock."
            })
        ),

        Command({
            name: "ClearAliroReaderConfig", id: 0x29, access: "A T", conformance: "ALIRO", direction: "request",
            response: "status", xref: "cluster§5.2.10.43",

            details: "This command allows clearing an existing Aliro Reader configuration for the lock. Administrators " +
                "shall NOT clear an Aliro Reader configuration without explicit user permission." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Using this command will revoke the ability of all existing Aliro user devices that have the old " +
                "  verification key to interact with the lock. This effect is not restricted to a single fabric or " +
                "  otherwise scoped in any way."
        }),

        Datatype(
            {
                name: "DaysMaskBitmap", type: "map8", xref: "cluster§5.2.6.1",
                details: "This bitmap shall indicate the days of the week the Week Day schedule applies for."
            },
            Field({ name: "Sunday", constraint: "0", description: "Schedule is applied on Sunday" }),
            Field({ name: "Monday", constraint: "1", description: "Schedule is applied on Monday" }),
            Field({ name: "Tuesday", constraint: "2", description: "Schedule is applied on Tuesday" }),
            Field({ name: "Wednesday", constraint: "3", description: "Schedule is applied on Wednesday" }),
            Field({ name: "Thursday", constraint: "4", description: "Schedule is applied on Thursday" }),
            Field({ name: "Friday", constraint: "5", description: "Schedule is applied on Friday" }),
            Field({ name: "Saturday", constraint: "6", description: "Schedule is applied on Saturday" })
        ),

        Datatype(
            { name: "CredentialRulesBitmap", type: "map8", xref: "cluster§5.2.6.2" },
            Field({ name: "Single", constraint: "0", description: "Only one credential is required for lock operation" }),
            Field({ name: "Dual", constraint: "1", description: "Any two credentials are required for lock operation" }),
            Field({ name: "Tri", constraint: "2", description: "Any three credentials are required for lock operation" })
        ),

        Datatype(
            {
                name: "OperatingModesBitmap", type: "map16", xref: "cluster§5.2.6.3",

                details: "### WARNING" +
                    "\n" +
                    "For the OperatingModesBitmap, a bit SET indicates that the operating mode IS NOT supported. A bit " +
                    "CLEAR indicates that the operating mode IS supported. This is the inverse of most bitmaps in this " +
                    "specification, and it is recommended that clients carefully take this into consideration. See " +
                    "SupportedOperatingModes."
            },

            Field({ name: "Normal", constraint: "0", description: "Normal operation mode" }),
            Field({ name: "Vacation", constraint: "1", description: "Vacation operation mode" }),
            Field({ name: "Privacy", constraint: "2", description: "Privacy operation mode" }),
            Field({ name: "NoRemoteLockUnlock", constraint: "3", description: "No remote lock and unlock operation mode" }),
            Field({ name: "Passage", constraint: "4", description: "Passage operation mode" })
        ),

        Datatype(
            { name: "ConfigurationRegisterBitmap", type: "map16", xref: "cluster§5.2.6.4" },

            Field(
                {
                    name: "LocalProgramming", constraint: "0",
                    description: "The state of local programming functionality", xref: "cluster§5.2.6.4.1",
                    details: "This bit shall indicate the state related to local programming:" +
                        "\n" +
                        "  • 0 = Local programming is disabled" +
                        "\n" +
                        "  • 1 = Local programming is enabled"
                }
            ),

            Field(
                {
                    name: "KeypadInterface", constraint: "1", description: "The state of the keypad interface",
                    xref: "cluster§5.2.6.4.2",
                    details: "This bit shall indicate the state related to keypad interface:" +
                        "\n" +
                        "  • 0 = Keypad interface is disabled" +
                        "\n" +
                        "  • 1 = Keypad interface is enabled"
                }
            ),

            Field(
                {
                    name: "RemoteInterface", constraint: "2", description: "The state of the remote interface",
                    xref: "cluster§5.2.6.4.3",
                    details: "This bit shall indicate the state related to remote interface:" +
                        "\n" +
                        "  • 0 = Remote interface is disabled" +
                        "\n" +
                        "  • 1 = Remote interface is enabled"
                }
            ),

            Field(
                {
                    name: "SoundVolume", constraint: "5", description: "Sound volume is set to Silent value",
                    xref: "cluster§5.2.6.4.4",
                    details: "This bit shall indicate the state related to sound volume:" +
                        "\n" +
                        "  • 0 = Sound volume value is 0 (Silent)" +
                        "\n" +
                        "  • 1 = Sound volume value is equal to something other than 0"
                }
            ),

            Field(
                {
                    name: "AutoRelockTime", constraint: "6", description: "Auto relock time it set to 0",
                    xref: "cluster§5.2.6.4.5",
                    details: "This bit shall indicate the state related to auto relock time:" +
                        "\n" +
                        "  • 0 = Auto relock time value is 0" +
                        "\n" +
                        "  • 1 = Auto relock time value is equal to something other than 0"
                }
            ),

            Field(
                {
                    name: "LedSettings", constraint: "7", description: "LEDs is disabled", xref: "cluster§5.2.6.4.6",
                    details: "This bit shall indicate the state related to LED settings:" +
                        "\n" +
                        "  • 0 = LED settings value is 0 (NoLEDSignal)" +
                        "\n" +
                        "  • 1 = LED settings value is equal to something other than 0"
                }
            )
        ),

        Datatype(
            { name: "LocalProgrammingFeaturesBitmap", type: "map8", xref: "cluster§5.2.6.5" },

            Field(
                {
                    name: "AddUsersCredentialsSchedules", constraint: "0",
                    description: "The state of the ability to add users, credentials or schedules on the device",
                    xref: "cluster§5.2.6.5.1",
                    details: "This bit shall indicate whether the door lock is able to add Users/Credentials/Schedules locally:" +
                        "\n" +
                        "  • 0 = This ability is disabled" +
                        "\n" +
                        "  • 1 = This ability is enabled"
                }
            ),

            Field(
                {
                    name: "ModifyUsersCredentialsSchedules", constraint: "1",
                    description: "The state of the ability to modify users, credentials or schedules on the device",
                    xref: "cluster§5.2.6.5.2",
                    details: "This bit shall indicate whether the door lock is able to modify Users/Credentials/Schedules locally:" +
                        "\n" +
                        "  • 0 = This ability is disabled" +
                        "\n" +
                        "  • 1 = This ability is enabled"
                }
            ),

            Field(
                {
                    name: "ClearUsersCredentialsSchedules", constraint: "2",
                    description: "The state of the ability to clear users, credentials or schedules on the device",
                    xref: "cluster§5.2.6.5.3",
                    details: "This bit shall indicate whether the door lock is able to clear Users/Credentials/Schedules locally:" +
                        "\n" +
                        "  • 0 = This ability is disabled" +
                        "\n" +
                        "  • 1 = This ability is enabled"
                }
            ),

            Field(
                {
                    name: "AdjustSettings", constraint: "3",
                    description: "The state of the ability to adjust settings on the device", xref: "cluster§5.2.6.5.4",
                    details: "This bit shall indicate whether the door lock is able to adjust lock settings locally:" +
                        "\n" +
                        "  • 0 = This ability is disabled" +
                        "\n" +
                        "  • 1 = This ability is enabled"
                }
            )
        ),

        Datatype(
            { name: "AlarmMaskBitmap", type: "map16", xref: "cluster§5.2.6.6" },
            Field({ name: "LockJammed", constraint: "0", description: "Locking Mechanism Jammed" }),
            Field({ name: "LockFactoryReset", constraint: "1", description: "Lock Reset to Factory Defaults" }),
            Field({ name: "LockRadioPowerCycled", constraint: "3", description: "RF Module Power Cycled" }),
            Field({ name: "WrongCodeEntryLimit", constraint: "4", description: "Tamper Alarm - wrong code entry limit" }),
            Field({
                name: "FrontEscutcheonRemoved", constraint: "5",
                description: "Tamper Alarm - front escutcheon removed from main"
            }),
            Field({ name: "DoorForcedOpen", constraint: "6", description: "Forced Door Open under Door Locked Condition" })
        ),

        Datatype(
            {
                name: "AlarmCodeEnum", type: "enum8", xref: "cluster§5.2.6.7",
                details: "This enumeration shall indicate the alarm type."
            },
            Field({ name: "LockJammed", id: 0x0, conformance: "M", description: "Locking Mechanism Jammed" }),
            Field({ name: "LockFactoryReset", id: 0x1, conformance: "O", description: "Lock Reset to Factory Defaults" }),
            Field({ name: "LockRadioPowerCycled", id: 0x3, conformance: "O", description: "Lock Radio Power Cycled" }),
            Field({
                name: "WrongCodeEntryLimit", id: 0x4, conformance: "[USR]",
                description: "Tamper Alarm - wrong code entry limit"
            }),
            Field({
                name: "FrontEsceutcheonRemoved", id: 0x5, conformance: "O",
                description: "Tamper Alarm - front escutcheon removed from main"
            }),
            Field({
                name: "DoorForcedOpen", id: 0x6, conformance: "[DPS]",
                description: "Forced Door Open under Door Locked Condition"
            }),
            Field({ name: "DoorAjar", id: 0x7, conformance: "[DPS]", description: "Door ajar" }),
            Field({ name: "ForcedUser", id: 0x8, conformance: "[USR]", description: "Force User SOS alarm" })
        ),

        Datatype(
            {
                name: "CredentialRuleEnum", type: "enum8", xref: "cluster§5.2.6.8",
                details: "This enumeration shall indicate the credential rule that can be applied to a particular user."
            },
            Field({
                name: "Single", id: 0x0, conformance: "USR",
                description: "Only one credential is required for lock operation"
            }),
            Field({
                name: "Dual", id: 0x1, conformance: "[USR]",
                description: "Any two credentials are required for lock operation"
            }),
            Field({
                name: "Tri", id: 0x2, conformance: "[USR]",
                description: "Any three credentials are required for lock operation"
            })
        ),

        Datatype(
            {
                name: "CredentialTypeEnum", type: "enum8", xref: "cluster§5.2.6.9",
                details: "This enumeration shall indicate the credential type."
            },
            Field({ name: "ProgrammingPin", id: 0x0, conformance: "O", description: "Programming PIN code credential type" }),
            Field({ name: "Pin", id: 0x1, conformance: "PIN", description: "PIN code credential type" }),
            Field({ name: "Rfid", id: 0x2, conformance: "RID", description: "RFID identifier credential type" }),
            Field({ name: "Fingerprint", id: 0x3, conformance: "FGP", description: "Fingerprint identifier credential type" }),
            Field({ name: "FingerVein", id: 0x4, conformance: "FGP", description: "Finger vein identifier credential type" }),
            Field({ name: "Face", id: 0x5, conformance: "FACE", description: "Face identifier credential type" }),

            Field({
                name: "AliroCredentialIssuerKey", id: 0x6, conformance: "ALIRO",
                description: "A Credential Issuer public key as defined in [Aliro]", xref: "cluster§5.2.6.9.1",

                details: "Credentials of this type shall be 65-byte uncompressed elliptic curve public keys as defined in " +
                    "section 2.3.3 of SEC 1." +
                    "\n" +
                    "Credentials of this type shall NOT be used to allow operating the lock. They shall be used, as " +
                    "defined in [Aliro], to create new credentials of type AliroEvictableEndpointKey via a step-up " +
                    "transaction." +
                    "\n" +
                    "When performing the step-up transaction, the lock shall request the data element with identifier " +
                    "\"matter1\", and shall attempt to create a new credential of type AliroEvictableEndpointKey if and " +
                    "only if the data element is returned and the Access Credential can be validated using the " +
                    "AliroCredentialIssuerKey." +
                    "\n" +
                    "When a new credential of type AliroEvictableEndpointKey is added in this manner, it shall be " +
                    "associated with the same user record as the AliroCredentialIssuerKey credential that allowed the new " +
                    "credential to be added." +
                    "\n" +
                    "If there are no available credential slots to add a new AliroEvictableEndpointKey credential (i.e. " +
                    "either the NumberOfCredentialsSupportedPerUser or the NumberOfAliroEndpointKeysSupported limit has " +
                    "been reached) but there exist credentials of type AliroEvictableEndpointKey associated with the user " +
                    "record, the server shall remove one of those credentials using the same procedure it would follow " +
                    "for the ClearCredential command before adding the new credential." +
                    "\n" +
                    "If there are no available credential slots to add a new AliroEvictableEndpointKey credential (i.e. " +
                    "either the NumberOfCredentialsSupportedPerUser or the NumberOfAliroEndpointKeysSupported limit has " +
                    "been reached) and there do not exist credentials of type AliroEvictableEndpointKey associated with " +
                    "the user record, a new AliroEvictableEndpointKey credential shall NOT be created." +
                    "\n" +
                    "If the step-up process results in addition of new credentials, the corresponding LockUserChange " +
                    "event shall have OperationSource set to Aliro." +
                    "\n" +
                    "If the step-up process results in the lock state changing (e.g. locking or unlocking), the " +
                    "credential associated with those changes in the LockOperation events shall be the newly provisioned " +
                    "AliroEvictableEndpointKey credential if one was created. If no new AliroEvictableEndpointKey " +
                    "credential was created, the credential associated with the changes in the LockOperation events shall " +
                    "be the AliroCredentialIssuerKey credential used for the step-up."
            }),

            Field({
                name: "AliroEvictableEndpointKey", id: 0x7, conformance: "ALIRO",
                description: "An Endpoint public key as defined in [Aliro] which can be evicted if space is needed for another endpoint key",
                xref: "cluster§5.2.6.9.2",
                details: "Credentials of this type shall be 65-byte uncompressed elliptic curve public keys as defined in " +
                    "section 2.3.3 of SEC 1."
            }),

            Field({
                name: "AliroNonEvictableEndpointKey", id: 0x8, conformance: "ALIRO",
                description: "An Endpoint public key as defined in [Aliro] which cannot be evicted if space is needed for another endpoint key",
                xref: "cluster§5.2.6.9.3",
                details: "Credentials of this type shall be 65-byte uncompressed elliptic curve public keys as defined in " +
                    "section 2.3.3 of SEC 1."
            })
        ),

        Datatype(
            {
                name: "DataOperationTypeEnum", type: "enum8", xref: "cluster§5.2.6.10",
                details: "This enumeration shall indicate the data operation performed."
            },
            Field({ name: "Add", id: 0x0, conformance: "M", description: "Data is being added or was added" }),
            Field({ name: "Clear", id: 0x1, conformance: "M", description: "Data is being cleared or was cleared" }),
            Field({ name: "Modify", id: 0x2, conformance: "M", description: "Data is being modified or was modified" })
        ),

        Datatype(
            {
                name: "DoorStateEnum", type: "enum8", xref: "cluster§5.2.6.11",
                details: "This enumeration shall indicate the current door state."
            },
            Field({ name: "DoorOpen", id: 0x0, conformance: "DPS", description: "Door state is open" }),
            Field({ name: "DoorClosed", id: 0x1, conformance: "DPS", description: "Door state is closed" }),
            Field({ name: "DoorJammed", id: 0x2, conformance: "[DPS]", description: "Door state is jammed" }),
            Field({
                name: "DoorForcedOpen", id: 0x3, conformance: "[DPS]",
                description: "Door state is currently forced open"
            }),
            Field({
                name: "DoorUnspecifiedError", id: 0x4, conformance: "[DPS]",
                description: "Door state is invalid for unspecified reason"
            }),
            Field({ name: "DoorAjar", id: 0x5, conformance: "[DPS]", description: "Door state is ajar" })
        ),

        Datatype(
            {
                name: "LockDataTypeEnum", type: "enum8", xref: "cluster§5.2.6.12",
                details: "This enumeration shall indicate the data type that is being or has changed."
            },
            Field({
                name: "Unspecified", id: 0x0, conformance: "O",
                description: "Unspecified or manufacturer specific lock user data added, cleared, or modified."
            }),
            Field({
                name: "ProgrammingCode", id: 0x1, conformance: "O",
                description: "Lock programming PIN code was added, cleared, or modified."
            }),
            Field({
                name: "UserIndex", id: 0x2, conformance: "M",
                description: "Lock user index was added, cleared, or modified."
            }),
            Field({
                name: "WeekDaySchedule", id: 0x3, conformance: "WDSCH",
                description: "Lock user week day schedule was added, cleared, or modified."
            }),
            Field({
                name: "YearDaySchedule", id: 0x4, conformance: "YDSCH",
                description: "Lock user year day schedule was added, cleared, or modified."
            }),
            Field({
                name: "HolidaySchedule", id: 0x5, conformance: "HDSCH",
                description: "Lock holiday schedule was added, cleared, or modified."
            }),
            Field({
                name: "Pin", id: 0x6, conformance: "PIN",
                description: "Lock user PIN code was added, cleared, or modified."
            }),
            Field({
                name: "Rfid", id: 0x7, conformance: "RID",
                description: "Lock user RFID code was added, cleared, or modified."
            }),
            Field({
                name: "Fingerprint", id: 0x8, conformance: "FGP",
                description: "Lock user fingerprint was added, cleared, or modified."
            }),
            Field({
                name: "FingerVein", id: 0x9, conformance: "FGP",
                description: "Lock user finger-vein information was added, cleared, or modified."
            }),
            Field({
                name: "Face", id: 0xa, conformance: "FACE",
                description: "Lock user face information was added, cleared, or modified."
            }),
            Field({
                name: "AliroCredentialIssuerKey", id: 0xb, conformance: "ALIRO",
                description: "An Aliro credential issuer key credential was added, cleared, or modified."
            }),
            Field({
                name: "AliroEvictableEndpointKey", id: 0xc, conformance: "ALIRO",
                description: "An Aliro endpoint key credential which can be evicted credential was added, cleared, or modified."
            }),
            Field({
                name: "AliroNonEvictableEndpointKey", id: 0xd, conformance: "ALIRO",
                description: "An Aliro endpoint key credential which cannot be evicted was added, cleared, or modified."
            })
        ),

        Datatype(
            {
                name: "LockOperationTypeEnum", type: "enum8", xref: "cluster§5.2.6.13",
                details: "This enumeration shall indicate the type of Lock operation performed."
            },
            Field({ name: "Lock", id: 0x0, conformance: "M", description: "Lock operation" }),
            Field({ name: "Unlock", id: 0x1, conformance: "M", description: "Unlock operation" }),
            Field({
                name: "NonAccessUserEvent", id: 0x2, conformance: "O",
                description: "Triggered by keypad entry for user with User Type set to Non Access User"
            }),
            Field({
                name: "ForcedUserEvent", id: 0x3, conformance: "O",
                description: "Triggered by using a user with UserType set to Forced User"
            }),
            Field({ name: "Unlatch", id: 0x4, conformance: "M", description: "Unlatch operation" })
        ),

        Datatype(
            {
                name: "OperationErrorEnum", type: "enum8", xref: "cluster§5.2.6.14",
                details: "This enumeration shall indicate the error cause of the Lock/Unlock operation performed."
            },
            Field({
                name: "Unspecified", id: 0x0, conformance: "O",
                description: "Lock/unlock error caused by unknown or unspecified source"
            }),
            Field({
                name: "InvalidCredential", id: 0x1, conformance: "USR",
                description: "Lock/unlock error caused by invalid PIN, RFID, fingerprint or other credential"
            }),
            Field({
                name: "DisabledUserDenied", id: 0x2, conformance: "M",
                description: "Lock/unlock error caused by disabled USER or credential"
            }),
            Field({
                name: "Restricted", id: 0x3, conformance: "WDSCH | YDSCH",
                description: "Lock/unlock error caused by schedule restriction"
            }),
            Field({
                name: "InsufficientBattery", id: 0x4, conformance: "O",
                description: "Lock/unlock error caused by insufficient battery power left to safely actuate the lock"
            })
        ),

        Datatype(
            {
                name: "OperatingModeEnum", type: "enum8", xref: "cluster§5.2.6.15",

                details: "This enumeration shall indicate the lock operating mode." +
                    "\n" +
                    "The table below shows the operating mode and which interfaces are enabled, if supported, for each " +
                    "mode." +
                    "\n" +
                    "* Interface Operational: Yes, No or N/A" +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> For modes that disable the remote interface, the door lock shall respond to Lock, Unlock, Toggle, " +
                    "  and Unlock with Timeout commands with a response status Failure and not take the action requested " +
                    "  by those commands. The door lock shall NOT disable the radio or otherwise unbind or leave the " +
                    "  network. It shall still respond to all other commands and requests."
            },

            Field({
                name: "Normal", id: 0x0, conformance: "M", xref: "cluster§5.2.6.15.1",
                details: "The lock operates normally. All interfaces are enabled."
            }),
            Field({
                name: "Vacation", id: 0x1, conformance: "O", xref: "cluster§5.2.6.15.2",
                details: "Only remote interaction is enabled. The keypad shall only be operable by the master user."
            }),

            Field({
                name: "Privacy", id: 0x2, conformance: "O", xref: "cluster§5.2.6.15.3",
                details: "This mode is only possible if the door is locked. Manual unlocking changes the mode to Normal " +
                    "operating mode. All external interaction with the door lock is disabled. This mode is intended to be " +
                    "used so that users, presumably inside the property, will have control over the entrance."
            }),

            Field({
                name: "NoRemoteLockUnlock", id: 0x3, conformance: "M", xref: "cluster§5.2.6.15.4",
                details: "This mode only disables remote interaction with the lock. This does not apply to any remote " +
                    "proprietary means of communication. It specifically applies to the Lock, Unlock, Toggle, and Unlock " +
                    "with Timeout Commands."
            }),

            Field({
                name: "Passage", id: 0x4, conformance: "O", xref: "cluster§5.2.6.15.5",
                details: "The lock is open or can be opened or closed at will without the use of a Keypad or other means of " +
                    "user validation (e.g. a lock for a business during work hours)."
            })
        ),

        Datatype(
            {
                name: "OperationSourceEnum", type: "enum8", xref: "cluster§5.2.6.16",
                details: "This enumeration shall indicate the source of the Lock/Unlock or user change operation performed."
            },
            Field({
                name: "Unspecified", id: 0x0, conformance: "O",
                description: "Lock/unlock operation came from unspecified source"
            }),
            Field({
                name: "Manual", id: 0x1, conformance: "O",
                description: "Lock/unlock operation came from manual operation (key, thumbturn, handle, etc)."
            }),
            Field({
                name: "ProprietaryRemote", id: 0x2, conformance: "O",
                description: "Lock/unlock operation came from proprietary remote source (e.g. vendor app/cloud)"
            }),
            Field({ name: "Keypad", id: 0x3, conformance: "O", description: "Lock/unlock operation came from keypad" }),
            Field({
                name: "Auto", id: 0x4, conformance: "O",
                description: "Lock/unlock operation came from lock automatically (e.g. relock timer)"
            }),
            Field({
                name: "Button", id: 0x5, conformance: "O",
                description: "Lock/unlock operation came from lock button (e.g. one touch or button)"
            }),
            Field({
                name: "Schedule", id: 0x6, conformance: "HDSCH",
                description: "Lock/unlock operation came from lock due to a schedule"
            }),
            Field({ name: "Remote", id: 0x7, conformance: "M", description: "Lock/unlock operation came from remote node" }),
            Field({ name: "Rfid", id: 0x8, conformance: "RID", description: "Lock/unlock operation came from RFID card" }),
            Field({
                name: "Biometric", id: 0x9, conformance: "[USR]",
                description: "Lock/unlock operation came from biometric source (e.g. face, fingerprint/fingervein)"
            }),
            Field({
                name: "Aliro", id: 0xa, conformance: "ALIRO",
                description: "Lock/unlock operation came from an interaction defined in [Aliro], or user change operation was a step-up credential provisioning as defined in [Aliro]"
            })
        ),

        Datatype(
            {
                name: "UserStatusEnum", type: "enum8", xref: "cluster§5.2.6.17",
                details: "This enumeration shall indicate what the status is for a specific user ID."
            },
            Field({ name: "Available", id: 0x0, conformance: "M", description: "The user ID is available" }),
            Field({ name: "OccupiedEnabled", id: 0x1, conformance: "M", description: "The user ID is occupied and enabled" }),
            Field({
                name: "OccupiedDisabled", id: 0x3, conformance: "O",
                description: "The user ID is occupied and disabled"
            })
        ),

        Datatype(
            {
                name: "UserTypeEnum", type: "enum8", xref: "cluster§5.2.6.18",
                details: "This enumeration shall indicate what the type is for a specific user ID."
            },

            Field({
                name: "UnrestrictedUser", id: 0x0, conformance: "M",
                description: "The user ID type is unrestricted", xref: "cluster§5.2.6.18.1",
                details: "This value shall indicate the user has access 24/7 provided proper PIN or RFID is supplied (e.g., " +
                    "owner)."
            }),

            Field({
                name: "YearDayScheduleUser", id: 0x1, conformance: "O", description: "The user ID type is schedule",
                xref: "cluster§5.2.6.18.2",

                details: "This value shall indicate the user has the ability to open lock within a specific time period (e.g., " +
                    "guest)." +
                    "\n" +
                    "When UserType is set to YearDayScheduleUser, user access shall be restricted as follows:" +
                    "\n" +
                    "  • If no YearDaySchedules are set for the user, then access shall be denied" +
                    "\n" +
                    "  • If one or more YearDaySchedules are set, user access shall be granted if and only if the current " +
                    "    time falls within at least one of the YearDaySchedules. If current time is not known, user " +
                    "    access shall NOT be granted."
            }),

            Field({
                name: "WeekDayScheduleUser", id: 0x2, conformance: "O", description: "The user ID type is schedule",
                xref: "cluster§5.2.6.18.3",

                details: "This value shall indicate the user has the ability to open lock based on specific time period within " +
                    "a reoccurring weekly schedule (e.g., cleaning worker)." +
                    "\n" +
                    "When UserType is set to WeekDayScheduleUser, user access shall be restricted as follows:" +
                    "\n" +
                    "  • If no WeekDaySchedules are set for the user, then access shall be denied" +
                    "\n" +
                    "  • If one or more WeekDaySchedules are set, user access shall be granted if and only if the current " +
                    "    time falls within at least one of the WeekDaySchedules. If current time is not known, user " +
                    "    access shall NOT be granted."
            }),

            Field({
                name: "ProgrammingUser", id: 0x3, conformance: "O", description: "The user ID type is programming",
                xref: "cluster§5.2.6.18.4",
                details: "This value shall indicate the user has the ability to both program and operate the door lock. This " +
                    "user can manage the users and user schedules. In all other respects this user matches the " +
                    "unrestricted (default) user. ProgrammingUser is the only user that can disable the user interface " +
                    "(keypad, remote, etc…)."
            }),

            Field({
                name: "NonAccessUser", id: 0x4, conformance: "O", description: "The user ID type is non access",
                xref: "cluster§5.2.6.18.5",
                details: "This value shall indicate the user is recognized by the lock but does not have the ability to open " +
                    "the lock. This user will only cause the lock to generate the appropriate event notification to any " +
                    "bound devices."
            }),

            Field({
                name: "ForcedUser", id: 0x5, conformance: "[USR]", description: "The user ID type is forced",
                xref: "cluster§5.2.6.18.6",
                details: "This value shall indicate the user has the ability to open lock but a ForcedUser LockOperationType " +
                    "and ForcedUser silent alarm will be emitted to allow a notified Node to alert emergency services or " +
                    "contacts on the user account when used."
            }),

            Field({
                name: "DisposableUser", id: 0x6, conformance: "[USR]",
                description: "The user ID type is disposable", xref: "cluster§5.2.6.18.7",
                details: "This value shall indicate the user has the ability to open lock once after which the lock shall " +
                    "change the corresponding user record UserStatus value to OccupiedDisabled automatically."
            }),

            Field({
                name: "ExpiringUser", id: 0x7, conformance: "[USR]", description: "The user ID type is expiring",
                xref: "cluster§5.2.6.18.8",
                details: "This value shall indicate the user has the ability to open lock for ExpiringUserTimeout attribute " +
                    "minutes after the first use of the PIN code, RFID code, Fingerprint, or other credential. After " +
                    "ExpiringUserTimeout minutes the corresponding user record UserStatus value shall be set to " +
                    "OccupiedDisabled automatically by the lock. The lock shall persist the timeout across reboots such " +
                    "that the ExpiringUserTimeout is honored."
            }),

            Field({
                name: "ScheduleRestrictedUser", id: 0x8, conformance: "WDSCH | YDSCH",
                description: "The user ID type is schedule restricted", xref: "cluster§5.2.6.18.9",

                details: "This value shall indicate the user access is restricted by Week Day and/or Year Day schedule. When " +
                    "UserType is set to ScheduleRestrictedUser, user access shall be restricted as follows:" +
                    "\n" +
                    "  • If no WeekDaySchedules and no YearDaySchedules are set for the user, then access shall be denied" +
                    "\n" +
                    "  • If one or more WeekDaySchedules are set, but no YearDaySchedules are set for the user, then user " +
                    "    access shall be equivalent to the WeekDayScheduleUser UserType" +
                    "\n" +
                    "  • If one or more YearDaySchedules are set, but no WeekDaySchedules are set for the user, then user " +
                    "    access shall be equivalent to the YearDayScheduleUser UserType" +
                    "\n" +
                    "  • If one or WeekDaySchedules are set AND one or more YearDaySchedules are set, then user access " +
                    "    shall be granted if and only if the current time falls within at least one of the " +
                    "    WeekDaySchedules AND the current time falls within at least one of the YearDaySchedules."
            }),

            Field({
                name: "RemoteOnlyUser", id: 0x9, conformance: "USR & COTA & PIN",
                description: "The user ID type is remote only", xref: "cluster§5.2.6.18.10",
                details: "This value shall indicate the user access and PIN code is restricted to remote lock/unlock commands " +
                    "only. This type of user might be useful for regular delivery services or voice assistant unlocking " +
                    "operations to prevent a PIN code credential created for them from being used at the keypad. The PIN " +
                    "code credential would only be provided over-the-air for the lock/unlock commands."
            })
        ),

        Datatype(
            { name: "LockStateEnum", type: "enum8", xref: "cluster§5.2.6.19" },
            Field({ name: "NotFullyLocked", id: 0x0, conformance: "M", description: "Lock state is not fully locked" }),
            Field({ name: "Locked", id: 0x1, conformance: "M", description: "Lock state is fully locked" }),
            Field({ name: "Unlocked", id: 0x2, conformance: "M", description: "Lock state is fully unlocked" }),
            Field({
                name: "Unlatched", id: 0x3, conformance: "O",
                description: "Lock state is fully unlocked and the latch is pulled"
            })
        ),

        Datatype(
            { name: "LockTypeEnum", type: "enum8", xref: "cluster§5.2.6.20" },
            Field({ name: "DeadBolt", id: 0x0, conformance: "M", description: "Physical lock type is dead bolt" }),
            Field({ name: "Magnetic", id: 0x1, conformance: "M", description: "Physical lock type is magnetic" }),
            Field({ name: "Other", id: 0x2, conformance: "M", description: "Physical lock type is other" }),
            Field({ name: "Mortise", id: 0x3, conformance: "M", description: "Physical lock type is mortise" }),
            Field({ name: "Rim", id: 0x4, conformance: "M", description: "Physical lock type is rim" }),
            Field({ name: "LatchBolt", id: 0x5, conformance: "M", description: "Physical lock type is latch bolt" }),
            Field({
                name: "CylindricalLock", id: 0x6, conformance: "M",
                description: "Physical lock type is cylindrical lock"
            }),
            Field({ name: "TubularLock", id: 0x7, conformance: "M", description: "Physical lock type is tubular lock" }),
            Field({
                name: "InterconnectedLock", id: 0x8, conformance: "M",
                description: "Physical lock type is interconnected lock"
            }),
            Field({ name: "DeadLatch", id: 0x9, conformance: "M", description: "Physical lock type is dead latch" }),
            Field({ name: "DoorFurniture", id: 0xa, conformance: "M", description: "Physical lock type is door furniture" }),
            Field({ name: "Eurocylinder", id: 0xb, conformance: "M", description: "Physical lock type is euro cylinder" })
        ),

        Datatype(
            { name: "LEDSettingEnum", type: "enum8", xref: "cluster§5.2.6.21" },
            Field({ name: "NoLedSignal", id: 0x0, conformance: "M", description: "Never use LED for signalization" }),
            Field({
                name: "NoLedSignalAccessAllowed", id: 0x1, conformance: "M",
                description: "Use LED signalization except for access allowed events"
            }),
            Field({ name: "LedSignalAll", id: 0x2, conformance: "M", description: "Use LED signalization for all events" })
        ),

        Datatype(
            { name: "SoundVolumeEnum", type: "enum8", xref: "cluster§5.2.6.22" },
            Field({ name: "Silent", id: 0x0, conformance: "M", description: "Silent Mode" }),
            Field({ name: "Low", id: 0x1, conformance: "M", description: "Low Volume" }),
            Field({ name: "High", id: 0x2, conformance: "M", description: "High Volume" }),
            Field({ name: "Medium", id: 0x3, conformance: "M", description: "Medium Volume" })
        ),

        Datatype(
            { name: "EventTypeEnum", type: "enum8", xref: "cluster§5.2.6.23" },
            Field({ name: "Operation", id: 0x0, conformance: "M", description: "Event type is operation" }),
            Field({ name: "Programming", id: 0x1, conformance: "M", description: "Event type is programming" }),
            Field({ name: "Alarm", id: 0x2, conformance: "M", description: "Event type is alarm" })
        ),

        Datatype(
            {
                name: "CredentialStruct", type: "struct", xref: "cluster§5.2.6.24",
                details: "This struct shall indicate the credential types and their corresponding indices (if any) for the " +
                    "event or user record."
            },
            Field({
                name: "CredentialType", id: 0x0, type: "CredentialTypeEnum", conformance: "M",
                xref: "cluster§5.2.6.24.1",
                details: "This field shall indicate the credential field used to authorize the lock operation."
            }),

            Field({
                name: "CredentialIndex", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§5.2.6.24.2",
                details: "This field shall indicate the index of the specific credential used to authorize the lock operation " +
                    "in the list of credentials identified by CredentialType (e.g. PIN, RFID, etc.). This field shall be " +
                    "set to 0 if CredentialType is ProgrammingPIN or does not correspond to a list that can be indexed " +
                    "into."
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "cluster§5.2.7.1" },
            Field({
                name: "Duplicate", id: 0x2, conformance: "M",
                description: "Entry would cause a duplicate credential/ID."
            }),
            Field({ name: "Occupied", id: 0x3, conformance: "M", description: "Entry would replace an occupied slot." })
        )
    ),

    Cluster(
        {
            name: "WindowCovering", id: 0x102, classification: "application", pics: "WNCV", xref: "cluster§5.3",
            details: "The window covering cluster provides an interface for controlling and adjusting automatic window " +
                "coverings such as drapery motors, automatic shades, curtains and blinds."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 6 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§5.3.4" },

            Field({
                name: "LF", conformance: "O.a+", constraint: "0", title: "Lift", xref: "cluster§5.3.4.1",
                details: "The Lift feature applies to window coverings that lift up and down (e.g. for a roller shade, Up and " +
                    "Down is lift Open and Close) or slide left to right (e.g. for a sliding curtain, Left and Right is " +
                    "lift Open and Close)."
            }),

            Field({
                name: "TL", conformance: "O.a+", constraint: "1", title: "Tilt", xref: "cluster§5.3.4.2",
                details: "The Tilt feature applies to window coverings with vertical or horizontal strips."
            }),
            Field({
                name: "PA_LF", conformance: "[LF]", constraint: "2", title: "PositionAwareLift",
                details: "Position aware lift control is supported."
            }),

            Field({
                name: "ABS", conformance: "P, O", constraint: "3", title: "AbsolutePosition",
                xref: "cluster§5.3.4.4",

                details: "The percentage attributes shall indicate the position as a percentage between the " +
                    "InstalledOpenLimits and InstalledClosedLimits attributes of the window covering starting at the open " +
                    "(0.00%)." +
                    "\n" +
                    "As a general rule, absolute positioning (in centimeters or tenth of a degrees) SHOULD NOT be " +
                    "supported for new implementations."
            }),

            Field({
                name: "PA_TL", conformance: "[TL]", constraint: "4", title: "PositionAwareTilt",
                details: "Position aware tilt control is supported."
            })
        ),

        Attribute({
            name: "Type", id: 0x0, type: "TypeEnum", access: "R V", conformance: "M", constraint: "desc",
            default: 0, quality: "F", xref: "cluster§5.3.6.1",

            details: "This attribute shall identify the type of window covering." +
                "\n" +
                "If the window covering supports the LF feature and not the TL feature, the following types shall be " +
                "used as the constraint for this attribute:" +
                "\n" +
                "If the window covering supports the TL feature and not the LF feature, the following types shall be " +
                "used as the constraint for this attribute:" +
                "\n" +
                "If the window covering supports both the LF and TL features, the following types are allowed to be " +
                "used:"
        }),

        Attribute({
            name: "PhysicalClosedLimitLift", id: 0x1, type: "uint16", access: "R V",
            conformance: "P, [LF & PA_LF & ABS]", default: 0, quality: "F", xref: "cluster§5.3.6.2",
            details: "Indicates the maximum possible encoder position possible (Unit cm, centimeters) to position the " +
                "height of the window covering lift."
        }),

        Attribute({
            name: "PhysicalClosedLimitTilt", id: 0x2, type: "uint16", access: "R V",
            conformance: "P, [TL & PA_TL & ABS]", default: 0, quality: "F", xref: "cluster§5.3.6.3",
            details: "Indicates the maximum possible encoder position possible (Unit 0.1°, tenths of a degree) to position " +
                "the angle of the window covering tilt."
        }),

        Attribute({
            name: "CurrentPositionLift", id: 0x3, type: "uint16", access: "R V",
            conformance: "P, [LF & PA_LF & ABS]",
            constraint: "installedOpenLimitLift to installedClosedLimitLift", default: null, quality: "X N",
            xref: "cluster§5.3.6.4",
            details: "Indicates the actual lift position (Unit cm, centimeters) of the window covering from the fully-open " +
                "position."
        }),

        Attribute({
            name: "CurrentPositionTilt", id: 0x4, type: "uint16", access: "R V",
            conformance: "P, [TL & PA_TL & ABS]",
            constraint: "installedOpenLimitTilt to installedClosedLimitTilt", default: null, quality: "X N",
            xref: "cluster§5.3.6.5",
            details: "Indicates the actual tilt position (Unit 0.1°, tenths of a degree) of the window covering from the " +
                "fully-open position."
        }),

        Attribute({
            name: "NumberOfActuationsLift", id: 0x5, type: "uint16", access: "R V", conformance: "[LF]",
            default: 0, quality: "N", xref: "cluster§5.3.6.6",
            details: "Indicates the total number of lift/slide actuations applied to the window covering since the device " +
                "was installed."
        }),

        Attribute({
            name: "NumberOfActuationsTilt", id: 0x6, type: "uint16", access: "R V", conformance: "[TL]",
            default: 0, quality: "N", xref: "cluster§5.3.6.7",
            details: "Indicates the total number of tilt actuations applied to the window covering since the device was " +
                "installed."
        }),

        Attribute({
            name: "ConfigStatus", id: 0x7, type: "ConfigStatusBitmap", access: "R V", conformance: "M",
            constraint: "desc", quality: "N", xref: "cluster§5.3.6.8",
            details: "This attribute specifies the configuration and status information of the window covering." +
                "\n" +
                "To change settings, devices shall write to the Mode attribute. The behavior causing the setting or " +
                "clearing of each bit is vendor specific."
        }),

        Attribute({
            name: "CurrentPositionLiftPercentage", id: 0x8, type: "percent", access: "R V",
            conformance: "[LF & PA_LF]", default: null, quality: "X N P", xref: "cluster§5.3.6.11",
            details: "Indicates the actual position as a percentage from 0% to 100% with 1% default step. This attribute " +
                "is equal to CurrentPositionLiftPercent100ths attribute divided by 100."
        }),

        Attribute({
            name: "CurrentPositionTiltPercentage", id: 0x9, type: "percent", access: "R V",
            conformance: "[TL & PA_TL]", default: null, quality: "X N P", xref: "cluster§5.3.6.12",
            details: "Indicates the actual position as a percentage from 0% to 100% with 1% default step. This attribute " +
                "is equal to CurrentPositionTiltPercent100ths attribute divided by 100."
        }),

        Attribute({
            name: "OperationalStatus", id: 0xa, type: "OperationalStatusBitmap", access: "R V",
            conformance: "M", constraint: "max 63", default: 0, quality: "P", xref: "cluster§5.3.6.15",
            details: "Indicates the currently ongoing operations and applies to all type of devices."
        }),

        Attribute({
            name: "TargetPositionLiftPercent100ths", id: 0xb, type: "percent100ths", access: "R V",
            conformance: "LF & PA_LF", default: null, quality: "X P", xref: "cluster§5.3.6.13",
            details: "Indicates the position where the window covering lift will go or is moving to as a percentage (Unit " +
                "0.01%)."
        }),

        Attribute({
            name: "TargetPositionTiltPercent100ths", id: 0xc, type: "percent100ths", access: "R V",
            conformance: "TL & PA_TL", default: null, quality: "X P", xref: "cluster§5.3.6.14",
            details: "Indicates the position where the window covering tilt will go or is moving to as a percentage (Unit " +
                "0.01%)."
        }),

        Attribute({
            name: "EndProductType", id: 0xd, type: "EndProductTypeEnum", access: "R V", conformance: "M",
            constraint: "desc", default: 0, quality: "F", xref: "cluster§5.3.6.16",

            details: "This attribute SHOULD provide more detail about the product type than can be determined from the " +
                "main category indicated by the Type attribute." +
                "\n" +
                "If the window covering supports the LF feature and not the TL feature, the following types shall be " +
                "used as the constraint for this attribute:" +
                "\n" +
                "If the window covering supports the TL feature and not the LF feature, the following types shall be " +
                "used as the constraint for this attribute:" +
                "\n" +
                "If the window covering supports both the LF and TL features, the following types are allowed to be " +
                "used:" +
                "\n" +
                "The table below helps to match the EndProductType attribute with the Type attribute."
        }),

        Attribute({
            name: "CurrentPositionLiftPercent100ths", id: 0xe, type: "percent100ths", access: "R V",
            conformance: "LF & PA_LF", constraint: "max 10000", default: null, quality: "X N P",
            xref: "cluster§5.3.6.9",
            details: "Indicates the actual position as a percentage with a minimal step of 0.01%. E.g Max 10000 equals " +
                "100.00%."
        }),

        Attribute({
            name: "CurrentPositionTiltPercent100ths", id: 0xf, type: "percent100ths", access: "R V",
            conformance: "TL & PA_TL", constraint: "max 10000", default: null, quality: "X N P",
            xref: "cluster§5.3.6.10",
            details: "Indicates the actual position as a percentage with a minimal step of 0.01%. E.g Max 10000 equals " +
                "100.00%."
        }),

        Attribute({
            name: "InstalledOpenLimitLift", id: 0x10, type: "uint16", access: "R V",
            conformance: "P, LF & PA_LF & ABS", constraint: "max 65534", default: 0, quality: "N",
            xref: "cluster§5.3.6.17",
            details: "Indicates the open limit for lifting the window covering whether position (in centimeters) is " +
                "encoded or timed."
        }),

        Attribute({
            name: "InstalledClosedLimitLift", id: 0x11, type: "uint16", access: "R V",
            conformance: "P, LF & PA_LF & ABS", constraint: "max 65534", default: 65534, quality: "N",
            xref: "cluster§5.3.6.18",
            details: "Indicates the closed limit for lifting the window covering whether position (in centimeters) is " +
                "encoded or timed."
        }),

        Attribute({
            name: "InstalledOpenLimitTilt", id: 0x12, type: "uint16", access: "R V",
            conformance: "P, TL & PA_TL & ABS", constraint: "max 65534", default: 0, quality: "N",
            xref: "cluster§5.3.6.19",
            details: "Indicates the open limit for tilting the window covering whether position (in tenth of a degree) is " +
                "encoded or timed."
        }),

        Attribute({
            name: "InstalledClosedLimitTilt", id: 0x13, type: "uint16", access: "R V",
            conformance: "P, TL & PA_TL & ABS", constraint: "max 65534", default: 65534, quality: "N",
            xref: "cluster§5.3.6.20",
            details: "Indicates the closed limit for tilting the window covering whether position (in tenth of a degree) " +
                "is encoded or timed."
        }),

        Attribute({ name: "VelocityLift", id: 0x14, conformance: "D", xref: "cluster§5.3.6" }),
        Attribute({ name: "AccelerationTimeLift", id: 0x15, conformance: "D", xref: "cluster§5.3.6" }),
        Attribute({ name: "DecelerationTimeLift", id: 0x16, conformance: "D", xref: "cluster§5.3.6" }),

        Attribute({
            name: "Mode", id: 0x17, type: "ModeBitmap", access: "RW VM", conformance: "M", constraint: "max 15",
            default: 0, quality: "N", xref: "cluster§5.3.6.21",

            details: "The Mode attribute allows configuration of the window covering, such as: reversing the motor " +
                "direction, placing the window covering into calibration mode, placing the motor into maintenance " +
                "mode, disabling the network, and disabling status LEDs." +
                "\n" +
                "In the case a device does not support or implement a specific mode, e.g. the device has a specific " +
                "installation method and reversal is not relevant or the device does not include a maintenance mode, " +
                "any write interaction to the Mode attribute, with an unsupported mode bit or any out of bounds bits " +
                "set, must be ignored and a response containing the status of CONSTRAINT_ERROR will be returned."
        }),

        Attribute({ name: "IntermediateSetpointsLift", id: 0x18, conformance: "D", xref: "cluster§5.3.6" }),
        Attribute({ name: "IntermediateSetpointsTilt", id: 0x19, conformance: "D", xref: "cluster§5.3.6" }),

        Attribute({
            name: "SafetyStatus", id: 0x1a, type: "SafetyStatusBitmap", access: "R V", conformance: "O",
            constraint: "desc", default: 0, quality: "P", xref: "cluster§5.3.6.22",
            details: "The SafetyStatus attribute reflects the state of the safety sensors and the common issues preventing " +
                "movements. By default for nominal operation all flags are cleared (0). A device might support none, " +
                "one or several bit flags from this attribute (all optional)."
        }),

        Command({
            name: "UpOrOpen", id: 0x0, access: "O", conformance: "M", direction: "request", response: "status",
            xref: "cluster§5.3.7.1",

            details: "Upon receipt of this command, the window covering will adjust its position so the physical " +
                "lift/slide and tilt is at the maximum open/up position. This will happen as fast as possible. The " +
                "server attributes shall be updated as follows:" +
                "\n" +
                "if the PositionAware feature is supported:" +
                "\n" +
                "  • TargetPositionLiftPercent100ths attribute shall be set to 0.00%." +
                "\n" +
                "  • TargetPositionTiltPercent100ths attribute shall be set to 0.00%." +
                "\n" +
                "The server positioning attributes will follow the movements, once the movement has successfully " +
                "finished, the server attributes shall be updated as follows:" +
                "\n" +
                "if the PositionAware feature is supported:" +
                "\n" +
                "  • CurrentPositionLiftPercent100ths attribute shall be 0.00%." +
                "\n" +
                "  • CurrentPositionLiftPercentage attribute shall be 0%." +
                "\n" +
                "  • CurrentPositionTiltPercent100ths attribute shall be 0.00%." +
                "\n" +
                "  • CurrentPositionTiltPercentage attribute shall be 0%." +
                "\n" +
                "if the AbsolutePosition feature is supported:" +
                "\n" +
                "  • CurrentPositionLift attribute shall be equal to the InstalledOpenLimitLift attribute." +
                "\n" +
                "  • CurrentPositionTilt attribute shall be equal to the InstalledOpenLimitTilt attribute."
        }),

        Command({
            name: "DownOrClose", id: 0x1, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§5.3.7.2",

            details: "Upon receipt of this command, the window covering will adjust its position so the physical " +
                "lift/slide and tilt is at the maximum closed/down position. This will happen as fast as possible. " +
                "The server attributes supported shall be updated as follows:" +
                "\n" +
                "if the PositionAware feature is supported:" +
                "\n" +
                "  • TargetPositionLiftPercent100ths attribute shall be set to 100.00%." +
                "\n" +
                "  • TargetPositionTiltPercent100ths attribute shall be set to 100.00%." +
                "\n" +
                "The server positioning attributes will follow the movements, once the movement has successfully " +
                "finished, the server attributes shall be updated as follows:" +
                "\n" +
                "if the PositionAware feature is supported:" +
                "\n" +
                "  • CurrentPositionLiftPercent100ths attribute shall be 100.00%." +
                "\n" +
                "  • CurrentPositionLiftPercentage attribute shall be 100%." +
                "\n" +
                "  • CurrentPositionTiltPercent100ths attribute shall be 100.00%." +
                "\n" +
                "  • CurrentPositionTiltPercentage attribute shall be 100%." +
                "\n" +
                "if the AbsolutePosition feature is supported:" +
                "\n" +
                "  • CurrentPositionLift attribute shall be equal to the InstalledClosedLimitLift attribute." +
                "\n" +
                "  • CurrentPositionTilt attribute shall be equal to the InstalledClosedLimitTilt attribute."
        }),

        Command({
            name: "StopMotion", id: 0x2, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§5.3.7.3",

            details: "Upon receipt of this command, the window covering will stop any adjusting to the physical tilt and " +
                "lift/slide that is currently occurring. The server attributes supported shall be updated as follows:" +
                "\n" +
                "  • TargetPositionLiftPercent100ths attribute will be set to CurrentPositionLiftPercent100ths " +
                "    attribute value." +
                "\n" +
                "  • TargetPositionTiltPercent100ths attribute will be set to CurrentPositionTiltPercent100ths " +
                "    attribute value."
        }),

        Command(
            {
                name: "GoToLiftValue", id: 0x4, access: "O", conformance: "P, [LF & ABS]", direction: "request",
                response: "status", xref: "cluster§5.3.7.4",
                details: "This command is used to set the target lift position of the window covering to the value specified " +
                    "in the command."
            },

            Field({
                name: "LiftValue", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.3.7.4.1",
                details: "This field shall specify the requested physical lift/slide position in unit cm (centimeters)."
            })
        ),

        Command(
            {
                name: "GoToLiftPercentage", id: 0x5, access: "O", conformance: "LF & PA_LF, [LF]",
                direction: "request", response: "status", xref: "cluster§5.3.7.5",

                details: "This command is used to set the target lift position of the window covering to the percentage value " +
                    "specified in the command." +
                    "\n" +
                    "Upon receipt of this command, the server will adjust the window covering to the lift/slide " +
                    "percentage specified in the payload of this command." +
                    "\n" +
                    "If the command includes LiftPercent100thsValue, then TargetPositionLiftPercent100ths attribute shall " +
                    "be set to LiftPercent100thsValue. Otherwise the TargetPositionLiftPercent100ths attribute shall be " +
                    "set to LiftPercentageValue * 100." +
                    "\n" +
                    "If a client includes LiftPercent100thsValue in the command, the LiftPercentageValue shall be set to " +
                    "LiftPercent100thsValue / 100, so a legacy server which only supports LiftPercentageValue (not " +
                    "LiftPercent100thsValue) has a value to set the target position." +
                    "\n" +
                    "If the server does not support the PositionAware feature, then a zero percentage shall be treated as " +
                    "a UpOrOpen command and a non-zero percentage shall be treated as an DownOrClose command. If the " +
                    "device is only a tilt control device, then the command SHOULD be ignored and a UNSUPPORTED_COMMAND " +
                    "status SHOULD be returned."
            },

            Field({ name: "LiftPercent100thsValue", id: 0x0, type: "percent100ths", conformance: "M", constraint: "desc" })
        ),

        Command(
            {
                name: "GoToTiltValue", id: 0x7, access: "O", conformance: "P, [TL & ABS]", direction: "request",
                response: "status", xref: "cluster§5.3.7.6",
                details: "This command is used to set the target tilt position of the window covering to the value specified " +
                    "in the command."
            },

            Field({
                name: "TiltValue", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "cluster§5.3.7.6.1",
                details: "This field shall specify the requested physical tilt position in unit 0.1° (tenth of a degrees)."
            })
        ),

        Command(
            {
                name: "GoToTiltPercentage", id: 0x8, access: "O", conformance: "TL & PA_TL, [TL]",
                direction: "request", response: "status", xref: "cluster§5.3.7.7",

                details: "This command is used to set the target tilt position of the window covering to the percentage value " +
                    "specified in the command." +
                    "\n" +
                    "Upon receipt of this command, the server will adjust the window covering to the tilt percentage " +
                    "specified in the payload of this command." +
                    "\n" +
                    "If the command includes TiltPercent100thsValue, then TargetPositionTiltPercent100ths attribute shall " +
                    "be set to TiltPercent100thsValue. Otherwise the TargetPositionTiltPercent100ths attribute shall be " +
                    "set to TiltPercentageValue * 100." +
                    "\n" +
                    "If a client includes TiltPercent100thsValue in the command, the TiltPercentageValue shall be set to " +
                    "TiltPercent100thsValue / 100, so a legacy server which only supports TiltPercentageValue (not " +
                    "TiltPercent100thsValue) has a value to set the target position." +
                    "\n" +
                    "If the server does not support the PositionAware feature, then a zero percentage shall be treated as " +
                    "a UpOrOpen command and a non-zero percentage shall be treated as an DownOrClose command. If the " +
                    "device is only a tilt control device, then the command SHOULD be ignored and a UNSUPPORTED_COMMAND " +
                    "status SHOULD be returned."
            },

            Field({ name: "TiltPercent100thsValue", id: 0x0, type: "percent100ths", conformance: "M", constraint: "desc" })
        ),

        Datatype(
            { name: "ConfigStatusBitmap", type: "map8", xref: "cluster§5.3.5.1" },

            Field(
                {
                    name: "Operational", constraint: "0", description: "Device is operational.",
                    xref: "cluster§5.3.5.1.1",
                    details: "This bit shall indicate whether the window covering is operational for regular use:" +
                        "\n" +
                        "  • 0 = Not Operational" +
                        "\n" +
                        "  • 1 = Operational"
                }
            ),

            Field({ name: "OnlineReserved", constraint: "1" }),

            Field(
                {
                    name: "LiftMovementReversed", constraint: "2", description: "The lift movement is reversed.",
                    xref: "cluster§5.3.5.1.2",
                    details: "This bit shall indicate whether the lift movement is reversed:" +
                        "\n" +
                        "  • 0 = Lift movement is normal" +
                        "\n" +
                        "  • 1 = Lift movement is reversed"
                }
            ),

            Field(
                {
                    name: "LiftPositionAware", constraint: "3",
                    description: "Supports the PositionAwareLift feature (PA_LF).", xref: "cluster§5.3.5.1.3",
                    details: "This bit shall indicate whether the window covering supports the PositionAwareLift feature:" +
                        "\n" +
                        "  • 0 = Lift control is not position aware" +
                        "\n" +
                        "  • 1 = Lift control is position aware (PA_LF)"
                }
            ),

            Field(
                {
                    name: "TiltPositionAware", constraint: "4",
                    description: "Supports the PositionAwareTilt feature (PA_TL).", xref: "cluster§5.3.5.1.4",
                    details: "This bit shall indicate whether the window covering supports the PositionAwareTilt feature:" +
                        "\n" +
                        "  • 0 = Tilt control is not position aware" +
                        "\n" +
                        "  • 1 = Tilt control is position aware (PA_TL)"
                }
            ),

            Field(
                {
                    name: "LiftEncoderControlled", constraint: "5", description: "Uses an encoder for lift.",
                    xref: "cluster§5.3.5.1.5",

                    details: "This bit shall indicate whether a position aware controlled window covering is employing an encoder " +
                        "for positioning the height of the window covering:" +
                        "\n" +
                        "  • 0 = Timer Controlled" +
                        "\n" +
                        "  • 1 = Encoder Controlled"
                }
            ),

            Field(
                {
                    name: "TiltEncoderControlled", constraint: "6", description: "Uses an encoder for tilt.",
                    xref: "cluster§5.3.5.1.6",

                    details: "This bit shall indicate whether a position aware controlled window covering is employing an encoder " +
                        "for tilting the window covering:" +
                        "\n" +
                        "  • 0 = Timer Controlled" +
                        "\n" +
                        "  • 1 = Encoder Controlled"
                }
            )
        ),

        Datatype(
            { name: "ModeBitmap", type: "map8", xref: "cluster§5.3.5.2" },

            Field(
                {
                    name: "MotorDirectionReversed", constraint: "0", description: "Reverse the lift direction.",
                    xref: "cluster§5.3.5.2.1",
                    details: "This bit shall control the motor direction:" +
                        "\n" +
                        "  • 0 = Lift movement is normal" +
                        "\n" +
                        "  • 1 = Lift movement is reversed"
                }
            ),

            Field(
                {
                    name: "CalibrationMode", constraint: "1", description: "Perform a calibration.",
                    xref: "cluster§5.3.5.2.2",
                    details: "This bit shall set the window covering into calibration mode:" +
                        "\n" +
                        "  • 0 = Normal mode" +
                        "\n" +
                        "  • 1 = Calibration mode"
                }
            ),

            Field(
                {
                    name: "MaintenanceMode", constraint: "2", description: "Freeze all motions for maintenance.",
                    xref: "cluster§5.3.5.2.3",
                    details: "This bit shall set the window covering into maintenance mode:" +
                        "\n" +
                        "  • 0 = Normal mode" +
                        "\n" +
                        "  • 1 = Maintenance mode"
                }
            ),

            Field(
                {
                    name: "LedFeedback", constraint: "3", description: "Control the LEDs feedback.",
                    xref: "cluster§5.3.5.2.4",
                    details: "This bit shall control feedback LEDs:" +
                        "\n" +
                        "  • 0 = LEDs are off" +
                        "\n" +
                        "  • 1 = LEDs will display feedback"
                }
            )
        ),

        Datatype(
            {
                name: "OperationalStatusBitmap", type: "map8", xref: "cluster§5.3.5.3",

                details: "The OperationalStatusBitmap is using several internal operational state fields (composed of 2 bits) " +
                    "following this definition:" +
                    "\n" +
                    "  • 00b = Currently not moving" +
                    "\n" +
                    "  • 01b = Currently opening (e.g. moving from closed to open)." +
                    "\n" +
                    "  • 10b = Currently closing (e.g. moving from open to closed)." +
                    "\n" +
                    "  • 11b = Reserved"
            },

            Field({
                name: "Global", constraint: "0 to 1", description: "Global operational state.",
                xref: "cluster§5.3.5.3.1",
                details: "These bits shall indicate in which direction the covering is currently moving or if it has stopped. " +
                    "Global operational state shall always reflect the overall motion of the device."
            }),

            Field({
                name: "Lift", constraint: "2 to 3", description: "Lift operational state.",
                xref: "cluster§5.3.5.3.2",
                details: "These bits shall indicate in which direction the covering’s lift is currently moving or if it has " +
                    "stopped."
            }),

            Field({
                name: "Tilt", constraint: "4 to 5", description: "Tilt operational state.",
                xref: "cluster§5.3.5.3.3",
                details: "These bits shall indicate in which direction the covering’s tilt is currently moving or if it has " +
                    "stopped."
            })
        ),

        Datatype(
            { name: "SafetyStatusBitmap", type: "map16", xref: "cluster§5.3.5.4" },
            Field({
                name: "RemoteLockout", constraint: "0",
                description: "Movement commands are ignored (locked out). e.g. not granted authorization, outside some time/date range."
            }),
            Field({
                name: "TamperDetection", constraint: "1",
                description: "Tampering detected on sensors or any other safety equipment. Ex: a device has been forcedly moved without its actuator(s)."
            }),
            Field({
                name: "FailedCommunication", constraint: "2",
                description: "Communication failure to sensors or other safety equipment."
            }),
            Field({
                name: "PositionFailure", constraint: "3",
                description: "Device has failed to reach the desired position. e.g. with position aware device, time expired before TargetPosition is reached."
            }),
            Field({
                name: "ThermalProtection", constraint: "4",
                description: "Motor(s) and/or electric circuit thermal protection activated."
            }),
            Field({ name: "ObstacleDetected", constraint: "5", description: "An obstacle is preventing actuator movement." }),
            Field({
                name: "Power", constraint: "6",
                description: "Device has power related issue or limitation e.g. device is running w/ the help of a backup battery or power might not be fully available at the moment."
            }),
            Field({
                name: "StopInput", constraint: "7",
                description: "Local safety sensor (not a direct obstacle) is preventing movements (e.g. Safety EU Standard EN60335)."
            }),
            Field({
                name: "MotorJammed", constraint: "8",
                description: "Mechanical problem related to the motor(s) detected."
            }),
            Field({ name: "HardwareFailure", constraint: "9", description: "PCB, fuse and other electrics problems." }),
            Field({
                name: "ManualOperation", constraint: "10",
                description: "Actuator is manually operated and is preventing actuator movement (e.g. actuator is disengaged/decoupled)."
            }),
            Field({ name: "Protection", constraint: "11", description: "Protection is activated." })
        ),

        Datatype(
            { name: "TypeEnum", type: "enum8", xref: "cluster§5.3.5.5" },
            Field({ name: "RollerShade", id: 0x0, conformance: "M", description: "RollerShade" }),
            Field({ name: "RollerShade2Motor", id: 0x1, conformance: "M", description: "RollerShade - 2 Motor" }),
            Field({ name: "RollerShadeExterior", id: 0x2, conformance: "M", description: "RollerShade - Exterior" }),
            Field({
                name: "RollerShadeExterior2Motor", id: 0x3, conformance: "M",
                description: "RollerShade - Exterior - 2 Motor"
            }),
            Field({ name: "Drapery", id: 0x4, conformance: "M", description: "Drapery (curtain)" }),
            Field({ name: "Awning", id: 0x5, conformance: "M", description: "Awning" }),
            Field({ name: "Shutter", id: 0x6, conformance: "M", description: "Shutter" }),
            Field({ name: "TiltBlindTiltOnly", id: 0x7, conformance: "M", description: "Tilt Blind - Tilt Only" }),
            Field({ name: "TiltBlindLiftAndTilt", id: 0x8, conformance: "M", description: "Tilt Blind - Lift & Tilt" }),
            Field({ name: "ProjectorScreen", id: 0x9, conformance: "M", description: "Projector Screen" }),
            Field({ name: "Unknown", id: 0xff, conformance: "M", description: "Unknown" })
        ),

        Datatype(
            { name: "EndProductTypeEnum", type: "enum8", xref: "cluster§5.3.5.6" },
            Field({ name: "RollerShade", id: 0x0, conformance: "M", description: "Simple Roller Shade" }),
            Field({ name: "RomanShade", id: 0x1, conformance: "M", description: "Roman Shade" }),
            Field({ name: "BalloonShade", id: 0x2, conformance: "M", description: "Balloon Shade" }),
            Field({ name: "WovenWood", id: 0x3, conformance: "M", description: "Woven Wood" }),
            Field({ name: "PleatedShade", id: 0x4, conformance: "M", description: "Pleated Shade" }),
            Field({ name: "CellularShade", id: 0x5, conformance: "M", description: "Cellular Shade" }),
            Field({ name: "LayeredShade", id: 0x6, conformance: "M", description: "Layered Shade" }),
            Field({ name: "LayeredShade2D", id: 0x7, conformance: "M", description: "Layered Shade 2D" }),
            Field({ name: "SheerShade", id: 0x8, conformance: "M", description: "Sheer Shade" }),
            Field({ name: "TiltOnlyInteriorBlind", id: 0x9, conformance: "M", description: "Tilt Only Interior Blind" }),
            Field({ name: "InteriorBlind", id: 0xa, conformance: "M", description: "Interior Blind" }),
            Field({
                name: "VerticalBlindStripCurtain", id: 0xb, conformance: "M",
                description: "Vertical Blind, Strip Curtain"
            }),
            Field({ name: "InteriorVenetianBlind", id: 0xc, conformance: "M", description: "Interior Venetian Blind" }),
            Field({ name: "ExteriorVenetianBlind", id: 0xd, conformance: "M", description: "Exterior Venetian Blind" }),
            Field({ name: "LateralLeftCurtain", id: 0xe, conformance: "M", description: "Lateral Left Curtain" }),
            Field({ name: "LateralRightCurtain", id: 0xf, conformance: "M", description: "Lateral Right Curtain" }),
            Field({ name: "CentralCurtain", id: 0x10, conformance: "M", description: "Central Curtain" }),
            Field({ name: "RollerShutter", id: 0x11, conformance: "M", description: "Roller Shutter" }),
            Field({ name: "ExteriorVerticalScreen", id: 0x12, conformance: "M", description: "Exterior Vertical Screen" }),
            Field({ name: "AwningTerracePatio", id: 0x13, conformance: "M", description: "Awning Terrace (Patio)" }),
            Field({ name: "AwningVerticalScreen", id: 0x14, conformance: "M", description: "Awning Vertical Screen" }),
            Field({ name: "TiltOnlyPergola", id: 0x15, conformance: "M", description: "Tilt Only Pergola" }),
            Field({ name: "SwingingShutter", id: 0x16, conformance: "M", description: "Swinging Shutter" }),
            Field({ name: "SlidingShutter", id: 0x17, conformance: "M", description: "Sliding Shutter" }),
            Field({ name: "Unknown", id: 0xff, conformance: "M", description: "Unknown" })
        )
    ),

    Cluster(
        {
            name: "AccountLogin", id: 0x50e, classification: "application", pics: "ALOGIN", xref: "cluster§6.2",

            details: "This cluster provides commands that facilitate user account login on a Content App or a node. For " +
                "example, a Content App running on a Video Player device, which is represented as an endpoint (see " +
                "Device Type Library document), can use this cluster to help make the user account on the Content App " +
                "match the user account on the Client." +
                "\n" +
                "Often a fabric administrator will facilitate commissioning of a Client (such as a Casting Video " +
                "Client), and invoke commands on the AccountLogin cluster on the Content App associated with that " +
                "client. Specifically:" +
                "\n" +
                "  1. GetSetupPIN in order to attempt to obtain the Passcode for commissioning." +
                "\n" +
                "  2. Login in order to let the Content App know that commissioning has completed. The Content App " +
                "     can use information provided in this command in order to determine the user account associated " +
                "     with the client, and potentially assume that user account." +
                "\n" +
                "  3. Logout in order to let the Content App know that client access has been removed, and " +
                "     potentially clear the current user account." +
                "\n" +
                "The cluster server for this cluster may be supported on each endpoint that represents a Content App " +
                "on a Video Player device." +
                "\n" +
                "See Device Type Library document for details of how a Content App, represented as an endpoint on the " +
                "Video Player device, may implement the cluster server for this cluster to simplify account login for " +
                "its users."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Event(
            {
                name: "LoggedOut", id: 0x0, access: "S A", conformance: "O", priority: "critical",
                xref: "cluster§6.2.5.1",
                details: "This event can be used by the Content App to indicate that the current user has logged out. In " +
                    "response to this event, the Fabric Admin shall remove access to this Content App by the specified " +
                    "Node. If no Node is provided, then the Fabric Admin shall remove access to all non-Admin Nodes."
            },

            Field({
                name: "Node", id: 0x0, type: "node-id", conformance: "O", xref: "cluster§6.2.5.1.1",
                details: "This field shall provide the Node ID corresponding to the user account that has logged out, if that " +
                    "Node ID is available. If it is NOT available, this field shall NOT be present in the event."
            })
        ),

        Command(
            {
                name: "GetSetupPin", id: 0x0, access: "F A T", conformance: "M", direction: "request",
                response: "GetSetupPinResponse", xref: "cluster§6.2.4.1",

                details: "The purpose of this command is to determine if the active user account of the given Content App " +
                    "matches the active user account of a given Commissionee, and when it does, return a Setup PIN which " +
                    "can be used for password-authenticated session establishment (PASE) with the Commissionee." +
                    "\n" +
                    "For example, a Video Player with a Content App Platform may invoke this command on one of its " +
                    "Content App endpoints to facilitate commissioning of a Phone App made by the same vendor as the " +
                    "Content App. If the accounts match, then the Content App may return a Setup PIN that can be used by " +
                    "the Video Player to commission the Phone App without requiring the user to physically input a Setup " +
                    "PIN." +
                    "\n" +
                    "The account match is determined by the Content App using a method which is outside the scope of this " +
                    "specification and will typically involve a central service which is in communication with both the " +
                    "Content App and the Commissionee. The GetSetupPIN command is needed in order to provide the " +
                    "Commissioner/Admin with a Setup PIN when this Commissioner/Admin is operated by a different vendor " +
                    "from the Content App." +
                    "\n" +
                    "This method is used to facilitate Setup PIN exchange (for PASE) between Commissioner and " +
                    "Commissionee when the same user account is active on both nodes. With this method, the Content App " +
                    "satisfies proof of possession related to commissioning by requiring the same user account to be " +
                    "active on both Commissionee and Content App, while the Commissioner/Admin ensures user consent by " +
                    "prompting the user prior to invocation of the command." +
                    "\n" +
                    "Upon receipt of this command, the Content App checks if the account associated with the Temporary " +
                    "Account Identifier sent by the client is the same account that is active on itself. If the accounts " +
                    "are the same, then the Content App returns the GetSetupPIN Response which includes a Setup PIN that " +
                    "may be used for PASE with the Commissionee." +
                    "\n" +
                    "The Temporary Account Identifier for a Commissionee may be populated with the Rotating ID field of " +
                    "the client’s commissionable node advertisement (see Rotating Device Identifier section in " +
                    "[MatterCore]) encoded as an octet string where the octets of the Rotating Device Identifier are " +
                    "encoded as 2-character sequences by representing each octet’s value as a 2-digit hexadecimal number, " +
                    "using uppercase letters." +
                    "\n" +
                    "The Setup PIN is a character string so that it can accommodate different future formats, including " +
                    "alpha-numeric encodings. For a Commissionee it shall be populated with the Manual Pairing Code (see " +
                    "Manual Pairing Code section in [MatterCore]) encoded as a string (11 characters) or the Passcode " +
                    "portion of the Manual Pairing Code (when less than 11 characters)." +
                    "\n" +
                    "The server shall implement rate limiting to prevent brute force attacks. No more than 10 unique " +
                    "requests in a 10 minute period shall be allowed; a command response status of FAILURE should sent " +
                    "for additional commands received within the 10 minute period. Because access to this command is " +
                    "limited to nodes with Admin-level access, and the user is prompted for consent prior to " +
                    "Commissioning, there are in place multiple obstacles to successfully mounting a brute force attack. " +
                    "A Content App that supports this command shall ensure that the Temporary Account Identifier used by " +
                    "its clients is not valid for more than 10 minutes."
            },

            Field({
                name: "TempAccountIdentifier", id: 0x0, type: "string", conformance: "M", constraint: "16 to 100",
                xref: "cluster§6.2.4.1.1",
                details: "This field shall specify the client’s Temporary Account Identifier. The length of this field shall " +
                    "be at least 16 characters to protect the account holder against password guessing attacks."
            })
        ),

        Command(
            {
                name: "GetSetupPinResponse", id: 0x1, access: "F", conformance: "M", direction: "response",
                xref: "cluster§6.2.4.2",
                details: "This message is sent in response to the GetSetupPIN command, and contains the Setup PIN, or null " +
                    "when the account identified in the request does not match the active account of the running Content " +
                    "App."
            },

            Field({
                name: "SetupPin", id: 0x0, type: "string", conformance: "M", constraint: "desc",
                xref: "cluster§6.2.4.2.1",

                details: "This field shall provide the Setup PIN as a text string at least 8 characters in length or empty " +
                    "string to indicate that the accounts do not match." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Newer cluster clients should be aware that AccountLogin cluster version 1 specified an 11 digit " +
                    "  minimum length."
            })
        ),

        Command(
            {
                name: "Login", id: 0x2, access: "F A T", conformance: "M", direction: "request", response: "status",
                xref: "cluster§6.2.4.3",

                details: "The purpose of this command is to allow the Content App to assume the user account of a given " +
                    "Commissionee by leveraging the Setup PIN input by the user during the commissioning process." +
                    "\n" +
                    "For example, a Video Player with a Content App Platform may invoke this command on one of its " +
                    "Content App endpoints after the commissioning has completed of a Phone App made by the same vendor " +
                    "as the Content App. The Content App may determine whether the Temporary Account Identifier maps to " +
                    "an account with a corresponding Setup PIN and, if so, it may automatically login to the account for " +
                    "the corresponding user. The end result is that a user performs commissioning of a Phone App to a " +
                    "Video Player by inputting the Setup PIN for the Phone App into the Video Player UX. Once " +
                    "commissioning has completed, the Video Player invokes this command to allow the corresponding " +
                    "Content App to assume the same user account as the Phone App." +
                    "\n" +
                    "The verification of Setup PIN for the given Temporary Account Identifier is determined by the " +
                    "Content App using a method which is outside the scope of this specification and will typically " +
                    "involve a central service which is in communication with both the Content App and the Commissionee. " +
                    "Implementations of such a service should impose aggressive time outs for any mapping of Temporary " +
                    "Account Identifier to Setup PIN in order to prevent accidental login due to delayed invocation." +
                    "\n" +
                    "Upon receipt, the Content App checks if the account associated with the client’s Temp Account " +
                    "Identifier has a current active Setup PIN with the given value. If the Setup PIN is valid for the " +
                    "user account associated with the Temp Account Identifier, then the Content App may make that user " +
                    "account active." +
                    "\n" +
                    "The Temporary Account Identifier for a Commissionee may be populated with the Rotating ID field of " +
                    "the client’s commissionable node advertisement encoded as an octet string where the octets of the " +
                    "Rotating Device Identifier are encoded as 2-character sequences by representing each octet’s value " +
                    "as a 2-digit hexadecimal number, using uppercase letters." +
                    "\n" +
                    "The Setup PIN for a Commissionee may be populated with the Manual Pairing Code encoded as a string " +
                    "of decimal numbers (11 characters) or the Passcode portion of the Manual Pairing Code encoded as a " +
                    "string of decimal numbers (8 characters)." +
                    "\n" +
                    "The server shall implement rate limiting to prevent brute force attacks. No more than 10 unique " +
                    "requests in a 10 minute period shall be allowed; a command response status of FAILURE should sent " +
                    "for additional commands received within the 10 minute period. Because access to this command is " +
                    "limited to nodes with Admin-level access, and the user is involved when obtaining the Setup PIN, " +
                    "there are in place multiple obstacles to successfully mounting a brute force attack. A Content App " +
                    "that supports this command shall ensure that the Temporary Account Identifier used by its clients is " +
                    "not valid for more than 10 minutes."
            },

            Field({
                name: "TempAccountIdentifier", id: 0x0, type: "string", conformance: "M", constraint: "16 to 100",
                xref: "cluster§6.2.4.3.1",
                details: "This field shall specify the client’s temporary account identifier."
            }),

            Field({
                name: "SetupPin", id: 0x1, type: "string", conformance: "M", constraint: "min 8",
                xref: "cluster§6.2.4.3.2",

                details: "This field shall provide the Setup PIN as a text string at least 8 characters in length." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Newer cluster clients should be aware that AccountLogin cluster revision 1 specified an 11 digit " +
                    "  minimum length."
            }),

            Field({
                name: "Node", id: 0x2, type: "node-id", conformance: "O", xref: "cluster§6.2.4.3.3",
                details: "This optional field shall provide the Node ID of the Client. This field can be used by the Content " +
                    "App to keep track of Nodes which currently have access to it."
            })
        ),

        Command(
            {
                name: "Logout", id: 0x3, access: "F O T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§6.2.4.4",
                details: "The purpose of this command is to instruct the Content App to clear the current user account. This " +
                    "command SHOULD be used by clients of a Content App to indicate the end of a user session."
            },

            Field({
                name: "Node", id: 0x0, type: "node-id", conformance: "O", xref: "cluster§6.2.4.4.1",
                details: "This optional field shall provide the Node ID of the Client. This field can be used by the Content " +
                    "App to keep track of Nodes which currently have access to it."
            })
        )
    ),

    Cluster(
        {
            name: "ApplicationBasic", id: 0x50d, classification: "application", pics: "APBSC",
            xref: "cluster§6.3",

            details: "This cluster provides information about a Content App running on a Video Player device which is " +
                "represented as an endpoint (see Device Type Library document)." +
                "\n" +
                "The cluster server for this cluster should be supported on each endpoint that represents a Content " +
                "App on a Video Player device. This cluster provides identification information about the Content App " +
                "such as vendor and product."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),
        Attribute({
            name: "VendorName", id: 0x0, type: "string", access: "R V", conformance: "O", constraint: "max 32",
            quality: "F", xref: "cluster§6.3.5.1",
            details: "This attribute shall specify a human readable (displayable) name of the vendor for the Content App."
        }),

        Attribute({
            name: "VendorId", id: 0x1, type: "vendor-id", access: "R V", conformance: "O", quality: "F",
            xref: "cluster§6.3.5.2",
            details: "This attribute, if present, shall specify the Connectivity Standards Alliance assigned Vendor ID for " +
                "the Content App."
        }),

        Attribute({
            name: "ApplicationName", id: 0x2, type: "string", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "cluster§6.3.5.3",
            details: "This attribute shall specify a human readable (displayable) name of the Content App assigned by the " +
                "vendor. For example, \"NPR On Demand\". The maximum length of the ApplicationName attribute is 256 " +
                "bytes of UTF-8 characters."
        }),

        Attribute({
            name: "ProductId", id: 0x3, type: "uint16", access: "R V", conformance: "O", quality: "F",
            xref: "cluster§6.3.5.4",
            details: "This attribute, if present, shall specify a numeric ID assigned by the vendor to identify a specific " +
                "Content App made by them. If the Content App is certified by the Connectivity Standards Alliance, " +
                "then this would be the Product ID as specified by the vendor for the certification."
        }),

        Attribute({
            name: "Application", id: 0x4, type: "ApplicationStruct", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "cluster§6.3.5.5",
            details: "This attribute shall specify a Content App which consists of an Application ID using a specified " +
                "catalog."
        }),

        Attribute({
            name: "Status", id: 0x5, type: "ApplicationStatusEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§6.3.5.6",
            details: "This attribute shall specify the current running status of the application."
        }),

        Attribute({
            name: "ApplicationVersion", id: 0x6, type: "string", access: "R V", conformance: "M",
            constraint: "max 32", quality: "F", xref: "cluster§6.3.5.7",
            details: "This attribute shall specify a human readable (displayable) version of the Content App assigned by " +
                "the vendor. The maximum length of the ApplicationVersion attribute is 32 bytes of UTF-8 characters."
        }),

        Attribute(
            {
                name: "AllowedVendorList", id: 0x7, type: "list", access: "R A", conformance: "M", quality: "F",
                xref: "cluster§6.3.5.8",
                details: "This attribute is a list of vendor IDs. Each entry is a vendor-id."
            },
            Field({ name: "entry", type: "vendor-id" })
        ),

        Datatype(
            { name: "ApplicationStatusEnum", type: "enum8", xref: "cluster§6.3.4.1" },
            Field({ name: "Stopped", id: 0x0, conformance: "M", description: "Application is not running." }),
            Field({
                name: "ActiveVisibleFocus", id: 0x1, conformance: "M",
                description: "Application is running, is visible to the user, and is the active target for input."
            }),
            Field({
                name: "ActiveHidden", id: 0x2, conformance: "M",
                description: "Application is running but not visible to the user."
            }),
            Field({
                name: "ActiveVisibleNotFocus", id: 0x3, conformance: "M",
                description: "Application is running and visible, but is not the active target for input."
            })
        ),

        Datatype(
            {
                name: "ApplicationStruct", type: "struct", xref: "cluster§6.3.4.2",
                details: "This indicates a global identifier for an Application given a catalog."
            },

            Field({
                name: "CatalogVendorId", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§6.3.4.2.1",

                details: "This field shall indicate the Connectivity Standards Alliance issued vendor ID for the catalog. The " +
                    "DIAL registry shall use value 0x0000." +
                    "\n" +
                    "It is assumed that Content App Platform providers (see Video Player Architecture section in " +
                    "[MatterDevLib]) will have their own catalog vendor ID (set to their own Vendor ID) and will assign " +
                    "an ApplicationID to each Content App."
            }),

            Field({
                name: "ApplicationId", id: 0x1, type: "string", conformance: "M", xref: "cluster§6.3.4.2.2",
                details: "This field shall indicate the application identifier, expressed as a string, such as \"123456-5433\", " +
                    "\"PruneVideo\" or \"Company X\". This field shall be unique within a catalog." +
                    "\n" +
                    "For the DIAL registry catalog, this value shall be the DIAL prefix."
            })
        )
    ),

    Cluster(
        {
            name: "ApplicationLauncher", id: 0x50c, classification: "application", pics: "APPLAUNCHER",
            xref: "cluster§6.4",

            details: "This cluster provides an interface for launching applications on a Video Player device such as a TV." +
                "\n" +
                "This cluster is supported on endpoints that can launch Applications, such as a Casting Video Player " +
                "device with a Content App Platform. It supports identifying an Application by global identifier from " +
                "a given catalog, and launching it. It also supports tracking the currently in-focus Application." +
                "\n" +
                "Depending on the support for the Application Platform feature, the cluster can either support " +
                "launching the application corresponding to the endpoint on which the cluster is supported (AP " +
                "feature not supported) or it can support launching any application (AP feature supported)."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.4.4" },
            Field({
                name: "AP", constraint: "0", title: "ApplicationPlatform",
                details: "Support for attributes and commands required for endpoint to support launching any application " +
                    "within the supported application catalogs"
            })
        ),

        Attribute(
            {
                name: "CatalogList", id: 0x0, type: "list", access: "R V", conformance: "AP", quality: "N",
                xref: "cluster§6.4.6.1",

                details: "This attribute shall specify the list of supported application catalogs, where each entry in the " +
                    "list is the Connectivity Standards Alliance-issued vendor ID for the catalog. The DIAL registry (see " +
                    "[DIAL Registry]) shall use value 0x0000." +
                    "\n" +
                    "It is expected that Content App Platform providers will have their own catalog vendor ID (set to " +
                    "their own Vendor ID) and will assign an ApplicationID to each Content App."
            },

            Field({ name: "entry", type: "uint16" })
        ),

        Attribute({
            name: "CurrentApp", id: 0x1, type: "ApplicationEPStruct", access: "R V", conformance: "O",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.4.6.2",
            details: "This attribute shall specify the current in-focus application, identified using an Application ID, " +
                "catalog vendor ID and the corresponding endpoint number when the application is represented by a " +
                "Content App endpoint. A null shall be used to indicate there is no current in-focus application."
        }),

        Command(
            {
                name: "LaunchApp", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "LauncherResponse", xref: "cluster§6.4.7.1",

                details: "Upon receipt of this command, the server shall launch the application with optional data. The " +
                    "application shall be either" +
                    "\n" +
                    "  • the specified application, if the Application Platform feature is supported;" +
                    "\n" +
                    "  • otherwise the application corresponding to the endpoint." +
                    "\n" +
                    "The endpoint shall launch and bring to foreground the requisite application if the application is " +
                    "not already launched and in foreground. The Status attribute shall be updated to ActiveVisibleFocus " +
                    "on the Application Basic cluster of the Endpoint corresponding to the launched application. The " +
                    "Status attribute shall be updated on any other application whose Status may have changed as a result " +
                    "of this command. The CurrentApp attribute, if supported, shall be updated to reflect the new " +
                    "application in the foreground." +
                    "\n" +
                    "This command returns a Launcher Response."
            },

            Field({
                name: "Application", id: 0x0, type: "ApplicationStruct", conformance: "AP", constraint: "desc",
                xref: "cluster§6.4.7.1.1",
                details: "This field shall specify the Application to launch."
            }),

            Field({
                name: "Data", id: 0x1, type: "octstr", conformance: "O", xref: "cluster§6.4.7.1.2",

                details: "This field shall specify optional app-specific data to be sent to the app." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> This format and meaning of this value is proprietary and outside the specification. It provides a " +
                    "  transition path for device makers that use other protocols (like DIAL) which allow for proprietary " +
                    "  data. Apps that are not yet Matter aware can be launched via Matter, while retaining the existing " +
                    "  ability to launch with proprietary data."
            })
        ),

        Command(
            {
                name: "StopApp", id: 0x1, access: "O", conformance: "M", direction: "request",
                response: "LauncherResponse", xref: "cluster§6.4.7.2",

                details: "Upon receipt of this command, the server shall stop the application if it is running. The " +
                    "application shall be either" +
                    "\n" +
                    "  • the specified application, if the Application Platform feature is supported;" +
                    "\n" +
                    "  • otherwise the application corresponding to the endpoint." +
                    "\n" +
                    "The Status attribute shall be updated to Stopped on the Application Basic cluster of the Endpoint " +
                    "corresponding to the stopped application. The Status attribute shall be updated on any other " +
                    "application whose Status may have changed as a result of this command." +
                    "\n" +
                    "This command returns a Launcher Response."
            },

            Field({
                name: "Application", id: 0x0, type: "ApplicationStruct", conformance: "AP", constraint: "desc",
                xref: "cluster§6.4.7.2.1",
                details: "This field shall specify the Application to stop."
            })
        ),

        Command(
            {
                name: "HideApp", id: 0x2, access: "O", conformance: "M", direction: "request",
                response: "LauncherResponse", xref: "cluster§6.4.7.3",

                details: "Upon receipt of this command, the server shall hide the application. The application shall be either" +
                    "\n" +
                    "  • the specified application, if the Application Platform feature is supported;" +
                    "\n" +
                    "  • otherwise the application corresponding to the endpoint." +
                    "\n" +
                    "The endpoint may decide to stop the application based on manufacturer specific behavior or resource " +
                    "constraints if any. The Status attribute shall be updated to ActiveHidden or Stopped, depending on " +
                    "the action taken, on the Application Basic cluster of the Endpoint corresponding to the application " +
                    "on which the action was taken. The Status attribute shall be updated on any other application whose " +
                    "Status may have changed as a result of this command." +
                    "\n" +
                    "This command returns a Launcher Response."
            },

            Field({
                name: "Application", id: 0x0, type: "ApplicationStruct", conformance: "AP", constraint: "desc",
                xref: "cluster§6.4.7.3.1",
                details: "This field shall specify the Application to hide."
            })
        ),

        Command(
            {
                name: "LauncherResponse", id: 0x3, conformance: "M", direction: "response", xref: "cluster§6.4.7.4",
                details: "This command shall be generated in response to LaunchApp/StopApp/HideApp commands."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "cluster§6.4.7.4.1",
                details: "This field shall indicate the status of the command which resulted in this response."
            }),
            Field({
                name: "Data", id: 0x1, type: "octstr", conformance: "O", xref: "cluster§6.4.7.4.2",
                details: "This field shall specify Optional app-specific data."
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.4.5.1" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Command succeeded" }),
            Field({ name: "AppNotAvailable", id: 0x1, conformance: "M", description: "Requested app is not available" }),
            Field({ name: "SystemBusy", id: 0x2, conformance: "M", description: "Video platform unable to honor command" }),
            Field({
                name: "PendingUserApproval", id: 0x3, conformance: "M",
                description: "User approval for app download is pending"
            }),
            Field({ name: "Downloading", id: 0x4, conformance: "M", description: "Downloading the requested app" }),
            Field({ name: "Installing", id: 0x5, conformance: "M", description: "Installing the requested app" })
        ),

        Datatype(
            {
                name: "ApplicationStruct", type: "struct", xref: "cluster§6.4.5.2",
                details: "This indicates a global identifier for an Application given a catalog."
            },

            Field({
                name: "CatalogVendorId", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§6.4.5.2.1",
                details: "This field shall indicate the Connectivity Standards Alliance-issued vendor ID for the catalog. The " +
                    "DIAL registry shall use value 0x0000." +
                    "\n" +
                    "Content App Platform providers will have their own catalog vendor ID (set to their own Vendor ID) " +
                    "and will assign an ApplicationID to each Content App."
            }),

            Field({
                name: "ApplicationId", id: 0x1, type: "string", conformance: "M", xref: "cluster§6.4.5.2.2",
                details: "This field shall indicate the application identifier, expressed as a string, such as \"PruneVideo\" or " +
                    "\"Company X\". This field shall be unique within a catalog." +
                    "\n" +
                    "For the DIAL registry catalog, this value shall be the DIAL prefix (see [DIAL Registry])."
            })
        ),

        Datatype(
            {
                name: "ApplicationEPStruct", type: "struct", xref: "cluster§6.4.5.3",
                details: "This specifies an app along with its corresponding endpoint."
            },
            Field({ name: "Application", id: 0x0, type: "ApplicationStruct", conformance: "M" }),
            Field({ name: "Endpoint", id: 0x1, type: "endpoint-no", conformance: "O" })
        )
    ),

    Cluster(
        {
            name: "AudioOutput", id: 0x50b, classification: "application", pics: "AUDIOOUTPUT",
            xref: "cluster§6.5",

            details: "This cluster provides an interface for controlling the Output on a Video Player device such as a TV." +
                "\n" +
                "This cluster would be supported on a device with audio outputs like a Video Player device (Smart TV, " +
                "TV Setup Top Box, Smart Speaker, etc)." +
                "\n" +
                "This cluster provides the list of available outputs and provides commands for selecting and renaming " +
                "them." +
                "\n" +
                "The cluster server for Audio Output is implemented by a device that has configurable audio output."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),
        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.5.4" },
            Field({ name: "NU", constraint: "0", title: "NameUpdates", details: "Supports updates to output names" })
        ),

        Attribute(
            {
                name: "OutputList", id: 0x0, type: "list", access: "R V", conformance: "M", xref: "cluster§6.5.6.1",
                details: "This attribute provides the list of outputs supported by the device."
            },
            Field({ name: "entry", type: "OutputInfoStruct" })
        ),

        Attribute({
            name: "CurrentOutput", id: 0x1, type: "uint8", access: "R V", conformance: "M",
            xref: "cluster§6.5.6.2",
            details: "This attribute contains the value of the index field of the currently selected OutputInfoStruct."
        }),

        Command(
            {
                name: "SelectOutput", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§6.5.7.1",

                details: "Upon receipt, this shall change the output on the device to the output at a specific index in the " +
                    "Output List." +
                    "\n" +
                    "Note that when the current output is set to an output of type HDMI, adjustments to volume via a " +
                    "Speaker endpoint on the same node may cause HDMI volume up/down commands to be sent to the given " +
                    "HDMI output."
            },

            Field({
                name: "Index", id: 0x0, type: "uint8", conformance: "M", xref: "cluster§6.5.7.1.1",
                details: "This shall indicate the index field of the OutputInfoStruct from the OutputList attribute in which " +
                    "to change to."
            })
        ),

        Command(
            {
                name: "RenameOutput", id: 0x1, access: "M", conformance: "NU", direction: "request",
                response: "status", xref: "cluster§6.5.7.2",
                details: "Upon receipt, this shall rename the output at a specific index in the Output List." +
                    "\n" +
                    "Updates to the output name shall appear in the device’s settings menus. Name updates may " +
                    "automatically be sent to the actual device to which the output connects."
            },

            Field({ name: "Index", id: 0x0, type: "uint8", conformance: "M" }),
            Field({ name: "Name", id: 0x1, type: "string", conformance: "M" })
        ),

        Datatype(
            {
                name: "OutputTypeEnum", type: "enum8", xref: "cluster§6.5.5.1",
                details: "The type of output, expressed as an enum, with the following values:"
            },
            Field({ name: "Hdmi", id: 0x0, conformance: "M", description: "HDMI" }),
            Field({ name: "Bt", id: 0x1, conformance: "M" }),
            Field({ name: "Optical", id: 0x2, conformance: "M" }),
            Field({ name: "Headphone", id: 0x3, conformance: "M" }),
            Field({ name: "Internal", id: 0x4, conformance: "M" }),
            Field({ name: "Other", id: 0x5, conformance: "M" })
        ),

        Datatype(
            {
                name: "OutputInfoStruct", type: "struct", xref: "cluster§6.5.5.2",
                details: "This contains information about an output."
            },
            Field({
                name: "Index", id: 0x0, type: "uint8", conformance: "M", xref: "cluster§6.5.5.2.1",
                details: "This field shall indicate the unique index into the list of outputs."
            }),
            Field({
                name: "OutputType", id: 0x1, type: "OutputTypeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.5.5.2.2",
                details: "This field shall indicate the type of output."
            }),
            Field({
                name: "Name", id: 0x2, type: "string", conformance: "M", xref: "cluster§6.5.5.2.3",
                details: "The device defined and user editable output name, such as “Soundbar”, “Speakers”. This field may be " +
                    "blank, but SHOULD be provided when known."
            })
        )
    ),

    Cluster(
        {
            name: "Channel", id: 0x504, classification: "application", pics: "CHANNEL", xref: "cluster§6.6",

            details: "This cluster provides an interface for controlling the current Channel on a device or endpoint." +
                "\n" +
                "This cluster server would be supported on Video Player devices or endpoints that allow Channel " +
                "control such as a Content App. This cluster provides a list of available channels and provides " +
                "commands for absolute and relative channel changes. Some of these commands and/or their responses " +
                "may be large (see Large Message Quality under Data Model section in [MatterCore]), but they do not " +
                "have the Large quality indicator (L) because they can also be transferred over MRP (see Message " +
                "Reliability Protocol in [MatterCore]) in pages that fit within the MRP MTU limit. However, an " +
                "implementation may leverage a transport like TCP that allows large payloads, if available, to " +
                "minimize the number of messages required to transfer the corresponding payload." +
                "\n" +
                "The cluster server for Channel is implemented by an endpoint that controls the current Channel."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.6.4" },
            Field({ name: "CL", constraint: "0", title: "ChannelList", details: "Provides list of available channels." }),
            Field({
                name: "LI", constraint: "1", title: "LineupInfo",
                details: "Provides lineup info, which is a reference to an external source of lineup information."
            }),
            Field({
                name: "EG", constraint: "2", title: "ElectronicGuide",
                details: "Provides electronic program guide information."
            }),
            Field({ name: "RP", constraint: "3", title: "RecordProgram", details: "Provides ability to record program." })
        ),

        Attribute(
            {
                name: "ChannelList", id: 0x0, type: "list", access: "R V", conformance: "CL", default: [],
                xref: "cluster§6.6.6.1",
                details: "This attribute shall provide the list of supported channels."
            },
            Field({ name: "entry", type: "ChannelInfoStruct" })
        ),

        Attribute({
            name: "Lineup", id: 0x1, type: "LineupInfoStruct", access: "R V", conformance: "LI",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.6.6.2",
            details: "This attribute shall identify the channel lineup using external data sources."
        }),

        Attribute({
            name: "CurrentChannel", id: 0x2, type: "ChannelInfoStruct", access: "R V", conformance: "O",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.6.6.3",
            details: "This attribute shall contain the current channel. When supported but a channel is not currently " +
                "tuned to (if a content application is in foreground), the value of the field shall be null."
        }),

        Command(
            {
                name: "ChangeChannel", id: 0x0, access: "O", conformance: "CL | LI", direction: "request",
                response: "ChangeChannelResponse", xref: "cluster§6.6.7.1",

                details: "Change the channel to the channel case-insensitive exact matching the value passed as an argument." +
                    "\n" +
                    "The match priority order shall be: Identifier, AffiliateCallSign, CallSign, Name, Number. In the " +
                    "match string, the Channel number should be presented in the \"Major.Minor\" format, such as \"13.1\"." +
                    "\n" +
                    "Upon receipt, this shall generate a ChangeChannelResponse command." +
                    "\n" +
                    "Upon success, the CurrentChannel attribute, if supported, shall be updated to reflect the change."
            },

            Field({
                name: "Match", id: 0x0, type: "string", conformance: "M", xref: "cluster§6.6.7.1.1",
                details: "This field shall contain a user-input string to match in order to identify the target channel."
            })
        ),

        Command(
            {
                name: "ChangeChannelResponse", id: 0x1, conformance: "CL | LI", direction: "response",
                xref: "cluster§6.6.7.2",
                details: "This command shall be generated in response to a ChangeChannel command."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.6.7.2.1",
                details: "This field shall indicate the status of the command which resulted in this response."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", constraint: "any",
                xref: "cluster§6.6.7.2.2",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Command(
            {
                name: "ChangeChannelByNumber", id: 0x2, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§6.6.7.3",
                details: "Change the channel to the channel with the given Number in the ChannelList attribute."
            },
            Field({
                name: "MajorNumber", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§6.6.7.3.1",
                details: "This field shall indicate the channel major number value (ATSC format) to which the channel should " +
                    "change."
            }),
            Field({
                name: "MinorNumber", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§6.6.7.3.2",
                details: "This field shall indicate the channel minor number value (ATSC format) to which the channel should " +
                    "change."
            })
        ),

        Command(
            {
                name: "SkipChannel", id: 0x3, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§6.6.7.4",

                details: "This command provides channel up and channel down functionality, but allows channel index jumps of " +
                    "size Count." +
                    "\n" +
                    "Jumps are relative to the available list of channels. For example, when the current channel is 100.0 " +
                    "and the list of available channels is [100.0, 200.0, 201.0, 305.1], a SkipChannel command with jump " +
                    "value of 2 shall change the channel to 201.0." +
                    "\n" +
                    "When the value of the increase or decrease is larger than the number of channels remaining in the " +
                    "given direction, then the behavior shall be to return to the beginning (or end) of the channel list " +
                    "and continue. For example, if the current channel is at index 0 and count value of -1 is given, then " +
                    "the current channel should change to the last channel."
            },

            Field({
                name: "Count", id: 0x0, type: "int16", conformance: "M", xref: "cluster§6.6.7.4.1",
                details: "This field shall indicate the number of steps to increase (Count is positive) or decrease (Count is " +
                    "negative) the current channel."
            })
        ),

        Command(
            {
                name: "GetProgramGuide", id: 0x4, access: "O", conformance: "EG", direction: "request",
                response: "ProgramGuideResponse", xref: "cluster§6.6.7.5",
                details: "This command retrieves the program guide. It accepts several filter parameters to return specific " +
                    "schedule and program information from a content app. The command shall receive in response a " +
                    "ProgramGuideResponse. Standard error codes shall be used when arguments provided are not valid. For " +
                    "example, if StartTime is greater than EndTime, the status code INVALID_ACTION shall be returned."
            },

            Field({
                name: "StartTime", id: 0x0, type: "epoch-s", conformance: "M", xref: "cluster§6.6.7.5.1",
                details: "This field shall indicate the beginning of the time window for which program guide entries are to be " +
                    "retrieved, as a UTC time. Entries with a start time on or after this value will be included in the " +
                    "results."
            }),

            Field({
                name: "EndTime", id: 0x1, type: "epoch-s", conformance: "M", xref: "cluster§6.6.7.5.2",
                details: "This field shall indicate the end of the time window for which program guide entries are to be " +
                    "retrieved, as a UTC time. Entries with an end time on or before this value will be included in the " +
                    "results. This field can represent a past or future value but shall be greater than the StartTime."
            }),

            Field(
                {
                    name: "ChannelList", id: 0x2, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.7.5.3",
                    details: "This field shall indicate the set of channels for which program guide entries should be fetched. By " +
                        "providing a list of channels in this field, the response will only include entries corresponding to " +
                        "the specified channels."
                },

                Field({ name: "entry", type: "ChannelInfoStruct" })
            ),

            Field({
                name: "PageToken", id: 0x3, type: "PageTokenStruct", conformance: "O", default: null, quality: "X",
                xref: "cluster§6.6.7.5.4",
                details: "This field shall indicate the pagination token used for managing pagination progression."
            }),
            Field({
                name: "RecordingFlag", id: 0x5, type: "RecordingFlagBitmap", conformance: "O", default: null,
                quality: "X", xref: "cluster§6.6.7.5.5",
                details: "This field shall indicate the flags of the programs for which entries should be fetched."
            }),

            Field(
                {
                    name: "ExternalIdList", id: 0x6, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.7.5.6",
                    details: "This field shall indicate the list of additional external content identifiers."
                },
                Field({ name: "entry", type: "ContentLauncher.AdditionalInfoStruct" })
            ),

            Field({
                name: "Data", id: 0x7, type: "octstr", conformance: "O", constraint: "max 8092",
                xref: "cluster§6.6.7.5.7",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Command(
            {
                name: "ProgramGuideResponse", id: 0x5, conformance: "EG", direction: "response",
                xref: "cluster§6.6.7.6",
                details: "This command is a response to the GetProgramGuide command."
            },
            Field({
                name: "Paging", id: 0x0, type: "ChannelPagingStruct", conformance: "M", xref: "cluster§6.6.7.6.1",
                details: "This field shall indicate the necessary pagination attributes that define information for both the " +
                    "succeeding and preceding data pages."
            }),

            Field(
                {
                    name: "ProgramList", id: 0x1, type: "list", conformance: "M", default: [],
                    xref: "cluster§6.6.7.6.2",
                    details: "This field shall indicate the list of programs."
                },
                Field({ name: "entry", type: "ProgramStruct" })
            )
        ),

        Command(
            {
                name: "RecordProgram", id: 0x6, access: "O", conformance: "RP & EG", direction: "request",
                response: "status", xref: "cluster§6.6.7.7",
                details: "Record a specific program or series when it goes live. This functionality enables DVR recording " +
                    "features."
            },

            Field({
                name: "ProgramIdentifier", id: 0x0, type: "string", conformance: "M", constraint: "max 255",
                xref: "cluster§6.6.7.7.1",
                details: "This field shall indicate the program identifier for the program that should be recorded. This value " +
                    "is provided by the identifier field in ProgramStruct."
            }),

            Field({
                name: "ShouldRecordSeries", id: 0x1, type: "bool", conformance: "M", xref: "cluster§6.6.7.7.2",
                details: "This field shall indicate whether the whole series associated to the program should be recorded. For " +
                    "example, invoking record program on an episode with that flag set to true, the target should " +
                    "schedule record the whole series."
            }),

            Field(
                {
                    name: "ExternalIdList", id: 0x2, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.7.7.3",
                    details: "This field, if present, shall indicate the list of additional external content identifiers."
                },
                Field({ name: "entry", type: "ContentLauncher.AdditionalInfoStruct" })
            ),

            Field({
                name: "Data", id: 0x3, type: "octstr", conformance: "O", constraint: "max 8092",
                xref: "cluster§6.6.7.7.4",
                details: "This field, if present, shall indicate app-specific data."
            })
        ),

        Command(
            {
                name: "CancelRecordProgram", id: 0x7, access: "O", conformance: "RP & EG", direction: "request",
                response: "status", xref: "cluster§6.6.7.8",
                details: "Cancel recording for a specific program or series."
            },

            Field({
                name: "ProgramIdentifier", id: 0x0, type: "string", conformance: "M", constraint: "max 255",
                xref: "cluster§6.6.7.8.1",
                details: "This field shall indicate the program identifier for the program that should be cancelled from " +
                    "recording. This value is provided by the identifier field in ProgramStruct."
            }),

            Field({
                name: "ShouldRecordSeries", id: 0x1, type: "bool", conformance: "M", xref: "cluster§6.6.7.8.2",
                details: "This field shall indicate whether the whole series associated to the program should be cancelled " +
                    "from recording. For example, invoking record program on an episode with that flag set to true, the " +
                    "target should schedule record the whole series."
            }),

            Field(
                {
                    name: "ExternalIdList", id: 0x2, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.7.8.3",
                    details: "This field, if present, shall indicate the list of additional external content identifiers."
                },
                Field({ name: "entry", type: "ContentLauncher.AdditionalInfoStruct" })
            ),

            Field({
                name: "Data", id: 0x3, type: "octstr", conformance: "O", constraint: "max 8092",
                xref: "cluster§6.6.7.8.4",
                details: "This field, if present, shall indicate app-specific data."
            })
        ),

        Datatype(
            { name: "RecordingFlagBitmap", type: "map8", xref: "cluster§6.6.5.1" },
            Field({ name: "Scheduled", constraint: "0", description: "The program is scheduled for recording." }),
            Field({ name: "RecordSeries", constraint: "1", description: "The program series is scheduled for recording." }),
            Field({ name: "Recorded", constraint: "2", description: "The program is recorded and available to be played." })
        ),

        Datatype(
            { name: "LineupInfoTypeEnum", type: "enum8", xref: "cluster§6.6.5.2" },
            Field({ name: "Mso", id: 0x0, conformance: "M", description: "Multi System Operator" })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.6.5.3" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Command succeeded" }),
            Field({
                name: "MultipleMatches", id: 0x1, conformance: "M",
                description: "More than one equal match for the ChannelInfoStruct passed in."
            }),
            Field({
                name: "NoMatches", id: 0x2, conformance: "M",
                description: "No matches for the ChannelInfoStruct passed in."
            })
        ),

        Datatype(
            { name: "ChannelTypeEnum", type: "enum8", xref: "cluster§6.6.5.4" },
            Field({
                name: "Satellite", id: 0x0, conformance: "M",
                description: "The channel is sourced from a satellite provider."
            }),
            Field({ name: "Cable", id: 0x1, conformance: "M", description: "The channel is sourced from a cable provider." }),
            Field({
                name: "Terrestrial", id: 0x2, conformance: "M",
                description: "The channel is sourced from a terrestrial provider."
            }),
            Field({ name: "Ott", id: 0x3, conformance: "M", description: "The channel is sourced from an OTT provider." })
        ),

        Datatype(
            {
                name: "ChannelInfoStruct", type: "struct", xref: "cluster§6.6.5.5",
                details: "This indicates a channel in a channel lineup." +
                    "\n" +
                    "While the major and minor numbers in the ChannelInfoStruct support use of ATSC channel format, a " +
                    "lineup may use other formats which can map into these numeric values."
            },

            Field({
                name: "MajorNumber", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§6.6.5.5.1",
                details: "This field shall indicate the channel major number value (for example, using ATSC format). When the " +
                    "channel number is expressed as a string, such as \"13.1\" or \"256\", the major number would be 13 or " +
                    "256, respectively. This field is required but shall be set to 0 for channels such as over-the-top " +
                    "channels that are not represented by a major or minor number."
            }),

            Field({
                name: "MinorNumber", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§6.6.5.5.2",
                details: "This field shall indicate the channel minor number value (for example, using ATSC format). When the " +
                    "channel number is expressed as a string, such as \"13.1\" or \"256\", the minor number would be 1 or 0, " +
                    "respectively. This field is required but shall be set to 0 for channels such as over-the-top " +
                    "channels that are not represented by a major or minor number."
            }),

            Field({
                name: "Name", id: 0x2, type: "string", conformance: "O", xref: "cluster§6.6.5.5.3",
                details: "This field shall indicate the marketing name for the channel, such as “The CW\" or \"Comedy Central\". " +
                    "This field is optional, but SHOULD be provided when known."
            }),
            Field({
                name: "CallSign", id: 0x3, type: "string", conformance: "O", xref: "cluster§6.6.5.5.4",
                details: "This field shall indicate the call sign of the channel, such as \"PBS\". This field is optional, but " +
                    "SHOULD be provided when known."
            }),
            Field({
                name: "AffiliateCallSign", id: 0x4, type: "string", conformance: "O", xref: "cluster§6.6.5.5.5",
                details: "This field shall indicate the local affiliate call sign, such as \"KCTS\". This field is optional, but " +
                    "SHOULD be provided when known."
            }),
            Field({
                name: "Identifier", id: 0x5, type: "string", conformance: "O", xref: "cluster§6.6.5.5.6",
                details: "This shall indicate the unique identifier for a specific channel. This field is optional, but SHOULD " +
                    "be provided when MajorNumber and MinorNumber are not available."
            }),
            Field({
                name: "Type", id: 0x6, type: "ChannelTypeEnum", conformance: "O", xref: "cluster§6.6.5.5.7",
                details: "This shall indicate the type or grouping of a specific channel. This field is optional, but SHOULD " +
                    "be provided when known."
            })
        ),

        Datatype(
            {
                name: "LineupInfoStruct", type: "struct", xref: "cluster§6.6.5.6",
                details: "The Lineup Info allows references to external lineup sources like Gracenote. The combination of " +
                    "OperatorName, LineupName, and PostalCode MUST uniquely identify a lineup."
            },
            Field({
                name: "OperatorName", id: 0x0, type: "string", conformance: "M", xref: "cluster§6.6.5.6.1",
                details: "This field shall indicate the name of the operator, for example “Comcast”."
            }),
            Field({
                name: "LineupName", id: 0x1, type: "string", conformance: "O", xref: "cluster§6.6.5.6.2",
                details: "This field shall indicate the name of the provider lineup, for example \"Comcast King County\". This " +
                    "field is optional, but SHOULD be provided when known."
            }),
            Field({
                name: "PostalCode", id: 0x2, type: "string", conformance: "O", xref: "cluster§6.6.5.6.3",
                details: "This field shall indicate the postal code (zip code) for the location of the device, such as " +
                    "\"98052\". This field is optional, but SHOULD be provided when known."
            }),

            Field({
                name: "LineupInfoType", id: 0x3, type: "LineupInfoTypeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.6.5.6.4",
                details: "This field shall indicate the type of lineup. This field is optional, but SHOULD be provided when " +
                    "known."
            })
        ),

        Datatype(
            {
                name: "ProgramStruct", type: "struct", xref: "cluster§6.6.5.7",
                details: "This indicates a program within an electronic program guide (EPG)."
            },

            Field({
                name: "Identifier", id: 0x0, type: "string", conformance: "M", constraint: "max 255",
                xref: "cluster§6.6.5.7.1",
                details: "This field shall indicate a unique identifier for a program within an electronic program guide list. " +
                    "The identifier shall be unique across multiple channels."
            }),

            Field({
                name: "Channel", id: 0x1, type: "ChannelInfoStruct", conformance: "M", xref: "cluster§6.6.5.7.2",
                details: "This field shall indicate the channel associated to the program."
            }),
            Field({
                name: "StartTime", id: 0x2, type: "epoch-s", conformance: "M", xref: "cluster§6.6.5.7.3",
                details: "This field shall indicate an epoch time in seconds indicating the start time of a program, as a UTC " +
                    "time. This field can represent a past or future value."
            }),
            Field({
                name: "EndTime", id: 0x3, type: "epoch-s", conformance: "M", xref: "cluster§6.6.5.7.4",
                details: "This field shall indicate an epoch time in seconds indicating the end time of a program, as a UTC " +
                    "time. This field can represent a past or future value but shall be greater than the StartTime."
            }),

            Field({
                name: "Title", id: 0x4, type: "string", conformance: "M", constraint: "max 255",
                xref: "cluster§6.6.5.7.5",
                details: "This field shall indicate the title or name for the specific program. For example, “MCIS: Los " +
                    "Angeles”."
            }),

            Field({
                name: "Subtitle", id: 0x5, type: "string", conformance: "O", constraint: "max 255",
                xref: "cluster§6.6.5.7.6",
                details: "This field shall indicate the subtitle for the specific program. For example, “Maybe Today\" which is " +
                    "an episode name for “MCIS: Los Angeles”. This field is optional but shall be provided if applicable " +
                    "and known."
            }),

            Field({
                name: "Description", id: 0x6, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.7.7",
                details: "This field shall indicate the brief description for the specific program. For example, a description " +
                    "of an episode. This field is optional but shall be provided if known."
            }),

            Field(
                {
                    name: "AudioLanguages", id: 0x7, type: "list", conformance: "O", constraint: "max 10[max 50]",
                    default: [], xref: "cluster§6.6.5.7.8",
                    details: "This field shall indicate the audio language for the specific program. The value is a string " +
                        "containing one of the standard Tags for Identifying Languages RFC 5646. This field is optional but " +
                        "shall be provided if known."
                },

                Field({ name: "entry", type: "string" })
            ),

            Field(
                {
                    name: "Ratings", id: 0x8, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.5.7.9",
                    details: "This field shall be used for indicating the level of parental guidance recommended for of a " +
                        "particular program. This can be any rating system used in the country or region where the program is " +
                        "broadcast. For example, in the United States “TV-PG” may contain material that parents can find not " +
                        "suitable for younger children but can be accepted in general for older children. This field is " +
                        "optional but shall be provided if known."
                },

                Field({ name: "entry", type: "string" })
            ),

            Field({
                name: "ThumbnailUrl", id: 0x9, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.7.10",
                details: "This field shall represent a URL of a thumbnail that clients can use to render an image for the " +
                    "program. The syntax of this field shall follow the syntax as specified in RFC 1738 and shall use the " +
                    "https scheme."
            }),

            Field({
                name: "PosterArtUrl", id: 0xa, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.7.11",
                details: "This field shall represent a URL of a poster that clients can use to render an image for the program " +
                    "on the detail view. The syntax of this field shall follow the syntax as specified in RFC 1738 and " +
                    "shall use the https scheme."
            }),

            Field({
                name: "DvbiUrl", id: 0xb, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.7.12",
                details: "This field shall represent the DVB-I URL associated to the program. The syntax of this field shall " +
                    "follow the syntax as specified in RFC 1738 and shall use the https scheme."
            }),

            Field({
                name: "ReleaseDate", id: 0xc, type: "string", conformance: "O", constraint: "max 30",
                xref: "cluster§6.6.5.7.13",
                details: "This field shall be a string, in ISO 8601 format, representing the date on which the program was " +
                    "released. This field is optional but when provided, the year shall be provided as part of the " +
                    "string."
            }),

            Field({
                name: "ParentalGuidanceText", id: 0xd, type: "string", conformance: "O", constraint: "max 255",
                xref: "cluster§6.6.5.7.14",
                details: "This field shall represent a string providing additional information on the parental guidance. This " +
                    "field is optional."
            }),

            Field({
                name: "RecordingFlag", id: 0xe, type: "RecordingFlagBitmap", conformance: "RP",
                xref: "cluster§6.6.5.7.15",
                details: "This field shall represent the recording status of the program. This field is required if the " +
                    "RecordProgram feature is set."
            }),

            Field({
                name: "SeriesInfo", id: 0xf, type: "SeriesInfoStruct", conformance: "O", default: null,
                quality: "X", xref: "cluster§6.6.5.7.16",
                details: "This field shall represent the information of a series such as season and episode number. This field " +
                    "is optional but SHOULD be provided if the program represents a series and this information is " +
                    "available."
            }),

            Field(
                {
                    name: "CategoryList", id: 0x10, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.5.7.17",
                    details: "This field shall represent the category of a particular program. This field is optional but shall be " +
                        "provided if known."
                },

                Field({ name: "entry", type: "ProgramCategoryStruct" })
            ),

            Field(
                {
                    name: "CastList", id: 0x11, type: "list", conformance: "O", constraint: "max 255", default: [],
                    xref: "cluster§6.6.5.7.18",
                    details: "This field shall represent a list of the cast or the crew on the program. A single cast member may " +
                        "have more than one role. This field is optional but shall be provided if known."
                },

                Field({ name: "entry", type: "ProgramCastStruct" })
            ),

            Field(
                {
                    name: "ExternalIdList", id: 0x12, type: "list", conformance: "O", constraint: "max 255",
                    default: [], xref: "cluster§6.6.5.7.19",
                    details: "This field shall indicate the list of additional external content identifiers."
                },
                Field({ name: "entry", type: "ContentLauncher.AdditionalInfoStruct" })
            )
        ),

        Datatype(
            {
                name: "ProgramCategoryStruct", type: "struct", xref: "cluster§6.6.5.8",
                details: "This object defines the category associated to a program."
            },
            Field({
                name: "Category", id: 0x0, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.6.5.8.1",
                details: "This field shall represent the category or genre of the program. Ex. News."
            }),
            Field({
                name: "SubCategory", id: 0x1, type: "string", conformance: "O", constraint: "max 256",
                xref: "cluster§6.6.5.8.2",
                details: "This field shall represent the sub-category or sub-genre of the program. Ex. Local."
            })
        ),

        Datatype(
            {
                name: "SeriesInfoStruct", type: "struct", xref: "cluster§6.6.5.9",
                details: "This object provides the episode information related to a program."
            },
            Field({
                name: "Season", id: 0x0, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.6.5.9.1",
                details: "This field shall represent the season of the series associated to the program."
            }),
            Field({
                name: "Episode", id: 0x1, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.6.5.9.2",
                details: "This field shall represent the episode of the program."
            })
        ),

        Datatype(
            {
                name: "ProgramCastStruct", type: "struct", xref: "cluster§6.6.5.10",
                details: "This object provides the cast information related to a program."
            },
            Field({
                name: "Name", id: 0x0, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.6.5.10.1",
                details: "This field shall represent the name of the cast member."
            }),
            Field({
                name: "Role", id: 0x1, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.6.5.10.2",
                details: "This field shall represent the role of the cast member. Ex. Actor, Director."
            })
        ),

        Datatype(
            {
                name: "PageTokenStruct", type: "struct", xref: "cluster§6.6.5.11",
                details: "This object defines the pagination structure."
            },

            Field({
                name: "Limit", id: 0x0, type: "uint16", conformance: "O", default: 0, xref: "cluster§6.6.5.11.1",
                details: "This field shall indicate the maximum number of entries that should be retrieved from the program " +
                    "guide in a single response. It allows clients to specify the size of the paginated result set based " +
                    "on their needs."
            }),

            Field({
                name: "After", id: 0x1, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.11.2",
                details: "This field shall indicate the cursor that pinpoints the start of the upcoming data page. In a " +
                    "Cursor-based pagination system, the field acts as a reference point, ensuring the set of results " +
                    "corresponds directly to the data following the specified cursor. In a Offset-based pagination " +
                    "system, the field, along with limit, indicate the offset from which entries in the program guide " +
                    "will be retrieved."
            }),

            Field({
                name: "Before", id: 0x2, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.6.5.11.3",
                details: "This field shall indicate the cursor that pinpoints the end of the upcoming data page. In a " +
                    "Cursor-based pagination system, the field acts as a reference point, ensuring the set of results " +
                    "corresponds directly to the data preceding the specified cursor. In a Offset-based pagination " +
                    "system, the field, along with limit, indicate the offset from which entries in the program guide " +
                    "will be retrieved."
            })
        ),

        Datatype(
            {
                name: "ChannelPagingStruct", type: "struct", xref: "cluster§6.6.5.12",
                details: "This object defines the paging structure that includes the previous and next pagination tokens."
            },

            Field({
                name: "PreviousToken", id: 0x0, type: "PageTokenStruct", conformance: "O", default: null,
                quality: "X", xref: "cluster§6.6.5.12.1",
                details: "This field shall indicate the token to retrieve the preceding page. Absence of this field denotes " +
                    "the response as the initial page."
            }),

            Field({
                name: "NextToken", id: 0x1, type: "PageTokenStruct", conformance: "O", default: null, quality: "X",
                xref: "cluster§6.6.5.12.2",
                details: "This field shall indicate the token to retrieve the next page. Absence of this field denotes the " +
                    "response as the last page."
            })
        )
    ),

    Cluster(
        {
            name: "ContentLauncher", id: 0x50a, classification: "application", pics: "CONTENTLAUNCHER",
            xref: "cluster§6.7",

            details: "This cluster provides an interface for launching content on a Video Player device such as a " +
                "Streaming Media Player, Smart TV or Smart Screen." +
                "\n" +
                "This cluster would be supported on a Video Player device or devices that can playback content, such " +
                "as a Streaming Media Player, Smart TV or Smart Screen. This cluster supports playing back content " +
                "referenced by URL. It supports finding content by type and global identifier, and either playing the " +
                "content or displaying the search results." +
                "\n" +
                "The cluster server for Content Launcher is implemented by an endpoint that can launch content, such " +
                "as a Video Player, or an endpoint representing a Content App on such a device." +
                "\n" +
                "When this cluster is implemented for an Content App Endpoint (Endpoint with type “Content App” and " +
                "having an Application Basic cluster), the Video Player device shall launch the application when a " +
                "client invokes the LaunchContent or LaunchURL commands."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.7.4" },
            Field({
                name: "CS", constraint: "0", title: "ContentSearch",
                details: "Device supports content search (non-app specific)"
            }),
            Field({
                name: "UP", constraint: "1", title: "UrlPlayback",
                details: "Device supports basic URL-based file playback"
            }),
            Field({
                name: "AS", constraint: "2", title: "AdvancedSeek",
                details: "Enables clients to implement more advanced media seeking behavior in their user interface, such as " +
                    "for example a \"seek bar\"."
            }),
            Field({ name: "TT", constraint: "3", title: "TextTracks", details: "Device or app supports Text Tracks." }),
            Field({ name: "AT", constraint: "4", title: "AudioTracks", details: "Device or app supports Audio Tracks." })
        ),

        Attribute(
            {
                name: "AcceptHeader", id: 0x0, type: "list", access: "R V", conformance: "UP",
                constraint: "max 100[max 1024]", default: [], quality: "N", xref: "cluster§6.7.6.1",
                details: "This attribute shall provide a list of content types supported by the Video Player or Content App in " +
                    "the form of entries in the HTTP \"Accept\" request header."
            },

            Field({ name: "entry", type: "string" })
        ),

        Attribute({
            name: "SupportedStreamingProtocols", id: 0x1, type: "SupportedProtocolsBitmap", access: "R V",
            conformance: "UP", default: 0, quality: "N", xref: "cluster§6.7.6.2",
            details: "This attribute shall provide information about supported streaming protocols."
        }),

        Command(
            {
                name: "LaunchContent", id: 0x0, access: "O", conformance: "CS", direction: "request",
                response: "LauncherResponse", xref: "cluster§6.7.7.1",
                details: "Upon receipt, this shall launch the specified content with optional search criteria. This command " +
                    "returns a Launch Response."
            },

            Field({
                name: "Search", id: 0x0, type: "ContentSearchStruct", conformance: "M", constraint: "desc",
                xref: "cluster§6.7.7.1.1",
                details: "This field shall indicate the content to launch."
            }),

            Field({
                name: "AutoPlay", id: 0x1, type: "bool", conformance: "M", constraint: "desc",
                xref: "cluster§6.7.7.1.2",
                details: "This field shall indicate whether to automatically start playing content, where:" +
                    "\n" +
                    "  • TRUE means best match should start playing automatically." +
                    "\n" +
                    "  • FALSE means matches should be displayed on screen for user selection."
            }),

            Field({
                name: "Data", id: 0x2, type: "string", conformance: "O", xref: "cluster§6.7.7.1.3",
                details: "This field, if present, shall indicate app-specific data."
            }),

            Field({
                name: "PlaybackPreferences", id: 0x3, type: "PlaybackPreferencesStruct", conformance: "O",
                xref: "cluster§6.7.7.1.4",

                details: "This field, if present, shall indicate the user’s preferred Text/AudioTracks and playbackPosition " +
                    "for the media, sent from the client to the server. If the server does not find an available track " +
                    "for the title being played exactly matching a Track requested here, in the list of available tracks, " +
                    "it may default to picking another track that closely matches the requested track. Alternately, it " +
                    "may go with user preferences set on the server side (it will use this option if these " +
                    "PlaybackPreferences are not specified). In the case of text tracks, that may mean that the subtitle " +
                    "text is not displayed at all. In the cases where the preferred Text/AudioTracks are not available, " +
                    "the server shall return the TextTrackNotAvailable and/or AudioTrackNotAvailable Status(es) in the " +
                    "LauncherResponse."
            }),

            Field({
                name: "UseCurrentContext", id: 0x4, type: "bool", conformance: "O", constraint: "desc",
                default: true, xref: "cluster§6.7.7.1.5",

                details: "This field, if present, shall indicate whether to consider the context of current ongoing activity " +
                    "on the receiver to fulfill the request. For example if the request only includes data in " +
                    "ContentSearch that specifies an Episode number, and UseCurrentContent is set to TRUE, if there is a " +
                    "TV series on going, the request refers to the specific episode of the ongoing season of the TV " +
                    "series. TRUE means current activity context may be considered FALSE means current activity context " +
                    "shall NOT be considered"
            })
        ),

        Command(
            {
                name: "LaunchUrl", id: 0x1, access: "O", conformance: "UP", direction: "request",
                response: "LauncherResponse", xref: "cluster§6.7.7.2",

                details: "Upon receipt, this shall launch content from the specified URL." +
                    "\n" +
                    "The content types supported include those identified in the AcceptHeader and " +
                    "SupportedStreamingProtocols attributes." +
                    "\n" +
                    "A check shall be made to ensure the URL is secure (uses HTTPS)." +
                    "\n" +
                    "When playing a video stream in response to this command, an indication (ex. visual) of the identity " +
                    "of the origin node of the video stream shall be provided. This could be in the form of a friendly " +
                    "name label which uniquely identifies the node to the user. This friendly name label is typically " +
                    "assigned by the Matter Admin (ex. TV) at the time of commissioning and, when it’s a device, is often " +
                    "editable by the user. It might be a combination of a company name and friendly name, for example, " +
                    "”Acme” or “Acme Streaming Service on Alice’s Phone”." +
                    "\n" +
                    "This command returns a Launch Response."
            },

            Field({
                name: "ContentUrl", id: 0x0, type: "string", conformance: "M", constraint: "any",
                xref: "cluster§6.7.7.2.1",
                details: "This field shall indicate the URL of content to launch. The syntax of this field shall follow the " +
                    "syntax as specified in RFC 1738 and shall use the https scheme."
            }),

            Field({
                name: "DisplayString", id: 0x1, type: "string", conformance: "O", constraint: "any",
                xref: "cluster§6.7.7.2.2",
                details: "This field, if present, shall provide a string that may be used to describe the content being " +
                    "accessed at the given URL."
            }),

            Field({
                name: "BrandingInformation", id: 0x2, type: "BrandingInformationStruct", conformance: "O",
                constraint: "any", xref: "cluster§6.7.7.2.3",
                details: "This field, if present, shall indicate the branding information that may be displayed when playing " +
                    "back the given content."
            }),

            Field({
                name: "PlaybackPreferences", id: 0x3, type: "PlaybackPreferencesStruct", conformance: "O",
                constraint: "any", xref: "cluster§6.7.7.2.4",

                details: "This field, if present, shall indicate the user’s preferred Text/AudioTracks and playbackPosition " +
                    "for the media, sent from the client to the server. If the server does not find an available track " +
                    "for the title being played exactly matching a Track requested here, in the list of available tracks, " +
                    "it may default to picking another track that closely matches the requested track. Alternately, it " +
                    "may go with user preferences set on the server side (it will use this option if these " +
                    "PlaybackPreferences are not specified). In the case of text tracks, that may mean that the subtitle " +
                    "text is not displayed at all. In the cases where the preferred Text/AudioTracks are not available, " +
                    "the server shall return the TextTrackNotAvailable and/or AudioTrackNotAvailable Status(es) in the " +
                    "LauncherResponse."
            })
        ),

        Command(
            {
                name: "LauncherResponse", id: 0x2, conformance: "CS | UP", direction: "response",
                xref: "cluster§6.7.7.3",
                details: "This command shall be generated in response to LaunchContent and LaunchURL commands."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "cluster§6.7.7.3.1",
                details: "This field shall indicate the status of the command which resulted in this response."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", xref: "cluster§6.7.7.3.2",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Datatype(
            { name: "SupportedProtocolsBitmap", type: "map32", xref: "cluster§6.7.5.1" },
            Field({
                name: "Dash", constraint: "0",
                description: "Device supports Dynamic Adaptive Streaming over HTTP (DASH)"
            }),
            Field({ name: "Hls", constraint: "1", description: "Device supports HTTP Live Streaming (HLS)" })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.7.5.2" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Command succeeded" }),
            Field({
                name: "UrlNotAvailable", id: 0x1, conformance: "M",
                description: "Requested URL could not be reached by device."
            }),
            Field({ name: "AuthFailed", id: 0x2, conformance: "M", description: "Requested URL returned 401 error code." }),
            Field({
                name: "TextTrackNotAvailable", id: 0x3, conformance: "TT",
                description: "Requested Text Track (in PlaybackPreferences) not available"
            }),
            Field({
                name: "AudioTrackNotAvailable", id: 0x4, conformance: "AT",
                description: "Requested Audio Track (in PlaybackPreferences) not available"
            })
        ),

        Datatype(
            { name: "ParameterEnum", type: "enum8", xref: "cluster§6.7.5.3" },
            Field({
                name: "Actor", id: 0x0, conformance: "M",
                description: "Actor represents an actor credited in video media content; for example, “Gaby Hoffman”"
            }),
            Field({
                name: "Channel", id: 0x1, conformance: "M",
                description: "Channel represents the identifying data for a television channel; for example, \"PBS\""
            }),
            Field({
                name: "Character", id: 0x2, conformance: "M",
                description: "A character represented in video media content; for example, “Snow White”"
            }),
            Field({
                name: "Director", id: 0x3, conformance: "M",
                description: "A director of the video media content; for example, “Spike Lee”"
            }),
            Field({
                name: "Event", id: 0x4, conformance: "M",
                description: "An event is a reference to a type of event; examples would include sports, music, or other types of events. For example, searching for \"Football games\" would search for a 'game' event entity and a 'football' sport entity."
            }),
            Field({
                name: "Franchise", id: 0x5, conformance: "M",
                description: "A franchise is a video entity which can represent a number of video entities, like movies or TV shows. For example, take the fictional franchise \"Intergalactic Wars\" which represents a collection of movie trilogies, as well as animated and live action TV shows. This entity type was introduced to account for requests by customers such as \"Find Intergalactic Wars movies\", which would search for all 'Intergalactic Wars' programs of the MOVIE MediaType, rather than attempting to match to a single title."
            }),
            Field({
                name: "Genre", id: 0x6, conformance: "M",
                description: "Genre represents the genre of video media content such as action, drama or comedy."
            }),
            Field({
                name: "League", id: 0x7, conformance: "M",
                description: "League represents the categorical information for a sporting league; for example, \"NCAA\""
            }),
            Field({
                name: "Popularity", id: 0x8, conformance: "M",
                description: "Popularity indicates whether the user asks for popular content."
            }),
            Field({
                name: "Provider", id: 0x9, conformance: "M",
                description: "The provider (MSP) the user wants this media to be played on; for example, \"Netflix\"."
            }),
            Field({
                name: "Sport", id: 0xa, conformance: "M",
                description: "Sport represents the categorical information of a sport; for example, football"
            }),
            Field({
                name: "SportsTeam", id: 0xb, conformance: "M",
                description: "SportsTeam represents the categorical information of a professional sports team; for example, \"University of Washington Huskies\""
            }),
            Field({
                name: "Type", id: 0xc, conformance: "M",
                description: "The type of content requested. Supported types are \"Movie\", \"MovieSeries\", \"TVSeries\", \"TVSeason\", \"TVEpisode\", \"Trailer\", \"SportsEvent\", \"LiveEvent\", and \"Video\""
            }),
            Field({
                name: "Video", id: 0xd, conformance: "M",
                description: "Video represents the identifying data for a specific piece of video content; for example, \"Manchester by the Sea\"."
            }),
            Field({
                name: "Season", id: 0xe, conformance: "O",
                description: "Season represents the specific season number within a TV series."
            }),
            Field({
                name: "Episode", id: 0xf, conformance: "O",
                description: "Episode represents a specific episode number within a Season in a TV series."
            }),
            Field({
                name: "Any", id: 0x10, conformance: "O",
                description: "Represents a search text input across many parameter types or even outside of the defined param types."
            })
        ),

        Datatype(
            { name: "MetricTypeEnum", type: "enum8", xref: "cluster§6.7.5.4" },
            Field({
                name: "Pixels", id: 0x0, conformance: "M", description: "Dimensions defined in a number of Pixels",
                xref: "cluster§6.7.5.4.1",
                details: "This value is used for dimensions defined in a number of Pixels."
            }),

            Field({
                name: "Percentage", id: 0x1, conformance: "M", description: "Dimensions defined as a percentage",
                xref: "cluster§6.7.5.4.2",
                details: "This value is for dimensions defined as a percentage of the overall display dimensions. For example, " +
                    "if using a Percentage Metric type for a Width measurement of 50.0, against a display width of 1920 " +
                    "pixels, then the resulting value used would be 960 pixels (50.0% of 1920) for that dimension. " +
                    "Whenever a measurement uses this Metric type, the resulting values shall be rounded (\"floored\") " +
                    "towards 0 if the measurement requires an integer final value."
            })
        ),

        Datatype(
            {
                name: "AdditionalInfoStruct", type: "struct", xref: "cluster§6.7.5.5",
                details: "This object defines additional name=value pairs that can be used for identifying content."
            },
            Field({
                name: "Name", id: 0x0, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.7.5.5.1",
                details: "This field shall indicate the name of external id, ex. \"musicbrainz\"."
            }),
            Field({
                name: "Value", id: 0x1, type: "string", conformance: "M", constraint: "max 8192",
                xref: "cluster§6.7.5.5.2",
                details: "This field shall indicate the value for external id, ex. \"ST0000000666661\"."
            })
        ),

        Datatype(
            {
                name: "ParameterStruct", type: "struct", xref: "cluster§6.7.5.6",
                details: "This object defines inputs to a search for content for display or playback."
            },
            Field({
                name: "Type", id: 0x0, type: "ParameterEnum", conformance: "M", xref: "cluster§6.7.5.6.1",
                details: "This field shall indicate the entity type."
            }),
            Field({
                name: "Value", id: 0x1, type: "string", conformance: "M", constraint: "max 1024",
                xref: "cluster§6.7.5.6.2",
                details: "This field shall indicate the entity value, which is a search string, ex. “Manchester by the Sea”."
            }),

            Field(
                {
                    name: "ExternalIdList", id: 0x2, type: "list", conformance: "O", default: [],
                    xref: "cluster§6.7.5.6.3",
                    details: "This field shall indicate the list of additional external content identifiers."
                },
                Field({ name: "entry", type: "AdditionalInfoStruct" })
            )
        ),

        Datatype(
            {
                name: "ContentSearchStruct", type: "struct", xref: "cluster§6.7.5.7",
                details: "This object defines inputs to a search for content for display or playback."
            },

            Field(
                {
                    name: "ParameterList", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.7.5.7.1",
                    details: "This field shall indicate the list of parameters comprising the search. If multiple parameters are " +
                        "provided, the search parameters shall be joined with 'AND' logic. e.g. action movies with Tom Cruise " +
                        "will be represented as [{Actor: 'Tom Cruise'}, {Type: 'Movie'}, {Genre: 'Action'}]"
                },

                Field({ name: "entry", type: "ParameterStruct" })
            )
        ),

        Datatype(
            {
                name: "DimensionStruct", type: "struct", xref: "cluster§6.7.5.8",
                details: "This object defines dimension which can be used for defining Size of background images."
            },
            Field({
                name: "Width", id: 0x0, type: "double", conformance: "M", xref: "cluster§6.7.5.8.1",
                details: "This field shall indicate the width using the metric defined in Metric"
            }),
            Field({
                name: "Height", id: 0x1, type: "double", conformance: "M", xref: "cluster§6.7.5.8.2",
                details: "This field shall indicate the height using the metric defined in Metric"
            }),
            Field({
                name: "Metric", id: 0x2, type: "MetricTypeEnum", conformance: "M", xref: "cluster§6.7.5.8.3",
                details: "This field shall indicate metric used for defining Height/Width."
            })
        ),

        Datatype(
            {
                name: "StyleInformationStruct", type: "struct", xref: "cluster§6.7.5.9",
                details: "This object defines style information which can be used by content providers to change the Media " +
                    "Player’s style related properties."
            },

            Field({
                name: "ImageUrl", id: 0x0, type: "string", conformance: "O", constraint: "max 8192",
                xref: "cluster§6.7.5.9.1",
                details: "This field shall indicate the URL of image used for Styling different Video Player sections like " +
                    "Logo, Watermark etc. The syntax of this field shall follow the syntax as specified in RFC 1738 and " +
                    "shall use the https scheme."
            }),

            Field(
                {
                    name: "Color", id: 0x1, type: "string", conformance: "O", constraint: "7, 9",
                    xref: "cluster§6.7.5.9.2",

                    details: "This field shall indicate the color, in RGB or RGBA, used for styling different Video Player " +
                        "sections like Logo, Watermark, etc. The value shall conform to the 6-digit or 8-digit format defined " +
                        "for CSS sRGB hexadecimal color notation [https://www.w3.org/TR/css-color-4/#hex-notation]. Examples:" +
                        "\n" +
                        "  • #76DE19 for R=0x76, G=0xDE, B=0x19, A absent" +
                        "\n" +
                        "  • #76DE1980 for R=0x76, G=0xDE, B=0x19, A=0x80"
                }
            ),

            Field({
                name: "Size", id: 0x2, type: "DimensionStruct", conformance: "O", xref: "cluster§6.7.5.9.3",
                details: "This field shall indicate the size of the image used for Styling different Video Player sections " +
                    "like Logo, Watermark etc."
            })
        ),

        Datatype(
            {
                name: "BrandingInformationStruct", type: "struct", xref: "cluster§6.7.5.10",
                details: "This object defines Branding Information which can be provided by the client in order to customize " +
                    "the skin of the Video Player during playback."
            },
            Field({
                name: "ProviderName", id: 0x0, type: "string", conformance: "M", constraint: "max 256",
                xref: "cluster§6.7.5.10.1",
                details: "This field shall indicate name of the provider for the given content."
            }),

            Field({
                name: "Background", id: 0x1, type: "StyleInformationStruct", conformance: "O",
                xref: "cluster§6.7.5.10.2",
                details: "This field shall indicate background of the Video Player while content launch request is being " +
                    "processed by it. This background information may also be used by the Video Player when it is in idle " +
                    "state."
            }),

            Field({
                name: "Logo", id: 0x2, type: "StyleInformationStruct", conformance: "O", xref: "cluster§6.7.5.10.3",
                details: "This field shall indicate the logo shown when the Video Player is launching. This is also used when " +
                    "the Video Player is in the idle state and Splash field is not available."
            }),
            Field({
                name: "ProgressBar", id: 0x3, type: "StyleInformationStruct", conformance: "O",
                xref: "cluster§6.7.5.10.4",
                details: "This field shall indicate the style of progress bar for media playback."
            }),

            Field({
                name: "Splash", id: 0x4, type: "StyleInformationStruct", conformance: "O",
                xref: "cluster§6.7.5.10.5",
                details: "This field shall indicate the screen shown when the Video Player is in an idle state. If this " +
                    "property is not populated, the Video Player shall default to logo or the provider name."
            }),

            Field({
                name: "Watermark", id: 0x5, type: "StyleInformationStruct", conformance: "O",
                xref: "cluster§6.7.5.10.6",
                details: "This field shall indicate watermark shown when the media is playing."
            })
        ),

        Datatype(
            {
                name: "PlaybackPreferencesStruct", type: "struct", xref: "cluster§6.7.5.11",
                details: "PlaybackPreferencesStruct defines the preferences sent by the client to the receiver in the " +
                    "ContentLauncher LaunchURL or LaunchContent commands."
            },

            Field({
                name: "PlaybackPosition", id: 0x0, type: "uint64", conformance: "AS", quality: "X",
                xref: "cluster§6.7.5.11.1",

                details: "This field shall indicate the preferred position (in milliseconds) in the media to launch playback " +
                    "from. In case the position falls in the middle of a frame, the server shall set the position to the " +
                    "beginning of that frame and set the SampledPosition attribute on the MediaPlayback cluster " +
                    "accordingly. A value of null shall indicate that playback position is not applicable for the current " +
                    "state of the media playback. (For example : Live media with no known duration and where seek is not " +
                    "supported)."
            }),

            Field({
                name: "TextTrack", id: 0x1, type: "TrackPreferenceStruct", conformance: "TT", quality: "X",
                xref: "cluster§6.7.5.11.2",
                details: "This field shall indicate the user’s preferred Text Track. A value of null shall indicate that the " +
                    "user did not specify a preferred Text Track on the client. In such a case, the decision to display " +
                    "and select a Text Track is up to the server."
            }),

            Field(
                {
                    name: "AudioTracks", id: 0x2, type: "list", conformance: "AT", quality: "X",
                    xref: "cluster§6.7.5.11.3",
                    details: "This field shall indicate the list of the user’s preferred Audio Tracks. If the list contains " +
                        "multiple values, each AudioTrack must also specify a unique audioOutputIndex to play the track on. A " +
                        "value of null shall indicate that the user did not specify a preferred Audio Track on the client. In " +
                        "such a case, the decision to play and select an Audio Track is up to the server."
                },

                Field({ name: "entry", type: "TrackPreferenceStruct" })
            )
        ),

        Datatype(
            {
                name: "TrackPreferenceStruct", type: "struct", xref: "cluster§6.7.5.12",
                details: "This structure defines Text/Audio Track preferences."
            },

            Field({
                name: "LanguageCode", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§6.7.5.12.1",
                details: "This field shall contain one of the standard Tags for Identifying Languages RFC 5646, which " +
                    "identifies the primary language used in the Track."
            }),

            Field(
                {
                    name: "Characteristics", id: 0x1, type: "list", conformance: "O", default: null, quality: "X",
                    xref: "cluster§6.7.5.12.2",
                    details: "This field shall contain a list of enumerated CharacteristicEnum values that indicate a purpose, " +
                        "trait or feature associated with the Track. A value of null shall indicate that there are no " +
                        "Characteristics corresponding to the Track."
                },

                Field({ name: "entry", type: "MediaPlayback.CharacteristicEnum" })
            ),

            Field({
                name: "AudioOutputIndex", id: 0x2, type: "uint8", conformance: "AT", quality: "X",
                xref: "cluster§6.7.5.12.3",

                details: "This field if present shall indicate the index of the OutputInfoStruct from the OutputList attribute " +
                    "(from the AudioOutput cluster) and indicates which audio output the Audio Track should be played on." +
                    "\n" +
                    "This field shall NOT be present if the track is not an audio track." +
                    "\n" +
                    "If the track is an audio track, this field MUST be present. A value of null shall indicate that the " +
                    "server can choose the audio output(s) to play the Audio Track on."
            })
        )
    ),

    Cluster(
        {
            name: "KeypadInput", id: 0x509, classification: "application", pics: "KEYPADINPUT",
            xref: "cluster§6.8",

            details: "This cluster provides an interface for key code based input and control on a device like a Video " +
                "Player or an endpoint like a Content App. This may include text or action commands such as UP, DOWN, " +
                "and SELECT." +
                "\n" +
                "This cluster would be supported on Video Player devices as well as devices that support remote " +
                "control input from a keypad or remote. This cluster provides the list of supported keypad inputs and " +
                "provides a command for sending them." +
                "\n" +
                "The cluster server for Keypad Input is implemented by a device that can receive keypad input, such " +
                "as a Video Player, or an endpoint that can receive keypad input, such as a Content App." +
                "\n" +
                "The key codes used are those defined in the HDMI CEC specification (see HDMI)." +
                "\n" +
                "Devices may understand a subset of these key codes. Feature flags are used to indicate a specific " +
                "subset that is supported. Device may support additional codes beyond what is indicated in feature " +
                "flags."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.8.4" },
            Field({
                name: "NV", constraint: "0", title: "NavigationKeyCodes",
                details: "Supports UP, DOWN, LEFT, RIGHT, SELECT, BACK, EXIT, MENU"
            }),
            Field({
                name: "LK", constraint: "1", title: "LocationKeys",
                details: "Supports CEC keys 0x0A (Settings) and 0x09 (Home)"
            }),
            Field({ name: "NK", constraint: "2", title: "NumberKeys", details: "Supports numeric input 0..9" })
        ),

        Command(
            {
                name: "SendKey", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "SendKeyResponse", xref: "cluster§6.8.6.1",

                details: "Upon receipt, this shall process a keycode as input to the media endpoint." +
                    "\n" +
                    "If a device has multiple media endpoints implementing this cluster, such as a casting video player " +
                    "endpoint with one or more content app endpoints, then only the endpoint receiving the command shall " +
                    "process the keycode as input. In other words, a specific content app endpoint shall NOT process a " +
                    "keycode received by a different content app endpoint." +
                    "\n" +
                    "If a second SendKey request with the same KeyCode value is received within 200 ms, then the endpoint " +
                    "will consider the first key press to be a press and hold. When such a repeat KeyCode value is not " +
                    "received within 200 ms, then the endpoint will consider the last key press to be a release."
            },

            Field({
                name: "KeyCode", id: 0x0, type: "CecKeyCodeEnum", conformance: "M", xref: "cluster§6.8.6.1.1",
                details: "This field shall indicate the key code to process."
            })
        ),

        Command(
            {
                name: "SendKeyResponse", id: 0x1, conformance: "M", direction: "response", xref: "cluster§6.8.6.2",
                details: "This command shall be generated in response to a SendKey command."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "cluster§6.8.6.2.1",
                details: "This field shall indicate the status of the request."
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.8.5.1" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Succeeded" }),
            Field({ name: "UnsupportedKey", id: 0x1, conformance: "M", description: "Key code is not supported." }),
            Field({
                name: "InvalidKeyInCurrentState", id: 0x2, conformance: "M",
                description: "Requested key code is invalid in the context of the responder’s current state."
            })
        ),

        Datatype(
            { name: "CecKeyCodeEnum", type: "enum8", xref: "cluster§6.8.5.2" },
            Field({ name: "Select", id: 0x0, conformance: "M" }),
            Field({ name: "Up", id: 0x1, conformance: "M" }),
            Field({ name: "Down", id: 0x2, conformance: "M" }),
            Field({ name: "Left", id: 0x3, conformance: "M" }),
            Field({ name: "Right", id: 0x4, conformance: "M" }),
            Field({ name: "RightUp", id: 0x5, conformance: "M" }),
            Field({ name: "RightDown", id: 0x6, conformance: "M" }),
            Field({ name: "LeftUp", id: 0x7, conformance: "M" }),
            Field({ name: "LeftDown", id: 0x8, conformance: "M" }),
            Field({ name: "RootMenu", id: 0x9, conformance: "M" }),
            Field({ name: "SetupMenu", id: 0xa, conformance: "M" }),
            Field({ name: "ContentsMenu", id: 0xb, conformance: "M" }),
            Field({ name: "FavoriteMenu", id: 0xc, conformance: "M" }),
            Field({ name: "Exit", id: 0xd, conformance: "M" }),
            Field({ name: "MediaTopMenu", id: 0x10, conformance: "M" }),
            Field({ name: "MediaContextSensitiveMenu", id: 0x11, conformance: "M" }),
            Field({ name: "NumberEntryMode", id: 0x1d, conformance: "M" }),
            Field({ name: "Number11", id: 0x1e, conformance: "M" }),
            Field({ name: "Number12", id: 0x1f, conformance: "M" }),
            Field({ name: "Number0OrNumber10", id: 0x20, conformance: "M" }),
            Field({ name: "Numbers1", id: 0x21, conformance: "M" }),
            Field({ name: "Numbers2", id: 0x22, conformance: "M" }),
            Field({ name: "Numbers3", id: 0x23, conformance: "M" }),
            Field({ name: "Numbers4", id: 0x24, conformance: "M" }),
            Field({ name: "Numbers5", id: 0x25, conformance: "M" }),
            Field({ name: "Numbers6", id: 0x26, conformance: "M" }),
            Field({ name: "Numbers7", id: 0x27, conformance: "M" }),
            Field({ name: "Numbers8", id: 0x28, conformance: "M" }),
            Field({ name: "Numbers9", id: 0x29, conformance: "M" }),
            Field({ name: "Dot", id: 0x2a, conformance: "M" }),
            Field({ name: "Enter", id: 0x2b, conformance: "M" }),
            Field({ name: "Clear", id: 0x2c, conformance: "M" }),
            Field({ name: "NextFavorite", id: 0x2f, conformance: "M" }),
            Field({ name: "ChannelUp", id: 0x30, conformance: "M" }),
            Field({ name: "ChannelDown", id: 0x31, conformance: "M" }),
            Field({ name: "PreviousChannel", id: 0x32, conformance: "M" }),
            Field({ name: "SoundSelect", id: 0x33, conformance: "M" }),
            Field({ name: "InputSelect", id: 0x34, conformance: "M" }),
            Field({ name: "DisplayInformation", id: 0x35, conformance: "M" }),
            Field({ name: "Help", id: 0x36, conformance: "M" }),
            Field({ name: "PageUp", id: 0x37, conformance: "M" }),
            Field({ name: "PageDown", id: 0x38, conformance: "M" }),
            Field({ name: "Power", id: 0x40, conformance: "M" }),
            Field({ name: "VolumeUp", id: 0x41, conformance: "M" }),
            Field({ name: "VolumeDown", id: 0x42, conformance: "M" }),
            Field({ name: "Mute", id: 0x43, conformance: "M" }),
            Field({ name: "Play", id: 0x44, conformance: "M" }),
            Field({ name: "Stop", id: 0x45, conformance: "M" }),
            Field({ name: "Pause", id: 0x46, conformance: "M" }),
            Field({ name: "Record", id: 0x47, conformance: "M" }),
            Field({ name: "Rewind", id: 0x48, conformance: "M" }),
            Field({ name: "FastForward", id: 0x49, conformance: "M" }),
            Field({ name: "Eject", id: 0x4a, conformance: "M" }),
            Field({ name: "Forward", id: 0x4b, conformance: "M" }),
            Field({ name: "Backward", id: 0x4c, conformance: "M" }),
            Field({ name: "StopRecord", id: 0x4d, conformance: "M" }),
            Field({ name: "PauseRecord", id: 0x4e, conformance: "M" }),
            Field({ name: "Angle", id: 0x50, conformance: "M" }),
            Field({ name: "SubPicture", id: 0x51, conformance: "M" }),
            Field({ name: "VideoOnDemand", id: 0x52, conformance: "M" }),
            Field({ name: "ElectronicProgramGuide", id: 0x53, conformance: "M" }),
            Field({ name: "TimerProgramming", id: 0x54, conformance: "M" }),
            Field({ name: "InitialConfiguration", id: 0x55, conformance: "M" }),
            Field({ name: "SelectBroadcastType", id: 0x56, conformance: "M" }),
            Field({ name: "SelectSoundPresentation", id: 0x57, conformance: "M" }),
            Field({ name: "PlayFunction", id: 0x60, conformance: "M" }),
            Field({ name: "PausePlayFunction", id: 0x61, conformance: "M" }),
            Field({ name: "RecordFunction", id: 0x62, conformance: "M" }),
            Field({ name: "PauseRecordFunction", id: 0x63, conformance: "M" }),
            Field({ name: "StopFunction", id: 0x64, conformance: "M" }),
            Field({ name: "MuteFunction", id: 0x65, conformance: "M" }),
            Field({ name: "RestoreVolumeFunction", id: 0x66, conformance: "M" }),
            Field({ name: "TuneFunction", id: 0x67, conformance: "M" }),
            Field({ name: "SelectMediaFunction", id: 0x68, conformance: "M" }),
            Field({ name: "SelectAvInputFunction", id: 0x69, conformance: "M" }),
            Field({ name: "SelectAudioInputFunction", id: 0x6a, conformance: "M" }),
            Field({ name: "PowerToggleFunction", id: 0x6b, conformance: "M" }),
            Field({ name: "PowerOffFunction", id: 0x6c, conformance: "M" }),
            Field({ name: "PowerOnFunction", id: 0x6d, conformance: "M" }),
            Field({ name: "F1Blue", id: 0x71, conformance: "M" }),
            Field({ name: "F2Red", id: 0x72, conformance: "M" }),
            Field({ name: "F3Green", id: 0x73, conformance: "M" }),
            Field({ name: "F4Yellow", id: 0x74, conformance: "M" }),
            Field({ name: "F5", id: 0x75, conformance: "M" }),
            Field({ name: "Data", id: 0x76, conformance: "M" })
        )
    ),

    Cluster(
        {
            name: "MediaInput", id: 0x507, classification: "application", pics: "MEDIAINPUT",
            xref: "cluster§6.9",

            details: "This cluster provides an interface for controlling the Input Selector on a media device such as a " +
                "Video Player." +
                "\n" +
                "This cluster would be implemented on TV and other media streaming devices, as well as devices that " +
                "provide input to or output from such devices." +
                "\n" +
                "This cluster provides the list of available inputs and provides commands for selecting and renaming " +
                "them." +
                "\n" +
                "The cluster server for Media Input is implemented by a device that has selectable input, such as a " +
                "Video Player device."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),
        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.9.4" },
            Field({ name: "NU", constraint: "0", title: "NameUpdates", details: "Supports updates to the input names" })
        ),

        Attribute(
            {
                name: "InputList", id: 0x0, type: "list", access: "R V", conformance: "M", xref: "cluster§6.9.6.1",
                details: "This attribute shall provide a list of the media inputs supported by the device."
            },
            Field({ name: "entry", type: "InputInfoStruct" })
        ),

        Attribute({
            name: "CurrentInput", id: 0x1, type: "uint8", access: "R V", conformance: "M",
            xref: "cluster§6.9.6.2",
            details: "This attribute shall contain the value of the index field of the currently selected InputInfoStruct."
        }),

        Command(
            {
                name: "SelectInput", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§6.9.7.1",
                details: "Upon receipt, this command shall change the media input on the device to the input at a specific " +
                    "index in the Input List."
            },

            Field({
                name: "Index", id: 0x0, type: "uint8", conformance: "M", xref: "cluster§6.9.7.1.1",
                details: "This field shall indicate the index field of the InputInfoStruct from the InputList attribute in " +
                    "which to change to."
            })
        ),

        Command({
            name: "ShowInputStatus", id: 0x1, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§6.9.7.2",
            details: "Upon receipt, this command shall display the active status of the input list on screen."
        }),
        Command({
            name: "HideInputStatus", id: 0x2, access: "O", conformance: "M", direction: "request",
            response: "status", xref: "cluster§6.9.7.3",
            details: "Upon receipt, this command shall hide the input list from the screen."
        }),

        Command(
            {
                name: "RenameInput", id: 0x3, access: "M", conformance: "NU", direction: "request",
                response: "status", xref: "cluster§6.9.7.4",
                details: "Upon receipt, this command shall rename the input at a specific index in the Input List. Updates to " +
                    "the input name shall appear in the device’s settings menus."
            },

            Field({ name: "Index", id: 0x0, type: "uint8", conformance: "M" }),
            Field({ name: "Name", id: 0x1, type: "string", conformance: "M" })
        ),

        Datatype(
            { name: "InputTypeEnum", type: "enum8", xref: "cluster§6.9.5.1" },
            Field({
                name: "Internal", id: 0x0, conformance: "M",
                description: "Indicates content not coming from a physical input."
            }),
            Field({ name: "Aux", id: 0x1, conformance: "M" }),
            Field({ name: "Coax", id: 0x2, conformance: "M" }),
            Field({ name: "Composite", id: 0x3, conformance: "M" }),
            Field({ name: "Hdmi", id: 0x4, conformance: "M" }),
            Field({ name: "Input", id: 0x5, conformance: "M" }),
            Field({ name: "Line", id: 0x6, conformance: "M" }),
            Field({ name: "Optical", id: 0x7, conformance: "M" }),
            Field({ name: "Video", id: 0x8, conformance: "M" }),
            Field({ name: "Scart", id: 0x9, conformance: "M" }),
            Field({ name: "Usb", id: 0xa, conformance: "M" }),
            Field({ name: "Other", id: 0xb, conformance: "M" })
        ),

        Datatype(
            {
                name: "InputInfoStruct", type: "struct", xref: "cluster§6.9.5.2",
                details: "This contains information about an input."
            },
            Field({
                name: "Index", id: 0x0, type: "uint8", conformance: "M", xref: "cluster§6.9.5.2.1",
                details: "This field shall indicate the unique index into the list of Inputs."
            }),
            Field({
                name: "InputType", id: 0x1, type: "InputTypeEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.9.5.2.2",
                details: "### This field shall indicate the type of input"
            }),
            Field({
                name: "Name", id: 0x2, type: "string", conformance: "M", xref: "cluster§6.9.5.2.3",
                details: "This field shall indicate the input name, such as “HDMI 1”. This field may be blank, but SHOULD be " +
                    "provided when known."
            }),
            Field({
                name: "Description", id: 0x3, type: "string", conformance: "M", xref: "cluster§6.9.5.2.4",
                details: "This field shall indicate the user editable input description, such as “Living room Playstation”. " +
                    "This field may be blank, but SHOULD be provided when known."
            })
        )
    ),

    Cluster(
        {
            name: "MediaPlayback", id: 0x506, classification: "application", pics: "MEDIAPLAYBACK",
            xref: "cluster§6.10",
            details: "This cluster provides an interface for controlling Media Playback (PLAY, PAUSE, etc) on a media " +
                "device such as a TV, Set-top Box, or Smart Speaker." +
                "\n" +
                "This cluster server would be supported on Video Player devices or endpoints that provide media " +
                "playback, such as a Content App. This cluster provides an interface for controlling Media Playback."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.10.4" },

            Field({
                name: "AS", constraint: "0", title: "AdvancedSeek", xref: "cluster§6.10.4.1",
                details: "This feature provides access to the time offset location within current playback media and allows " +
                    "for jumping to a specific location using time offsets. This enables clients to implement more " +
                    "advanced media seeking behavior in their user interface, for instance a \"seek bar\"."
            }),

            Field({
                name: "VS", constraint: "1", title: "VariableSpeed", xref: "cluster§6.10.4.2",
                details: "This feature is for a device which supports variable speed playback on media that supports it."
            }),
            Field({
                name: "TT", constraint: "2", title: "TextTracks", xref: "cluster§6.10.4.3",
                details: "This feature is for a device or app that supports Text Tracks."
            }),
            Field({
                name: "AT", constraint: "3", title: "AudioTracks", xref: "cluster§6.10.4.4",
                details: "This feature is for a device or app that supports Audio Tracks."
            }),

            Field({
                name: "AA", constraint: "4", title: "AudioAdvance", xref: "cluster§6.10.4.5",
                details: "This feature is for a device or app that supports playing audio during fast and slow advance and " +
                    "rewind (e.g., while playback speed is not 1). A device that supports this feature may only support " +
                    "playing audio during certain speeds." +
                    "\n" +
                    "A cluster implementing AA shall implement AS."
            })
        ),

        Attribute({
            name: "CurrentState", id: 0x0, type: "PlaybackStateEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§6.10.6.1",
            details: "Indicates the current playback state of media." +
                "\n" +
                "During fast-forward, rewind, and other seek operations; this attribute shall be set to PLAYING."
        }),

        Attribute({
            name: "StartTime", id: 0x1, type: "epoch-us", access: "R V", conformance: "AS", constraint: "desc",
            default: null, quality: "X", xref: "cluster§6.10.6.2",
            details: "Indicates the start time of the media, in case the media has a fixed start time (for example, live " +
                "stream or television broadcast), or null when start time does not apply to the current media (for " +
                "example, video-on-demand). This time is a UTC time. The client needs to handle conversion to local " +
                "time, as required, taking in account time zone and possible local DST offset."
        }),

        Attribute({
            name: "Duration", id: 0x2, type: "uint64", access: "R V", conformance: "AS", constraint: "desc",
            default: null, quality: "X", xref: "cluster§6.10.6.3",
            details: "Indicates the duration, in milliseconds, of the current media being played back or null when " +
                "duration is not applicable (for example, in live streaming content with no known duration). This " +
                "attribute shall never be 0."
        }),

        Attribute({
            name: "SampledPosition", id: 0x3, type: "PlaybackPositionStruct", access: "R V", conformance: "AS",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.4",

            details: "Indicates the position of playback (Position field) at the time (UpdateAt field) specified in the " +
                "attribute. The client may use the SampledPosition attribute to compute the current position within " +
                "the media stream based on the PlaybackSpeed, PlaybackPositionStruct.UpdatedAt and " +
                "PlaybackPositionStruct.Position fields. To enable this, the SampledPosition attribute shall be " +
                "updated whenever a change in either the playback speed or the playback position is triggered outside " +
                "the normal playback of the media. The events which may cause this to happen include:" +
                "\n" +
                "  • Starting or resumption of playback" +
                "\n" +
                "  • Seeking" +
                "\n" +
                "  • Skipping forward or backward" +
                "\n" +
                "  • Fast-forwarding or rewinding" +
                "\n" +
                "  • Updating of playback speed as a result of explicit request, or as a result of buffering events"
        }),

        Attribute({
            name: "PlaybackSpeed", id: 0x4, type: "single", access: "R V", conformance: "AS",
            constraint: "desc", default: 0, xref: "cluster§6.10.6.5",

            details: "Indicates the speed at which the current media is being played. The new PlaybackSpeed shall be " +
                "reflected in this attribute whenever any of the following occurs:" +
                "\n" +
                "  • Starting of playback" +
                "\n" +
                "  • Resuming of playback" +
                "\n" +
                "  • Fast-forwarding" +
                "\n" +
                "  • Rewinding" +
                "\n" +
                "The PlaybackSpeed shall reflect the ratio of time elapsed in the media to the actual time taken for " +
                "the playback assuming no changes to media playback (for example buffering events or requests to " +
                "pause/rewind/forward)." +
                "\n" +
                "  • A value for PlaybackSpeed of 1 shall indicate normal playback where, for example, playback for 1 " +
                "    second causes the media to advance by 1 second within the duration of the media." +
                "\n" +
                "  • A value for PlaybackSpeed which is greater than 0 shall indicate that as playback is happening " +
                "    the media is currently advancing in time within the duration of the media." +
                "\n" +
                "  • A value for PlaybackSpeed which is less than 0 shall indicate that as playback is happening the " +
                "    media is currently going back in time within the duration of the media." +
                "\n" +
                "  • A value for PlaybackSpeed of 0 shall indicate that the media is currently not playing back. When " +
                "    the CurrentState attribute has the value of PAUSED, NOT_PLAYING or BUFFERING, the PlaybackSpeed " +
                "    shall be set to 0 to reflect that the media is not playing." +
                "\n" +
                "Following examples illustrate the PlaybackSpeed attribute values in various conditions."
        }),

        Attribute({
            name: "SeekRangeEnd", id: 0x5, type: "uint64", access: "R V", conformance: "AS", constraint: "desc",
            default: null, quality: "X", xref: "cluster§6.10.6.7",

            details: "Indicates the furthest forward valid position to which a client may seek forward, in milliseconds " +
                "from the start of the media. When the media has an associated StartTime, a value of null shall " +
                "indicate that a seek forward is valid only until the current time within the media, using a position " +
                "computed from the difference between the current time offset and StartTime, in milliseconds from " +
                "start of the media, truncating fractional milliseconds towards 0. A value of NULL when StartTime is " +
                "not specified shall indicate that seeking forward is not allowed."
        }),

        Attribute({
            name: "SeekRangeStart", id: 0x6, type: "uint64", access: "R V", conformance: "AS",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.6",
            details: "Indicates the earliest valid position to which a client may seek back, in milliseconds from start of " +
                "the media. A value of NULL shall indicate that seeking backwards is not allowed."
        }),

        Attribute({
            name: "ActiveAudioTrack", id: 0x7, type: "TrackStruct", access: "R V", conformance: "AT",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.8",
            details: "ActiveTrack refers to the Audio track currently set and being used for the streaming media. A value " +
                "of null shall indicate that no Audio Track corresponding to the current media is currently being " +
                "played."
        }),

        Attribute(
            {
                name: "AvailableAudioTracks", id: 0x8, type: "list", access: "R V", conformance: "AT",
                constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.9",
                details: "AvailableAudioTracks refers to the list of Audio tracks available for the current title being " +
                    "played. A value of null shall indicate that no Audio Tracks corresponding to the current media are " +
                    "selectable by the client."
            },

            Field({ name: "entry", type: "TrackStruct" })
        ),

        Attribute({
            name: "ActiveTextTrack", id: 0x9, type: "TrackStruct", access: "R V", conformance: "TT",
            constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.10",
            details: "ActiveTrack refers to the Text track currently set and being used for the streaming media. This can " +
                "be nil. A value of null shall indicate that no Text Track corresponding to the current media is " +
                "currently being displayed."
        }),

        Attribute(
            {
                name: "AvailableTextTracks", id: 0xa, type: "list", access: "R V", conformance: "TT",
                constraint: "desc", default: null, quality: "X", xref: "cluster§6.10.6.11",
                details: "AvailableTextTracks refers to the list of Text tracks available for the current title being played. " +
                    "This can be an empty list. A value of null shall indicate that no Text Tracks corresponding to the " +
                    "current media are selectable by the client."
            },

            Field({ name: "entry", type: "TrackStruct" })
        ),

        Event(
            {
                name: "StateChanged", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "cluster§6.10.8.1",
                details: "If supported, this event shall be generated when there is a change in any of the supported " +
                    "attributes of the Media Playback cluster."
            },

            Field({
                name: "CurrentState", id: 0x0, type: "PlaybackStateEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.10.8.1.1",
                details: "This field shall indicate the updated playback state as defined by the CurrentState attribute, and " +
                    "has the same constraint as that attribute."
            }),

            Field({
                name: "StartTime", id: 0x1, type: "epoch-us", conformance: "AS", constraint: "desc",
                xref: "cluster§6.10.8.1.2",
                details: "This field shall indicate the updated start time as defined by the StartTime attribute, and has the " +
                    "same constraint as that attribute." +
                    "\n" +
                    "This field value shall be 0 when the value of the StartTime attribute is NULL."
            }),

            Field({
                name: "Duration", id: 0x2, type: "uint64", conformance: "AS", constraint: "desc",
                xref: "cluster§6.10.8.1.3",
                details: "This field shall indicate the updated duration as defined by the Duration attribute, and has the " +
                    "same constraint as that attribute." +
                    "\n" +
                    "This field value shall be 0 when the value of the Duration attribute is NULL."
            }),

            Field({
                name: "SampledPosition", id: 0x3, type: "PlaybackPositionStruct", conformance: "AS",
                constraint: "desc", xref: "cluster§6.10.8.1.4",
                details: "This field shall indicate the updated position of playback as defined by the SampledPosition " +
                    "attribute, and has the same constraint as that attribute." +
                    "\n" +
                    "The UpdatedAt field value of the PlaybackPositionStruct shall be 0, and the Position field value of " +
                    "the PlaybackPositionStruct shall be NULL, when the value of the SampledPosition attribute is NULL."
            }),

            Field({
                name: "PlaybackSpeed", id: 0x4, type: "single", conformance: "AS", constraint: "desc",
                xref: "cluster§6.10.8.1.5",
                details: "This field shall indicate the updated speed at which the current media is being played as defined by " +
                    "the PlaybackSpeed attribute, and has the same constraint as that attribute."
            }),

            Field({
                name: "SeekRangeEnd", id: 0x5, type: "uint64", conformance: "AS", constraint: "desc",
                xref: "cluster§6.10.8.1.7",
                details: "This field shall indicate the updated start of the seek range end as defined by the SeekRangeEnd " +
                    "attribute, and has the same constraint as that attribute." +
                    "\n" +
                    "This field value shall be 0 when the value of the SeekRangeEnd attribute is NULL."
            }),

            Field({
                name: "SeekRangeStart", id: 0x6, type: "uint64", conformance: "AS", constraint: "desc",
                xref: "cluster§6.10.8.1.6",
                details: "This field shall indicate the updated start of the seek range start as defined by the SeekRangeStart " +
                    "attribute, and has the same constraint as that attribute." +
                    "\n" +
                    "This field value shall be 0 when the value of the SeekRangeStart attribute is NULL."
            }),

            Field({
                name: "Data", id: 0x7, type: "octstr", conformance: "O", constraint: "max 900",
                xref: "cluster§6.10.8.1.8",
                details: "This field shall indicate Optional app-specific data."
            }),

            Field({
                name: "AudioAdvanceUnmuted", id: 0x8, type: "bool", conformance: "AA", constraint: "desc",
                default: false, xref: "cluster§6.10.8.1.9",

                details: "This field shall indicate whether audio is unmuted by the player due to a FF or REW command. This " +
                    "field is only meaningful when the PlaybackSpeed is present and not equal to 0 (paused) or 1 (normal " +
                    "playback). Typically the value will be false (muted), however, some players will play audio during " +
                    "certain fast forward and rewind speeds, and in these cases, the value will be true (not muted)." +
                    "\n" +
                    "A value of true does not guarantee that audio can be heard by the user since the speaker may be " +
                    "muted, turned down to a low level and/or unplugged."
            })
        ),

        Command({
            name: "Play", id: 0x0, access: "O", conformance: "M", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.1",
            details: "This command is used to start playback of the media." +
                "\n" +
                "Upon receipt, this shall play media. If content is currently in a FastForward or Rewind state. Play " +
                "shall return media to normal playback speed."
        }),

        Command({
            name: "Pause", id: 0x1, access: "O", conformance: "M", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.2",
            details: "This command is used to pause playback of the media. Upon receipt, this shall pause playback of the " +
                "media."
        }),

        Command({
            name: "Stop", id: 0x2, access: "O", conformance: "M", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.3",
            details: "This command is used to stop playback of the media." +
                "\n" +
                "Upon receipt, this shall stop playback of the media. User-visible outcome is context-specific. This " +
                "may navigate the user back to the location from where the media was originally launched."
        }),

        Command({
            name: "StartOver", id: 0x3, access: "O", conformance: "O", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.4",
            details: "This command is used to start playback of the media from the beginning. Upon receipt, this shall " +
                "Start Over with the current media playback item."
        }),

        Command({
            name: "Previous", id: 0x4, access: "O", conformance: "O", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.5",
            details: "This command is used to go back to the previous media playback item." +
                "\n" +
                "Upon receipt, this shall cause the handler to be invoked for \"Previous\". User experience is " +
                "context-specific. This will often Go back to the previous media playback item."
        }),

        Command({
            name: "Next", id: 0x5, access: "O", conformance: "O", direction: "request",
            response: "PlaybackResponse", xref: "cluster§6.10.7.6",
            details: "This command is used to go to the next media playback item." +
                "\n" +
                "Upon receipt, this shall cause the handler to be invoked for \"Next\". User experience is " +
                "context-specific. This will often Go forward to the next media playback item."
        }),

        Command(
            {
                name: "Rewind", id: 0x6, access: "O", conformance: "VS", direction: "request",
                response: "PlaybackResponse", xref: "cluster§6.10.7.7",

                details: "This command is used to rewind the media." +
                    "\n" +
                    "Upon receipt, this shall start playback of the media backward in case the media is currently playing " +
                    "in the forward direction or is not playing. If the playback is already happening in the backwards " +
                    "direction receipt of this command shall increase the speed of the media playback backwards." +
                    "\n" +
                    "Different \"rewind\" speeds may be reflected on the media playback device based upon the number of " +
                    "sequential calls to this function and the capability of the device. This is to avoid needing to " +
                    "define every speed (multiple fast, slow motion, etc). If the PlaybackSpeed attribute is supported it " +
                    "shall be updated to reflect the new speed of playback. If the playback speed cannot be changed for " +
                    "the media being played(for example, in live streaming content not supporting seek), the status of " +
                    "NOT_ALLOWED shall be returned. If the playback speed has reached the maximum supported speed for " +
                    "media playing backwards, the status of SPEED_OUT_OF_RANGE shall be returned."
            },

            Field({
                name: "AudioAdvanceUnmuted", id: 0x0, type: "bool", conformance: "AA", default: false,
                xref: "cluster§6.10.7.7.1",
                details: "This field shall indicate whether audio should be unmuted by the player during rewind." +
                    "\n" +
                    "A value of true does not guarantee that audio can be heard by the user since the speaker may be " +
                    "muted, turned down to a low level and/or unplugged."
            })
        ),

        Command(
            {
                name: "FastForward", id: 0x7, access: "O", conformance: "VS", direction: "request",
                response: "PlaybackResponse", xref: "cluster§6.10.7.8",

                details: "This command is used to fast forward the media." +
                    "\n" +
                    "Upon receipt, this shall start playback of the media in the forward direction in case the media is " +
                    "currently playing in the backward direction or is not playing. If the playback is already happening " +
                    "in the forward direction receipt of this command shall increase the speed of the media playback." +
                    "\n" +
                    "Different \"fast-forward\" speeds may be reflected on the media playback device based upon the number " +
                    "of sequential calls to this function and the capability of the device. This is to avoid needing to " +
                    "define every speed (multiple fast, slow motion, etc). If the PlaybackSpeed attribute is supported it " +
                    "shall be updated to reflect the new speed of playback. If the playback speed cannot be changed for " +
                    "the media being played(for example, in live streaming content not supporting seek), the status of " +
                    "NOT_ALLOWED shall be returned. If the playback speed has reached the maximum supported speed for " +
                    "media playing forward, the status of SPEED_OUT_OF_RANGE shall be returned."
            },

            Field({
                name: "AudioAdvanceUnmuted", id: 0x0, type: "bool", conformance: "AA", default: false,
                xref: "cluster§6.10.7.8.1",
                details: "This field shall indicate whether audio should be unmuted by the player during fast forward." +
                    "\n" +
                    "A value of true does not guarantee that audio can be heard by the user since the speaker may be " +
                    "muted, turned down to a low level and/or unplugged."
            })
        ),

        Command(
            {
                name: "SkipForward", id: 0x8, access: "O", conformance: "O", direction: "request",
                response: "PlaybackResponse", xref: "cluster§6.10.7.9",
                details: "This command is used to skip forward in the media." +
                    "\n" +
                    "Upon receipt, this shall Skip forward in the media by the given number of milliseconds."
            },

            Field({
                name: "DeltaPositionMilliseconds", id: 0x0, type: "uint64", conformance: "M",
                xref: "cluster§6.10.7.9.1",

                details: "This field shall indicate the duration of the time span to skip forward in the media, in " +
                    "milliseconds. In case the resulting position falls in the middle of a frame, the server shall set " +
                    "the position to the beginning of that frame and set the SampledPosition attribute on the cluster " +
                    "accordingly. If the resultant position falls beyond the furthest valid position in the media the " +
                    "client may seek forward to, the position should be set to that furthest valid position. If the " +
                    "SampledPosition attribute is supported it shall be updated on the cluster accordingly."
            })
        ),

        Command(
            {
                name: "SkipBackward", id: 0x9, access: "O", conformance: "O", direction: "request",
                response: "PlaybackResponse", xref: "cluster§6.10.7.10",
                details: "This command is used to skip backward in the media." +
                    "\n" +
                    "Upon receipt, this shall Skip backward in the media by the given number of milliseconds."
            },

            Field({
                name: "DeltaPositionMilliseconds", id: 0x0, type: "uint64", conformance: "M",
                xref: "cluster§6.10.7.10.1",

                details: "This field shall indicate the duration of the time span to skip backward in the media, in " +
                    "milliseconds. In case the resulting position falls in the middle of a frame, the server shall set " +
                    "the position to the beginning of that frame and set the SampledPosition attribute on the cluster " +
                    "accordingly. If the resultant position falls before the earliest valid position to which a client " +
                    "may seek back to, the position should be set to that earliest valid position. If the SampledPosition " +
                    "attribute is supported it shall be updated on the cluster accordingly."
            })
        ),

        Command(
            {
                name: "PlaybackResponse", id: 0xa, conformance: "M", direction: "response",
                xref: "cluster§6.10.7.12",
                details: "This command is used to indicate the status of the command that was issued by the client." +
                    "\n" +
                    "This command shall be generated in response to various Playback Commands."
            },

            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", constraint: "desc",
                xref: "cluster§6.10.7.12.1",
                details: "This field shall indicate the status of the command which resulted in this response."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", constraint: "any",
                xref: "cluster§6.10.7.12.2",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Command(
            {
                name: "Seek", id: 0xb, access: "O", conformance: "AS", direction: "request",
                response: "PlaybackResponse", xref: "cluster§6.10.7.11",
                details: "This command is used to seek to a specific position in the media." +
                    "\n" +
                    "Upon receipt, this shall change the playback position in the media to the given position."
            },

            Field({
                name: "Position", id: 0x0, type: "uint64", conformance: "M", xref: "cluster§6.10.7.11.1",

                details: "This field shall indicate the position (in milliseconds) in the media to seek to. In case the " +
                    "position falls in the middle of a frame, the server shall set the position to the beginning of that " +
                    "frame and set the SampledPosition attribute on the cluster accordingly. If the position falls before " +
                    "the earliest valid position or beyond the furthest valid position to which a client may seek back or " +
                    "forward to respectively, the status of SEEK_OUT_OF_RANGE shall be returned and no change shall be " +
                    "made to the position of the playback."
            })
        ),

        Command(
            {
                name: "ActivateAudioTrack", id: 0xc, access: "O", conformance: "AT", direction: "request",
                response: "status", xref: "cluster§6.10.7.13",

                details: "This command is used to activate a specific Audio Track for the media being played." +
                    "\n" +
                    "Upon receipt, the server shall set the active Audio Track to the one identified by the TrackID in " +
                    "the Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR " +
                    "does not correspond to the streaming media OR no media is being streamed at the time of receipt of " +
                    "this command, the server will return an error status of INVALID_ARGUMENT."
            },

            Field({
                name: "TrackId", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§6.10.7.13.1",
                details: "This field shall indicate the Audio Track to activate."
            }),

            Field({
                name: "AudioOutputIndex", id: 0x1, type: "uint8", conformance: "AT", quality: "X",
                xref: "cluster§6.10.7.13.2",
                details: "This value is the index field of the OutputInfoStruct from the OutputList attribute (from the " +
                    "AudioOutput cluster) and indicates which audio output the Audio Track should be played on. This " +
                    "field is absent for Text Tracks and only present for Audio Tracks. A value of null shall indicate " +
                    "that the server can choose the audio output(s) to play the Audio Track on."
            })
        ),

        Command(
            {
                name: "ActivateTextTrack", id: 0xd, access: "O", conformance: "TT", direction: "request",
                response: "status", xref: "cluster§6.10.7.14",

                details: "This command is used to activate a specific Text Track for the media being played." +
                    "\n" +
                    "Upon receipt, the server shall set the active Text Track to the one identified by the TrackID in the " +
                    "Track catalog for the streaming media. If the TrackID does not exist in the Track catalog, OR does " +
                    "not correspond to the streaming media OR no media is being streamed at the time of receipt of this " +
                    "command, the server shall return an error status of INVALID_ARGUMENT."
            },

            Field({
                name: "TrackId", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§6.10.7.14.1",
                details: "This field shall indicate the Text Track to activate."
            })
        ),

        Command({
            name: "DeactivateTextTrack", id: 0xe, access: "O", conformance: "TT", direction: "request",
            response: "status", xref: "cluster§6.10.7.15",
            details: "This command is used to deactivate a specific Text Track for the media being played." +
                "\n" +
                "If a Text Track is active (i.e. being displayed), upon receipt of this command, the server shall " +
                "stop displaying it."
        }),

        Datatype(
            { name: "PlaybackStateEnum", type: "enum8", xref: "cluster§6.10.5.1" },
            Field({
                name: "Playing", id: 0x0, conformance: "M",
                description: "Media is currently playing (includes FF and REW)"
            }),
            Field({ name: "Paused", id: 0x1, conformance: "M", description: "Media is currently paused" }),
            Field({ name: "NotPlaying", id: 0x2, conformance: "M", description: "Media is not currently playing" }),
            Field({
                name: "Buffering", id: 0x3, conformance: "M",
                description: "Media is not currently buffering and playback will start when buffer has been filled"
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.10.5.2" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Succeeded" }),
            Field({
                name: "InvalidStateForCommand", id: 0x1, conformance: "M",
                description: "Requested playback command is invalid in the current playback state."
            }),
            Field({
                name: "NotAllowed", id: 0x2, conformance: "M",
                description: "Requested playback command is not allowed in the current playback state. For example, attempting to fast-forward during a commercial might return NotAllowed."
            }),
            Field({ name: "NotActive", id: 0x3, conformance: "M", description: "This endpoint is not active for playback." }),
            Field({
                name: "SpeedOutOfRange", id: 0x4, conformance: "VS",
                description: "The FastForward or Rewind Command was issued but the media is already playing back at the fastest speed supported by the server in the respective direction."
            }),
            Field({
                name: "SeekOutOfRange", id: 0x5, conformance: "AS",
                description: "The Seek Command was issued with a value of position outside of the allowed seek range of the media."
            })
        ),

        Datatype(
            { name: "CharacteristicEnum", type: "enum8", xref: "cluster§6.10.5.3" },
            Field({
                name: "ForcedSubtitles", id: 0x0, conformance: "M",
                description: "Textual information meant for display when no other text representation is selected. It is used to clarify dialogue, alternate languages, texted graphics or location/person IDs that are not otherwise covered in the dubbed/localized audio."
            }),
            Field({
                name: "DescribesVideo", id: 0x1, conformance: "M",
                description: "Textual or audio media component containing a textual description (intended for audio synthesis) or an audio description describing a visual component"
            }),
            Field({
                name: "EasyToRead", id: 0x2, conformance: "M",
                description: "Simplified or reduced captions as specified in [United States Code Title 47 CFR 79.103(c)(9)]."
            }),
            Field({
                name: "FrameBased", id: 0x3, conformance: "M",
                description: "A media characteristic that indicates that a track selection option includes frame-based content."
            }),
            Field({
                name: "MainProgram", id: 0x4, conformance: "M",
                description: "Main media component(s) which is/are intended for presentation if no other information is provided"
            }),
            Field({
                name: "OriginalContent", id: 0x5, conformance: "M",
                description: "A media characteristic that indicates that a track or media selection option contains original content."
            }),
            Field({
                name: "VoiceOverTranslation", id: 0x6, conformance: "M",
                description: "A media characteristic that indicates that a track or media selection option contains a language translation and verbal interpretation of spoken dialog."
            }),
            Field({
                name: "Caption", id: 0x7, conformance: "M",
                description: "Textual media component containing transcriptions of spoken dialog and auditory cues such as sound effects and music for the hearing impaired."
            }),
            Field({ name: "Subtitle", id: 0x8, conformance: "M", description: "Textual transcriptions of spoken dialog." }),
            Field({
                name: "Alternate", id: 0x9, conformance: "M",
                description: "Textual media component containing transcriptions of spoken dialog and auditory cues such as sound effects and music for the hearing impaired."
            }),
            Field({
                name: "Supplementary", id: 0xa, conformance: "M",
                description: "Media content component that is supplementary to a media content component of a different media component type."
            }),
            Field({
                name: "Commentary", id: 0xb, conformance: "M",
                description: "Experience that contains a commentary (e.g. director’s commentary) (typically audio)"
            }),
            Field({
                name: "DubbedTranslation", id: 0xc, conformance: "M",
                description: "Experience that contains an element that is presented in a different language from the original (e.g. dubbed audio, translated captions)"
            }),
            Field({
                name: "Description", id: 0xd, conformance: "M",
                description: "Textual or audio media component containing a textual description (intended for audio synthesis) or an audio description describing a visual component"
            }),
            Field({
                name: "Metadata", id: 0xe, conformance: "M",
                description: "Media component containing information intended to be processed by application specific elements."
            }),
            Field({
                name: "EnhancedAudioIntelligibility", id: 0xf, conformance: "M",
                description: "Experience containing an element for improved intelligibility of the dialogue."
            }),
            Field({
                name: "Emergency", id: 0x10, conformance: "M",
                description: "Experience that provides information, about a current emergency, that is intended to enable the protection of life, health, safety, and property, and may also include critical details regarding the emergency and how to respond to the emergency."
            }),
            Field({
                name: "Karaoke", id: 0x11, conformance: "M",
                description: "Textual representation of a songs’ lyrics, usually in the same language as the associated song as specified in [SMPTE ST 2067-2]."
            })
        ),

        Datatype(
            {
                name: "PlaybackPositionStruct", type: "struct", xref: "cluster§6.10.5.4",
                details: "This structure defines a playback position within a media stream being played."
            },
            Field({
                name: "UpdatedAt", id: 0x0, type: "epoch-us", conformance: "M", xref: "cluster§6.10.5.4.1",
                details: "This field shall indicate the time when the position was last updated."
            }),

            Field({
                name: "Position", id: 0x1, type: "uint64", conformance: "M", quality: "X",
                xref: "cluster§6.10.5.4.2",

                details: "This field shall indicate the associated discrete position within the media stream, in milliseconds " +
                    "from the beginning of the stream, being associated with the time indicated by the UpdatedAt field. " +
                    "The Position shall NOT be greater than the duration of the media if duration is specified. The " +
                    "Position shall NOT be greater than the time difference between current time and start time of the " +
                    "media when start time is specified." +
                    "\n" +
                    "A value of null shall indicate that playback position is not applicable for the current state of the " +
                    "media playback (For example : Live media with no known duration and where seek is not supported)."
            })
        ),

        Datatype(
            {
                name: "TrackStruct", type: "struct", xref: "cluster§6.10.5.5",
                details: "This structure defines a uniquely identifiable Text Track or Audio Track."
            },

            Field({
                name: "Id", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§6.10.5.5.1",
                details: "This field shall indicate the Identifier for the Track which is unique within the Track catalog. The " +
                    "Track catalog contains all the Text/Audio tracks corresponding to the main media content."
            }),

            Field({
                name: "TrackAttributes", id: 0x1, type: "TrackAttributesStruct", conformance: "M",
                xref: "cluster§6.10.5.5.2",
                details: "This field shall indicate the Attributes associated to the Track, like languageCode."
            })
        ),

        Datatype(
            {
                name: "TrackAttributesStruct", type: "struct", xref: "cluster§6.10.5.6",
                details: "This structure includes the attributes associated with a Text/Audio Track"
            },

            Field({
                name: "LanguageCode", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "cluster§6.10.5.6.1",
                details: "The value is a String containing one of the standard Tags for Identifying Languages RFC 5646, which " +
                    "identifies the primary language used in the Track."
            }),

            Field(
                {
                    name: "Characteristics", id: 0x1, type: "list", conformance: "O", default: null, quality: "X",
                    xref: "cluster§6.10.5.6.2",
                    details: "This is a list of enumerated CharacteristicEnum values that indicate a purpose, trait or feature " +
                        "associated with the Track. A value of null shall indicate that there are no Characteristics " +
                        "corresponding to the Track."
                },

                Field({ name: "entry", type: "CharacteristicEnum" })
            ),

            Field({
                name: "DisplayName", id: 0x2, type: "string", conformance: "O", constraint: "max 256",
                default: null, quality: "X", xref: "cluster§6.10.5.6.3",
                details: "The value is a String containing a user displayable name for the Track. A value of null shall " +
                    "indicate that there is no DisplayName corresponding to the Track."
            })
        )
    ),

    Cluster(
        {
            name: "TargetNavigator", id: 0x505, classification: "application", pics: "TGTNAV",
            xref: "cluster§6.11",

            details: "This cluster provides an interface for UX navigation within a set of targets on a device or " +
                "endpoint." +
                "\n" +
                "This cluster would be supported on Video Player devices or devices with navigable user interfaces. " +
                "This cluster would also be supported on endpoints with navigable user interfaces such as a Content " +
                "App. It supports listing a set of navigation targets, tracking and changing the current target." +
                "\n" +
                "The cluster server for Target Navigator is implemented by endpoints on a device that support UX " +
                "navigation." +
                "\n" +
                "When this cluster is implemented for a Content App endpoint, the Video Player device containing the " +
                "endpoint shall launch the Content App when a client invokes the NavigateTarget command."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            {
                name: "TargetList", id: 0x0, type: "list", access: "R V", conformance: "M",
                xref: "cluster§6.11.5.1",
                details: "Indicates a list of targets that can be navigated to within the experience presented to the user by " +
                    "the Endpoint (Video Player or Content App). The list shall NOT contain any entries with the same " +
                    "Identifier in the TargetInfoStruct object."
            },

            Field({ name: "entry", type: "TargetInfoStruct" })
        ),

        Attribute({
            name: "CurrentTarget", id: 0x1, type: "uint8", access: "R V", conformance: "O", constraint: "desc",
            default: 255, xref: "cluster§6.11.5.2",
            details: "Indicates the Identifier for the target which is currently in foreground on the corresponding " +
                "Endpoint (Video Player or Content App), or 0xFF to indicate that no target is in the foreground." +
                "\n" +
                "When not 0xFF, the CurrentTarget shall be an Identifier value contained within one of the " +
                "TargetInfoStruct objects in the TargetList attribute."
        }),

        Event(
            {
                name: "TargetUpdated", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "cluster§6.11.7.1",
                details: "This event shall be generated when there is a change in either the active target or the list of " +
                    "available targets or both."
            },

            Field(
                { name: "TargetList", id: 0x0, type: "list", conformance: "O" },
                Field({ name: "entry", type: "TargetInfoStruct" })
            ),
            Field({ name: "CurrentTarget", id: 0x1, type: "uint8", conformance: "O", constraint: "desc", default: 255 }),
            Field({ name: "Data", id: 0x2, type: "octstr", conformance: "O", constraint: "max 900" })
        ),

        Command(
            {
                name: "NavigateTarget", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "NavigateTargetResponse", xref: "cluster§6.11.6.1",
                details: "Upon receipt, this shall navigation the UX to the target identified."
            },
            Field({
                name: "Target", id: 0x0, type: "uint8", conformance: "M", xref: "cluster§6.11.6.1.1",
                details: "This field shall indicate the Identifier for the target for UX navigation. The Target shall be an " +
                    "Identifier value contained within one of the TargetInfoStruct objects in the TargetList attribute."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", xref: "cluster§6.11.6.1.2",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Command(
            {
                name: "NavigateTargetResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "cluster§6.11.6.2",
                details: "This command shall be generated in response to NavigateTarget command."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "cluster§6.11.6.2.1",
                details: "This field shall indicate the of the command."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", constraint: "any",
                xref: "cluster§6.11.6.2.2",
                details: "This field shall indicate Optional app-specific data."
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.11.4.1" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Command succeeded" }),
            Field({
                name: "TargetNotFound", id: 0x1, conformance: "M",
                description: "Requested target was not found in the TargetList"
            }),
            Field({
                name: "NotAllowed", id: 0x2, conformance: "M",
                description: "Target request is not allowed in current state."
            })
        ),

        Datatype(
            {
                name: "TargetInfoStruct", type: "struct", xref: "cluster§6.11.4.2",
                details: "This indicates an object describing the navigable target."
            },
            Field({
                name: "Identifier", id: 0x0, type: "uint8", conformance: "M", constraint: "max 254",
                xref: "cluster§6.11.4.2.1",
                details: "This field shall contain an unique id within the TargetList."
            }),
            Field({
                name: "Name", id: 0x1, type: "string", conformance: "M", xref: "cluster§6.11.4.2.2",
                details: "This field shall contain a name string for the TargetInfoStruct."
            })
        )
    ),

    Cluster(
        {
            name: "ContentAppObserver", id: 0x510, classification: "application", pics: "APPOBSERVER",
            xref: "cluster§6.12",

            details: "This cluster provides an interface for sending targeted commands to an Observer of a Content App on " +
                "a Video Player device such as a Streaming Media Player, Smart TV or Smart Screen." +
                "\n" +
                "The cluster server for Content App Observer is implemented by an endpoint that communicates with a " +
                "Content App, such as a Casting Video Client." +
                "\n" +
                "The cluster client for Content App Observer is implemented by a Content App endpoint." +
                "\n" +
                "A Content App is informed of the NodeId of an Observer when a binding is set on the Content App. For " +
                "a Content App Platform, the binding is set by the platform when a CastingVideoClient is granted " +
                "access to the Content App, and the CastingVideoClient supports the Content App Observer cluster. The " +
                "Content App can then send the ContentAppMessage to the Observer (server cluster), and the Observer " +
                "responds with a ContentAppMessageResponse." +
                "\n" +
                "The Data and EncodingHint fields of the ContentAppMessage and ContentAppMessageResponse contain " +
                "content app-specific values, the format and interpretation of which is defined by the Content App " +
                "vendor, analogous to the custom message features offered by other popular casting protocols. " +
                "Standardized cluster and commands are used here rather than manufacturer-specific cluster and " +
                "commands because of the role that the Content App Platform plays in creating the ACLs and Bindings " +
                "on both sides of the communication between the Content App Observer endpoint and the Content App " +
                "endpoint." +
                "\n" +
                "By using standard cluster and commands:" +
                "\n" +
                "  1. The Content App Platform is able to easily determine that a binding is needed on the Content " +
                "     App endpoint because it can recognize the Content App Observer cluster implemented by a client " +
                "     node." +
                "\n" +
                "  2. The Content App Platform is able to easily identify commands that are allowed to be sent by the " +
                "     Content App to a client node because those commands use the Content App Observer cluster." +
                "\n" +
                "  3. The Content App is able to easily determine that a node supports the Content App Observer " +
                "     cluster because it has received a binding which specifies the Content App Observer cluster." +
                "\n" +
                "  4. The Casting Video Client is able to support a single cluster for receiving commands from any " +
                "     Content App and does not need to explicitly list every Content App it understands." +
                "\n" +
                "A Content App Observer SHOULD ignore the Data and EncodingHint field values in commands from a " +
                "Content App it does not recognize. A Content App SHOULD ignore the Data field values in responses " +
                "when the EncodingHint value is blank or not recognized."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Command(
            {
                name: "ContentAppMessage", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "ContentAppMessageResponse", xref: "cluster§6.12.5.1",
                details: "Upon receipt, the data field may be parsed and interpreted. Message encoding is specific to the " +
                    "Content App. A Content App may when possible read attributes from the Basic Information Cluster on " +
                    "the Observer and use this to determine the Message encoding." +
                    "\n" +
                    "This command returns a ContentAppMessage Response."
            },

            Field({
                name: "Data", id: 0x0, type: "string", conformance: "M", constraint: "max 500",
                xref: "cluster§6.12.5.1.1",
                details: "This field shall indicate content app-specific data."
            }),
            Field({
                name: "EncodingHint", id: 0x1, type: "string", conformance: "O", constraint: "max 100",
                xref: "cluster§6.12.5.1.2",
                details: "This optional field shall indicate a content app-specific hint to the encoding of the data."
            })
        ),

        Command(
            {
                name: "ContentAppMessageResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "cluster§6.12.5.2",
                details: "This command shall be generated in response to ContentAppMessage command."
            },
            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "cluster§6.12.5.2.1",
                details: "This field shall indicate the status of the command which resulted in this response."
            }),
            Field({
                name: "Data", id: 0x1, type: "string", conformance: "O", constraint: "max 500",
                xref: "cluster§6.12.5.2.2",
                details: "This optional field shall indicate content app-specific data."
            }),
            Field({
                name: "EncodingHint", id: 0x2, type: "string", conformance: "O", constraint: "max 100",
                xref: "cluster§6.12.5.2.3",
                details: "This optional field shall indicate a content app-specific hint to the encoding of the data."
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "cluster§6.12.4.1" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "Command succeeded" }),
            Field({
                name: "UnexpectedData", id: 0x1, conformance: "M",
                description: "Data field in command was not understood by the Observer"
            })
        )
    ),

    Cluster(
        {
            name: "ContentControl", id: 0x50f, classification: "application", pics: "CONCON",
            xref: "cluster§6.13",

            details: "This cluster is used for managing the content control (including \"parental control\") settings on a " +
                "media device such as a TV, or Set-top Box." +
                "\n" +
                "This cluster allows to configure content control settings by clients with the Management privilege. " +
                "It is responsibility of the end product to enforce appropriate right access (for example, to prevent " +
                "a child from disabling this feature)." +
                "\n" +
                "NOTE Support for Content Control cluster is provisional."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§6.13.4" },
            Field({ name: "ST", constraint: "0", title: "ScreenTime", details: "Supports managing screen time limits." }),
            Field({
                name: "PM", constraint: "1", title: "PinManagement",
                details: "Supports managing a PIN code which is used for restricting access to configuration of this feature."
            }),
            Field({
                name: "BU", constraint: "2", title: "BlockUnrated",
                details: "Supports managing content controls for unrated content."
            }),
            Field({
                name: "OCR", constraint: "3", title: "OnDemandContentRating",
                details: "Supports managing content controls based upon rating threshold for on demand content."
            }),
            Field({
                name: "SCR", constraint: "4", title: "ScheduledContentRating",
                details: "Supports managing content controls based upon rating threshold for scheduled content."
            }),
            Field({
                name: "BC", constraint: "5", title: "BlockChannels",
                details: "Supports managing a set of channels that are prohibited."
            }),
            Field({
                name: "BA", constraint: "6", title: "BlockApplications",
                details: "Supports managing a set of applications that are prohibited."
            }),
            Field({
                name: "BTW", constraint: "7", title: "BlockContentTimeWindow",
                details: "Supports managing content controls based upon setting time window in which all contents and " +
                    "applications SHALL be blocked."
            })
        ),

        Attribute({
            name: "Enabled", id: 0x0, type: "bool", access: "R V", conformance: "M", xref: "cluster§6.13.7.1",
            details: "Indicates whether the Content Control feature implemented on a media device is turned off (FALSE) or " +
                "turned on (TRUE)."
        }),

        Attribute(
            {
                name: "OnDemandRatings", id: 0x1, type: "list", access: "R V", conformance: "OCR",
                xref: "cluster§6.13.7.2",

                details: "This attribute shall provide the collection of ratings that are currently valid for this media " +
                    "device. The items should honor the metadata of the on-demand content (e.g. Movie) rating system for " +
                    "one country or region where the media device has been provisioned. For example, for the MPAA system, " +
                    "RatingName may be one value out of \"G\", \"PG\", \"PG-13\", \"R\", \"NC-17\"." +
                    "\n" +
                    "The media device shall have a way to determine which rating system applies for the on-demand content " +
                    "and then populate this attribute. For example, it can do it through examining the Location attribute " +
                    "in the Basic Information cluster, and then determining which rating system applies." +
                    "\n" +
                    "The ratings in this collection shall be in order from a rating for the youngest viewers to the one " +
                    "for the oldest viewers. Each rating in the list shall be unique."
            },

            Field({ name: "entry", type: "RatingNameStruct" })
        ),

        Attribute({
            name: "OnDemandRatingThreshold", id: 0x2, type: "string", access: "R V", conformance: "OCR",
            constraint: "max 8", xref: "cluster§6.13.7.3",

            details: "Indicates a threshold rating as a content filter which is compared with the rating for on-demand " +
                "content. For example, if the on-demand content rating is greater than or equal to " +
                "OnDemandRatingThreshold, for a rating system that is ordered from lower viewer age to higher viewer " +
                "age, then on-demand content is not appropriate for the User and the Node shall prevent the playback " +
                "of content." +
                "\n" +
                "This attribute shall be set to one of the values present in the OnDemandRatings attribute." +
                "\n" +
                "When this attribute changes, the device SHOULD make the user aware of any limits of this feature. " +
                "For example, if the feature does not control content within apps, then the device should make this " +
                "clear to the user when the attribute changes."
        }),

        Attribute(
            {
                name: "ScheduledContentRatings", id: 0x3, type: "list", access: "R V", conformance: "SCR",
                xref: "cluster§6.13.7.4",

                details: "Indicates a collection of ratings which ScheduledContentRatingThreshold can be set to. The items " +
                    "should honor metadata of the scheduled content rating system for the country or region where the " +
                    "media device has been provisioned." +
                    "\n" +
                    "The media device shall have a way to determine which scheduled content rating system applies and " +
                    "then populate this attribute. For example, this can be done by examining the Location attribute in " +
                    "Basic Information cluster, and then determining which rating system applies." +
                    "\n" +
                    "The ratings in this collection shall be in order from a rating for the youngest viewers to the one " +
                    "for the oldest viewers. Each rating in the list shall be unique."
            },

            Field({ name: "entry", type: "RatingNameStruct" })
        ),

        Attribute({
            name: "ScheduledContentRatingThreshold", id: 0x4, type: "string", access: "R V", conformance: "SCR",
            constraint: "max 8", xref: "cluster§6.13.7.5",

            details: "Indicates a threshold rating as a content filter which is used to compare with the rating for " +
                "scheduled content. For example, if the scheduled content rating is greater than or equal to " +
                "ScheduledContentRatingThreshold for a rating system that is ordered from lower viewer age to higher " +
                "viewer age, then the scheduled content is not appropriate for the User and shall be blocked." +
                "\n" +
                "This attribute shall be set to one of the values present in the ScheduledContentRatings attribute." +
                "\n" +
                "When this attribute changes, the device SHOULD make the user aware of any limits of this feature. " +
                "For example, if the feature does not control content within apps, then the device should make this " +
                "clear to the user when the attribute changes."
        }),

        Attribute({
            name: "ScreenDailyTime", id: 0x5, type: "elapsed-s", access: "R V", conformance: "ST",
            constraint: "max 86400", xref: "cluster§6.13.7.6",
            details: "Indicates the amount of time (in seconds) which the User is allowed to spend watching TV within one " +
                "day when the Content Control feature is activated."
        }),

        Attribute({
            name: "RemainingScreenTime", id: 0x6, type: "elapsed-s", access: "R V", conformance: "ST",
            constraint: "max 86400", xref: "cluster§6.13.7.7",

            details: "Indicates the remaining screen time (in seconds) which the User is allowed to spend watching TV for " +
                "the current day when the Content Control feature is activated. When this value equals 0, the media " +
                "device shall terminate the playback of content." +
                "\n" +
                "This attribute shall be updated when the AddBonusTime command is received and processed successfully " +
                "(with the correct PIN)."
        }),

        Attribute({
            name: "BlockUnrated", id: 0x7, type: "bool", access: "R V", conformance: "BU",
            xref: "cluster§6.13.7.8",

            details: "Indicates whether the playback of unrated content is allowed when the Content Control feature is " +
                "activated. If this attribute equals FALSE, then playback of unrated content shall be permitted. " +
                "Otherwise, the media device shall prevent the playback of unrated content." +
                "\n" +
                "When this attribute changes, the device SHOULD make the user aware of any limits of this feature. " +
                "For example, if the feature does not control content within apps, then the device should make this " +
                "clear to the user when the attribute changes."
        }),

        Attribute(
            {
                name: "BlockChannelList", id: 0x8, type: "list", access: "R V", conformance: "BC",
                xref: "cluster§6.13.7.9",
                details: "Indicates a set of channels that shall be blocked when the Content Control feature is activated."
            },
            Field({ name: "entry", type: "BlockChannelStruct" })
        ),

        Attribute(
            {
                name: "BlockApplicationList", id: 0x9, type: "list", access: "R V", conformance: "BA",
                xref: "cluster§6.13.7.10",
                details: "Indicates a set of applications that shall be blocked when the Content Control feature is activated."
            },
            Field({ name: "entry", type: "AppInfoStruct" })
        ),

        Attribute(
            {
                name: "BlockContentTimeWindow", id: 0xa, type: "list", access: "R V", conformance: "BTW",
                constraint: "max 7", xref: "cluster§6.13.7.11",

                details: "Indicates a set of periods during which the playback of content on media device shall be blocked " +
                    "when the Content Control feature is activated. The media device shall reject any request to play " +
                    "content during one period of this attribute. If it is entering any one period of this attribute, the " +
                    "media device shall block content which is playing and generate an event " +
                    "EnteringBlockContentTimeWindow. There shall NOT be multiple entries in this attribute list for the " +
                    "same day of week."
            },

            Field({ name: "entry", type: "TimeWindowStruct" })
        ),

        Event({
            name: "RemainingScreenTimeExpired", id: 0x0, access: "V", conformance: "ST", priority: "info",
            xref: "cluster§6.13.9.1",
            details: "This event shall be generated when the RemainingScreenTime equals 0."
        }),

        Event({
            name: "EnteringBlockContentTimeWindow", id: 0x1, access: "V", conformance: "BTW", priority: "info",
            xref: "cluster§6.13.9.2",
            details: "This event shall be generated when entering a period of blocked content as configured in the " +
                "BlockContentTimeWindow attribute."
        }),

        Command(
            {
                name: "UpdatePin", id: 0x0, access: "M T", conformance: "PM", direction: "request",
                response: "status", xref: "cluster§6.13.8.1",

                details: "The purpose of this command is to update the PIN used for protecting configuration of the content " +
                    "control settings. Upon success, the old PIN shall no longer work." +
                    "\n" +
                    "The PIN is used to ensure that only the Node (or User) with the PIN code can make changes to the " +
                    "Content Control settings, for example, turn off Content Controls or modify the ScreenDailyTime. The " +
                    "PIN is composed of a numeric string of up to 6 human readable characters (displayable) ." +
                    "\n" +
                    "Upon receipt of this command, the media device shall check if the OldPIN field of this command is " +
                    "the same as the current PIN. If the PINs are the same, then the PIN code shall be set to NewPIN. " +
                    "Otherwise a response with InvalidPINCode error status shall be returned." +
                    "\n" +
                    "The media device may provide a default PIN to the User via an out of band mechanism. For security " +
                    "reasons, it is recommended that a client encourage the user to update the PIN from its default value " +
                    "when performing configuration of the Content Control settings exposed by this cluster. The ResetPIN " +
                    "command can also be used to obtain the default PIN."
            },

            Field({
                name: "OldPin", id: 0x0, type: "string", conformance: "M", constraint: "max 6",
                xref: "cluster§6.13.8.1.1",
                details: "This field shall specify the original PIN. Once the UpdatePIN command is performed successfully, it " +
                    "shall be invalid."
            }),

            Field({
                name: "NewPin", id: 0x1, type: "string", conformance: "M", constraint: "max 6",
                xref: "cluster§6.13.8.1.2",
                details: "This field shall indicate a new PIN for the Content Control feature."
            })
        ),

        Command({
            name: "ResetPin", id: 0x1, access: "A T", conformance: "PM", direction: "request",
            response: "ResetPinResponse", xref: "cluster§6.13.8.2",
            details: "The purpose of this command is to reset the PIN." +
                "\n" +
                "If this command is executed successfully, a ResetPINResponse command with a new PIN shall be " +
                "returned."
        }),

        Command(
            {
                name: "ResetPinResponse", id: 0x2, conformance: "PM", direction: "response",
                xref: "cluster§6.13.8.3",
                details: "This command shall be generated in response to a ResetPIN command."
            },
            Field({
                name: "PinCode", id: 0x0, type: "string", conformance: "M", constraint: "max 6",
                xref: "cluster§6.13.8.3.1",
                details: "This field shall indicate a new PIN of the Content Control feature."
            })
        ),

        Command({
            name: "Enable", id: 0x3, access: "M T", conformance: "M", direction: "request", response: "status",
            xref: "cluster§6.13.8.4",
            details: "The purpose of this command is to turn on the Content Control feature on a media device." +
                "\n" +
                "Upon receipt of the Enable command, the media device shall set the Enabled attribute to TRUE."
        }),

        Command({
            name: "Disable", id: 0x4, access: "M T", conformance: "M", direction: "request", response: "status",
            xref: "cluster§6.13.8.5",
            details: "The purpose of this command is to turn off the Content Control feature on a media device." +
                "\n" +
                "On receipt of the Disable command, the media device shall set the Enabled attribute to FALSE."
        }),

        Command(
            {
                name: "AddBonusTime", id: 0x5, access: "O", conformance: "ST", direction: "request",
                response: "status", xref: "cluster§6.13.8.6",

                details: "The purpose of this command is to add the extra screen time for the user." +
                    "\n" +
                    "If a client with Operate privilege invokes this command, the media device shall check whether the " +
                    "PINCode passed in the command matches the current PINCode value. If these match, then the " +
                    "RemainingScreenTime attribute shall be increased by the specified BonusTime value." +
                    "\n" +
                    "If the PINs do not match, then a response with InvalidPINCode error status shall be returned, and no " +
                    "changes shall be made to RemainingScreenTime." +
                    "\n" +
                    "If a client with Manage privilege or greater invokes this command, the media device shall ignore the " +
                    "PINCode field and directly increase the RemainingScreenTime attribute by the specified BonusTime " +
                    "value." +
                    "\n" +
                    "A server that does not support the PM feature shall respond with InvalidPINCode to clients that only " +
                    "have Operate privilege unless:" +
                    "\n" +
                    "  • It has been provided with the PIN value to expect via an out of band mechanism, and" +
                    "\n" +
                    "  • The client has provided a PINCode that matches the expected PIN value."
            },

            Field({
                name: "PinCode", id: 0x0, type: "string", conformance: "O", constraint: "max 6",
                xref: "cluster§6.13.8.6.1",

                details: "This field shall indicate the PIN." +
                    "\n" +
                    "This field shall be optional for clients with Manage or greater privilege but shall be mandatory for " +
                    "clients with Operate privilege. The PIN provided in this field shall be used to guarantee that a " +
                    "client with Operate permission is allowed to invoke this command only if the PIN passed in this " +
                    "command is equal to the current PIN value."
            }),

            Field({
                name: "BonusTime", id: 0x1, type: "elapsed-s", conformance: "M", constraint: "desc", default: 300,
                xref: "cluster§6.13.8.6.2",
                details: "This field shall indicate the amount of extra time (in seconds) to increase RemainingScreenTime. " +
                    "This field shall NOT exceed the remaining time of this day."
            })
        ),

        Command(
            {
                name: "SetScreenDailyTime", id: 0x6, access: "M", conformance: "ST", direction: "request",
                response: "status", xref: "cluster§6.13.8.7",
                details: "The purpose of this command is to set the ScreenDailyTime attribute." +
                    "\n" +
                    "Upon receipt of the SetScreenDailyTime command, the media device shall set the ScreenDailyTime " +
                    "attribute to the ScreenTime value."
            },

            Field({
                name: "ScreenTime", id: 0x0, type: "elapsed-s", conformance: "M", constraint: "max 86400",
                xref: "cluster§6.13.8.7.1",
                details: "This field shall indicate the time (in seconds) which the User is allowed to spend watching TV on " +
                    "this media device within one day."
            })
        ),

        Command({
            name: "BlockUnratedContent", id: 0x7, access: "M", conformance: "BU", direction: "request",
            response: "status", xref: "cluster§6.13.8.8",
            details: "The purpose of this command is to specify whether programs with no Content rating must be blocked by " +
                "this media device." +
                "\n" +
                "Upon receipt of the BlockUnratedContent command, the media device shall set the BlockUnrated " +
                "attribute to TRUE."
        }),

        Command({
            name: "UnblockUnratedContent", id: 0x8, access: "M", conformance: "BU", direction: "request",
            response: "status", xref: "cluster§6.13.8.9",
            details: "The purpose of this command is to specify whether programs with no Content rating must be blocked by " +
                "this media device." +
                "\n" +
                "Upon receipt of the UnblockUnratedContent command, the media device shall set the BlockUn rated " +
                "attribute to FALSE."
        }),

        Command(
            {
                name: "SetOnDemandRatingThreshold", id: 0x9, access: "M", conformance: "OCR", direction: "request",
                response: "status", xref: "cluster§6.13.8.10",
                details: "The purpose of this command is to set the OnDemandRatingThreshold attribute." +
                    "\n" +
                    "Upon receipt of the SetOnDemandRatingThreshold command, the media device shall check if the Rating " +
                    "field is one of values present in the OnDemandRatings attribute. If not, then a response with " +
                    "InvalidRating error status shall be returned."
            },

            Field({
                name: "Rating", id: 0x0, type: "string", conformance: "M", constraint: "max 8",
                xref: "cluster§6.13.8.10.1",
                details: "This field indicates a threshold rating for filtering on-demand content. This field shall be set to " +
                    "one of the values present in the OnDemandRatings attribute"
            })
        ),

        Command(
            {
                name: "SetScheduledContentRatingThreshold", id: 0xa, access: "M", conformance: "SCR",
                direction: "request", response: "status", xref: "cluster§6.13.8.11",
                details: "The purpose of this command is to set ScheduledContentRatingThreshold attribute." +
                    "\n" +
                    "Upon receipt of the SetScheduledContentRatingThreshold command, the media device shall check if the " +
                    "Rating field is one of values present in the ScheduledContentRatings attribute. If not, then a " +
                    "response with InvalidRating error status shall be returned."
            },

            Field({
                name: "Rating", id: 0x0, type: "string", conformance: "M", constraint: "max 8",
                xref: "cluster§6.13.8.11.1",
                details: "This field indicates a threshold rating for filtering scheduled content. This field shall be set to " +
                    "one of the values present in the ScheduledContentRatings attribute."
            })
        ),

        Command(
            {
                name: "AddBlockChannels", id: 0xb, access: "M", conformance: "BC", direction: "request",
                response: "status", xref: "cluster§6.13.8.12",

                details: "The purpose of this command is to set BlockChannelList attribute." +
                    "\n" +
                    "Upon receipt of the AddBlockChannels command, the media device shall check if the channels passed in " +
                    "this command are valid. If the channel is invalid, then a response with InvalidChannel error Status " +
                    "shall be returned." +
                    "\n" +
                    "If there is at least one channel in Channels field which is not in the BlockChannelList attribute, " +
                    "the media device shall process the request by adding these new channels into the BlockChannelList " +
                    "attribute and return a successful Status Response. During this process, the media device shall " +
                    "assign one unique index to BlockChannelIndex field for every channel passed in this command." +
                    "\n" +
                    "If all channels in Channel field already exist in the BlockChannelList attribute, then a response " +
                    "with ChannelAlreadyExist error Status shall be returned."
            },

            Field(
                {
                    name: "Channels", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.13.8.12.1",
                    details: "This field indicates a set of channels that shall be blocked when the Content Control feature is " +
                        "activated. This field shall be set to values present in ChannelList attribute in the Channel " +
                        "cluster. The BlockChannelIndex field passed in this command shall be NULL."
                },

                Field({ name: "entry", type: "BlockChannelStruct" })
            )
        ),

        Command(
            {
                name: "RemoveBlockChannels", id: 0xc, access: "M", conformance: "BC", direction: "request",
                response: "status", xref: "cluster§6.13.8.13",

                details: "The purpose of this command is to remove channels from the BlockChannelList attribute." +
                    "\n" +
                    "Upon receipt of the RemoveBlockChannels command, the media device shall check if the channels " +
                    "indicated by ChannelIndexes passed in this command are present in BlockChannelList attribute. If one " +
                    "or more channels indicated by ChannelIndexes passed in this command field are not present in the " +
                    "BlockChannelList attribute, then a response with ChannelNotExist error Status shall be returned."
            },

            Field(
                {
                    name: "ChannelIndexes", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.13.8.13.1",
                    details: "This field shall specify a set of indexes indicating Which channels shall be removed from the " +
                        "BlockChannelList attribute."
                },
                Field({ name: "entry", type: "uint16" })
            )
        ),

        Command(
            {
                name: "AddBlockApplications", id: 0xd, access: "M", conformance: "BA", direction: "request",
                response: "status", xref: "cluster§6.13.8.14",

                details: "The purpose of this command is to set applications to the BlockApplicationList attribute." +
                    "\n" +
                    "Upon receipt of the AddBlockApplications command, the media device shall check if the Applications " +
                    "passed in this command are installed. If there is an application in Applications field which is not " +
                    "identified by media device, then a response with UnidentifiableApplication error Status may be " +
                    "returned." +
                    "\n" +
                    "If there is one or more applications which are not present in BlockApplicationList attribute, the " +
                    "media device shall process the request by adding the new application to the BlockApplicationList " +
                    "attribute and return a successful Status Response." +
                    "\n" +
                    "If all applications in Applications field are already present in BlockApplicationList attribute, " +
                    "then a response with ApplicationAlreadyExist error Status shall be returned."
            },

            Field(
                {
                    name: "Applications", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.13.8.14.1",
                    details: "This field indicates a set of applications that shall be blocked when the Content Control feature is " +
                        "activated."
                },
                Field({ name: "entry", type: "AppInfoStruct" })
            )
        ),

        Command(
            {
                name: "RemoveBlockApplications", id: 0xe, access: "M", conformance: "BA", direction: "request",
                response: "status", xref: "cluster§6.13.8.15",

                details: "The purpose of this command is to remove applications from the BlockApplicationList attribute." +
                    "\n" +
                    "Upon receipt of the RemoveBlockApplications command, the media device shall check if the " +
                    "applications passed in this command present in the BlockApplicationList attribute. If one or more " +
                    "applications in Applications field which are not present in the BlockApplicationList attribute, then " +
                    "a response with ApplicationNotExist error Status shall be returned."
            },

            Field(
                {
                    name: "Applications", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.13.8.15.1",
                    details: "This field indicates a set of applications which shall be removed from BlockApplicationList " +
                        "attribute."
                },
                Field({ name: "entry", type: "AppInfoStruct" })
            )
        ),

        Command(
            {
                name: "SetBlockContentTimeWindow", id: 0xf, access: "M", conformance: "BTW", direction: "request",
                response: "status", xref: "cluster§6.13.8.16",

                details: "The purpose of this command is to set the BlockContentTimeWindow attribute." +
                    "\n" +
                    "Upon receipt of the SetBlockContentTimeWindow command, the media device shall check if the " +
                    "TimeWindowIndex field passed in this command is NULL. If the TimeWindowIndex field is NULL, the " +
                    "media device shall check if there is an entry in the BlockContentTimeWindow attribute which matches " +
                    "with the TimePeriod and DayOfWeek fields passed in this command. * If Yes, then a response with " +
                    "TimeWindowAlreadyExist error status shall be returned. * If No, then the media device shall assign " +
                    "one unique index for this time window and add it into the BlockContentTimeWindow list attribute." +
                    "\n" +
                    "If the TimeWindowIndex field is not NULL and presents in the BlockContentTimeWindow attribute, the " +
                    "media device shall replace the original time window with the new time window passed in this command."
            },

            Field({
                name: "TimeWindow", id: 0x0, type: "TimeWindowStruct", conformance: "M",
                xref: "cluster§6.13.8.16.1",
                details: "This field shall indicate a time window requested to set to the BlockContentTimeWindow attribute."
            })
        ),

        Command(
            {
                name: "RemoveBlockContentTimeWindow", id: 0x10, access: "M", conformance: "BTW",
                direction: "request", response: "status", xref: "cluster§6.13.8.17",

                details: "The purpose of this command is to remove the selected time windows from the BlockContentTimeWindow " +
                    "attribute." +
                    "\n" +
                    "Upon receipt of the RemoveBlockContentTimeWindow command, the media device shall check if the time " +
                    "window index passed in this command presents in the BlockContentTimeWindow attribute." +
                    "\n" +
                    "If one or more time window indexes passed in this command are not present in BlockContentTimeWindow " +
                    "attribute, then a response with TimeWindowNotExist error status shall be returned."
            },

            Field(
                {
                    name: "TimeWindowIndexes", id: 0x0, type: "list", conformance: "M", xref: "cluster§6.13.8.17.1",
                    details: "This field shall specify a set of time window indexes indicating which time windows will be removed " +
                        "from the BlockContentTimeWindow attribute."
                },
                Field({ name: "entry", type: "uint16" })
            )
        ),

        Datatype(
            { name: "DayOfWeekBitmap", type: "map8", xref: "cluster§6.13.5.1" },
            Field({ name: "Sunday", constraint: "0", description: "Sunday" }),
            Field({ name: "Monday", constraint: "1", description: "Monday" }),
            Field({ name: "Tuesday", constraint: "2", description: "Tuesday" }),
            Field({ name: "Wednesday", constraint: "3", description: "Wednesday" }),
            Field({ name: "Thursday", constraint: "4", description: "Thursday" }),
            Field({ name: "Friday", constraint: "5", description: "Friday" }),
            Field({ name: "Saturday", constraint: "6", description: "Saturday" })
        ),

        Datatype(
            { name: "RatingNameStruct", type: "struct", xref: "cluster§6.13.5.2" },

            Field({
                name: "RatingName", id: 0x0, type: "string", conformance: "M", constraint: "max 8",
                xref: "cluster§6.13.5.2.1",
                details: "This field shall indicate the name of the rating level of the applied rating system. The applied " +
                    "rating system is dependent upon the region or country where the Node has been provisioned, and may " +
                    "vary from one country to another."
            }),

            Field({
                name: "RatingNameDesc", id: 0x1, type: "string", conformance: "O", constraint: "max 64",
                xref: "cluster§6.13.5.2.2",
                details: "This field shall specify a human readable (displayable) description for RatingName."
            })
        ),

        Datatype(
            { name: "BlockChannelStruct", type: "struct", xref: "cluster§6.13.5.3" },

            Field({
                name: "BlockChannelIndex", id: 0x0, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§6.13.5.3.1",
                details: "This field shall indicate a unique index value for a blocked channel. This value may be used to " +
                    "indicate one selected channel which will be removed from BlockChannelList attribute."
            }),

            Field({
                name: "MajorNumber", id: 0x1, type: "uint16", conformance: "M", xref: "cluster§6.13.5.3.2",
                details: "This field shall indicate the channel major number value (for example, using ATSC format). When the " +
                    "channel number is expressed as a string, such as \"13.1\" or \"256\", the major number would be 13 or " +
                    "256, respectively. This field is required but shall be set to 0 for channels such as over-the-top " +
                    "channels that are not represented by a major or minor number."
            }),

            Field({
                name: "MinorNumber", id: 0x2, type: "uint16", conformance: "M", xref: "cluster§6.13.5.3.3",
                details: "This field shall indicate the channel minor number value (for example, using ATSC format). When the " +
                    "channel number is expressed as a string, such as \"13.1\" or \"256\", the minor number would be 1 or 0, " +
                    "respectively. This field is required but shall be set to 0 for channels such as over-the-top " +
                    "channels that are not represented by a major or minor number."
            }),

            Field({
                name: "Identifier", id: 0x3, type: "string", conformance: "O", xref: "cluster§6.13.5.3.4",
                details: "This field shall indicate the unique identifier for a specific channel. This field is optional, but " +
                    "SHOULD be provided when MajorNumber and MinorNumber are not available."
            })
        ),

        Datatype(
            { name: "AppInfoStruct", type: "struct", xref: "cluster§6.13.5.4" },

            Field({
                name: "CatalogVendorId", id: 0x0, type: "uint16", conformance: "M", xref: "cluster§6.13.5.4.1",
                details: "This field shall indicate the Connectivity Standards Alliance-issued vendor ID for the catalog. The " +
                    "DIAL registry shall use value 0x0000." +
                    "\n" +
                    "Content App Platform providers will have their own catalog vendor ID (set to their own Vendor ID) " +
                    "and will assign an ApplicationID to each Content App."
            }),

            Field({
                name: "ApplicationId", id: 0x1, type: "string", conformance: "M", xref: "cluster§6.13.5.4.2",
                details: "This field shall indicate the application identifier, expressed as a string, such as \"PruneVideo\" or " +
                    "\"Company X\". This field shall be unique within a catalog."
            })
        ),

        Datatype(
            { name: "TimeWindowStruct", type: "struct", xref: "cluster§6.13.5.5" },

            Field({
                name: "TimeWindowIndex", id: 0x0, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§6.13.5.5.1",
                details: "This field shall indicate a unique index of a specific time window. This value may be used to " +
                    "indicate a selected time window which will be removed from the BlockContentTimeWindow attribute."
            }),

            Field({
                name: "DayOfWeek", id: 0x1, type: "DayOfWeekBitmap", conformance: "M", constraint: "desc",
                xref: "cluster§6.13.5.5.2",
                details: "This field shall indicate a day of week."
            }),

            Field(
                {
                    name: "TimePeriod", id: 0x2, type: "list", conformance: "M", constraint: "desc",
                    xref: "cluster§6.13.5.5.3",
                    details: "This field shall indicate one or more discrete time periods."
                },
                Field({ name: "entry", type: "TimePeriodStruct" })
            )
        ),

        Datatype(
            { name: "TimePeriodStruct", type: "struct", xref: "cluster§6.13.5.6" },
            Field({
                name: "StartHour", id: 0x0, type: "uint8", conformance: "M", constraint: "0 to 23",
                xref: "cluster§6.13.5.6.1",
                details: "This field shall indicate the starting hour."
            }),
            Field({
                name: "StartMinute", id: 0x1, type: "uint8", conformance: "M", constraint: "0 to 59",
                xref: "cluster§6.13.5.6.2",
                details: "This field shall indicate the starting minute."
            }),
            Field({
                name: "EndHour", id: 0x2, type: "uint8", conformance: "M", constraint: "0 to 23",
                xref: "cluster§6.13.5.6.3",
                details: "This field shall indicate the ending hour. EndHour shall be equal to or greater than StartHour"
            }),

            Field({
                name: "EndMinute", id: 0x3, type: "uint8", conformance: "M", constraint: "0 to 59",
                xref: "cluster§6.13.5.6.4",
                details: "This field shall indicate the ending minute. If EndHour is equal to StartHour then EndMinute shall " +
                    "be greater than StartMinute. If the EndHour is equal to 23 and the EndMinute is equal to 59, all " +
                    "contents shall be blocked until 23:59:59."
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "cluster§6.13.6.1" },
            Field({ name: "InvalidPinCode", id: 0x2, description: "Provided PIN Code does not match the current PIN code." }),
            Field({
                name: "InvalidRating", id: 0x3,
                description: "Provided Rating is out of scope of the corresponding Rating list."
            }),
            Field({ name: "InvalidChannel", id: 0x4, description: "Provided Channel(s) is invalid." }),
            Field({ name: "ChannelAlreadyExist", id: 0x5, description: "Provided Channel(s) already exists." }),
            Field({
                name: "ChannelNotExist", id: 0x6,
                description: "Provided Channel(s) doesn’t exist in BlockChannelList attribute."
            }),
            Field({ name: "UnidentifiableApplication", id: 0x7, description: "Provided Application(s) is not identified." }),
            Field({ name: "ApplicationAlreadyExist", id: 0x8, description: "Provided Application(s) already exists." }),
            Field({
                name: "ApplicationNotExist", id: 0x9,
                description: "Provided Application(s) doesn’t exist in BlockApplicationList attribute."
            }),
            Field({
                name: "TimeWindowAlreadyExist", id: 0xa,
                description: "Provided time Window already exists in BlockContentTimeWindow attribute."
            }),
            Field({
                name: "TimeWindowNotExist", id: 0xb,
                description: "Provided time window doesn’t exist in BlockContentTimeWindow attribute."
            })
        )
    ),

    Cluster(
        {
            name: "RvcRunMode", id: 0x54, type: "ModeBase", classification: "application", pics: "RVCRUNM",
            xref: "cluster§7.2",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for the running modes of robotic vacuum cleaner devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§7.2.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§7.2.6.1",

            details: "At least one entry in the SupportedModes attribute shall include the Idle mode tag in the ModeTags " +
                "field." +
                "\n" +
                "At least one entry in the SupportedModes attribute (different from the one above) shall include the " +
                "Cleaning mode tag in the ModeTags field." +
                "\n" +
                "The Mapping, Cleaning, and Idle mode tags are mutually exclusive and shall NOT be used together in a " +
                "mode’s ModeTags."
        }),

        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§7.2.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§7.2.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§7.2.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§7.2.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeChangeStatus", type: "enum8" },
            Field({ name: "Stuck", id: 0x41, xref: "cluster§7.2.7.1" }),
            Field({ name: "DustBinMissing", id: 0x42, xref: "cluster§7.2.7.1" }),
            Field({ name: "DustBinFull", id: 0x43, xref: "cluster§7.2.7.1" }),
            Field({ name: "WaterTankEmpty", id: 0x44, xref: "cluster§7.2.7.1" }),
            Field({ name: "WaterTankMissing", id: 0x45, xref: "cluster§7.2.7.1" }),
            Field({ name: "WaterTankLidOpen", id: 0x46, xref: "cluster§7.2.7.1" }),
            Field({ name: "MopCleaningPadMissing", id: 0x47, xref: "cluster§7.2.7.1" }),
            Field({ name: "BatteryLow", id: 0x48, xref: "cluster§7.2.7.1" })
        ),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§7.2.7.2" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§7.2.7.2" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§7.2.7.2" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§7.2.7.2" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§7.2.7.2" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§7.2.7.2" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§7.2.7.2" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§7.2.7.2" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§7.2.7.2" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§7.2.7.2" }),

            Field({
                name: "Idle", id: 0x4000, xref: "cluster§7.2.7.2.1",
                details: "The device is not performing any of the main operations of the other modes. However, auxiliary " +
                    "actions, such as seeking the charger or charging, may occur." +
                    "\n" +
                    "For example, the device has completed cleaning, successfully or not, on its own or due to a command, " +
                    "or has not been asked to clean after a restart."
            }),

            Field({
                name: "Cleaning", id: 0x4001, xref: "cluster§7.2.7.2.2",
                details: "The device was asked to clean so it may be actively running, or paused due to an error, due to a " +
                    "pause command, or for recharging etc. If currently paused and the device can resume it will continue " +
                    "to clean."
            }),

            Field({
                name: "Mapping", id: 0x4002, xref: "cluster§7.2.7.2.3",

                details: "The device was asked to create a map of the space it is located in, so it may be actively running, " +
                    "or paused due to an error, due to a pause command, or for recharging etc. If currently paused and " +
                    "the device can resume, it will continue to map." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> this mode is intended to be used so the current space can be mapped by the device if the robot has " +
                    "  not previously done that, or if the layout has substantially changed, for an optimal subsequent " +
                    "  cleaning experience."
            })
        )
    ),

    Cluster(
        {
            name: "RvcCleanMode", id: 0x55, type: "ModeBase", classification: "application", pics: "RVCCLEANM",
            xref: "cluster§7.3",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for the cleaning type of robotic vacuum cleaner devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 4 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§7.3.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§7.3.6.1",
            details: "At least one entry in the SupportedModes attribute shall include the Vacuum and/or the Mop mode tag " +
                "in the ModeTags field list."
        }),
        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§7.3.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§7.3.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§7.3.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§7.3.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),
        Datatype(
            { name: "ModeChangeStatus", type: "enum8" },
            Field({ name: "CleaningInProgress", id: 0x40, xref: "cluster§7.3.7.1" })
        ),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§7.3.7.2" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§7.3.7.2" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§7.3.7.2" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§7.3.7.2" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§7.3.7.2" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§7.3.7.2" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§7.3.7.2" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§7.3.7.2" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§7.3.7.2" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§7.3.7.2" }),
            Field({ name: "DeepClean", id: 0x4000, xref: "cluster§7.3.7.2" }),
            Field({
                name: "Vacuum", id: 0x4001, xref: "cluster§7.3.7.2.2",
                details: "The device’s vacuuming feature is enabled in this mode."
            }),
            Field({
                name: "Mop", id: 0x4002, xref: "cluster§7.3.7.2.3",
                details: "The device’s mopping feature is enabled in this mode."
            }),
            Field({ name: "VacuumThenMop", id: 0x4003, xref: "cluster§7.3.7.2" })
        )
    ),

    Cluster(
        {
            name: "RvcOperationalState", id: 0x61, type: "OperationalState", classification: "application",
            pics: "RVCOPSTATE", xref: "cluster§7.4",
            details: "This cluster is derived from the Operational State cluster and provides an interface for monitoring " +
                "the operational state of a robotic vacuum cleaner."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),
        Command({ name: "Pause", id: 0x0, xref: "cluster§7.4.5" }),
        Command({ name: "Stop", id: 0x1, conformance: "X", xref: "cluster§7.4.5" }),
        Command({ name: "Start", id: 0x2, conformance: "X", xref: "cluster§7.4.5" }),
        Command({ name: "Resume", id: 0x3, xref: "cluster§7.4.5" }),
        Command({ name: "OperationalCommandResponse", id: 0x4, xref: "cluster§7.4.5" }),

        Command({
            name: "GoHome", id: 0x80, access: "O", conformance: "O", direction: "request",
            response: "OperationalCommandResponse", xref: "cluster§7.4.5.1",

            details: "On receipt of this command, the device shall start seeking the charging dock, if possible in the " +
                "current state of the device." +
                "\n" +
                "If this command is received when already in the SeekingCharger state the device shall respond with " +
                "an OperationalCommandResponse command with an ErrorStateID of NoError but the command shall have no " +
                "other effect." +
                "\n" +
                "A device that receives this command in any state which does not allow seeking the charger, such as " +
                "Charging or Docked, shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "CommandInvalidInState and shall have no other effect." +
                "\n" +
                "Otherwise, on success:" +
                "\n" +
                "  • The OperationalState attribute shall be set to SeekingCharger." +
                "\n" +
                "  • The device shall respond with an OperationalCommandResponse command with an ErrorStateID of " +
                "    NoError."
        }),

        Datatype(
            {
                name: "OperationalStateEnum", type: "enum8", xref: "cluster§7.4.4.1",

                details: "The values defined herein are applicable to this derived cluster of Operational State only and are " +
                    "additional to the set of values defined in Operational State itself." +
                    "\n" +
                    "RVC Pause Compatibility defines the compatibility of the states this cluster defines with the Pause " +
                    "command." +
                    "\n" +
                    "### Table 13. RVC Pause Compatibility" +
                    "\n" +
                    "RVC Resume Compatibility defines the compatibility of the states this cluster defines with the " +
                    "Resume command." +
                    "\n" +
                    "### Table 14. RVC Resume Compatibility" +
                    "\n" +
                    "While in the Charging or Docked states, the device shall NOT attempt to resume unless it " +
                    "transitioned to those states while operating and can resume, such as, for example, if it is " +
                    "recharging while in a cleaning cycle. Else, if the operational state is Charging or Docked but " +
                    "there’s no operation to resume or the operation can’t be resumed, the device shall respond with an " +
                    "OperationalCommandResponse command with an ErrorStateID of CommandInvalidInState but take no further " +
                    "action."
            },

            Field({ name: "Stopped", id: 0x0, conformance: "M", description: "The device is stopped" }),
            Field({ name: "Running", id: 0x1, conformance: "M", description: "The device is operating" }),
            Field({ name: "Paused", id: 0x2, conformance: "M", description: "The device is paused during an operation" }),
            Field({ name: "Error", id: 0x3, conformance: "M", description: "The device is in an error state" }),
            Field({
                name: "SeekingCharger", id: 0x40, conformance: "M",
                description: "The device is en route to the charging dock"
            }),
            Field({ name: "Charging", id: 0x41, conformance: "M", description: "The device is charging" }),
            Field({ name: "Docked", id: 0x42, conformance: "M", description: "The device is on the dock, not charging" }),
            Field({
                name: "EmptyingDustBin", id: 0x43, conformance: "O",
                description: "The device is automatically emptying its own dust bin, such as to a dock"
            }),
            Field({
                name: "CleaningMop", id: 0x44, conformance: "O",
                description: "The device is automatically cleaning its own mopping device, such as on a dock"
            }),
            Field({
                name: "FillingWaterTank", id: 0x45, conformance: "O",
                description: "The device is automatically filling its own clean water tank for use when mopping, such as from a dock"
            }),
            Field({
                name: "UpdatingMaps", id: 0x46, conformance: "O",
                description: "The device is processing acquired data to update its maps"
            })
        ),

        Datatype(
            {
                name: "ErrorStateEnum", type: "enum8", xref: "cluster§7.4.4.2",
                details: "The values defined herein are applicable to this derived cluster of Operational State only and are " +
                    "additional to the set of values defined in Operational State itself."
            },
            Field({ name: "NoError", id: 0x0, conformance: "M", description: "The device is not in an error state" }),
            Field({
                name: "UnableToStartOrResume", id: 0x1, conformance: "M",
                description: "The device is unable to start or resume operation"
            }),
            Field({
                name: "UnableToCompleteOperation", id: 0x2, conformance: "M",
                description: "The device was unable to complete the current operation"
            }),
            Field({
                name: "CommandInvalidInState", id: 0x3, conformance: "M",
                description: "The device cannot process the command in its current state"
            }),
            Field({
                name: "FailedToFindChargingDock", id: 0x40, conformance: "M",
                description: "The device has failed to find or reach the charging dock"
            }),
            Field({
                name: "Stuck", id: 0x41, conformance: "M",
                description: "The device is stuck and requires manual intervention"
            }),
            Field({
                name: "DustBinMissing", id: 0x42, conformance: "M",
                description: "The device has detected that its dust bin is missing"
            }),
            Field({
                name: "DustBinFull", id: 0x43, conformance: "M",
                description: "The device has detected that its dust bin is full"
            }),
            Field({
                name: "WaterTankEmpty", id: 0x44, conformance: "M",
                description: "The device has detected that its clean water tank is empty"
            }),
            Field({
                name: "WaterTankMissing", id: 0x45, conformance: "M",
                description: "The device has detected that its clean water tank is missing"
            }),
            Field({
                name: "WaterTankLidOpen", id: 0x46, conformance: "M",
                description: "The device has detected that its water tank lid is open"
            }),
            Field({
                name: "MopCleaningPadMissing", id: 0x47, conformance: "M",
                description: "The device has detected that its cleaning pad is missing"
            }),
            Field({
                name: "LowBattery", id: 0x48, conformance: "M",
                description: "The device is unable to start or to continue operating due to a low battery"
            }),
            Field({
                name: "CannotReachTargetArea", id: 0x49, conformance: "M",
                description: "The device is unable to move to an area where it was asked to operate, such as by setting the ServiceArea cluster’s SelectedAreas attribute, due to an obstruction. For example, the obstruction might be a closed door or objects blocking the mapped path."
            }),
            Field({
                name: "DirtyWaterTankFull", id: 0x4a, conformance: "M",
                description: "The device has detected that its dirty water tank is full"
            }),
            Field({
                name: "DirtyWaterTankMissing", id: 0x4b, conformance: "M",
                description: "The device has detected that its dirty water is missing"
            }),
            Field({
                name: "WheelsJammed", id: 0x4c, conformance: "M",
                description: "The device has detected that one or more wheels are jammed by an object"
            }),
            Field({
                name: "BrushJammed", id: 0x4d, conformance: "M",
                description: "The device has detected that its brush is jammed by an object"
            }),
            Field({
                name: "NavigationSensorObscured", id: 0x4e, conformance: "M",
                description: "The device has detected that one of its sensors, such as LiDAR, infrared, or camera is obscured and needs to be cleaned"
            })
        )
    ),

    Cluster(
        {
            name: "TemperatureControl", id: 0x56, classification: "application", pics: "TCTL",
            xref: "cluster§8.2",

            details: "This cluster provides an interface to the setpoint temperature on devices such as washers, " +
                "refrigerators, and water heaters. The setpoint temperature is the temperature to which a device " +
                "using this cluster would attempt to control to. This cluster does not provide access to the actual " +
                "or physical temperature associated with any device using this cluster. Access to the physical " +
                "temperature associated with a device using this cluster would be provided by other clusters as part " +
                "of that devices device type definition." +
                "\n" +
                "The values and constraints of the attributes communicated to clients SHOULD match the controls on " +
                "any physical interface on a device implementing this server. For example, the value of the Step " +
                "attribute SHOULD match the incremental value by which the temperature setpoint can be changed on the " +
                "physical device."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.2.4" },

            Field({
                name: "TN", conformance: "O.a", constraint: "0", title: "TemperatureNumber",
                xref: "cluster§8.2.4.1",
                details: "For devices that use an actual temperature value for the temperature setpoint, such as some water " +
                    "heaters, the feature TN shall be used. Note that this cluster provides and supports temperatures in " +
                    "degrees Celsius via the temperature data type."
            }),

            Field({
                name: "TL", conformance: "O.a", constraint: "1", title: "TemperatureLevel", xref: "cluster§8.2.4.2",
                details: "For devices that use vendor-specific temperature levels for the temperature setpoint, such as some " +
                    "washers, the feature TL shall be used."
            }),

            Field({
                name: "STEP", conformance: "[TN]", constraint: "2", title: "TemperatureStep",
                xref: "cluster§8.2.4.3",
                details: "For devices that support discrete temperature setpoints that are larger than the temperature " +
                    "resolution imposed via the temperature data type, the Step feature may be used."
            })
        ),

        Attribute({
            name: "TemperatureSetpoint", id: 0x0, type: "temperature", access: "R V", conformance: "TN",
            constraint: "minTemperature to maxTemperature", xref: "cluster§8.2.5.1",
            details: "Indicates the desired Temperature Setpoint on the device."
        }),
        Attribute({
            name: "MinTemperature", id: 0x1, type: "temperature", access: "R V", conformance: "TN",
            constraint: "max maxTemperature - 1", quality: "F", xref: "cluster§8.2.5.2",
            details: "Indicates the minimum temperature to which the TemperatureSetpoint attribute may be set."
        }),

        Attribute(
            {
                name: "MaxTemperature", id: 0x2, type: "temperature", access: "R V", conformance: "TN",
                constraint: "desc", quality: "F", xref: "cluster§8.2.5.3",
                details: "Indicates the maximum temperature to which the TemperatureSetpoint attribute may be set." +
                    "\n" +
                    "If the Step attribute is supported, this attribute shall be such that MaxTemperature = " +
                    "MinTemperature + (Step * n), where n is an integer and n > 0. If the Step attribute is not " +
                    "supported, this attribute shall be such that MaxTemperature > MinTemperature."
            }
        ),

        Attribute({
            name: "Step", id: 0x3, type: "temperature", access: "R V", conformance: "STEP",
            constraint: "1 to maxTemperature - minTemperature", quality: "F", xref: "cluster§8.2.5.4",

            details: "Indicates the discrete value by which the TemperatureSetpoint attribute can be changed via the " +
                "SetTemperature command." +
                "\n" +
                "For example, if the value of MinTemperature is 25.00C (2500) and the Step value is 0.50C (50), valid " +
                "values of the TargetTemperature field of the SetTemperature command would be 25.50C" +
                "\n" +
                "(2550), 26.00C (2600), 26.50C (2650), etc."
        }),

        Attribute({
            name: "SelectedTemperatureLevel", id: 0x4, type: "uint8", access: "R V", conformance: "TL",
            constraint: "max 31", xref: "cluster§8.2.5.5",
            details: "Indicates the currently selected temperature level setting of the server. This attribute shall be " +
                "the positional index of the list item in the SupportedTemperatureLevels list that represents the " +
                "currently selected temperature level setting of the server."
        }),

        Attribute(
            {
                name: "SupportedTemperatureLevels", id: 0x5, type: "list", access: "R V", conformance: "TL",
                constraint: "max 32[max 16]", xref: "cluster§8.2.5.6",

                details: "Indicates the list of supported temperature level settings that may be selected via the " +
                    "TargetTemperatureLevel field in the SetTemperature command. Each string is readable text that " +
                    "describes each temperature level setting in a way that can be easily understood by humans. For " +
                    "example, a washing machine can have temperature levels like \"Cold\", \"Warm\", and \"Hot\". Each string " +
                    "is specified by the manufacturer." +
                    "\n" +
                    "Each item in this list shall represent a unique temperature level. Each entry in this list shall " +
                    "have a unique value. The entries in this list shall appear in order of increasing temperature level " +
                    "with list item 0 being the setting with the lowest temperature level."
            },

            Field({ name: "entry", type: "string" })
        ),

        Command(
            {
                name: "SetTemperature", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§8.2.6.1",
                details: "This command is used to set the temperature setpoint."
            },

            Field({
                name: "TargetTemperature", id: 0x0, type: "temperature", conformance: "TN", constraint: "desc",
                xref: "cluster§8.2.6.1.1",
                details: "This field shall specify the desired temperature setpoint that the server is to be set to." +
                    "\n" +
                    "The TargetTemperature shall be from MinTemperature to MaxTemperature inclusive. If the Step " +
                    "attribute is supported, TargetTemperature shall be such that (TargetTemperature - MinTemperature) % " +
                    "Step == 0."
            }),

            Field({
                name: "TargetTemperatureLevel", id: 0x1, type: "uint8", conformance: "TL", constraint: "desc",
                xref: "cluster§8.2.6.1.2",
                details: "This field shall specify the index of the list item in the SupportedTemperatureLevels list that " +
                    "represents the desired temperature level setting of the server. The value of this field shall be " +
                    "between 0 and the length of the SupportedTemperatureLevels list -1."
            })
        )
    ),

    Cluster(
        {
            name: "DishwasherMode", id: 0x59, type: "ModeBase", classification: "application", pics: "DISHM",
            xref: "cluster§8.3",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for dishwasher devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.3.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, conformance: "M", xref: "cluster§8.3.6.1",
            details: "At least one entry in the SupportedModes attribute shall include the Normal mode tag in the ModeTags " +
                "field list."
        }),
        Attribute({ name: "CurrentMode", id: 0x1, conformance: "M", xref: "cluster§8.3.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§8.3.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§8.3.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§8.3.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§8.3.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§8.3.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§8.3.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§8.3.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§8.3.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§8.3.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§8.3.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§8.3.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§8.3.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§8.3.7.1" }),
            Field({ name: "Normal", id: 0x4000, xref: "cluster§8.3.7.1.1", details: "The normal regime of operation." }),
            Field({
                name: "Heavy", id: 0x4001, xref: "cluster§8.3.7.1.2",
                details: "Mode optimized for washing heavily-soiled dishes."
            }),
            Field({ name: "Light", id: 0x4002, xref: "cluster§8.3.7.1.3", details: "Mode optimized for light washing." })
        )
    ),

    Cluster(
        {
            name: "DishwasherAlarm", id: 0x5d, type: "AlarmBase", classification: "application",
            pics: "DISHALM", xref: "cluster§8.4",
            details: "This cluster is a derived cluster of the Alarm Base cluster and provides the alarm definition " +
                "related to dishwasher devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Datatype(
            { name: "AlarmBitmap", type: "map32", xref: "cluster§8.4.4.1" },
            Field({ name: "InflowError", constraint: "0", description: "Water inflow is abnormal" }),
            Field({ name: "DrainError", constraint: "1", description: "Water draining is abnormal" }),
            Field({ name: "DoorError", constraint: "2", description: "Door or door lock is abnormal" }),
            Field({ name: "TempTooLow", constraint: "3", description: "Unable to reach normal temperature" }),
            Field({ name: "TempTooHigh", constraint: "4", description: "Temperature is too high" }),
            Field({ name: "WaterLevelError", constraint: "5", description: "Water level is abnormal" })
        )
    ),

    Cluster(
        {
            name: "LaundryWasherMode", id: 0x51, type: "ModeBase", classification: "application", pics: "LWM",
            xref: "cluster§8.5",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for laundry washer as well as laundry dryer devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.5.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, conformance: "M", xref: "cluster§8.5.6.1",
            details: "At least one entry in the SupportedModes attribute shall include the Normal mode tag in the ModeTags " +
                "field list."
        }),
        Attribute({ name: "CurrentMode", id: 0x1, conformance: "M", xref: "cluster§8.5.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§8.5.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§8.5.6" }),

        Datatype(
            {
                name: "ModeOptionStruct", type: "struct", xref: "cluster§8.5.5.1",
                details: "The table below lists the changes relative to the Mode Base cluster for the fields of the ModeOption " +
                    "Struct type. A blank field indicates no change."
            },
            Field({ name: "Label", id: 0x0, conformance: "M" }),
            Field({ name: "Mode", id: 0x1, conformance: "M" }),
            Field({ name: "ModeTags", id: 0x2, conformance: "M", constraint: "1 to 8" })
        ),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§8.5.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§8.5.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§8.5.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§8.5.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§8.5.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§8.5.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§8.5.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§8.5.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§8.5.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§8.5.7.1" }),
            Field({ name: "Normal", id: 0x4000, xref: "cluster§8.5.7.1.1", details: "The normal regime of operation." }),
            Field({
                name: "Delicate", id: 0x4001, xref: "cluster§8.5.7.1.2",
                details: "Mode optimized for washing delicate garments."
            }),
            Field({ name: "Heavy", id: 0x4002, xref: "cluster§8.5.7.1.3", details: "Mode optimized for heavy washing." }),
            Field({
                name: "Whites", id: 0x4003, xref: "cluster§8.5.7.1.4",
                details: "Mode optimized for stain removal on white fabrics."
            })
        )
    ),

    Cluster(
        {
            name: "LaundryWasherControls", id: 0x53, classification: "application", pics: "WASHERCTRL",
            xref: "cluster§8.6",
            details: "This cluster provides a way to access options associated with the operation of a laundry washer " +
                "device type."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.6.4" },
            Field({
                name: "SPIN", conformance: "O.a+", constraint: "0", title: "Spin", xref: "cluster§8.6.4.1",
                details: "This feature indicates multiple spin speeds are supported in at least one supported mode. Note that " +
                    "some modes may not support multiple spin speeds even if this feature is supported."
            }),

            Field({
                name: "RINSE", conformance: "O.a+", constraint: "1", title: "Rinse", xref: "cluster§8.6.4.2",
                details: "This feature indicates multiple rinse cycles are supported in at least one supported mode. Note that " +
                    "some modes may not support selection of the number of rinse cycles even if this feature is " +
                    "supported."
            })
        ),

        Attribute(
            {
                name: "SpinSpeeds", id: 0x0, type: "list", access: "R V", conformance: "SPIN",
                constraint: "max 16[max 64]", xref: "cluster§8.6.6.1",
                details: "Indicates the list of spin speeds available to the appliance in the currently selected mode. The " +
                    "spin speed values are determined by the manufacturer. At least one spin speed value shall be " +
                    "provided in the SpinSpeeds list. The list of spin speeds may change depending on the currently " +
                    "selected Laundry Washer mode. For example, Quick mode might have a completely different list of " +
                    "SpinSpeeds than Delicates mode."
            },

            Field({ name: "entry", type: "string" })
        ),

        Attribute({
            name: "SpinSpeedCurrent", id: 0x1, type: "uint8", access: "RW VO", conformance: "SPIN",
            constraint: "max 15", quality: "X", xref: "cluster§8.6.6.2",

            details: "Indicates the currently selected spin speed. It is the index into the SpinSpeeds list of the " +
                "selected spin speed, as such, this attribute can be an integer between 0 and the number of entries " +
                "in SpinSpeeds - 1. If a value is received that is outside of the defined constraints, a " +
                "CONSTRAINT_ERROR shall be sent as the response. If a value is attempted to be written that doesn’t " +
                "match a valid index (e.g. an index of 5 when the list has 4 values), a CONSTRAINT_ERROR shall be" +
                "\n" +
                "sent as the response. If null is written to this attribute, there will be no spin speed for the " +
                "selected cycle. If the value is null, there will be no spin speed on the current mode."
        }),

        Attribute({
            name: "NumberOfRinses", id: 0x2, type: "NumberOfRinsesEnum", access: "RW VO", conformance: "RINSE",
            constraint: "desc", xref: "cluster§8.6.6.3",
            details: "Indicates how many times a rinse cycle shall be performed on a device for the current mode of " +
                "operation. A value of None shall indicate that no rinse cycle will be performed. This value may be " +
                "set by the client to adjust the number of rinses that are performed for the current mode of " +
                "operation. If the device is not in a compatible state to accept the provided value, an " +
                "INVALID_IN_STATE error shall be sent as the response."
        }),

        Attribute(
            {
                name: "SupportedRinses", id: 0x3, type: "list", access: "R V", conformance: "RINSE",
                constraint: "max 4", xref: "cluster§8.6.6.4",
                details: "Indicates the amount of rinses allowed for a specific mode. Each entry shall indicate a " +
                    "NumberOfRinsesEnum value that is possible in the selected mode on the device. The value of this " +
                    "attribute may change at runtime based on the currently selected mode. Each entry shall be distinct."
            },

            Field({ name: "entry", type: "NumberOfRinsesEnum" })
        ),

        Datatype(
            {
                name: "NumberOfRinsesEnum", type: "enum8", xref: "cluster§8.6.5.1",
                details: "The NumberOfRinsesEnum provides a representation of the number of rinses that will be performed for " +
                    "a selected mode. NumberOfRinsesEnum is derived from enum8. It is up to the device manufacturer to " +
                    "determine the mapping between the enum values and the corresponding numbers of rinses."
            },

            Field({
                name: "None", id: 0x0, conformance: "RINSE",
                description: "This laundry washer mode does not perform rinse cycles"
            }),
            Field({
                name: "Normal", id: 0x1, conformance: "RINSE",
                description: "This laundry washer mode performs normal rinse cycles determined by the manufacturer"
            }),
            Field({
                name: "Extra", id: 0x2, conformance: "RINSE",
                description: "This laundry washer mode performs an extra rinse cycle"
            }),
            Field({
                name: "Max", id: 0x3, conformance: "RINSE",
                description: "This laundry washer mode performs the maximum number of rinse cycles determined by the manufacturer"
            })
        )
    ),

    Cluster(
        {
            name: "RefrigeratorAndTemperatureControlledCabinetMode", id: 0x52, type: "ModeBase",
            classification: "application", pics: "TCCM", xref: "cluster§8.7",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for refrigerator and temperature controlled cabinet devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.7.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, conformance: "M", xref: "cluster§8.7.6.1",
            details: "At least one entry in the SupportedModes attribute shall include the Auto mode tag in the ModeTags " +
                "field list."
        }),
        Attribute({ name: "CurrentMode", id: 0x1, conformance: "M", xref: "cluster§8.7.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§8.7.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§8.7.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§8.7.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§8.7.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§8.7.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§8.7.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§8.7.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§8.7.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§8.7.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§8.7.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§8.7.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§8.7.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§8.7.7.1" }),
            Field({
                name: "RapidCool", id: 0x4000, xref: "cluster§8.7.7.1.1",
                details: "This mode reduces the temperature rapidly, typically above freezing grade."
            }),
            Field({
                name: "RapidFreeze", id: 0x4001, xref: "cluster§8.7.7.1.2",
                details: "This mode reduces the temperature rapidly, below freezing grade."
            })
        )
    ),

    Cluster(
        {
            name: "RefrigeratorAlarm", id: 0x57, type: "AlarmBase", classification: "application",
            pics: "REFALM", xref: "cluster§8.8",
            details: "This cluster is a derived cluster of Alarm Base cluster and provides the alarm definition related to " +
                "refrigerator and temperature controlled cabinet devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.8.4" },
            Field({
                name: "RESET", conformance: "X", constraint: "0", title: "Reset",
                details: "Supports the ability to reset alarms"
            })
        ),

        Command({ name: "ModifyEnabledAlarms", id: 0x1, conformance: "X", xref: "cluster§8.8.7" }),

        Datatype(
            { name: "AlarmBitmap", type: "map32", xref: "cluster§8.8.5.1" },
            Field({
                name: "DoorOpen", constraint: "0",
                description: "The cabinet’s door has been open for a vendor defined amount of time."
            })
        )
    ),

    Cluster(
        {
            name: "LaundryDryerControls", id: 0x4a, classification: "application", pics: "DRYERCTRL",
            xref: "cluster§8.9",
            details: "This cluster provides a way to access options associated with the operation of a laundry dryer " +
                "device type."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "SupportedDrynessLevels", id: 0x0, type: "list", access: "R V", conformance: "M",
                constraint: "1 to 4", xref: "cluster§8.9.5.1",
                details: "Indicates the list of supported dryness levels available to the appliance in the currently selected " +
                    "mode. The dryness level values are determined by the manufacturer. At least one dryness level value " +
                    "shall be provided in the SupportedDrynessLevels list. The list of dryness levels may change " +
                    "depending on the currently-selected Laundry Dryer mode."
            },

            Field({ name: "entry", type: "DrynessLevelEnum" })
        ),

        Attribute({
            name: "SelectedDrynessLevel", id: 0x1, type: "DrynessLevelEnum", access: "RW VO", conformance: "M",
            constraint: "desc", quality: "X", xref: "cluster§8.9.5.2",

            details: "Indicates the currently-selected dryness level and it shall be the index into the " +
                "SupportedDrynessLevels list of the selected dryness level." +
                "\n" +
                "If an attempt is made to write this attribute with a value other than null or a value contained in " +
                "SupportedDrynessLevels, a CONSTRAINT_ERROR response shall be sent as the response. If an attempt is " +
                "made to write this attribute while the device is not in a state that supports modifying the dryness " +
                "level, an INVALID_IN_STATE error shall be sent as the response. A value of null shall indicate that " +
                "there will be no dryness level setting for the current mode."
        }),

        Datatype(
            {
                name: "DrynessLevelEnum", type: "enum8", xref: "cluster§8.9.4.1",
                details: "This enum provides a representation of the level of dryness that will be used while drying in a " +
                    "selected mode." +
                    "\n" +
                    "It is up to the device manufacturer to determine the mapping between the enum values and the " +
                    "corresponding temperature level."
            },

            Field({
                name: "Low", id: 0x0, conformance: "M",
                description: "Provides a low dryness level for the selected mode"
            }),
            Field({
                name: "Normal", id: 0x1, conformance: "M",
                description: "Provides the normal level of dryness for the selected mode"
            }),
            Field({
                name: "Extra", id: 0x2, conformance: "M",
                description: "Provides an extra dryness level for the selected mode"
            }),
            Field({
                name: "Max", id: 0x3, conformance: "M",
                description: "Provides the max dryness level for the selected mode"
            })
        )
    ),

    Cluster(
        {
            name: "OvenCavityOperationalState", id: 0x48, type: "OperationalState",
            classification: "application", pics: "OVENOPSTATE", xref: "cluster§8.10",
            details: "This cluster is derived from the Operational State cluster and provides an interface for monitoring " +
                "the operational state of an oven."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),
        Command({ name: "Pause", id: 0x0, conformance: "X", xref: "cluster§8.10.5" }),
        Command({ name: "Stop", id: 0x1, xref: "cluster§8.10.5" }),
        Command({ name: "Start", id: 0x2, xref: "cluster§8.10.5" }),
        Command({ name: "Resume", id: 0x3, conformance: "X", xref: "cluster§8.10.5" }),
        Command({ name: "OperationalCommandResponse", id: 0x4, xref: "cluster§8.10.5" })
    ),

    Cluster(
        {
            name: "OvenMode", id: 0x49, type: "ModeBase", classification: "application", pics: "OTCCM",
            xref: "cluster§8.11",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for oven devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.11.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§8.11.6.1",
            details: "At least one entry in the SupportedModes attribute shall include the Bake mode tag in the ModeTags " +
                "field list."
        }),
        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§8.11.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§8.11.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§8.11.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§8.11.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§8.11.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§8.11.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§8.11.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§8.11.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§8.11.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§8.11.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§8.11.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§8.11.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§8.11.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§8.11.7.1" }),
            Field({
                name: "Bake", id: 0x4000, xref: "cluster§8.11.7.1.1",
                details: "This mode sets the device into baking mode for baking food items."
            }),
            Field({
                name: "Convection", id: 0x4001, xref: "cluster§8.11.7.1.2",
                details: "This mode sets the device into convection mode which creates an airflow within the device during the " +
                    "cooking duration."
            }),
            Field({
                name: "Grill", id: 0x4002, xref: "cluster§8.11.7.1.3",
                details: "This mode sets the device into grill mode for grilling food items. This is the same as Broil for " +
                    "many regions."
            }),
            Field({
                name: "Roast", id: 0x4003, xref: "cluster§8.11.7.1.4",
                details: "This mode sets the device into roast mode for roasting food items."
            }),
            Field({
                name: "Clean", id: 0x4004, xref: "cluster§8.11.7.1.5",
                details: "This mode sets the device into cleaning mode to clean the internal components of the appliance."
            }),
            Field({ name: "ConvectionBake", id: 0x4005, xref: "cluster§8.11.7.1" }),
            Field({ name: "ConvectionRoast", id: 0x4006, xref: "cluster§8.11.7.1" }),
            Field({
                name: "Warming", id: 0x4007, xref: "cluster§8.11.7.1.8",
                details: "This mode sets the device into a warming mode which begins warming the cavity."
            }),
            Field({
                name: "Proofing", id: 0x4008, xref: "cluster§8.11.7.1.9",
                details: "This mode sets the device into proofing mode which creates an environment ready for proofing."
            }),
            Field({ name: "Steam", id: 0x4009, xref: "cluster§8.11.7.1" })
        )
    ),

    Cluster(
        {
            name: "MicrowaveOvenMode", id: 0x5e, type: "ModeBase", classification: "application", pics: "MWOM",
            xref: "cluster§8.12",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for microwave oven devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.12.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§8.12.5.1",
            details: "Exactly one entry in the SupportedModes attribute shall include the Normal mode tag in the ModeTags " +
                "field." +
                "\n" +
                "The Normal and Defrost mode tags are mutually exclusive and shall NOT both be used together in a " +
                "mode’s ModeTags."
        }),

        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§8.12.5" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§8.12.5" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§8.12.5" }),
        Command({ name: "ChangeToMode", id: 0x0, conformance: "X", xref: "cluster§8.12.6" }),
        Command({ name: "ChangeToModeResponse", id: 0x1, conformance: "X", xref: "cluster§8.12.6" }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§8.12.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§8.12.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§8.12.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§8.12.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§8.12.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§8.12.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§8.12.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§8.12.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§8.12.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§8.12.7.1" }),
            Field({
                name: "Normal", id: 0x4000, xref: "cluster§8.12.7.1.1",
                details: "This is the normal mode of operation for general cooking of food."
            }),
            Field({
                name: "Defrost", id: 0x4001, xref: "cluster§8.12.7.1.2",
                details: "This is a mode optimized for defrosting food."
            })
        )
    ),

    Cluster(
        {
            name: "MicrowaveOvenControl", id: 0x5f, classification: "application", pics: "MWOCTRL",
            xref: "cluster§8.13",
            details: "This cluster defines the requirements for the Microwave Oven Control cluster." +
                "\n" +
                "This cluster has dependencies with the Operational State and Microwave Oven Mode clusters. The " +
                "Operational State cluster and the Microwave Oven Mode clusters, or derivatives of those clusters " +
                "shall appear on the same endpoint as this cluster."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§8.13.4" },
            Field({
                name: "PWRNUM", conformance: "O.a", constraint: "0", title: "PowerAsNumber",
                details: "Power is specified as a unitless number or a percentage"
            }),
            Field({
                name: "WATTS", conformance: "P, O.a", constraint: "1", title: "PowerInWatts",
                details: "Power is specified in Watts"
            }),
            Field({
                name: "PWRLMTS", conformance: "[PWRNUM]", constraint: "2", title: "PowerNumberLimits",
                details: "Supports the limit attributes used with the PWRNUM feature"
            })
        ),

        Attribute({
            name: "CookTime", id: 0x0, type: "elapsed-s", access: "R V", conformance: "M",
            constraint: "1 to maxCookTime", xref: "cluster§8.13.5.1",
            details: "Indicates the total cook time associated with the operation of the device." +
                "\n" +
                "This attribute shall remain unchanged during the operation of the oven unless the value is changed " +
                "via a command or out-of-band action."
        }),

        Attribute({
            name: "MaxCookTime", id: 0x1, type: "elapsed-s", access: "R V", conformance: "M",
            constraint: "1 to 86400", quality: "F", xref: "cluster§8.13.5.2",
            details: "Indicates the maximum value to which the CookTime attribute can be set."
        }),

        Attribute({
            name: "PowerSetting", id: 0x2, type: "uint8", access: "R V", conformance: "PWRNUM",
            constraint: "desc", xref: "cluster§8.13.5.3",

            details: "Indicates the power level associated with the operation of the device. If the MinPower, MaxPower, " +
                "and PowerStep attributes are not supported:" +
                "\n" +
                "  • The minimum value of this attribute shall be 10," +
                "\n" +
                "  • The maximum value of this attribute shall be 100," +
                "\n" +
                "  • The value shall be in even multiples of 10," +
                "\n" +
                "  • The default value shall be 100." +
                "\n" +
                "If the MinPower, MaxPower, and PowerStep attributes are supported:" +
                "\n" +
                "  • The value of this attribute shall be between MinPower and MaxPower inclusive." +
                "\n" +
                "  • The value of this attribute shall be such that (PowerSetting - MinPower) % PowerStep == 0"
        }),

        Attribute({
            name: "MinPower", id: 0x3, type: "uint8", access: "R V", conformance: "PWRLMTS",
            constraint: "1 to 99", quality: "F", xref: "cluster§8.13.5.4",
            details: "Indicates the minimum value to which the PowerSetting attribute that can be set on the server."
        }),
        Attribute({
            name: "MaxPower", id: 0x4, type: "uint8", access: "R V", conformance: "PWRLMTS",
            constraint: "minPower + 1 to 100", quality: "F", xref: "cluster§8.13.5.5",
            details: "Indicates the maximum value to which the PowerSetting attribute that can be set on the server."
        }),

        Attribute({
            name: "PowerStep", id: 0x5, type: "uint8", access: "R V", conformance: "PWRLMTS",
            constraint: "desc", quality: "F", xref: "cluster§8.13.5.6",

            details: "Indicates the increment of power that can be set on the server. The value of this attribute shall be " +
                "between 1 and MaxPower inclusive." +
                "\n" +
                "The value of this attribute shall be such that (MaxPower - MinPower) % PowerStep == 0" +
                "\n" +
                "For example, if MinPower is 1, MaxPower is 10, and PowerSetting can be set to any integer between " +
                "MinPower and MaxPower, PowerStep would be set to 1."
        }),

        Attribute(
            {
                name: "SupportedWatts", id: 0x6, type: "list", access: "R V", conformance: "P, WATTS",
                constraint: "1 to 10", quality: "F", xref: "cluster§8.13.5.7",
                details: "Indicates the list of power levels (in W) supported by the server."
            },
            Field({ name: "entry", type: "uint16" })
        ),

        Attribute({
            name: "SelectedWattIndex", id: 0x7, type: "uint8", access: "R V", conformance: "P, WATTS",
            constraint: "desc", xref: "cluster§8.13.5.8",
            details: "Indicates the index into the list of SupportedWatts of the currently selected power setting." +
                "\n" +
                "The index shall be a valid index into the SupportedWatts list."
        }),

        Attribute({
            name: "WattRating", id: 0x8, type: "uint16", access: "R V", conformance: "O", quality: "F",
            xref: "cluster§8.13.5.9",
            details: "Indicates the rating, in Watts, of the microwave power of the oven." +
                "\n" +
                "Supporting this attribute can assist clients in suggesting cooking settings for various foods and " +
                "beverages."
        }),

        Command(
            {
                name: "SetCookingParameters", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "cluster§8.13.6.2",
                details: "This command is used to set the cooking parameters associated with the operation of the device. This " +
                    "command supports the following fields:"
            },

            Field({
                name: "CookMode", id: 0x0, type: "uint8", conformance: "O.b+", constraint: "desc",
                xref: "cluster§8.13.6.2.1",

                details: "This field shall indicate the value to which the CurrentMode attribute of the Microwave Oven Mode " +
                    "cluster should be set. The value of this field shall be one from the list of SupportedModes from the " +
                    "Microwave Oven Mode cluster." +
                    "\n" +
                    "If this field is missing, the CurrentMode attribute shall be set to a mode having the Normal mode " +
                    "tag."
            }),

            Field({
                name: "CookTime", id: 0x1, type: "elapsed-s", conformance: "O.b+", constraint: "1 to maxCookTime",
                default: 30, xref: "cluster§8.13.6.2.2",
                details: "This field shall indicate the CookTime associated with the operation of the device. The value of " +
                    "this field shall be subject to the constraints of the CookTime attribute of this cluster." +
                    "\n" +
                    "If this field is missing, the CookTime attribute shall be set to 30 seconds by the server."
            }),

            Field({
                name: "PowerSetting", id: 0x2, type: "uint8", conformance: "[PWRNUM].b+",
                constraint: "minPower to maxPower", default: { type: "reference", name: "MaxPower" },
                xref: "cluster§8.13.6.2.3",

                details: "This field shall indicate the PowerSetting associated with the operation of the device. The value of " +
                    "this field shall be subject to the constraints of the PowerSetting attribute of this cluster. If the " +
                    "PowerSetting field does not conform to the constraints of the PowerSetting attribute, the server " +
                    "shall return a CONSTRAINT_ERROR status." +
                    "\n" +
                    "If this field is missing, the PowerSetting attribute shall be set to 100 if MaxPower is not " +
                    "supported by the server, otherwise it shall be set to MaxPower if the MaxPower attribute is " +
                    "supported by the server."
            }),

            Field({
                name: "WattSettingIndex", id: 0x3, type: "uint8", conformance: "[WATTS].b+", constraint: "desc",
                xref: "cluster§8.13.6.2.4",

                details: "This field shall indicate the value to which the SelectedWattIndex attribute is set. If the value of " +
                    "this field is greater than or equal to the length of the SupportedWatts attribute list, the server " +
                    "shall return a CONSTRAINT_ERROR status and the value of the SelectedWattIndex attribute shall be " +
                    "unchanged." +
                    "\n" +
                    "If this field is missing, the SelectedWattIndex attribute shall be set by the server to the index " +
                    "associated with the highest Watt setting for the selected CookMode."
            }),

            Field({
                name: "StartAfterSetting", id: 0x4, type: "bool", conformance: "O", default: false,
                xref: "cluster§8.13.6.2.5",
                details: "This field shall indicate whether or not oven operation shall be started when the command is " +
                    "received."
            })
        ),

        Command(
            {
                name: "AddMoreTime", id: 0x1, access: "O", conformance: "O", direction: "request",
                response: "status", xref: "cluster§8.13.6.3",
                details: "This command is used to add more time to the CookTime attribute of the server. This command supports " +
                    "these fields:"
            },

            Field({
                name: "TimeToAdd", id: 0x0, type: "elapsed-s", conformance: "M", constraint: "1 to maxCookTime",
                xref: "cluster§8.13.6.3.1",
                details: "This field shall indicate the number of seconds to be added to the CookTime attribute."
            })
        )
    ),

    Cluster(
        {
            name: "DeviceEnergyManagement", id: 0x98, classification: "application", pics: "DEM",
            xref: "cluster§9.2",

            details: "This cluster allows a client to manage the power draw of a device. An example of such a client could " +
                "be an Energy Management System (EMS) which controls an Energy Smart Appliance (ESA)." +
                "\n" +
                "In most deployments the EMS will be the client, and the ESA will host the Device Energy Management " +
                "Cluster server." +
                "\n" +
                "This cluster is intended to be generic in nature and could apply to any electrical load or generator " +
                "(e.g. a Battery Electric Storage System - BESS, solar PV inverter, EVSE, HVAC, heat pump, hot water " +
                "heater, white goods appliances etc)." +
                "\n" +
                "It consists of the following areas which shall be supported by all devices implementing this " +
                "cluster:" +
                "\n" +
                "  • Description of ESA and its capabilities & power limits (sometimes referred to as a nameplate)" +
                "\n" +
                "  • Current state of operation (including user opt-out, safety limitations / alarms) There are some " +
                "    optional capabilities that some ESAs may be able to offer:" +
                "\n" +
                "  • Ability to control the load or generation" +
                "\n" +
                "  • Forecast data, including when it can be flexible (i.e. modify the power or time period)" +
                "\n" +
                "  • The ability to have their power profile adjusted by an EMS, and to provide an updated Forecast " +
                "    back to the EMS." +
                "\n" +
                "This allows the EMS to manage multiple home loads and where ESAs can be flexible, continuously " +
                "optimizing the home energy to minimize cost, reduce CO2 impact, maximize self-consumption of solar " +
                "PV and provide Demand Side Response (DSR) Grid services." +
                "\n" +
                "It is likely that the ESA may also use the Pricing Cluster to obtain incentive signals such as 'grid " +
                "carbon intensity', 'time of use' or 'type of use' tariffs to schedule its operation to run at the " +
                "cheapest and greenest times." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Grid Services are market dependent and will use other protocols ([OpenADR] / [IEEE2030.5]) to " +
                "  communicate grid events to the EMS. These are outside the scope of Matter." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Different markets may follow different approaches, but the UK [PAS1878] and [EUCodeOfConduct] give " +
                "  examples of how ESAs may be mandated to support these features in the future."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 4 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.2.4" },

            Field({
                name: "PA", conformance: "O", constraint: "0", title: "PowerAdjustment", xref: "cluster§9.2.4.1",

                details: "For Energy Smart Appliances (ESA) the definition of being 'smart' mandates that they can report " +
                    "their current power adjustment capability and have an EMS request a temporary adjustment. This may " +
                    "typically be to curtail power requirements during peak periods, but can also be used to turn on an " +
                    "ESA if there is excess renewable or local generation (Solar PV)." +
                    "\n" +
                    "For example, a home may have solar PV which often produces more power than the home requires, " +
                    "resulting in the excess power flowing into the grid. This excess power naturally fluctuates when " +
                    "clouds pass overhead and other loads in the home are switched on and off." +
                    "\n" +
                    "EVSE Example: An EMS may therefore be able to turn on the EVSE (if the vehicle is plugged in) and " +
                    "can start charging the vehicle, and periodically modify the charging power depending on PV " +
                    "generation and other home loads, so as to minimize import and export to the grid. An EMS may also " +
                    "use this feature to control the discharging (and re-charging) of the vehicle if the EVSE and vehicle " +
                    "support the V2X feature of the EVSE cluster of the associated EVSE device."
            }),

            Field({
                name: "PFR", conformance: "[!PA].a, STA | PAU | FA | CON, O", constraint: "1",
                title: "PowerForecastReporting", xref: "cluster§9.2.4.2",

                details: "For Energy Smart Appliances (ESA) the definition of being 'smart' implies that they can report their " +
                    "indicative forecast power demands or generation, to a greater or lesser extent. For some ESAs this " +
                    "is highly predictable (in terms of both power and time), in other appliances this is more " +
                    "challenging and only a basic level of forecast is possible." +
                    "\n" +
                    "Forecasts are defined from a current time, using a slot format, where the slot is akin to a " +
                    "relatively constant operating mode." +
                    "\n" +
                    "Washing machine example: a washing machine may have stages of a washing cycle: heating, tumbling, " +
                    "rinse and spin stages. At each stage, the approximate minimum and maximum power consumption may be " +
                    "known, as well as the duration of that stage." +
                    "\n" +
                    "In some circumstances the ESA may allow the stage to be delayed or paused (subject to safety and " +
                    "manufacturer’s discretion and user preferences)." +
                    "\n" +
                    "Typically, appliances with a heating element cannot have their power consumption adjusted and can " +
                    "only be paused or delayed." +
                    "\n" +
                    "Some ESAs may not be flexible other than a delayed cycle start (for example, once the washing cycle " +
                    "has been started then they run continuously until the cycle completes)." +
                    "\n" +
                    "Appliances that only support the PowerForecastReporting and not any of the adjustment features may " +
                    "indicate that they are not flexible in the forecast slot format." +
                    "\n" +
                    "The PowerForecastReporting and the adjustment features aim to align to the [SAREF4ENER] ontology." +
                    "\n" +
                    "Inverter driven ESAs: some inverter driven ESAs can consume or generate a variable amount of power." +
                    "\n" +
                    "For example, a single phase EVSE can be adjusted in the range of 6-32Amps in 0.6 Amp steps in EU or " +
                    "on a hardwired 120V supply in the range of 6-15 Amps in US." +
                    "\n" +
                    "For example, a home battery may be adjusted to charge or discharge in steps of 1W." +
                    "\n" +
                    "For example, a heat pump may be able to modulate its compressor inverter between 20-100% of its " +
                    "rated power." +
                    "\n" +
                    "The ESA indicates its power adjustment range and its nominal power consumption as part of its " +
                    "Forecast."
            }),

            Field({
                name: "SFR", conformance: "[!PA].a", constraint: "2", title: "StateForecastReporting",
                xref: "cluster§9.2.4.3",

                details: "Some ESAs do not know their actual power consumption, but do know the state of operation. Like the " +
                    "PowerForecastingReporting feature, this uses the same slot structure mechanism to indicate a change " +
                    "in state vs time." +
                    "\n" +
                    "An external observing EMS may have access to real-time meter readings, and could learn the typical " +
                    "power consumption based on the advertised internal state of the ESA." +
                    "\n" +
                    "To enable this capability, the ESA shall report its internal operational state using an manufacturer " +
                    "specific value." +
                    "\n" +
                    "Once the EMS has built a model of the state vs observed power consumption, it may request a forecast " +
                    "adjustment for particular times of the day, encouraging the ESA to use power at alternative times."
            }),

            Field({
                name: "STA", conformance: "O", constraint: "3", title: "StartTimeAdjustment",
                xref: "cluster§9.2.4.4",

                details: "ESAs which support the Start Time Adjustment feature, allow an EMS to recommend a change to the " +
                    "start time of the energy transfer that the ESA has previously suggested it would use." +
                    "\n" +
                    "Washing machine example: A Washing Machine may have been set to start a wash cycle at 9pm when the " +
                    "variable tariff normally reduces." +
                    "\n" +
                    "However, the EMS is aware that a grid event has occurred, making it cheaper to run the cycle at a " +
                    "later time, but the washing machine is not aware of this." +
                    "\n" +
                    "The EMS first requests the Forecast data from each of its registered ESAs. It determines that the " +
                    "washing machine has a power profile suggesting it will start the wash cycle at 9pm, but the EMS now " +
                    "knows that the grid event means it will be cheaper to delay the start until 11pm." +
                    "\n" +
                    "The EMS can then optimize the cost by asking the washing machine to delay starting the wash cycle " +
                    "until 11pm." +
                    "\n" +
                    "It does this by sending a StartTimeAdjustRequest to the washing machine to request delaying the " +
                    "start of the washing cycle."
            }),

            Field({
                name: "PAU", conformance: "O", constraint: "4", title: "Pausable", xref: "cluster§9.2.4.5",

                details: "ESAs which support the Pausable feature, allow an EMS to recommend a pause in the middle of a " +
                    "forecast power profile that the ESA is currently using." +
                    "\n" +
                    "Washing machine example: A Washing Machine is in operation, and starting its water heating step." +
                    "\n" +
                    "However, the EMS becomes aware from the smart meter that the total home load on the grid is close to " +
                    "exceeding its allowed total grid load." +
                    "\n" +
                    "The EMS first requests the Forecast data from each of its registered ESAs. It determines that the " +
                    "washing machine has a power profile suggesting its current step in the wash cycle is using power to " +
                    "heat the water, but that this step can be paused." +
                    "\n" +
                    "The EMS can then reduce the grid load by asking the washing machine to pause the wash cycle for a " +
                    "short duration." +
                    "\n" +
                    "It does this by sending a PauseRequest to the washing machine to request pausing the current step of " +
                    "the forecast power usage for a period to allow other home loads to finish before resuming the " +
                    "washing cycle."
            }),

            Field({
                name: "FA", conformance: "O", constraint: "5", title: "ForecastAdjustment", xref: "cluster§9.2.4.6",

                details: "ESAs which support the Forecast adjustment feature, allow an EMS to recommend a change to the start, " +
                    "duration and/or power level limits of the steps of the power profile that the ESA has previously " +
                    "suggested it would use." +
                    "\n" +
                    "Heat pump and Solar PV example: A heat pump may have the ability to heat hot water as well as " +
                    "heating the home. The heat pump scheduling system may have determined that the home will be " +
                    "unoccupied during the day, or that the indoor temperature is above the set-point and so it knows " +
                    "that it will not need to heat the home." +
                    "\n" +
                    "However, the hot water tank is likely to need to be reheated before the homeowner comes home in the " +
                    "evening. The heat pump is not aware that the property also has a solar PV inverter which is also an " +
                    "ESA that is communicating with the EMS." +
                    "\n" +
                    "The EMS first requests the Forecast data from each of its registered ESAs. It determines that the " +
                    "heat pump has a power profile suggesting it needs to heat hot water around 6pm. The solar PV " +
                    "inverter has forecast that it will generate 3.6kW of power during the middle of the day and into the " +
                    "afternoon before the sun goes down." +
                    "\n" +
                    "The EMS can then optimize the home considering other non-ESA loads and can ask the heat pump to heat " +
                    "the hot water around 3pm when it has forecast that excess solar power will be available." +
                    "\n" +
                    "It does this by sending a ModifyForecastRequest to the heat pump and asks the heat pump to expect to " +
                    "run at a lower power consumption (within the solar excess power) which requires the heat pump to run " +
                    "for a longer duration to achieve its required energy demand."
            }),

            Field({
                name: "CON", conformance: "O", constraint: "6", title: "ConstraintBasedAdjustment",
                xref: "cluster§9.2.4.7",

                details: "ESAs which support the Constraint-Based Adjustment feature allow an EMS to inform the ESA of periods " +
                    "during which power usage should be modified (for example when the EMS has been made aware that the " +
                    "grid supplier has requested reduced energy usage due to overall peak grid demand) and may cause the " +
                    "ESA to modify the intended power profile has previously suggested it would use." +
                    "\n" +
                    "EVSE example: An EVSE scheduling system may have determined that the vehicle would be charged " +
                    "starting at a moderate rate at 1am, so that it has enough charge by the time it is needed later that " +
                    "morning." +
                    "\n" +
                    "However, the DSR service provider has informed the EMS that due to high forecast winds it is now " +
                    "forecast that there will be very cheap energy available from wind generation between 2am and 3am." +
                    "\n" +
                    "The EMS first requests the Forecast data from each of its registered ESAs. It determines that the " +
                    "EVSE has a power profile suggesting it plans to start charging the vehicle at 1am." +
                    "\n" +
                    "The EMS can then try to reduce the cost of charging the EV by informing the EVSE of the desire to " +
                    "increase the charging between scheduled times." +
                    "\n" +
                    "It does this by sending a RequestConstraintBasedForecast to the EVSE and asks it to run at a higher " +
                    "NominalPower consumption during the constraint period, which may require it to decrease its charge " +
                    "rate outside the constraint period to achieve its required energy demand."
            })
        ),

        Attribute({
            name: "EsaType", id: 0x0, type: "ESATypeEnum", access: "R V", conformance: "M", quality: "F",
            xref: "cluster§9.2.8.1",

            details: "Indicates the type of ESA." +
                "\n" +
                "This attribute enables an EMS to understand some of the basic properties about how the energy may be " +
                "consumed, generated, and stored by the ESA." +
                "\n" +
                "For example, the heat energy converted by a heat pump will naturally be lost through the building to " +
                "the outdoor environment relatively quickly, compared to storing heat in a well-insulated hot water " +
                "tank. Similarly, battery storage and EVs can store electrical energy for much longer durations." +
                "\n" +
                "This attribute can also help the EMS display information to a user and to make basic assumptions " +
                "about typical best use of energy. For example, an EVSE may not always have an EV plugged in, so " +
                "knowing the type of ESA that is being controlled can allow advanced energy management strategies."
        }),

        Attribute(
            {
                name: "EsaCanGenerate", id: 0x1, type: "bool", access: "R V", conformance: "M", quality: "F",
                xref: "cluster§9.2.8.2",

                details: "Indicates whether the ESA is classed as a generator or load. This allows an EMS to understand " +
                    "whether the power values reported by the ESA need to have their sign inverted when dealing with " +
                    "forecasts and adjustments." +
                    "\n" +
                    "For example, a solar PV inverter (being a generator) may produce negative values to indicate " +
                    "generation (since power is flowing out of the node into the home), however a display showing the " +
                    "power to the consumers may need to present a positive solar production value to the consumer." +
                    "\n" +
                    "For example, a home battery storage system (BESS) which needs to charge the battery and then " +
                    "discharge to the home loads, would be classed as a generator. These types of devices shall have this " +
                    "field set to true. When generating its forecast or advertising its PowerAdjustmentCapability, the " +
                    "power values shall be negative to indicate discharging to the loads in the home, and positive to " +
                    "indicate when it is charging its battery." +
                    "\n" +
                    "GRID meter = Σ LoadPowers + Σ GeneratorPowers" +
                    "\n" +
                    "Example:"
            }
        ),

        Attribute({
            name: "EsaState", id: 0x2, type: "ESAStateEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "cluster§9.2.8.3",

            details: "Indicates the current state of the ESA." +
                "\n" +
                "If the ESA is in the Offline or Fault state it cannot be controlled by an EMS, and may not be able " +
                "to report its Forecast information. An EMS may subscribe to the ESAState to get notified about " +
                "changes in operational state." +
                "\n" +
                "The ESA may have a local user interface to allow a service technician to put the ESA into Offline " +
                "mode, for example to avoid the EMS accidentally starting or stopping the appliance when it is being " +
                "serviced or tested."
        }),

        Attribute({
            name: "AbsMinPower", id: 0x3, type: "power-mW", access: "R V", conformance: "M",
            xref: "cluster§9.2.8.4",

            details: "Indicates the minimum electrical power that the ESA can consume when switched on. This does not " +
                "include when in power save or standby modes." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> For Generator ESAs that can discharge an internal battery (such as a battery storage inverter) to " +
                "  loads in the home, the AbsMinPower will be a negative number representing the maximum power that " +
                "  the ESA can discharge its internal battery."
        }),

        Attribute({
            name: "AbsMaxPower", id: 0x4, type: "power-mW", access: "R V", conformance: "M",
            constraint: "min absMinPower", xref: "cluster§9.2.8.5",

            details: "Indicates the maximum electrical power that the ESA can consume when switched on." +
                "\n" +
                "Note that for Generator ESAs that can charge a battery by importing power into the node (such as a " +
                "battery storage inverter), the AbsMaxPower will be a positive number representing the maximum power " +
                "at which the ESA can charge its internal battery." +
                "\n" +
                "For example, a battery storage inverter that can charge its battery at a maximum power of 2000W and " +
                "can discharge the battery at a maximum power of 3000W, would have a AbsMinPower: -3000, AbsMaxPower: " +
                "2000W."
        }),

        Attribute({
            name: "PowerAdjustmentCapability", id: 0x5, type: "PowerAdjustCapabilityStruct", access: "R V",
            conformance: "PA", quality: "X Q", xref: "cluster§9.2.8.6",

            details: "Indicates how the ESA can be adjusted at the current time, and the state of any active adjustment." +
                "\n" +
                "A null value indicates that no power adjustment is currently possible, and nor is any adjustment " +
                "currently active." +
                "\n" +
                "This attribute SHOULD be updated periodically by ESAs to reflect any changes in internal state, for " +
                "example temperature or stored energy, which would affect the power or duration limits." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once every 10 seconds on changes, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa."
        }),

        Attribute({
            name: "Forecast", id: 0x6, type: "ForecastStruct", access: "R V", conformance: "PFR | SFR",
            quality: "X Q", xref: "cluster§9.2.8.7",

            details: "This attribute allows an ESA to share its intended forecast with a client (such as an Energy " +
                "Management System)." +
                "\n" +
                "A null value indicates that there is no forecast currently available (for example, a program has not " +
                "yet been selected by the user)." +
                "\n" +
                "A server may reset this value attribute to null on a reboot, and it does not need to persist any " +
                "previous forecasts." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once every 10 seconds on changes, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa, or" +
                "\n" +
                "  • As a result of a command which causes the forecast to be updated, or" +
                "\n" +
                "  • As a result of a change in the opt-out status which in turn may cause the ESA to recalculate its " +
                "    forecast."
        }),

        Attribute({
            name: "OptOutState", id: 0x7, type: "OptOutStateEnum", access: "R V",
            conformance: "PA | STA | PAU | FA | CON", constraint: "desc", xref: "cluster§9.2.8.8",

            details: "Indicates the current Opt-Out state of the ESA. The ESA may have a local user interface to allow the " +
                "user to control this OptOutState. An EMS may subscribe to the OptOutState to get notified about " +
                "changes in operational state." +
                "\n" +
                "If the ESA is in the LocalOptOut or OptOut states, so it cannot be controlled by an EMS for local " +
                "optimization reasons, it shall reject any commands which have the AdjustmentCauseEnum value " +
                "LocalOptimization. If the ESA is in the GridOptOut or OptOut states, so it cannot be controlled by " +
                "an EMS for grid optimization reasons, it shall reject any commands which have the " +
                "AdjustmentCauseEnum value GridOptimization." +
                "\n" +
                "If the user changes the Opt-Out state of the ESA which is currently operating with a Forecast that " +
                "is due to a previous StartTimeAdjustRequest, ModifyForecastRequest or RequestConstraintBasedForecast " +
                "command that would now not be permitted due to the new Opt-out state (i.e. the Forecast attribute " +
                "ForecastUpdateReason field currently contains a reason which is now opted out), the ESA shall behave " +
                "as if it had received a CancelRequest command." +
                "\n" +
                "If the user changes the Opt-Out state of the ESA which currently has the ESAStateEnum with value " +
                "Paused due to a previous PauseRequest command that would now not be permitted due to the new Opt-out " +
                "state, and the ESA supports the PFR or SFR features (i.e. the Forecast attribute " +
                "ForecastUpdateReason field currently contains a reason which is now opted out), the ESA shall behave " +
                "as if it had received a ResumeRequest command." +
                "\n" +
                "If the user changes the Opt-Out state of the ESA which currently has the ESAStateEnum with value " +
                "PowerAdjustActive due to a previous PowerAdjustRequest command that would now not be permitted due " +
                "to the new Opt-out state (i.e. the Forecast attribute ForecastUpdateReason field currently contains " +
                "a reason which is now opted out), the ESA shall behave as if it had received a " +
                "CancelPowerAdjustRequest command." +
                "\n" +
                "If the ESA is in the LocalOptOut, GridOptOut, or NoOptOut states, the device is still permitted to " +
                "optimize its own energy usage, for example, using tariff information it may obtain."
        }),

        Event({
            name: "PowerAdjustStart", id: 0x0, access: "V", conformance: "PA", priority: "info",
            xref: "cluster§9.2.10.1",
            details: "This event shall be generated when the Power Adjustment session is started."
        }),

        Event(
            {
                name: "PowerAdjustEnd", id: 0x1, access: "V", conformance: "PA", priority: "info",
                xref: "cluster§9.2.10.2",
                details: "This event shall be generated when the Power Adjustment session ends."
            },
            Field({
                name: "Cause", id: 0x0, type: "CauseEnum", conformance: "M", xref: "cluster§9.2.10.2.1",
                details: "This field shall indicate the reason why the power adjustment session ended."
            }),
            Field({
                name: "Duration", id: 0x1, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.10.2.2",
                details: "This field shall indicate the number of seconds that the power adjustment session lasted before " +
                    "ending."
            }),

            Field({
                name: "EnergyUse", id: 0x2, type: "energy-mWh", conformance: "M", xref: "cluster§9.2.10.2.3",
                details: "This field shall indicate the approximate energy used by the ESA during the session." +
                    "\n" +
                    "For example, if the ESA was on and was adjusted to be switched off, then this shall be 0 mWh. If " +
                    "this was a battery inverter that was requested to discharge it would have a negative EnergyUse " +
                    "value. If this was a normal load that was turned on, then it will have positive value."
            })
        ),

        Event({
            name: "Paused", id: 0x2, access: "V", conformance: "PAU", priority: "info",
            xref: "cluster§9.2.10.3",
            details: "This event shall be generated when the ESA enters the Paused state. There is no data for this event."
        }),

        Event(
            {
                name: "Resumed", id: 0x3, access: "V", conformance: "PAU", priority: "info",
                xref: "cluster§9.2.10.4",
                details: "This event shall be generated when the ESA leaves the Paused state and resumes operation."
            },
            Field({
                name: "Cause", id: 0x0, type: "CauseEnum", conformance: "M", xref: "cluster§9.2.10.4.1",
                details: "This field shall indicate the reason why the pause ended."
            })
        ),

        Command(
            {
                name: "PowerAdjustRequest", id: 0x0, access: "O", conformance: "PA", direction: "request",
                response: "status", xref: "cluster§9.2.9.1",
                details: "Allows a client to request an adjustment in the power consumption of an ESA for a specified " +
                    "duration."
            },

            Field({
                name: "Power", id: 0x0, type: "power-mW", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.9.1.1",
                details: "This field shall indicate the power that the ESA shall use during the adjustment period." +
                    "\n" +
                    "This value shall be between the MinPower and MaxPower fields of the PowerAdjustStruct in the " +
                    "PowerAdjustmentCapability attribute."
            }),

            Field({
                name: "Duration", id: 0x1, type: "elapsed-s", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.9.1.2",
                details: "This field shall indicate the duration that the ESA shall maintain the requested power for." +
                    "\n" +
                    "This value shall be between the MinDuration and MaxDuration fields of the PowerAdjustStruct in the " +
                    "PowerAdjustmentCapability attribute."
            }),

            Field({
                name: "Cause", id: 0x2, type: "AdjustmentCauseEnum", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.9.1.3",
                details: "This field shall indicate the cause of the request from the EMS."
            })
        ),

        Command({
            name: "CancelPowerAdjustRequest", id: 0x1, access: "O", conformance: "PA", direction: "request",
            response: "status", xref: "cluster§9.2.9.2",
            details: "Allows a client to cancel an ongoing PowerAdjustmentRequest operation."
        }),

        Command(
            {
                name: "StartTimeAdjustRequest", id: 0x2, access: "O", conformance: "STA", direction: "request",
                response: "status", xref: "cluster§9.2.9.3",
                details: "Allows a client to adjust the start time of a Forecast sequence that has not yet started operation " +
                    "(i.e. where the current Forecast StartTime is in the future)."
            },

            Field({
                name: "RequestedStartTime", id: 0x0, type: "epoch-s", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.9.3.1",

                details: "This field shall indicate the requested start time, in UTC, that the client would like the appliance " +
                    "to shift its Forecast to. This value MUST be in the future." +
                    "\n" +
                    "A client can estimate the entire Forecast sequence duration by computing the EndTime - StartTime " +
                    "fields from the Forecast attribute, and therefore avoid scheduling the start time too late." +
                    "\n" +
                    "This value shall be after the EarliestStartTime in the Forecast attribute. The new EndTime, that can " +
                    "be computed from the RequestedStartTime and the Forecast sequence duration, shall be before the " +
                    "LatestEndTime."
            }),

            Field({
                name: "Cause", id: 0x1, type: "AdjustmentCauseEnum", conformance: "M", xref: "cluster§9.2.9.3.2",
                details: "This field shall indicate the cause of the request from the EMS."
            })
        ),

        Command(
            {
                name: "PauseRequest", id: 0x3, access: "O", conformance: "PAU", direction: "request",
                response: "status", xref: "cluster§9.2.9.4",
                details: "Allows a client to temporarily pause an operation and reduce the ESAs energy demand."
            },

            Field({
                name: "Duration", id: 0x0, type: "elapsed-s", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.9.4.1",
                details: "This field shall indicate the duration that the ESA shall be paused for. This value shall be between " +
                    "the MinPauseDuration and MaxPauseDuration indicated in the ActiveSlotNumber index in the Slots list " +
                    "in the Forecast."
            }),

            Field({
                name: "Cause", id: 0x1, type: "AdjustmentCauseEnum", conformance: "M", xref: "cluster§9.2.9.4.2",
                details: "This field shall indicate the cause of the request from the EMS."
            })
        ),

        Command({
            name: "ResumeRequest", id: 0x4, access: "O", conformance: "PAU", direction: "request",
            response: "status", xref: "cluster§9.2.9.5",
            details: "Allows a client to cancel the PauseRequest command and enable earlier resumption of operation."
        }),

        Command(
            {
                name: "ModifyForecastRequest", id: 0x5, access: "O", conformance: "FA", direction: "request",
                response: "status", xref: "cluster§9.2.9.6",
                details: "Allows a client to modify a Forecast within the limits allowed by the ESA."
            },
            Field({
                name: "ForecastId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.2.9.6.1",
                details: "This field shall indicate the ForecastID that is to be modified."
            }),

            Field(
                {
                    name: "SlotAdjustments", id: 0x1, type: "list", conformance: "M", constraint: "max 10",
                    xref: "cluster§9.2.9.6.2",
                    details: "This field shall contain a list of SlotAdjustment parameters that should be modified in the " +
                        "corresponding Forecast with matching ForecastID."
                },

                Field({ name: "entry", type: "SlotAdjustmentStruct" })
            ),

            Field({
                name: "Cause", id: 0x2, type: "AdjustmentCauseEnum", conformance: "M", xref: "cluster§9.2.9.6.3",
                details: "This field shall indicate the cause of the request from the EMS."
            })
        ),

        Command(
            {
                name: "RequestConstraintBasedForecast", id: 0x6, access: "O", conformance: "CON",
                direction: "request", response: "status", xref: "cluster§9.2.9.7",
                details: "Allows a client to ask the ESA to recompute its Forecast based on power and time constraints."
            },

            Field(
                {
                    name: "Constraints", id: 0x0, type: "list", conformance: "M", constraint: "max 10",
                    xref: "cluster§9.2.9.7.1",

                    details: "This field shall indicate the series of turn up or turn down power requests that the ESA is being " +
                        "asked to constrain its operation within. These requests shall be in the future, shall be in " +
                        "chronological order, starting with the earliest start time, and shall NOT overlap in time." +
                        "\n" +
                        "For example, a grid event which requires devices to reduce power (turn down) between 4pm and 6pm and " +
                        "due to excess power on the grid overnight, may request ESAs to increase their power demand (turn up) " +
                        "between midnight and 6am." +
                        "\n" +
                        "If this ESA supports PFR this would have 2 entries in the list as follows:" +
                        "\n" +
                        "If this ESA supports SFR where it does not know the actual power, but has an understanding of the " +
                        "functions that use more energy, it could be requested to use more or less energy using the LoadCon " +
                        "trol field as follows:"
                },

                Field({ name: "entry", type: "ConstraintsStruct" })
            ),

            Field({
                name: "Cause", id: 0x1, type: "AdjustmentCauseEnum", conformance: "M", xref: "cluster§9.2.9.7.2",
                details: "This field shall indicate the cause of the request from the EMS."
            })
        ),

        Command({
            name: "CancelRequest", id: 0x7, access: "O", conformance: "STA | FA | CON", direction: "request",
            response: "status", xref: "cluster§9.2.9.8",
            details: "Allows a client to request cancellation of a previous adjustment request in a " +
                "StartTimeAdjustRequest, ModifyForecastRequest or RequestConstraintBasedForecast command."
        }),

        Datatype(
            { name: "CostTypeEnum", type: "enum8", xref: "cluster§9.2.7.1" },
            Field({
                name: "Financial", id: 0x0, conformance: "M", description: "Financial cost",
                xref: "cluster§9.2.7.1.1",
                details: "This value shall indicate that the cost is related to the financial cost to provide the energy."
            }),
            Field({
                name: "GhgEmissions", id: 0x1, conformance: "M", description: "Grid CO2e grams cost",
                xref: "cluster§9.2.7.1.2",
                details: "This value shall indicate that the cost is related to greenhouse gas emissions (in grams of CO2e)."
            }),

            Field({
                name: "Comfort", id: 0x2, conformance: "M", description: "Consumer comfort impact cost",
                xref: "cluster§9.2.7.1.3",
                details: "This value shall indicate that the cost is related to some abstract sense of comfort expressed by " +
                    "the consumer; a higher value indicates more discomfort. For example, a consumer may be more " +
                    "comfortable knowing that their EV is charged earlier in the day in case there is a sudden need to " +
                    "depart and drive to the hospital. Or the consumer may feel inconvenienced by the fact that they need " +
                    "to wait for the washing machine to finish its load so that they can use it again."
            }),

            Field({
                name: "Temperature", id: 0x3, conformance: "M", description: "Temperature impact cost",
                xref: "cluster§9.2.7.1.4",
                details: "This value shall indicate that the cost is related to the temperature of the home or water being at " +
                    "its setpoint. Some consumers may be more sensitive to being too hot or too cold." +
                    "\n" +
                    "This is expressed in degrees Celsius."
            })
        ),

        Datatype(
            { name: "ESATypeEnum", type: "enum8", xref: "cluster§9.2.7.2" },
            Field({ name: "Evse", id: 0x0, conformance: "O", description: "EV Supply Equipment" }),
            Field({ name: "SpaceHeating", id: 0x1, conformance: "O", description: "Space heating appliance" }),
            Field({ name: "WaterHeating", id: 0x2, conformance: "O", description: "Water heating appliance" }),
            Field({ name: "SpaceCooling", id: 0x3, conformance: "O", description: "Space cooling appliance" }),
            Field({
                name: "SpaceHeatingCooling", id: 0x4, conformance: "O",
                description: "Space heating and cooling appliance"
            }),
            Field({ name: "BatteryStorage", id: 0x5, conformance: "O", description: "Battery Electric Storage System" }),
            Field({ name: "SolarPv", id: 0x6, conformance: "O", description: "Solar PV inverter" }),
            Field({ name: "FridgeFreezer", id: 0x7, conformance: "O", description: "Fridge / Freezer" }),
            Field({ name: "WashingMachine", id: 0x8, conformance: "O", description: "Washing Machine" }),
            Field({ name: "Dishwasher", id: 0x9, conformance: "O", description: "Dishwasher" }),
            Field({ name: "Cooking", id: 0xa, conformance: "O", description: "Cooking appliance" }),
            Field({ name: "HomeWaterPump", id: 0xb, conformance: "O", description: "Home water pump (e.g. drinking well)" }),
            Field({ name: "IrrigationWaterPump", id: 0xc, conformance: "O", description: "Irrigation water pump" }),
            Field({ name: "PoolPump", id: 0xd, conformance: "O", description: "Pool pump" }),
            Field({ name: "Other", id: 0xff, conformance: "O", description: "Other appliance type" })
        ),

        Datatype(
            { name: "ESAStateEnum", type: "enum8", xref: "cluster§9.2.7.3" },
            Field({
                name: "Offline", id: 0x0, conformance: "M",
                description: "The ESA is not available to the EMS (e.g. start-up, maintenance mode)"
            }),
            Field({
                name: "Online", id: 0x1, conformance: "M",
                description: "The ESA is working normally and can be controlled by the EMS"
            }),
            Field({
                name: "Fault", id: 0x2, conformance: "M",
                description: "The ESA has developed a fault and cannot provide service"
            }),
            Field({
                name: "PowerAdjustActive", id: 0x3, conformance: "PA",
                description: "The ESA is in the middle of a power adjustment event"
            }),
            Field({
                name: "Paused", id: 0x4, conformance: "PAU",
                description: "The ESA is currently paused by a client using the PauseRequest command"
            })
        ),

        Datatype(
            { name: "OptOutStateEnum", type: "enum8", xref: "cluster§9.2.7.4" },
            Field({
                name: "NoOptOut", id: 0x0, conformance: "M",
                description: "The user has not opted out of either local or grid optimizations"
            }),
            Field({
                name: "LocalOptOut", id: 0x1, conformance: "M",
                description: "The user has opted out of local EMS optimizations only"
            }),
            Field({
                name: "GridOptOut", id: 0x2, conformance: "M",
                description: "The user has opted out of grid EMS optimizations only"
            }),
            Field({
                name: "OptOut", id: 0x3, conformance: "M",
                description: "The user has opted out of all external optimizations"
            })
        ),

        Datatype(
            { name: "CauseEnum", type: "enum8", xref: "cluster§9.2.7.5" },
            Field({
                name: "NormalCompletion", id: 0x0, conformance: "M",
                description: "The ESA completed the power adjustment as requested"
            }),
            Field({ name: "Offline", id: 0x1, conformance: "M", description: "The ESA was set to offline" }),
            Field({
                name: "Fault", id: 0x2, conformance: "M",
                description: "The ESA has developed a fault could not complete the adjustment"
            }),
            Field({
                name: "UserOptOut", id: 0x3, conformance: "M",
                description: "The user has disabled the ESA’s flexibility capability"
            }),
            Field({ name: "Cancelled", id: 0x4, conformance: "M", description: "The adjustment was cancelled by a client" })
        ),

        Datatype(
            { name: "AdjustmentCauseEnum", type: "enum8", xref: "cluster§9.2.7.6" },
            Field({
                name: "LocalOptimization", id: 0x0, conformance: "M",
                description: "The adjustment is to optimize the local energy usage"
            }),
            Field({
                name: "GridOptimization", id: 0x1, conformance: "M",
                description: "The adjustment is to optimize the grid energy usage"
            })
        ),

        Datatype(
            { name: "ForecastUpdateReasonEnum", type: "enum8", xref: "cluster§9.2.7.7" },
            Field({
                name: "InternalOptimization", id: 0x0, conformance: "M",
                description: "The update was due to internal ESA device optimization"
            }),
            Field({
                name: "LocalOptimization", id: 0x1, conformance: "M",
                description: "The update was due to local EMS optimization"
            }),
            Field({
                name: "GridOptimization", id: 0x2, conformance: "M",
                description: "The update was due to grid optimization"
            })
        ),

        Datatype(
            { name: "PowerAdjustReasonEnum", type: "enum8", xref: "cluster§9.2.7.8" },
            Field({ name: "NoAdjustment", id: 0x0, conformance: "M", description: "There is no Power Adjustment active" }),
            Field({
                name: "LocalOptimizationAdjustment", id: 0x1, conformance: "M",
                description: "There is PowerAdjustment active due to local EMS optimization"
            }),
            Field({
                name: "GridOptimizationAdjustment", id: 0x2, conformance: "M",
                description: "There is PowerAdjustment active due to grid optimization"
            })
        ),

        Datatype(
            {
                name: "CostStruct", type: "struct", xref: "cluster§9.2.7.9",
                details: "This indicates a generic mechanism for expressing cost to run an appliance, in terms of financial, " +
                    "GHG emissions, comfort value etc."
            },
            Field({
                name: "CostType", id: 0x0, type: "CostTypeEnum", conformance: "M", xref: "cluster§9.2.7.9.1",
                details: "This field shall indicate the type of cost being represented (see CostTypeEnum)."
            }),

            Field({
                name: "Value", id: 0x1, type: "int32", conformance: "M", xref: "cluster§9.2.7.9.2",
                details: "This field shall indicate the value of the cost. This may be negative (indicating that it is not a " +
                    "cost, but a free benefit)." +
                    "\n" +
                    "For example, if the Value was -302 and DecimalPoints was 2, then this would represent a benefit of " +
                    "3.02."
            }),

            Field({
                name: "DecimalPoints", id: 0x2, type: "uint8", conformance: "M", xref: "cluster§9.2.7.9.3",
                details: "This field shall indicate the number of digits to the right of the decimal point in the Value field. " +
                    "For example, if the Value was 102 and DecimalPoints was 2, then this would represent a cost of 1.02."
            }),

            Field({
                name: "Currency", id: 0x3, type: "uint16", conformance: "O", constraint: "max 999", default: 0,
                xref: "cluster§9.2.7.9.4",
                details: "Indicates the currency for the value in the Value field. The value of the currency field shall match " +
                    "the values defined by [ISO 4217]." +
                    "\n" +
                    "This is an optional field. It shall be included if CostType is Financial."
            })
        ),

        Datatype(
            { name: "PowerAdjustStruct", type: "struct", xref: "cluster§9.2.7.10" },

            Field({
                name: "MinPower", id: 0x0, type: "power-mW", conformance: "M", xref: "cluster§9.2.7.10.1",
                details: "This field shall indicate the minimum power that the ESA can have its power adjusted to." +
                    "\n" +
                    "Note that this is a signed value. Negative values indicate power flows out of the node (e.g. " +
                    "discharging a battery)."
            }),

            Field({
                name: "MaxPower", id: 0x1, type: "power-mW", conformance: "M", constraint: "min minPower",
                xref: "cluster§9.2.7.10.2",

                details: "This field shall indicate the maximum power that the ESA can have its power adjusted to." +
                    "\n" +
                    "Note that this is a signed value. Negative values indicate power flows out of the node (e.g. " +
                    "discharging a battery)." +
                    "\n" +
                    "For example, if the charging current of an EVSE can be adjusted within the range of 6A to 32A on a " +
                    "230V supply, then the power adjustment range is between 1380W and 7360W. Here the MinPower would be " +
                    "1380W, and MaxPower would be 7360W." +
                    "\n" +
                    "For example, if a battery storage inverter can discharge between 0 to 3000W towards a load, then " +
                    "power is flowing out of the node and is therefore negative. Its MinPower would be -3000W and its " +
                    "MaxPower would be 0W." +
                    "\n" +
                    "In another example, if a battery storage inverter can charge its internal battery, between 0W and " +
                    "2000W. Here power is flowing into the node when charging. As such the MinPower becomes 0W and " +
                    "MaxPower becomes 2000W."
            }),

            Field({
                name: "MinDuration", id: 0x2, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.10.3",
                details: "This field shall indicate the minimum duration, in seconds, that a controller may invoke an ESA " +
                    "power adjustment. Manufacturers may use this to as an anti-cycling capability to avoid controllers " +
                    "from rapidly making power adjustments."
            }),

            Field({
                name: "MaxDuration", id: 0x3, type: "elapsed-s", conformance: "M", constraint: "min minDuration",
                xref: "cluster§9.2.7.10.4",
                details: "This field shall indicate the maximum duration, in seconds, that a controller may invoke an ESA " +
                    "power adjustment. Manufacturers may use this to protect the user experience, to avoid over heating " +
                    "of the ESA, ensuring that there is sufficient headroom to use or store energy in the ESA or for any " +
                    "other reason."
            })
        ),

        Datatype(
            { name: "PowerAdjustCapabilityStruct", type: "struct", xref: "cluster§9.2.7.11" },

            Field(
                {
                    name: "PowerAdjustCapability", id: 0x0, type: "list", conformance: "M", constraint: "max 8",
                    quality: "X", xref: "cluster§9.2.7.12",

                    details: "This field shall indicate how the ESA can be adjusted at the current time." +
                        "\n" +
                        "For example, a battery storage inverter may need to regulate its internal temperature, or the " +
                        "charging rate of the battery may be limited due to cold temperatures, or a change in the state of " +
                        "charge of the battery may mean that the maximum charging or discharging rate is limited." +
                        "\n" +
                        "An empty list shall indicate that no power adjustment is currently possible." +
                        "\n" +
                        "Multiple entries in the list allow indicating that permutations of scenarios may be possible." +
                        "\n" +
                        "For example, a 10kWh battery could be at 80% state of charge. If charging at 2kW, then it would be " +
                        "full in 1 hour. However, it could be discharged at 2kW for 4 hours." +
                        "\n" +
                        "In this example the list of PowerAdjustStructs allows multiple scenarios to be offered as follows:"
                },

                Field({ name: "entry", type: "PowerAdjustStruct" })
            ),

            Field({ name: "Cause", id: 0x1, type: "PowerAdjustReasonEnum", conformance: "M" })
        ),

        Datatype(
            {
                name: "ForecastStruct", type: "struct", xref: "cluster§9.2.7.13",

                details: "This indicates a list of 'slots' describing the overall timing of the ESA’s planned energy and power " +
                    "use, with different power and energy demands per slot. For example, slots might be used to describe " +
                    "the distinct stages of a washing machine cycle." +
                    "\n" +
                    "Where an ESA does not know the actual power and energy use of the system, it may support the SFR " +
                    "feature and instead report its internal state."
            },

            Field({
                name: "ForecastId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.2.7.13.1",

                details: "This field shall indicate the sequence number for the current forecast. If the ESA updates a " +
                    "forecast, it shall monotonically increase this value." +
                    "\n" +
                    "The ESA does not need to persist this value across reboots, since the EMS SHOULD be able to detect " +
                    "that any previous subscriptions are lost if a device reboots. The loss of a subscription and " +
                    "subsequent re-subscription allows the EMS to learn about any new forecasts." +
                    "\n" +
                    "The value of ForecastID is allowed to wrap."
            }),

            Field({
                name: "ActiveSlotNumber", id: 0x1, type: "uint16", conformance: "M", quality: "X",
                xref: "cluster§9.2.7.13.2",
                details: "This field shall indicate which element of the Slots list is currently active in the Forecast " +
                    "sequence. A null value indicates that the sequence has not yet started."
            }),

            Field({
                name: "StartTime", id: 0x2, type: "epoch-s", conformance: "M", xref: "cluster§9.2.7.13.3",
                details: "This field shall indicate the planned start time, in UTC, for the entire Forecast."
            }),
            Field({
                name: "EndTime", id: 0x3, type: "epoch-s", conformance: "M", xref: "cluster§9.2.7.13.4",
                details: "This field shall indicate the planned end time, in UTC, for the entire Forecast."
            }),

            Field({
                name: "EarliestStartTime", id: 0x4, type: "epoch-s", conformance: "STA", quality: "X",
                xref: "cluster§9.2.7.13.5",
                details: "This field shall indicate the earliest start time, in UTC, that the entire Forecast can be shifted " +
                    "to. A null value indicates that it can be started immediately."
            }),

            Field({
                name: "LatestEndTime", id: 0x5, type: "epoch-s", conformance: "STA", xref: "cluster§9.2.7.13.6",
                details: "This field shall indicate the latest end time, in UTC, for the entire Forecast." +
                    "\n" +
                    "e.g. for an EVSE charging session, this may indicate the departure time for the vehicle, by which " +
                    "time the charging session must end."
            }),

            Field({
                name: "IsPausable", id: 0x6, type: "bool", conformance: "M", xref: "cluster§9.2.7.13.7",
                details: "This field shall indicate that some part of the Forecast can be paused. It aims to allow a client to " +
                    "read this flag and if it is false, then none of the slots contain SlotIsPausable set to true. This " +
                    "can save a client from having to check each slot in the list."
            }),

            Field(
                {
                    name: "Slots", id: 0x7, type: "list", conformance: "M", constraint: "max 10",
                    xref: "cluster§9.2.7.13.8",
                    details: "This field shall contain a list of SlotStructs." +
                        "\n" +
                        "It shall contain at least 1 entry, and a maximum of 10."
                },

                Field({ name: "entry", type: "SlotStruct" })
            ),

            Field({
                name: "ForecastUpdateReason", id: 0x8, type: "ForecastUpdateReasonEnum", conformance: "M",
                xref: "cluster§9.2.7.13.9",
                details: "This field shall contain the reason the current Forecast was generated."
            })
        ),

        Datatype(
            {
                name: "SlotStruct", type: "struct", xref: "cluster§9.2.7.14",
                details: "This indicates a specific stage of an ESA’s operation."
            },
            Field({
                name: "MinDuration", id: 0x0, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.14.1",
                details: "This field shall indicate the minimum time (in seconds) that the appliance expects to be in this " +
                    "slot for."
            }),
            Field({
                name: "MaxDuration", id: 0x1, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.14.2",
                details: "This field shall indicate the maximum time (in seconds) that the appliance expects to be in this " +
                    "slot for."
            }),
            Field({
                name: "DefaultDuration", id: 0x2, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.14.3",
                details: "This field shall indicate the expected time (in seconds) that the appliance expects to be in this " +
                    "slot for."
            }),

            Field({
                name: "ElapsedSlotTime", id: 0x3, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.14.4",

                details: "This field shall indicate the time (in seconds) that has already elapsed whilst in this slot. If the " +
                    "slot has not yet been started, then it shall be 0. Once the slot has been completed, then this " +
                    "reflects how much time was spent in this slot." +
                    "\n" +
                    "When subscribed to, a change in this field value shall NOT cause the Forecast attribute to be " +
                    "updated since this value may change every 1 second." +
                    "\n" +
                    "When the Forecast attribute is read, then this value shall be the most recent value."
            }),

            Field({
                name: "RemainingSlotTime", id: 0x4, type: "elapsed-s", conformance: "M", xref: "cluster§9.2.7.14.5",

                details: "This field shall indicate the time (in seconds) that is estimated to be remaining." +
                    "\n" +
                    "Note that it may not align to the DefaultDuration - ElapsedSlotTime since an appliance may have " +
                    "revised its planned operation based on conditions." +
                    "\n" +
                    "When subscribed to, a change in this field value shall NOT cause the Forecast attribute to be " +
                    "updated, since this value may change every 1 second." +
                    "\n" +
                    "Note that if the ESA is currently paused, then this value shall NOT change." +
                    "\n" +
                    "When the Forecast attribute is read, then this value shall be the most recent value."
            }),

            Field({
                name: "SlotIsPausable", id: 0x5, type: "bool", conformance: "PAU", xref: "cluster§9.2.7.14.6",
                details: "This field shall indicate whether this slot can be paused."
            }),

            Field({
                name: "MinPauseDuration", id: 0x6, type: "elapsed-s", conformance: "PAU",
                xref: "cluster§9.2.7.14.7",
                details: "This field shall indicate the shortest period that the slot can be paused for. This can be set to " +
                    "avoid controllers trying to pause ESAs for short periods and then resuming operation in a cyclic " +
                    "fashion which may damage or cause excess energy to be consumed with restarting of an operation."
            }),

            Field({
                name: "MaxPauseDuration", id: 0x7, type: "elapsed-s", conformance: "PAU",
                xref: "cluster§9.2.7.14.8",
                details: "This field shall indicate the longest period that the slot can be paused for."
            }),

            Field({
                name: "ManufacturerEsaState", id: 0x8, type: "uint16", conformance: "SFR",
                xref: "cluster§9.2.7.14.9",

                details: "This field shall indicate a manufacturer defined value indicating the state of the ESA." +
                    "\n" +
                    "This may be used by an observing EMS which also has access to the metering data to ascertain the " +
                    "typical power drawn when the ESA is in a manufacturer defined state." +
                    "\n" +
                    "Some appliances, such as smart thermostats, may not know how much power is being drawn by the HVAC " +
                    "system, but do know what they have asked the HVAC system to do." +
                    "\n" +
                    "Manufacturers can use this value to indicate a variety of states in an unspecified way. For example, " +
                    "they may choose to use values between 0-100 as a percentage of compressor modulation, or could use " +
                    "these values as Enum states meaning heating with fan, heating without fan etc." +
                    "\n" +
                    "NOTE An ESA shall always use the same value to represent the same operating state." +
                    "\n" +
                    "By providing this information a smart EMS may be able to learn the observed power draw when the ESA " +
                    "is put into a specific state. It can potentially then use the ManufacturerESAState field in the " +
                    "Forecast attribute along with observed power drawn to predict the power draw from the appliance and " +
                    "potentially ask it to modify its timing via one of the adjustment request commands, or adjust other " +
                    "ESAs power to compensate."
            }),

            Field({
                name: "NominalPower", id: 0x9, type: "power-mW", conformance: "PFR", xref: "cluster§9.2.7.14.10",
                details: "This field shall indicate the expected power that the appliance will use during this slot. It may be " +
                    "considered the average value over the slot, and some variation from this would be expected (for " +
                    "example, as it is ramping up)."
            }),

            Field({
                name: "MinPower", id: 0xa, type: "power-mW", conformance: "PFR", xref: "cluster§9.2.7.14.11",
                details: "This field shall indicate the lowest power that the appliance expects to use during this slot. (e.g. " +
                    "during a ramp up it may be 0W)." +
                    "\n" +
                    "Some appliances (e.g. battery inverters which can charge and discharge) may have a negative power."
            }),

            Field({
                name: "MaxPower", id: 0xb, type: "power-mW", conformance: "PFR", xref: "cluster§9.2.7.14.12",
                details: "This field shall indicate the maximum power that the appliance expects to use during this slot. " +
                    "(e.g. during a ramp up it may be 0W). This field ignores the effects of short-lived inrush currents." +
                    "\n" +
                    "Some appliances (e.g. battery inverters which can charge and discharge) may have a negative power."
            }),

            Field({
                name: "NominalEnergy", id: 0xc, type: "energy-mWh", conformance: "PFR", xref: "cluster§9.2.7.14.13",
                details: "This field shall indicate the expected energy that the appliance expects to use or produce during " +
                    "this slot." +
                    "\n" +
                    "Some appliances (e.g. battery inverters which can charge and discharge) may have a negative energy."
            }),

            Field(
                {
                    name: "Costs", id: 0xd, type: "list", conformance: "O", constraint: "max 5",
                    xref: "cluster§9.2.7.14.14",

                    details: "This field shall indicate the current estimated cost for operating." +
                        "\n" +
                        "For example, if the device has access to an Energy pricing server it may be able to use the tariff " +
                        "to estimate the cost of energy for this slot in the power forecast." +
                        "\n" +
                        "When an Energy Management System requests a change in the schedule, then the device may suggest a " +
                        "change in the cost as a result of shifting its energy. This can allow a demand side response service " +
                        "to be informed of the relative cost to use energy at a different time." +
                        "\n" +
                        "The Costs field is a list of CostStruct structures which allows multiple CostTypeEnum and Values to " +
                        "be shared by the energy appliance. These could be based on GHG emissions, comfort value for the " +
                        "consumer etc." +
                        "\n" +
                        "For example, comfort could be expressed in abstract units or in currency. A water heater that is " +
                        "heated earlier in the day is likely to lose some of its heat before it is needed, which could " +
                        "require a top-up heating event to occur later in the day (which may incur additional cost)." +
                        "\n" +
                        "If the ESA cannot calculate its cost for any reason (such as losing its connection to a Price " +
                        "server) it may omit this field. This is treated as extra meta data that an EMS may use to optimize a " +
                        "system."
                },

                Field({ name: "entry", type: "CostStruct" })
            ),

            Field({
                name: "MinPowerAdjustment", id: 0xe, type: "power-mW", conformance: "FA & PFR",
                xref: "cluster§9.2.7.14.15",

                details: "This field shall indicate the minimum power that the appliance can be requested to use." +
                    "\n" +
                    "For example, some EVSEs cannot be switched on to charge below 6A which may equate to ~1.3kW in EU " +
                    "markets. If the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this " +
                    "allows an ESA to indicate it could be switched on to charge, but this would be the minimum power " +
                    "limit it can be set to."
            }),

            Field({
                name: "MaxPowerAdjustment", id: 0xf, type: "power-mW", conformance: "FA & PFR",
                xref: "cluster§9.2.7.14.16",

                details: "This field shall indicate the maximum power that the appliance can be requested to use." +
                    "\n" +
                    "For example, an EVSE may be limited by its electrical supply to 32A which would be ~7.6kW in EU " +
                    "markets. If the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this " +
                    "allows an ESA to indicate it could be switched on to charge, but this would be the maximum power " +
                    "limit it can be set to."
            }),

            Field({
                name: "MinDurationAdjustment", id: 0x10, type: "elapsed-s", conformance: "FA",
                xref: "cluster§9.2.7.14.17",

                details: "This field shall indicate the minimum time, in seconds, that the slot can be requested to shortened " +
                    "to." +
                    "\n" +
                    "For example, if the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this " +
                    "would allow an ESA to specify the minimum time it could be switched on for. This is to help protect " +
                    "the appliance from being damaged by short cycling times." +
                    "\n" +
                    "For example, a heat pump compressor may have a minimum cycle time of order a few minutes."
            }),

            Field({
                name: "MaxDurationAdjustment", id: 0x11, type: "elapsed-s", conformance: "FA",
                xref: "cluster§9.2.7.14.18",

                details: "This field shall indicate the maximum time, in seconds, that the slot can be requested to extended " +
                    "to." +
                    "\n" +
                    "For example, if the slot indicates a NominalPower of 0W (indicating it is expecting to be off), this " +
                    "allows an ESA to specify the maximum time it could be switched on for. This may allow a battery or " +
                    "water heater to indicate the maximum duration that it can charge for before becoming full. In the " +
                    "case of a battery inverter which can be discharged, it may equally indicate the maximum time the " +
                    "battery could be discharged for (at the MaxPowerAdjustment power level)."
            })
        ),

        Datatype(
            { name: "SlotAdjustmentStruct", type: "struct", xref: "cluster§9.2.7.15" },

            Field({
                name: "SlotIndex", id: 0x0, type: "uint8", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.7.15.1",
                details: "This field shall indicate the index into the Slots list within the Forecast that is to be modified. " +
                    "It shall be less than the actual length of the Slots list (implicitly it must be in the range 0 to 9 " +
                    "based on the maximum length of the Slots list constraint)."
            }),

            Field({
                name: "NominalPower", id: 0x1, type: "power-mW", conformance: "PFR", constraint: "desc",
                xref: "cluster§9.2.7.15.2",
                details: "This field shall indicate the new requested power that the ESA shall operate at. It MUST be between " +
                    "the AbsMinPower and AbsMaxPower attributes as advertised by the ESA if it supports PFR." +
                    "\n" +
                    "This is a signed value and can be used to indicate charging or discharging. If the ESA does NOT " +
                    "support PFR this value shall be ignored by the ESA."
            }),

            Field({
                name: "Duration", id: 0x2, type: "elapsed-s", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.7.15.3",
                details: "This field shall indicate the new requested duration, in seconds, that the ESA shall extend or " +
                    "shorten the slot duration to. It MUST be between the MinDurationAdjustment and MaxDurationAdjustment " +
                    "for the slot as advertised by the ESA."
            })
        ),

        Datatype(
            {
                name: "ConstraintsStruct", type: "struct", xref: "cluster§9.2.7.16",
                details: "The ConstraintsStruct allows a client to inform an ESA about a constraint period (such as a grid " +
                    "event, or perhaps excess solar PV). The format allows the client to suggest that the ESA can either " +
                    "turn up its energy consumption, or turn down its energy consumption during this period."
            },

            Field({
                name: "StartTime", id: 0x0, type: "epoch-s", conformance: "M", constraint: "desc",
                xref: "cluster§9.2.7.16.1",
                details: "This field shall indicate the start time of the constraint period that the client wishes the ESA to " +
                    "compute a new Forecast." +
                    "\n" +
                    "This value is in UTC and MUST be in the future."
            }),

            Field({
                name: "Duration", id: 0x1, type: "elapsed-s", conformance: "M", constraint: "max 86400",
                xref: "cluster§9.2.7.16.2",
                details: "This field shall indicate the duration of the constraint in seconds."
            }),

            Field({
                name: "NominalPower", id: 0x2, type: "power-mW", conformance: "PFR", constraint: "desc",
                xref: "cluster§9.2.7.16.3",
                details: "This field shall indicate the nominal power that client wishes the ESA to operate at during the " +
                    "constrained period. It MUST be between the AbsMinPower and AbsMaxPower attributes as advertised by " +
                    "the ESA if it supports PFR." +
                    "\n" +
                    "This is a signed value and can be used to indicate charging or discharging."
            }),

            Field({
                name: "MaximumEnergy", id: 0x3, type: "energy-mWh", conformance: "PFR", xref: "cluster§9.2.7.16.4",
                details: "This field shall indicate the maximum energy that can be transferred to or from the ESA during the " +
                    "constraint period." +
                    "\n" +
                    "This is a signed value and can be used to indicate charging or discharging."
            }),

            Field({
                name: "LoadControl", id: 0x4, type: "int8", conformance: "SFR", xref: "cluster§9.2.7.16.5",

                details: "This field shall indicate the turn up or turn down nature that the grid wants as the outcome by the " +
                    "ESA during the constraint period." +
                    "\n" +
                    "This is expressed as a signed value between -100 to +100. A value of 0 would indicate no bias to " +
                    "using more or less energy. A negative value indicates a request to use less energy. A positive value " +
                    "indicates a request to use more energy." +
                    "\n" +
                    "Note that the mapping between values and operation is manufacturer specific."
            })
        )
    ),

    Cluster(
        {
            name: "EnergyEvse", id: 0x99, classification: "application", pics: "EEVSE", xref: "cluster§9.3",

            details: "Electric Vehicle Supply Equipment (EVSE) is equipment used to charge an Electric Vehicle (EV) or " +
                "Plug-In Hybrid Electric Vehicle. This cluster provides an interface to the functionality of Electric " +
                "Vehicle Supply Equipment (EVSE) management." +
                "\n" +
                "Devices targeted by this cluster include Electric Vehicle Supply Equipment (EVSE). The cluster " +
                "generically assumes a signaling protocol (J1772 in NA and IEC61851 in Europe and Asia) between the " +
                "EVSE and Electric Vehicle (EV) that utilizes a pilot signal to manage the states of the charging " +
                "process. [SAE J2847/3_202311] version and IEC61841 define Pilot signal as a modulated DC voltage on " +
                "a single wire." +
                "\n" +
                "Power Line Communication (PLC) is supported by some EVSEs (e.g. for support of ISO 15118 in Europe " +
                "and SAE J2931/4 in NA) and may enable features such as Vehicle to Grid (V2G) or Vehicle to Home " +
                "(V2H) that allows for bi-directional charging/discharging of electric vehicles." +
                "\n" +
                "More modern EVSE devices may optionally support ISO 15118-20 in Europe and SAE J2836/3 for NA to " +
                "support bi-directional charging (Vehicle to Grid - V2G) and Plug and Charge capabilities." +
                "\n" +
                "This cluster definition assumes AC charging only. DC charging options may be added in future " +
                "revisions of this cluster." +
                "\n" +
                "This cluster supports a safety mechanism that may lockout remote operation until the initial " +
                "latching conditions have been met. Some of the fault conditions defined in SAE J1772, such as " +
                "Ground- Fault Circuit Interrupter (GFCI) or Charging Circuit Interrupting Device (CCID), may require " +
                "clearing by an operator by, for example, pressing a button on the equipment or breaker panel." +
                "\n" +
                "This EVSE cluster is written around support of a single EVSE. Having multiple EVSEs at home or a " +
                "business is managed by backend system and outside scope of this cluster." +
                "\n" +
                "Note that in many deployments the EVSE may be outside the home and may suffer from intermittent " +
                "network connections (e.g. a weak Wi-Fi signal). It also allows for a charging profile to be " +
                "pre-configured, in case there is a temporary communications loss during a charging session."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.3.4" },

            Field({
                name: "PREF", conformance: "M", constraint: "0", title: "ChargingPreferences",
                xref: "cluster§9.3.4.1",

                details: "Since some EVSEs cannot obtain the SoC from the vehicle, some EV charging solutions allow the " +
                    "consumer to specify a daily charging target (for adding energy to the EV’s battery). This feature " +
                    "allows the consumer to specify how many miles or km of additional range they need for their typical " +
                    "daily commute. This range requirement can be converted into a daily energy demand with a target " +
                    "charging completion time." +
                    "\n" +
                    "The EVSE itself can use this information (or may allow a controller such as an EMS) to compute an " +
                    "optimized charging schedule." +
                    "\n" +
                    "An EVSE device which includes a Device Energy Management device with the Device Energy Management " +
                    "cluster PFR (Power Forecast Reporting) feature can use the charging preferences information to " +
                    "produce its power forecast." +
                    "\n" +
                    "EVSE devices that support the Device Energy Management cluster’s FA feature can have their charging " +
                    "profiles set by a controller device such as an EMS. For example, if the EVSE advertises a simple " +
                    "power forecast which allows the EMS to adjust over a wide range of power and time durations, then " +
                    "the EVSE may allow the EMS to propose a revised optimized forecast (which is the charging profile). " +
                    "For example, a solar PV ESA may also share its Forecast, so enabling an EMS to adjust the EVSE " +
                    "forecast to the best time to charge so that any excess solar generation is used to charge the EV." +
                    "\n" +
                    "See the Device Energy Management Cluster for more details."
            }),

            Field({
                name: "SOC", conformance: "P, O", constraint: "1", title: "SoCReporting", xref: "cluster§9.3.4.2",

                details: "Vehicles and EVSEs which support ISO 15118 may allow the vehicle to report its battery size and " +
                    "state of charge. If the EVSE supports PLC it may have a vehicle connected which optionally supports " +
                    "reporting of its battery size and current State of Charge (SoC)." +
                    "\n" +
                    "If the EVSE supports reporting of State of Charge this feature will only work if a compatible EV is " +
                    "connected." +
                    "\n" +
                    "Note some EVSEs may use other undefined mechanisms to obtain vehicle State of Charge outside the " +
                    "scope of this cluster."
            }),

            Field({
                name: "PNC", conformance: "P, O", constraint: "2", title: "PlugAndCharge", xref: "cluster§9.3.4.3",
                details: "If the EVSE supports PLC, it may be able to support the Plug and Charge feature. e.g. this may allow " +
                    "the vehicle ID to be obtained which may allow an energy management system to track energy usage per " +
                    "vehicle (e.g. to give the owner an indicative cost of charging, or for work place charging)." +
                    "\n" +
                    "If the EVSE supports the Plug and Charge feature, it will only work if a compatible EV is connected."
            }),

            Field({
                name: "RFID", conformance: "O", constraint: "3", title: "Rfid", xref: "cluster§9.3.4.4",

                details: "If the EVSE is fitted with an RFID reader, it may be possible to obtain the User or Vehicle ID from " +
                    "an RFID card. This may be used to record a charging session against a specific charging account, and " +
                    "may optionally be used to authorize a charging session." +
                    "\n" +
                    "An RFID event can be generated when a user taps an RFID card onto the RFID reader. The event must be " +
                    "subscribed to by the EVSE Management cluster client. This client may use this to enable the EV to " +
                    "charge or discharge. The lookup and authorization of RIFD UID is outside the scope of this cluster."
            }),

            Field({
                name: "V2X", conformance: "P, O", constraint: "4", title: "V2X", xref: "cluster§9.3.4.5",

                details: "If the EVSE can support bi-directional charging, it may be possible to request that the vehicle can " +
                    "discharge to the home or grid." +
                    "\n" +
                    "The charging and discharging may be controlled by a home Energy Management System (EMS) using the " +
                    "Device Energy Management cluster of the associated Device Energy Management device. For example, an " +
                    "EMS may use the PA (Power Adjustment) feature to continually adjust the charge/discharge current " +
                    "to/from the EV so as to minimise the energy flow from/to the grid as the demand in the home and the " +
                    "solar supply to the home both fluctuate."
            })
        ),

        Attribute({
            name: "State", id: 0x0, type: "StateEnum", access: "R V", conformance: "M", quality: "X",
            xref: "cluster§9.3.8.1",

            details: "Indicates the current status of the EVSE. This higher-level status is partly derived from the " +
                "signaling protocol as communicated between the EVSE and the vehicle through the pilot signal." +
                "\n" +
                "The State attribute shall change when the EVSE detects change of condition of the EV (plugged in or " +
                "unplugged, whether the vehicle is asking for demand or not, and if it is charging or discharging)." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> SessionEnding is not really a state but a transition. However, the transition period may take a " +
                "  few seconds and is useful for some clean up purposes." +
                "\n" +
                "The Fault state is used to indicate that the FaultState attribute is not NoError." +
                "\n" +
                "A null value shall indicate that the state cannot be determined."
        }),

        Attribute({
            name: "SupplyState", id: 0x1, type: "SupplyStateEnum", access: "R V", conformance: "M",
            xref: "cluster§9.3.8.2",
            details: "Indicates whether the EV is currently allowed to charge from or discharge to the EVSE."
        }),

        Attribute({
            name: "FaultState", id: 0x2, type: "FaultStateEnum", access: "R V", conformance: "M",
            xref: "cluster§9.3.8.3",
            details: "Indicates the type of fault detected by the EVSE (internally or as detected in the pilot signal)." +
                "\n" +
                "When the SupplyState attribute is DisabledError, the FaultState attribute will be one of the values " +
                "listed in FaultStateEnum, except NoError. For all values of SupplyState other than DisabledError, " +
                "the FaultState attribute shall be NoError."
        }),

        Attribute({
            name: "ChargingEnabledUntil", id: 0x3, type: "epoch-s", access: "R V", conformance: "M",
            quality: "X N", xref: "cluster§9.3.8.4",

            details: "Indicates the time, in UTC, that the EVSE will automatically stop current flow to the EV." +
                "\n" +
                "A null value indicates the EVSE is always enabled for charging." +
                "\n" +
                "A value in the past or 0x0 indicates that EVSE charging shall be disabled. The attribute is only set " +
                "via the payload of the EnableCharging command." +
                "\n" +
                "This attribute shall be persisted, for example a temporary power failure should not stop the vehicle " +
                "from being charged."
        }),

        Attribute({
            name: "DischargingEnabledUntil", id: 0x4, type: "epoch-s", access: "R V", conformance: "V2X",
            quality: "X N", xref: "cluster§9.3.8.5",

            details: "Indicates the time, in UTC, that the EVSE will automatically stop current flow from the EV." +
                "\n" +
                "A null value indicates the EVSE is always enabled for discharging." +
                "\n" +
                "A value in the past or 0x0 indicates that EVSE discharging shall be disabled. The attribute is only " +
                "set via the payload of the EnableDischarging command." +
                "\n" +
                "This attribute shall be persisted, for example a temporary power failure should not stop the vehicle " +
                "from being discharged."
        }),

        Attribute({
            name: "CircuitCapacity", id: 0x5, type: "amperage-mA", access: "R V", conformance: "M",
            constraint: "min 0", quality: "N", xref: "cluster§9.3.8.6",
            details: "Indicates the capacity that the circuit that the EVSE is connected to can provide. It is intended to " +
                "allow implementation of a self-managed network of EVSEs. It is assumed that the device will allow " +
                "the setting of such values by an installer."
        }),

        Attribute({
            name: "MinimumChargeCurrent", id: 0x6, type: "amperage-mA", access: "R V", conformance: "M",
            constraint: "min 0", quality: "N", xref: "cluster§9.3.8.7",
            details: "Indicates the minimum current that can be delivered by the EVSE to the EV." +
                "\n" +
                "The attribute can be set using the EnableCharging command."
        }),

        Attribute({
            name: "MaximumChargeCurrent", id: 0x7, type: "amperage-mA", access: "R V", conformance: "M",
            constraint: "min 0", quality: "N", xref: "cluster§9.3.8.8",

            details: "Indicates the maximum current that can be delivered by the EVSE to the EV." +
                "\n" +
                "This shall represent the actual maximum current offered to the EV at any time. Note that the EV can " +
                "draw less current than this value. For example, the EV may be limiting its power draw based on the " +
                "operating conditions of the battery, such as temperature and state of charge." +
                "\n" +
                "The attribute can be initially set using the EnableCharging command or by adjusting the " +
                "UserMaximumChargeCurrent attribute." +
                "\n" +
                "This attribute value shall be the minimum of:" +
                "\n" +
                "  • CircuitCapacity - Electrician’s installation setting" +
                "\n" +
                "  • CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)" +
                "\n" +
                "  • MaximumChargeCurrent field in the EnableCharging command" +
                "\n" +
                "  • UserMaximumChargeCurrent attribute"
        }),

        Attribute({
            name: "MaximumDischargeCurrent", id: 0x8, type: "amperage-mA", access: "R V", conformance: "V2X",
            constraint: "min 0", quality: "N", xref: "cluster§9.3.8.9",

            details: "Indicates the maximum current that can be received by the EVSE from the EV. This attribute can be " +
                "set using the EnableDischarging command." +
                "\n" +
                "This attribute value shall be the minimum of:" +
                "\n" +
                "  • CircuitCapacity - Electrician’s installation setting" +
                "\n" +
                "  • CableAssemblyCurrentLimit (detected by the EVSE when the cable is plugged in)" +
                "\n" +
                "  • MaximumDischargeCurrent field in the EnableDischarging command"
        }),

        Attribute({
            name: "UserMaximumChargeCurrent", id: 0x9, type: "amperage-mA", access: "RW VM", conformance: "O",
            constraint: "desc", default: 0, quality: "N", xref: "cluster§9.3.8.10",

            details: "Indicates a maximum current that can set by the consumer (e.g. via an app) as a preference to " +
                "further reduce the charging rate. This may be desirable if the home owner has a solar PV or battery " +
                "storage system which may only be able to deliver a limited amount of power. The consumer can " +
                "manually control how much they allow the EV to take." +
                "\n" +
                "This attribute value shall be limited by the EVSE to be in the range of:" +
                "\n" +
                "MinimumChargeCurrent <= UserMaximumChargeCurrent <= MaximumChargeCurrent where MinimumChargeCurrent " +
                "and MaximumChargeCurrent are the values received in the EnableCharging command." +
                "\n" +
                "Its default value SHOULD be initialized to the same as the CircuitCapacity attribute. This value " +
                "shall be persisted across reboots to ensure it does not cause charging issues during temporary power " +
                "failures."
        }),

        Attribute({
            name: "RandomizationDelayWindow", id: 0xa, type: "elapsed-s", access: "RW VM", conformance: "O",
            constraint: "max 86400", default: 600, quality: "N", xref: "cluster§9.3.8.11",

            details: "Indicates the size of a random window over which the EVSE will randomize the start of a charging " +
                "session. This value is in seconds." +
                "\n" +
                "This is a feature that is mandated in some markets (such as UK) where the EVSE should by default " +
                "randomize its start time within the randomization window. By default in the UK this should be 600s." +
                "\n" +
                "For example, if the RandomizationDelayWindow is 600s (i.e. 10 minutes) and if there was a cheap rate " +
                "energy starting at 00:30, then the EVSE must compute a random delay between 0-599s and add this to " +
                "its initial planned start time."
        }),

        Attribute({
            name: "NextChargeStartTime", id: 0x23, type: "epoch-s", access: "R V", conformance: "PREF",
            quality: "X", xref: "cluster§9.3.8.12",

            details: "Indicates the time, in UTC, when the EVSE plans to start the next scheduled charge based on the " +
                "charging preferences." +
                "\n" +
                "A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use " +
                "Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that " +
                "charging is enabled."
        }),

        Attribute({
            name: "NextChargeTargetTime", id: 0x24, type: "epoch-s", access: "R V", conformance: "PREF",
            quality: "X", xref: "cluster§9.3.8.13",

            details: "Indicates the time, in UTC, when the EVSE SHOULD complete the next scheduled charge based on the " +
                "charging preferences." +
                "\n" +
                "A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use " +
                "Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that " +
                "charging is enabled."
        }),

        Attribute({
            name: "NextChargeRequiredEnergy", id: 0x25, type: "energy-mWh", access: "R V", conformance: "PREF",
            constraint: "min 0", quality: "X", xref: "cluster§9.3.8.14",

            details: "Indicates the amount of energy that the EVSE is going to attempt to add to the vehicle in the next " +
                "charging target." +
                "\n" +
                "A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use " +
                "Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that " +
                "charging is enabled, or that the next ChargingTargetStruct is using the TargetSoC value to charge " +
                "the vehicle."
        }),

        Attribute({
            name: "NextChargeTargetSoC", id: 0x26, type: "percent", access: "R V", conformance: "PREF",
            quality: "X", xref: "cluster§9.3.8.15",

            details: "Indicates the target SoC the EVSE is going to attempt to reach when the vehicle is next charged." +
                "\n" +
                "A null value indicates that there is no scheduled charging (for example, the EVSE Mode is set to use " +
                "Manual mode tag), or that the vehicle is not plugged in with the SupplyState indicating that " +
                "charging is enabled, or that the next ChargingTargetStruct is using the AddedEnergy value to charge " +
                "the vehicle." +
                "\n" +
                "If the SOC feature is not supported, only the values null and 100% are supported."
        }),

        Attribute(
            {
                name: "ApproximateEvEfficiency", id: 0x27, type: "uint16", access: "RW VM", conformance: "[PREF]",
                constraint: "desc", default: null, quality: "X N", xref: "cluster§9.3.8.16",

                details: "Indicates the vehicle efficiency rating for a connected vehicle." +
                    "\n" +
                    "This can be used to help indicate to the user approximately how many miles or km of range will be " +
                    "added. It allows user interfaces to display to the user simpler terms that they can relate to " +
                    "compared to kWh." +
                    "\n" +
                    "This is value is stored in km per kWh multiplied by a scaling factor of 1000." +
                    "\n" +
                    "A null value indicates that the EV efficiency is unknown and the NextChargeRequiredEnergy attribute " +
                    "cannot be converted from Wh to miles or km." +
                    "\n" +
                    "To convert from Wh into Range:" +
                    "\n" +
                    "AddedRange (km) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) AddedRange (Miles) = " +
                    "AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) x 0.6213" +
                    "\n" +
                    "Example:" +
                    "\n" +
                    "ApproxEVEfficiency (km/kWh x 1000): 4800 (i.e. 4.8km/kWh x 1000)" +
                    "\n" +
                    "### AddedEnergy (Wh): 10,000" +
                    "\n" +
                    "AddedRange (km) = 10,000 x 4800 / 1,000,000 = 48 km" +
                    "\n" +
                    "AddedRange (Miles) = AddedEnergy (Wh) x ApproxEVEfficiency (km/kWh x 1000) x" +
                    "\n" +
                    "0.6213" +
                    "\n" +
                    "= 29.82 Miles"
            }
        ),

        Attribute({
            name: "StateOfCharge", id: 0x30, type: "percent", access: "R V", conformance: "SOC", quality: "X",
            xref: "cluster§9.3.8.17",
            details: "Indicates the state of charge of the EV battery in steps of 1%. The values are in the 0-100%. This " +
                "attribute is only available on EVSEs which can read the state of charge from the vehicle and that " +
                "support the SOC feature. If the StateOfCharge cannot be read from the vehicle it shall be returned " +
                "with a NULL value."
        }),

        Attribute({
            name: "BatteryCapacity", id: 0x31, type: "energy-mWh", access: "R V", conformance: "SOC",
            constraint: "min 0", quality: "X", xref: "cluster§9.3.8.18",
            details: "Indicates the capacity of the EV battery in mWh. This value is always positive."
        }),

        Attribute({
            name: "VehicleId", id: 0x32, type: "string", access: "R V", conformance: "PNC",
            constraint: "max 32", quality: "X", xref: "cluster§9.3.8.19",
            details: "Indicates the vehicle ID read by the EVSE via ISO-15118 using the PNC feature, if the EVSE supports " +
                "this capability." +
                "\n" +
                "The field may be based on the e-Mobility Account Identifier (EMAID). A null value shall indicate " +
                "that this is unknown."
        }),

        Attribute({
            name: "SessionId", id: 0x40, type: "uint32", access: "R V", conformance: "M", quality: "X N",
            xref: "cluster§9.3.8"
        }),
        Attribute({
            name: "SessionDuration", id: 0x41, type: "elapsed-s", access: "R V", conformance: "M",
            quality: "X N Q", xref: "cluster§9.3.8"
        }),
        Attribute({
            name: "SessionEnergyCharged", id: 0x42, type: "energy-mWh", access: "R V", conformance: "M",
            constraint: "min 0", quality: "X N Q", xref: "cluster§9.3.8"
        }),
        Attribute({
            name: "SessionEnergyDischarged", id: 0x43, type: "energy-mWh", access: "R V", conformance: "V2X",
            constraint: "min 0", quality: "X N Q", xref: "cluster§9.3.8"
        }),

        Event(
            {
                name: "EvConnected", id: 0x0, access: "V", conformance: "M", priority: "info",
                xref: "cluster§9.3.10.1",
                details: "This event shall be generated when the EV is plugged in."
            },
            Field({
                name: "SessionId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.3.10.1.1",
                details: "This is the new session ID created after the vehicle is plugged in."
            })
        ),

        Event(
            {
                name: "EvNotDetected", id: 0x1, access: "V", conformance: "M", priority: "info",
                xref: "cluster§9.3.10.2",
                details: "This event shall be generated when the EV is unplugged or not detected (having been previously " +
                    "plugged in). When the vehicle is unplugged then the session is ended."
            },

            Field({
                name: "SessionId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.3.10.2.1",
                details: "This field shall indicate the current value of the SessionID attribute."
            }),
            Field({
                name: "State", id: 0x1, type: "StateEnum", conformance: "M", xref: "cluster§9.3.10.2.2",
                details: "This field shall indicate the value of the State attribute prior to the EV not being detected."
            }),
            Field({
                name: "SessionDuration", id: 0x2, type: "elapsed-s", conformance: "M", xref: "cluster§9.3.10.2.3",
                details: "This field shall indicate the total duration of the session, from the start of the session when the " +
                    "EV was plugged in, until it was unplugged."
            }),

            Field({
                name: "SessionEnergyCharged", id: 0x3, type: "energy-mWh", conformance: "M", constraint: "min 0",
                xref: "cluster§9.3.10.2.4",

                details: "This field shall indicate the total amount of energy transferred from the EVSE to the EV during the " +
                    "session." +
                    "\n" +
                    "Note that if bi-directional charging occurs during the session, then this value shall only include " +
                    "the sum of energy transferred from the EVSE to the EV, and shall NOT be a net value of charging and " +
                    "discharging energy."
            }),

            Field({
                name: "SessionEnergyDischarged", id: 0x4, type: "energy-mWh", conformance: "V2X",
                constraint: "min 0", xref: "cluster§9.3.10.2.5",

                details: "This field shall indicate the total amount of energy transferred from the EV to the EVSE during the " +
                    "session." +
                    "\n" +
                    "Note that if bi-directional discharging occurs during the session, then this value shall only " +
                    "include the sum of energy transferred from the EV to the EVSE, and shall NOT be a net value of " +
                    "charging and discharging energy."
            })
        ),

        Event(
            {
                name: "EnergyTransferStarted", id: 0x2, access: "V", conformance: "M", priority: "info",
                xref: "cluster§9.3.10.3",
                details: "This event shall be generated whenever the EV starts charging or discharging, except when an EV has " +
                    "switched between charging and discharging under the control of the PowerAdjustment feature of the " +
                    "Device Energy Management cluster of the associated Device Energy Management device."
            },

            Field({
                name: "SessionId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.3.10.3.1",
                details: "This field shall indicate the value of the SessionID attribute at the time the event was generated."
            }),
            Field({
                name: "State", id: 0x1, type: "StateEnum", conformance: "M", xref: "cluster§9.3.10.3.2",
                details: "This field shall indicate the value of the State attribute at the time the event was generated."
            }),

            Field({
                name: "MaximumCurrent", id: 0x2, type: "amperage-mA", conformance: "M", constraint: "min 0",
                xref: "cluster§9.3.10.3.3",

                details: "This field shall indicate the value of the maximum charging current at the time the event was " +
                    "generated." +
                    "\n" +
                    "A non-zero value indicates that the EV has been enabled for charging and the value is taken directly " +
                    "from the MaximumChargeCurrent attribute. A zero value indicates that the EV has not been enabled for " +
                    "charging."
            }),

            Field({
                name: "MaximumDischargeCurrent", id: 0x3, type: "amperage-mA", conformance: "V2X",
                constraint: "min 0", xref: "cluster§9.3.10.3.4",

                details: "This field shall indicate the value of the maximum discharging current at the time the event was " +
                    "generated." +
                    "\n" +
                    "A non-zero value indicates that the EV has been enabled for discharging and the value is taken " +
                    "directly from the MaximumDischargeCurrent attribute. A zero value indicates that the EV has not been " +
                    "enabled for discharging."
            })
        ),

        Event(
            {
                name: "EnergyTransferStopped", id: 0x3, access: "V", conformance: "M", priority: "info",
                xref: "cluster§9.3.10.4",
                details: "This event shall be generated whenever the EV stops charging or discharging, except when an EV has " +
                    "switched between charging and discharging under the control of the PowerAdjustment feature of the " +
                    "Device Energy Management cluster of the associated Device Energy Management device."
            },

            Field({
                name: "SessionId", id: 0x0, type: "uint32", conformance: "M", xref: "cluster§9.3.10.4.1",
                details: "This field shall indicate the value of the SessionID attribute prior to the energy transfer " +
                    "stopping."
            }),
            Field({
                name: "State", id: 0x1, type: "StateEnum", conformance: "M", xref: "cluster§9.3.10.4.2",
                details: "This field shall indicate the value of the State attribute prior to the energy transfer stopping."
            }),
            Field({
                name: "Reason", id: 0x2, type: "EnergyTransferStoppedReasonEnum", conformance: "M",
                xref: "cluster§9.3.10.4.3",
                details: "This field shall indicate the reason why the energy transferred stopped."
            }),

            Field({
                name: "EnergyTransferred", id: 0x4, type: "energy-mWh", conformance: "M", constraint: "min 0",
                xref: "cluster§9.3.10.4.4",
                details: "This field shall indicate the amount of energy transferred from the EVSE to the EV since the " +
                    "previous EnergyTransferStarted event, in mWh."
            }),

            Field({
                name: "EnergyDischarged", id: 0x5, type: "energy-mWh", conformance: "V2X", constraint: "min 0",
                xref: "cluster§9.3.10.4.5",
                details: "This field shall indicate the amount of energy transferred from the EV to the EVSE since the " +
                    "previous EnergyTransferStarted event, in mWh."
            })
        ),

        Event(
            {
                name: "Fault", id: 0x4, access: "V", conformance: "M", priority: "critical",
                xref: "cluster§9.3.10.5",

                details: "If the EVSE detects a fault it shall generate a Fault Event. The SupplyState attribute shall be set " +
                    "to DisabledError and the type of fault detected by the EVSE shall be stored in the FaultState " +
                    "attribute." +
                    "\n" +
                    "This event shall be generated when the FaultState changes from any error state. i.e. if it changes " +
                    "from NoError to any other state and if the error then clears, this would generate 2 events." +
                    "\n" +
                    "It is assumed that the fault will be cleared locally on the EVSE device. When all faults have been " +
                    "cleared, the EVSE device shall set the FaultState attribute to NoError and the SupplyState attribute " +
                    "shall be set back to its previous state."
            },

            Field({
                name: "SessionId", id: 0x0, type: "uint32", conformance: "M", quality: "X",
                xref: "cluster§9.3.10.5.1",
                details: "This field shall indicate the value of the SessionID attribute prior to the Fault State being " +
                    "changed. A value of null indicates no sessions have occurred before the fault occurred."
            }),

            Field({
                name: "State", id: 0x1, type: "StateEnum", conformance: "M", xref: "cluster§9.3.10.5.2",
                details: "This field shall indicate the value of the State attribute prior to the Fault State being changed."
            }),

            Field({
                name: "FaultStatePreviousState", id: 0x2, type: "FaultStateEnum", conformance: "M",
                xref: "cluster§9.3.10.5.3",
                details: "This field shall indicate the value of the FaultState attribute prior to the Fault State being " +
                    "changed."
            }),

            Field({
                name: "FaultStateCurrentState", id: 0x4, type: "FaultStateEnum", conformance: "M",
                xref: "cluster§9.3.10.5.4",
                details: "This field shall indicate the current value of the FaultState attribute."
            })
        ),

        Event(
            {
                name: "Rfid", id: 0x5, access: "V", conformance: "[RFID]", priority: "info",
                xref: "cluster§9.3.10.6",
                details: "This event shall be generated when a RFID card has been read. This allows a controller to register " +
                    "the card ID and use this to authenticate and start the charging session."
            },

            Field({
                name: "Uid", id: 0x0, type: "octstr", conformance: "M", constraint: "max 10",
                xref: "cluster§9.3.10.6.1",
                details: "The UID field (ISO 14443A UID) is either 4, 7 or 10 bytes."
            })
        ),

        Command({
            name: "Disable", id: 0x1, access: "O T", conformance: "M", direction: "request", response: "status",
            xref: "cluster§9.3.9.1",
            details: "Allows a client to disable the EVSE from charging and discharging."
        }),

        Command(
            {
                name: "EnableCharging", id: 0x2, access: "O T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§9.3.9.2",
                details: "This command allows a client to enable the EVSE to charge an EV, and to provide or update the " +
                    "maximum and minimum charge current."
            },

            Field({
                name: "ChargingEnabledUntil", id: 0x0, type: "epoch-s", conformance: "M", quality: "X",
                xref: "cluster§9.3.9.2.1",
                details: "This field shall indicate the expiry time, in UTC, when charging will be automatically disabled." +
                    "\n" +
                    "A value in the past in this field shall disable the EVSE charging whereas a null value shall enable " +
                    "it permanently."
            }),

            Field({
                name: "MinimumChargeCurrent", id: 0x1, type: "amperage-mA", conformance: "M", constraint: "min 0",
                xref: "cluster§9.3.9.2.2",
                details: "This field shall indicate the minimum current that can be delivered by the EVSE to the EV in trickle " +
                    "mode. The EVSE current limit can be advertised to an EV in 0.6A steps." +
                    "\n" +
                    "The value of the MinimumChargeCurrent attribute shall be set to the value of this field (see Section " +
                    "9.3.8.7, “MinimumChargeCurrent Attribute” for further details)."
            }),

            Field({
                name: "MaximumChargeCurrent", id: 0x2, type: "amperage-mA", conformance: "M", constraint: "min 0",
                xref: "cluster§9.3.9.2.3",

                details: "This field shall indicate the maximum current that can be delivered by the EVSE to the EV. The EVSE " +
                    "current limit can be advertised to an EV in 0.6A steps." +
                    "\n" +
                    "The value of the this field shall be stored by the EVSE to determine the value of " +
                    "MaximumChargeCurrent attribute. For example, if the UserMaximumChargeCurrent attribute is adjusted " +
                    "below then this value, and then later adjusted above this value, the resulting MaximumChargeCurrent " +
                    "attribute will be limited to this value."
            })
        ),

        Command(
            {
                name: "EnableDischarging", id: 0x3, access: "O T", conformance: "V2X", direction: "request",
                response: "status", xref: "cluster§9.3.9.3",
                details: "Upon receipt, this shall allow a client to enable the discharge of an EV, and to provide or update " +
                    "the maximum discharge current."
            },

            Field({
                name: "DischargingEnabledUntil", id: 0x0, type: "epoch-s", conformance: "M", quality: "X",
                xref: "cluster§9.3.9.3.1",
                details: "This field shall indicate the expiry time, in UTC, when discharging will be automatically disabled." +
                    "\n" +
                    "A value in the past in this field shall disable the EVSE discharging whereas a null value shall " +
                    "enable EVSE discharging permanently."
            }),

            Field({
                name: "MaximumDischargeCurrent", id: 0x1, type: "amperage-mA", conformance: "M",
                constraint: "min 0", xref: "cluster§9.3.9.3.2",
                details: "This field shall indicate the maximum current that can be received by the EVSE from the EV. The EVSE " +
                    "current limit can be advertised to an EV in 0.6A steps. The value of the MaximumDischargeCurrent " +
                    "attribute shall be stored and persisted across reboots by the EVSE to the value of this field."
            })
        ),

        Command({
            name: "StartDiagnostics", id: 0x4, access: "O T", conformance: "O", direction: "request",
            response: "status", xref: "cluster§9.3.9.4",
            details: "Allows a client to put the EVSE into a self-diagnostics mode."
        }),

        Command(
            {
                name: "SetTargets", id: 0x5, access: "O T", conformance: "PREF", direction: "request",
                response: "status", xref: "cluster§9.3.9.5",
                details: "Allows a client to set the user specified charging targets."
            },

            Field(
                {
                    name: "ChargingTargetSchedules", id: 0x0, type: "list", conformance: "M", constraint: "max 7",
                    xref: "cluster§9.3.9.5.1",
                    details: "This field shall indicate a list of up to 7 sets of daily charging targets together with their " +
                        "associated days of the week. Each of the days of the week may only be included in a single " +
                        "ChargingTargetSchedule within this list field."
                },

                Field({ name: "entry", type: "ChargingTargetScheduleStruct" })
            )
        ),

        Command({
            name: "GetTargets", id: 0x6, access: "O T", conformance: "PREF", direction: "request",
            response: "GetTargetsResponse", xref: "cluster§9.3.9.6",
            details: "Allows a client to retrieve the current set of charging targets."
        }),
        Command({
            name: "ClearTargets", id: 0x7, access: "O T", conformance: "PREF", direction: "request",
            response: "status", xref: "cluster§9.3.9.8",
            details: "Allows a client to clear all stored charging targets."
        }),

        Command(
            {
                name: "GetTargetsResponse", id: 0x0, conformance: "PREF", direction: "response",
                xref: "cluster§9.3.9.7",
                details: "The GetTargetsResponse is sent in response to the GetTargets Command."
            },

            Field(
                {
                    name: "ChargingTargetSchedules", id: 0x0, type: "list", conformance: "M", constraint: "max 7",
                    xref: "cluster§9.3.9.7.1",
                    details: "This field shall indicate a list of up to 7 sets of daily charging targets together with their " +
                        "associated days of the week."
                },

                Field({ name: "entry", type: "ChargingTargetScheduleStruct" })
            )
        ),

        Datatype(
            { name: "TargetDayOfWeekBitmap", type: "map8", xref: "cluster§9.3.7.1" },
            Field({ name: "Sunday", constraint: "0", description: "Sunday" }),
            Field({ name: "Monday", constraint: "1", description: "Monday" }),
            Field({ name: "Tuesday", constraint: "2", description: "Tuesday" }),
            Field({ name: "Wednesday", constraint: "3", description: "Wednesday" }),
            Field({ name: "Thursday", constraint: "4", description: "Thursday" }),
            Field({ name: "Friday", constraint: "5", description: "Friday" }),
            Field({ name: "Saturday", constraint: "6", description: "Saturday" })
        ),

        Datatype(
            { name: "StateEnum", type: "enum8", xref: "cluster§9.3.7.2" },
            Field({ name: "NotPluggedIn", id: 0x0, conformance: "M", description: "The EV is not plugged in." }),
            Field({
                name: "PluggedInNoDemand", id: 0x1, conformance: "M",
                description: "The EV is plugged in, but not demanding current."
            }),
            Field({
                name: "PluggedInDemand", id: 0x2, conformance: "M",
                description: "The EV is plugged in and is demanding current, but EVSE is not allowing current to flow."
            }),
            Field({
                name: "PluggedInCharging", id: 0x3, conformance: "M",
                description: "The EV is plugged in, charging is in progress, and current is flowing"
            }),
            Field({
                name: "PluggedInDischarging", id: 0x4, conformance: "V2X",
                description: "The EV is plugged in, discharging is in progress, and current is flowing"
            }),
            Field({
                name: "SessionEnding", id: 0x5, conformance: "M",
                description: "The EVSE is transitioning from any plugged-in state to NotPluggedIn"
            }),
            Field({
                name: "Fault", id: 0x6, conformance: "M",
                description: "There is a fault, further details in the FaultState attribute"
            })
        ),

        Datatype(
            { name: "SupplyStateEnum", type: "enum8", xref: "cluster§9.3.7.3" },
            Field({
                name: "Disabled", id: 0x0, conformance: "M",
                description: "The EV is not currently allowed to charge or discharge"
            }),
            Field({
                name: "ChargingEnabled", id: 0x1, conformance: "M",
                description: "The EV is currently allowed to charge"
            }),
            Field({
                name: "DischargingEnabled", id: 0x2, conformance: "[V2X]",
                description: "The EV is currently allowed to discharge"
            }),
            Field({
                name: "DisabledError", id: 0x3, conformance: "M",
                description: "The EV is not currently allowed to charge or discharge due to an error. The error must be cleared before operation can continue."
            }),
            Field({
                name: "DisabledDiagnostics", id: 0x4, conformance: "M",
                description: "The EV is not currently allowed to charge or discharge due to self-diagnostics mode."
            }),
            Field({
                name: "Enabled", id: 0x5, conformance: "[V2X]",
                description: "The EV is currently allowed to charge and discharge"
            })
        ),

        Datatype(
            { name: "FaultStateEnum", type: "enum8", xref: "cluster§9.3.7.4" },
            Field({ name: "NoError", id: 0x0, conformance: "M", description: "The EVSE is not in an error state." }),
            Field({
                name: "MeterFailure", id: 0x1, conformance: "M",
                description: "The EVSE is unable to obtain electrical measurements."
            }),
            Field({
                name: "OverVoltage", id: 0x2, conformance: "M",
                description: "The EVSE input voltage level is too high."
            }),
            Field({
                name: "UnderVoltage", id: 0x3, conformance: "M",
                description: "The EVSE input voltage level is too low."
            }),
            Field({
                name: "OverCurrent", id: 0x4, conformance: "M",
                description: "The EVSE detected charging current higher than allowed by charger."
            }),
            Field({
                name: "ContactWetFailure", id: 0x5, conformance: "M",
                description: "The EVSE detected voltage on charging pins when the contactor is open."
            }),
            Field({
                name: "ContactDryFailure", id: 0x6, conformance: "M",
                description: "The EVSE detected absence of voltage after enabling contactor."
            }),
            Field({
                name: "GroundFault", id: 0x7, conformance: "M",
                description: "The EVSE has an unbalanced current supply."
            }),
            Field({ name: "PowerLoss", id: 0x8, conformance: "M", description: "The EVSE has detected a loss in power." }),
            Field({
                name: "PowerQuality", id: 0x9, conformance: "M",
                description: "The EVSE has detected another power quality issue (e.g. phase imbalance)."
            }),
            Field({
                name: "PilotShortCircuit", id: 0xa, conformance: "M",
                description: "The EVSE pilot signal amplitude short circuited to ground."
            }),
            Field({ name: "EmergencyStop", id: 0xb, conformance: "M", description: "The emergency stop button was pressed." }),
            Field({
                name: "EvDisconnected", id: 0xc, conformance: "M",
                description: "The EVSE detected that the cable has been disconnected."
            }),
            Field({
                name: "WrongPowerSupply", id: 0xd, conformance: "M",
                description: "The EVSE could not determine proper power supply level."
            }),
            Field({
                name: "LiveNeutralSwap", id: 0xe, conformance: "M",
                description: "The EVSE detected Live and Neutral are swapped."
            }),
            Field({
                name: "OverTemperature", id: 0xf, conformance: "M",
                description: "The EVSE internal temperature is too high."
            }),
            Field({ name: "Other", id: 0xff, conformance: "M", description: "Any other reason." })
        ),

        Datatype(
            { name: "EnergyTransferStoppedReasonEnum", type: "enum8", xref: "cluster§9.3.7.5" },
            Field({ name: "EvStopped", id: 0x0, conformance: "M", description: "The EV decided to stop" }),
            Field({ name: "EvseStopped", id: 0x1, conformance: "M", description: "The EVSE decided to stop" }),
            Field({ name: "Other", id: 0x2, conformance: "M", description: "An other unknown reason" })
        ),

        Datatype(
            {
                name: "ChargingTargetStruct", type: "struct", xref: "cluster§9.3.7.6",

                details: "This represents a single user specified charging target for an EV." +
                    "\n" +
                    "An EVSE or EMS system optimizer may use this information to take the Time of Use Tariff, grid carbon " +
                    "intensity, local generation (solar PV) into account to provide the cheapest and cleanest energy to " +
                    "the EV." +
                    "\n" +
                    "The optimization strategy is not defined here, however in simple terms, the AddedEnergy requirement " +
                    "can be fulfilled by knowing the charging Power (W) and the time needed to charge." +
                    "\n" +
                    "To compute the Charging Time: Required Energy (Wh) = Power (W) x ChargingTime (s) / 3600 Therefore: " +
                    "ChargingTime (s) = (3600 x RequiredEnergy (wH)) / Power (W)" +
                    "\n" +
                    "To compute the charging time: Charging StartTime = TargetTimeMinutesPastMidnight - ChargingTime"
            },

            Field({
                name: "TargetTimeMinutesPastMidnight", id: 0x0, type: "uint16", conformance: "M",
                constraint: "max 1439", xref: "cluster§9.3.7.6.1",

                details: "This field shall indicate the desired charging completion time of the associated day. The time will " +
                    "be represented by a 16 bits unsigned integer to designate the minutes since midnight. For example, " +
                    "6am will be represented by 360 minutes since midnight and 11:30pm will be represented by 1410 " +
                    "minutes since midnight." +
                    "\n" +
                    "This field is based on local wall clock time. In case of Daylight Savings Time transition which may " +
                    "result in an extra hour or one hour less in the day, the charging algorithm should take into account " +
                    "the shift appropriately." +
                    "\n" +
                    "Note that if the TargetTimeMinutesPastMidnight values are too close together (e.g. 2 per day) these " +
                    "may overlap. The EVSE may have to coalesce the charging targets into a single target. e.g. if the " +
                    "1st charging target cannot be met in the time available, the EVSE may be forced to begin working " +
                    "towards the 2nd charging target and immediately continue until both targets have been satisfied (or " +
                    "the vehicle becomes full)." +
                    "\n" +
                    "The EVSE itself cannot predict the behavior of the vehicle (i.e. if it cannot obtain the SoC from " +
                    "the vehicle), so should attempt to perform a sensible operation based on these targets. It is " +
                    "recommended that the charging schedule is pessimistic (i.e. starts earlier) since the vehicle may " +
                    "charge more slowly than the electrical supply may provide power (especially if it is cold)." +
                    "\n" +
                    "If the user configures large charging targets (e.g. high values of AddedEnergy or SoC) then it is " +
                    "expected that the EVSE may need to begin charging immediately, and may not be able to guarantee that " +
                    "the vehicle will be able to reach the target."
            }),

            Field({
                name: "TargetSoC", id: 0x1, type: "percent", conformance: "SOC, O.a+", default: 0,
                xref: "cluster§9.3.7.6.2",

                details: "This field represents the target SoC that the vehicle should be charged to before the " +
                    "TargetTimeMinutesPastMidnight." +
                    "\n" +
                    "If the EVSE supports the SOC feature and can obtain the SoC of the vehicle:" +
                    "\n" +
                    "  • the TargetSoC field shall take precedence over the AddedEnergy field." +
                    "\n" +
                    "  • the EVSE SHOULD charge to the TargetSoC and then stop the charging automatically when it reaches " +
                    "    that point." +
                    "\n" +
                    "  • if the TargetSoC value is set to 100% then the EVSE SHOULD continue to charge the vehicle until " +
                    "    the vehicle decides to stop charging." +
                    "\n" +
                    "If the EVSE does not support the SOC feature or cannot obtain the SoC of the vehicle:" +
                    "\n" +
                    "  • the AddedEnergy field shall take precedence over the TargetSoC field, and if the EVSE does not " +
                    "    support the SOC feature then the TargetSoC field may only take the values null or 100%." +
                    "\n" +
                    "  • if the AddedEnergy field has not been provided, the EVSE SHOULD assume the vehicle is empty" +
                    "\n" +
                    "and charge until the vehicle stops demanding a charge."
            }),

            Field({
                name: "AddedEnergy", id: 0x2, type: "energy-mWh", conformance: "[SOC], O.a+", constraint: "min 0",
                default: 0, xref: "cluster§9.3.7.6.3",

                details: "This field represents the amount of energy that the user would like to have added to the vehicle " +
                    "before the TargetTimeMinutesPastMidnight." +
                    "\n" +
                    "This represents a positive value in mWh that SHOULD be added during the session (i.e. if the vehicle " +
                    "charging is stopped and started several times, this equates to the total energy since the vehicle " +
                    "has been plugged in)." +
                    "\n" +
                    "The maximum value (500kWh) is much larger than most EV batteries on the market today. If the client " +
                    "tries to set this value too high then the EVSE will need to start charging immediately and continue " +
                    "charging until the vehicle stops demanding charge (i.e. it is full). Therefore the maximum value " +
                    "should be set based on typical battery size of the vehicles on the market (e.g. 70000Wh), however " +
                    "this is up to the client to carefully choose a value." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> If the EVSE can obtain the Battery Capacity of the vehicle, it SHOULD NOT limit this AddedEnergy " +
                    "  value to the Battery Capacity of the vehicle, since the EV may also require energy for heating and " +
                    "  cooling of the battery during charging, or for heating or cooling the cabin."
            })
        ),

        Datatype(
            {
                name: "ChargingTargetScheduleStruct", type: "struct", xref: "cluster§9.3.7.7",
                details: "This represents a set of user specified charging targets for an EV for a set of specified days."
            },

            Field({
                name: "DayOfWeekForSequence", id: 0x0, type: "TargetDayOfWeekBitmap", conformance: "M",
                xref: "cluster§9.3.7.8",
                details: "This field shall indicate the days of the week that the charging targets SHOULD be associated to. " +
                    "This field is a bitmap and therefore the associated targets could be applied to multiple days."
            }),

            Field(
                {
                    name: "ChargingTargets", id: 0x1, type: "list", conformance: "M", constraint: "max 10",
                    xref: "cluster§9.3.7.9",
                    details: "This field shall indicate a list of up to 10 charging targets for each of the associated days of the " +
                        "week."
                },

                Field({ name: "entry", type: "ChargingTargetStruct" })
            )
        )
    ),

    Cluster(
        {
            name: "EnergyEvseMode", id: 0x9d, type: "ModeBase", classification: "application", pics: "EEVSEM",
            xref: "cluster§9.4",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for EVSE devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.4.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§9.4.6.1",

            details: "At least one entry in the SupportedModes attribute shall include the Manual mode tag in the ModeTags " +
                "field list." +
                "\n" +
                "Modes with entries in the SupportedModes attribute which contain multiple mode tags permitting " +
                "charging or discharging under different conditions shall permit the charging or discharging to occur " +
                "if any of the conditions are satisfied." +
                "\n" +
                "Modes shall NOT have both the Manual tag and the TimeOfUse or SolarCharging tags defined in the " +
                "SupportedModes attribute."
        }),

        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§9.4.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§9.4.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§9.4.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§9.4.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§9.4.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§9.4.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§9.4.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§9.4.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§9.4.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§9.4.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§9.4.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§9.4.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§9.4.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§9.4.7.1" }),
            Field({
                name: "Manual", id: 0x4000, xref: "cluster§9.4.7.1.1",
                details: "While in modes with this tag, and once enabled with the EnableCharging command, the EVSE will permit " +
                    "charging based on demand from the EV."
            }),

            Field({
                name: "TimeOfUse", id: 0x4001, xref: "cluster§9.4.7.1.2",
                details: "While in modes with this tag, and once enabled with the EnableCharging command, the EVSE will " +
                    "attempt to automatically start charging based on the user’s charging targets (for example, set based " +
                    "on a Time of Use tariff to charge at the cheapest times of the day)."
            }),

            Field({
                name: "SolarCharging", id: 0x4002, xref: "cluster§9.4.7.1.3",
                details: "While in modes with this tag, and once enabled with the EnableCharging, the EVSE will attempt to " +
                    "automatically start charging based on available excess solar PV generation, limiting the charging " +
                    "power to avoid importing energy from the grid."
            }),

            Field({
                name: "V2X", id: 0x4003, xref: "cluster§9.4.7.1.4",

                details: "While in modes with this tag, and once enabled with the EnableDischarging command, the EVSE will " +
                    "permit discharging based on the current charge state of the EV, and its control from an associated " +
                    "Device Energy Management cluster." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> being in a mode with this tag set or not does not affect the handling of the EnableDischarging " +
                    "  command by the Energy EVSE cluster, but once enabled, only modes with this tag enable the " +
                    "  discharging to actually occur."
            })
        )
    ),

    Cluster(
        {
            name: "WaterHeaterManagement", id: 0x94, classification: "application", pics: "EWATERHTR",
            xref: "cluster§9.5",

            details: "This cluster is used to allow clients to control the operation of a hot water heating appliance so " +
                "that it can be used with energy management." +
                "\n" +
                "Heating of hot water is one of the main energy uses in homes, and when coupled with the Energy " +
                "Management cluster, it can help consumers save cost (e.g. using power at cheaper times or from local " +
                "solar PV generation)."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.5.4" },
            Field({
                name: "EM", conformance: "O", constraint: "0", title: "EnergyManagement",
                details: "Allows energy management control of the tank"
            }),
            Field({
                name: "TP", conformance: "O", constraint: "1", title: "TankPercent",
                details: "Supports monitoring the percentage of hot water in the tank"
            })
        ),

        Attribute({
            name: "HeaterTypes", id: 0x0, type: "WaterHeaterHeatSourceBitmap", access: "R V", conformance: "M",
            quality: "F", xref: "cluster§9.5.7.1",
            details: "Indicates the heat sources that the water heater can call on for heating. If a bit is set then the " +
                "water heater supports the corresponding heat source."
        }),

        Attribute({
            name: "HeatDemand", id: 0x1, type: "WaterHeaterHeatSourceBitmap", access: "R V", conformance: "M",
            xref: "cluster§9.5.7.2",
            details: "Indicates if the water heater is heating water. If a bit is set then the corresponding heat source " +
                "is active."
        }),

        Attribute({
            name: "TankVolume", id: 0x2, type: "uint16", access: "R V", conformance: "EM",
            xref: "cluster§9.5.7.3",
            details: "Indicates the volume of water that the hot water tank can hold (in units of Litres). This allows an " +
                "energy management system to estimate the required heating energy needed to reach the target " +
                "temperature."
        }),

        Attribute(
            {
                name: "EstimatedHeatRequired", id: 0x3, type: "energy-mWh", access: "R V", conformance: "EM",
                constraint: "min 0", xref: "cluster§9.5.7.4",

                details: "Indicates the estimated heat energy needed to raise the water temperature to the target setpoint. " +
                    "This can be computed by taking the specific heat capacity of water (4182 J/kg °C) and by knowing the " +
                    "current temperature of the water, the tank volume and target temperature." +
                    "\n" +
                    "For example, if the target temperature was 60°C, the current temperature was 20°C and the tank " +
                    "volume was 100L:" +
                    "\n" +
                    "### Mass of water = 1kg per Litre" +
                    "\n" +
                    "Total Mass = 100 x 1kg = 100kg" +
                    "\n" +
                    "Δ Temperature = (target temperature - current temperature)" +
                    "\n" +
                    "= (60°C - 20°C) = 40°C" +
                    "\n" +
                    "### Energy required to" +
                    "\n" +
                    "heat the water to 60°C = 4182 x 40 x 100 = 16,728,000 J" +
                    "\n" +
                    "Converting Joules in to Wh of heat (divide by 3600):" +
                    "\n" +
                    "If the TankPercent feature is supported, then this estimate shall also take into account the " +
                    "percentage of the water in the tank which is already hot." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> The electrical energy required to heat the water depends on the heating system used to heat the " +
                    "  water. For example, a direct electric immersion heating element can be close to 100% efficient, so " +
                    "  the electrical energy needed to heat the hot water is nearly the same as the " +
                    "  EstimatedHeatEnergyRequired. However some forms of heating, such as an air-source heat pump which " +
                    "  extracts heat from ambient air, requires much less electrical energy to heat hot water. Heat pumps " +
                    "  can be produce 3kWh of heat output for 1kWh of electrical energy input. The conversion between " +
                    "  heat energy and electrical energy is outside the scope of this cluster."
            }
        ),

        Attribute(
            {
                name: "TankPercentage", id: 0x4, type: "percent", access: "R V", conformance: "TP",
                xref: "cluster§9.5.7.5",

                details: "Indicates an approximate level of hot water stored in the tank, which might help consumers " +
                    "understand the amount of hot water remaining in the tank. The accuracy of this attribute is " +
                    "manufacturer specific." +
                    "\n" +
                    "In most hot water tanks, there is a stratification effect where the hot water layer rests above a " +
                    "cooler layer of water below. For this reason cold water is fed in at the bottom of the tank and the " +
                    "hot water is drawn from the top." +
                    "\n" +
                    "Some water tanks might use multiple temperature probes to estimate the level of the hot water layer. " +
                    "A water heater with multiple temperature probes is likely to implement an algorithm to estimate the " +
                    "hot water tank percentage by taking into account the temperature values of each probe to determine " +
                    "the height of the hot water." +
                    "\n" +
                    "However it might be possible with a single temperature probe to estimate how much hot water is left " +
                    "using a simpler algorithm:" +
                    "\n" +
                    "For example, if the target temperature was 60°C, the CurrentTemperature was 40°C from a single " +
                    "temperature probe measuring the average water temperature and the temperature of incoming cold water " +
                    "(COLD_WATER_TEMP) was assumed to be 20°C:" +
                    "\n" +
                    "TankPercentage = int(((current temperature - COLD_WATER_TEMP) / (target temperature - " +
                    "COLD_WATER_TEMP)) * 100)" +
                    "\n" +
                    "TankPercentage = min( max(TankPercentage,0), 100)" +
                    "\n" +
                    "### TankPercentage = 50%"
            }
        ),

        Attribute({
            name: "BoostState", id: 0x5, type: "BoostStateEnum", access: "R V", conformance: "M",
            xref: "cluster§9.5.7.6",
            details: "Indicates whether the Boost, as triggered by a Boost command, is currently Active or Inactive." +
                "\n" +
                "See Section 9.5.8.1, “Boost Command” and Section 9.5.8.2, “CancelBoost Command” for more details."
        }),

        Event(
            {
                name: "BoostStarted", id: 0x0, access: "V", conformance: "M", priority: "info",
                xref: "cluster§9.5.9.1",
                details: "This event shall be generated whenever a Boost command is accepted." +
                    "\n" +
                    "The corresponding structure fields within the WaterHeaterBoostInfoStruct are copied from the Boost " +
                    "command."
            },

            Field({ name: "BoostInfo", id: 0x0, type: "WaterHeaterBoostInfoStruct", conformance: "M" })
        ),

        Event({
            name: "BoostEnded", id: 0x1, access: "V", conformance: "M", priority: "info",
            xref: "cluster§9.5.9.2",
            details: "This event shall be generated whenever the BoostState transitions from Active to Inactive."
        }),

        Command(
            {
                name: "Boost", id: 0x0, access: "M", conformance: "M", direction: "request", response: "status",
                xref: "cluster§9.5.8.1",
                details: "Allows a client to request that the water heater is put into a Boost state."
            },
            Field({ name: "BoostInfo", id: 0x0, type: "WaterHeaterBoostInfoStruct", conformance: "M" })
        ),

        Command({
            name: "CancelBoost", id: 0x1, access: "M", conformance: "M", direction: "request",
            response: "status", xref: "cluster§9.5.8.2",
            details: "Allows a client to cancel an ongoing Boost operation. This command has no payload."
        }),

        Datatype(
            { name: "WaterHeaterHeatSourceBitmap", type: "map8", xref: "cluster§9.5.6.1" },
            Field({ name: "ImmersionElement1", constraint: "0", description: "Immersion Heating Element 1" }),
            Field({ name: "ImmersionElement2", constraint: "1", description: "Immersion Heating Element 2" }),
            Field({ name: "HeatPump", constraint: "2", description: "Heat pump Heating" }),
            Field({ name: "Boiler", constraint: "3", description: "Boiler Heating (e.g. Gas or Oil)" }),
            Field({ name: "Other", constraint: "4", description: "Other Heating" })
        ),

        Datatype(
            { name: "BoostStateEnum", type: "enum8", xref: "cluster§9.5.6.2" },
            Field({ name: "Inactive", id: 0x0, conformance: "M", description: "Boost is not currently active" }),
            Field({ name: "Active", id: 0x1, conformance: "M", description: "Boost is currently active" })
        ),

        Datatype(
            { name: "WaterHeaterBoostInfoStruct", type: "struct", xref: "cluster§9.5.6.3" },
            Field({
                name: "Duration", id: 0x0, type: "elapsed-s", conformance: "M", constraint: "min 1",
                xref: "cluster§9.5.6.3.1",
                details: "This field shall indicate the time period, in seconds, for which the boost state is activated."
            }),

            Field({
                name: "OneShot", id: 0x1, type: "bool", conformance: "[!TP], [TP].a-", default: false,
                xref: "cluster§9.5.6.3.2",

                details: "This field shall indicate whether the boost state shall be automatically canceled once the hot water " +
                    "has reached either:" +
                    "\n" +
                    "  • the set point temperature (from the thermostat cluster)" +
                    "\n" +
                    "  • the TemporarySetpoint temperature (if specified)" +
                    "\n" +
                    "  • the TargetPercentage (if specified)."
            }),

            Field({
                name: "EmergencyBoost", id: 0x2, type: "bool", conformance: "O", default: false,
                xref: "cluster§9.5.6.3.3",
                details: "This field shall indicate that the consumer wants the water to be heated quickly. This may cause " +
                    "multiple heat sources to be activated (e.g. a heat pump and direct electric immersion heating " +
                    "element)." +
                    "\n" +
                    "The choice of which heat sources are activated is manufacturer specific."
            }),

            Field({
                name: "TemporarySetpoint", id: 0x3, type: "temperature", conformance: "O", constraint: "desc",
                xref: "cluster§9.5.6.3.4",

                details: "This field shall indicate the target temperature to which the water will be heated." +
                    "\n" +
                    "If included, it shall be used instead of the thermostat cluster set point temperature whilst the " +
                    "boost state is activated." +
                    "\n" +
                    "The value of this field shall be within the constraints of the MinHeatSetpointLimit and " +
                    "MaxHeatSetpointLimit attributes (inclusive), of the thermostat cluster."
            }),

            Field({
                name: "TargetPercentage", id: 0x4, type: "percent", conformance: "TargetReheat, [TP]",
                xref: "cluster§9.5.6.3.5",
                details: "This field shall indicate the target percentage of hot water in the tank that the TankPercentage " +
                    "attribute must reach before the heating is switched off."
            }),

            Field({
                name: "TargetReheat", id: 0x5, type: "percent", conformance: "[TP].a-",
                constraint: "max targetPercentage", xref: "cluster§9.5.6.3.6",

                details: "This field shall indicate the percentage to which the hot water in the tank shall be allowed to fall " +
                    "before again beginning to reheat it." +
                    "\n" +
                    "For example if the TargetPercentage was 80%, and the TargetReheat was 40%, then after initial " +
                    "heating to 80% hot water, the tank may have hot water drawn off until only 40% hot water remains. At " +
                    "this point the heater will begin to heat back up to 80% of hot water. If this field and the OneShot " +
                    "field were both omitted, heating would begin again after any water draw which reduced the " +
                    "TankPercentage below 80%." +
                    "\n" +
                    "This field shall be less than or equal to the TargetPercentage field."
            })
        )
    ),

    Cluster(
        {
            name: "WaterHeaterMode", id: 0x9e, type: "ModeBase", classification: "application", pics: "WHM",
            xref: "cluster§9.6",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for water heater devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.6.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§9.6.6.1",

            details: "At least one entry in the SupportedModes attribute shall include the Manual mode tag in the ModeTags " +
                "field list." +
                "\n" +
                "At least one entry in the SupportedModes attribute shall include the Off mode tag in the ModeTags " +
                "field list." +
                "\n" +
                "An entry in the SupportedModes attribute that includes one of an Off, Manual, or Timed tag shall NOT " +
                "also include an additional instance of any one of these tag types."
        }),

        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§9.6.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§9.6.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§9.6.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§9.6.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§9.6.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§9.6.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§9.6.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§9.6.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§9.6.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§9.6.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§9.6.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§9.6.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§9.6.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§9.6.7.1" }),
            Field({
                name: "Off", id: 0x4000, xref: "cluster§9.6.7.1.1",
                details: "While in modes with this tag, the device will not attempt to keep the water warm."
            }),
            Field({
                name: "Manual", id: 0x4001, xref: "cluster§9.6.7.1.2",
                details: "While in modes with this tag, the device will attempt to keep the water warm based on the " +
                    "OccupiedHeatingSetpoint attribute of the associated Thermostat cluster."
            }),
            Field({
                name: "Timed", id: 0x4002, xref: "cluster§9.6.7.1.3",
                details: "While in modes with this tag, the device will attempt to keep the water warm based on the Schedules " +
                    "attribute of the associated Thermostat cluster."
            })
        )
    ),

    Cluster(
        {
            name: "EnergyPreference", id: 0x9b, classification: "application", pics: "EPREF",
            xref: "cluster§9.7",
            details: "This cluster provides an interface to specify preferences for how devices should consume energy." +
                "\n" +
                "NOTE Support for Energy Preference cluster is provisional."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.7.4" },
            Field({
                name: "BALA", conformance: "O.a+", constraint: "0", title: "EnergyBalance", xref: "cluster§9.7.4.1",
                details: "This feature allows a user to select from a list of energy balances with associated descriptions of " +
                    "which strategies a device will use to target the specified balance."
            }),

            Field({
                name: "LPMS", conformance: "O.a+", constraint: "1", title: "LowPowerModeSensitivity",
                xref: "cluster§9.7.4.2",
                details: "This feature allows the user to select a condition or set of conditions which will cause the device " +
                    "to switch to a mode using less power. For example, a device might provide a scale of durations that " +
                    "must elapse without user interaction before it goes to sleep."
            })
        ),

        Attribute(
            {
                name: "EnergyBalances", id: 0x0, type: "list", access: "R V", conformance: "BALA",
                constraint: "2 to 10", quality: "F", xref: "cluster§9.7.6.1",

                details: "Indicates a list of BalanceStructs, each representing a step along a linear scale of relative " +
                    "priorities. A Step field with a value of zero shall indicate that the device SHOULD entirely favor " +
                    "the priority specified by the first element in EnergyPriorities; whereas a Step field with a value " +
                    "of 100 shall indicate that the device SHOULD entirely favor the priority specified by the second " +
                    "element in EnergyPriorities. The midpoint value of 50 shall indicate an even split between the two " +
                    "priorities." +
                    "\n" +
                    "This shall contain at least two BalanceStructs." +
                    "\n" +
                    "Each BalanceStruct shall have a Step field larger than the Step field on the previous BalanceStruct " +
                    "in the list." +
                    "\n" +
                    "The first BalanceStruct shall have a Step value of zero, and the last BalanceStruct shall have a " +
                    "Step value of 100."
            },

            Field({ name: "entry", type: "BalanceStruct" })
        ),

        Attribute({
            name: "CurrentEnergyBalance", id: 0x1, type: "uint8", access: "RW VO", conformance: "BALA",
            quality: "N", xref: "cluster§9.7.6.2",

            details: "Indicates the current preference of the user for balancing different priorities during device use. " +
                "The value of this attribute is the index, 0-based, into the EnergyBalances attribute for the " +
                "currently selected balance." +
                "\n" +
                "If an attempt is made to set this attribute to an index outside the maximum index for " +
                "EnergyBalances, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If the value of EnergyBalances changes after an update, the device shall migrate the value of the " +
                "CurrentEnergyBalance attribute to the index which the manufacturer specifies most closely matches " +
                "the previous value, while preserving extreme preferences as follows:" +
                "\n" +
                "  1. If the previous value of CurrentEnergyBalance was zero, indicating a total preference for the " +
                "     priority specified by the first element in EnergyPriorities, the new value of " +
                "     CurrentEnergyBalance shall also be zero." +
                "\n" +
                "  2. If the previous value of CurrentEnergyBalance was the index of the last BalanceStruct in the " +
                "     previous value of EnergyBalances, indicating a total preference for the priority specified by " +
                "     the last element in EnergyPriorities, the new value of CurrentEnergyBalance shall be the index " +
                "     of the last element in the updated value of EnergyBalances."
        }),

        Attribute(
            {
                name: "EnergyPriorities", id: 0x2, type: "list", access: "R V", conformance: "BALA",
                constraint: "2", quality: "F", xref: "cluster§9.7.6.3",

                details: "Indicates two extremes for interpreting the values in the EnergyBalances attribute. These two " +
                    "priorities shall be in opposition to each other; e.g. Comfort vs. Efficiency or Speed vs. " +
                    "WaterConsumption." +
                    "\n" +
                    "If the value of EnergyPriorities changes after an update to represent a new balance between " +
                    "priorities, the value of the CurrentEnergyBalance attribute shall be set to its default."
            },

            Field({ name: "entry", type: "EnergyPriorityEnum" })
        ),

        Attribute(
            {
                name: "LowPowerModeSensitivities", id: 0x3, type: "list", access: "R V", conformance: "LPMS",
                constraint: "2 to 10", quality: "F", xref: "cluster§9.7.6.4",
                details: "Indicates a list of BalanceStructs, each representing a condition or set of conditions for the " +
                    "device to enter a low power mode. This shall contain at least two BalanceStructs." +
                    "\n" +
                    "Each BalanceStruct shall have a Step field larger than the Step field on the previous BalanceStruct " +
                    "in the list."
            },

            Field({ name: "entry", type: "BalanceStruct" })
        ),

        Attribute({
            name: "CurrentLowPowerModeSensitivity", id: 0x4, type: "uint8", access: "RW VO",
            conformance: "LPMS", quality: "N", xref: "cluster§9.7.6.5",

            details: "Indicates the current preference of the user for determining when the device should enter a low " +
                "power mode. The value of this attribute is the index, 0-based, into the LowPowerModeSensitivities " +
                "attribute for the currently selected preference." +
                "\n" +
                "If an attempt is made to set this attribute to an index outside the maximum index for " +
                "LowPowerModeSensitivities, a response with the status code CONSTRAINT_ERROR shall be returned." +
                "\n" +
                "If the value of LowPowerModeSensitivities changes after an update, the device shall migrate the " +
                "value of the LowPowerModeSensitivity attribute to the index which the manufacturer specifies most " +
                "closely matches the previous value."
        }),

        Datatype(
            { name: "EnergyPriorityEnum", type: "enum8", xref: "cluster§9.7.5.1" },
            Field({
                name: "Comfort", id: 0x0, conformance: "M", description: "User comfort", xref: "cluster§9.7.5.1.1",
                details: "This value shall emphasize user comfort; e.g. local temperature for a thermostat."
            }),

            Field({
                name: "Speed", id: 0x1, conformance: "M", description: "Speed of operation",
                xref: "cluster§9.7.5.1.2",
                details: "This value shall emphasize how quickly a device accomplishes its targeted use; e.g. how quickly a " +
                    "robot vacuum completes a cleaning cycle."
            }),

            Field({
                name: "Efficiency", id: 0x2, conformance: "M",
                description: "Amount of Energy consumed by the device", xref: "cluster§9.7.5.1.3",
                details: "This value shall emphasize how much energy a device uses; e.g. electricity usage for a Pump."
            }),
            Field({
                name: "WaterConsumption", id: 0x3, conformance: "M",
                description: "Amount of water consumed by the device"
            })
        ),

        Datatype(
            {
                name: "BalanceStruct", type: "struct", xref: "cluster§9.7.5.2",
                details: "This represents a step along a scale of preferences."
            },
            Field({
                name: "Step", id: 0x0, type: "percent", conformance: "M", quality: "F", xref: "cluster§9.7.5.2.1",
                details: "This field shall indicate the relative value of this step."
            }),

            Field({
                name: "Label", id: 0x1, type: "string", conformance: "O", constraint: "max 64", quality: "F",
                xref: "cluster§9.7.5.2.2",
                details: "This field shall indicate an optional string explaining which actions a device might take at the " +
                    "given step value."
            })
        )
    ),

    Cluster(
        {
            name: "DeviceEnergyManagementMode", id: 0x9f, type: "ModeBase", classification: "application",
            pics: "DEMM", xref: "cluster§9.8",
            details: "This cluster is derived from the Mode Base cluster and defines additional mode tags and namespaced " +
                "enumerated values for Device Energy Management devices."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§9.8.4" },
            Field({
                name: "DEPONOFF", conformance: "X", constraint: "0", title: "OnOff",
                details: "Dependency with the OnOff cluster"
            })
        ),

        Attribute({
            name: "SupportedModes", id: 0x0, xref: "cluster§9.8.6.1",

            details: "At least one entry in the SupportedModes attribute shall include the NoOptimization mode tag in the " +
                "ModeTags field." +
                "\n" +
                "At least one entry in the SupportedModes attribute shall include the LocalOptimization mode tag in " +
                "the ModeTags field list." +
                "\n" +
                "At least one entry in the SupportedModes attribute shall include the GridOptimization mode tag in " +
                "the ModeTags field list." +
                "\n" +
                "An entry in the SupportedModes attribute that includes one of an DeviceOptimization, " +
                "LocalOptimization, or GridOptimization tags shall NOT also include NoOptimization tag."
        }),

        Attribute({ name: "CurrentMode", id: 0x1, xref: "cluster§9.8.6" }),
        Attribute({ name: "StartUpMode", id: 0x2, conformance: "X", xref: "cluster§9.8.6" }),
        Attribute({ name: "OnMode", id: 0x3, conformance: "X", xref: "cluster§9.8.6" }),
        Datatype({
            name: "ModeOptionStruct", type: "ModeOptionStruct", xref: "cluster§9.8.5.1",
            details: "The table below lists the changes relative to the Mode Base cluster for the fields of the " +
                "ModeOptionStruct type. A blank field indicates no change."
        }),

        Datatype(
            { name: "ModeTag", type: "enum16" },
            Field({ name: "Auto", id: 0x0, xref: "cluster§9.8.7.1" }),
            Field({ name: "Quick", id: 0x1, xref: "cluster§9.8.7.1" }),
            Field({ name: "Quiet", id: 0x2, xref: "cluster§9.8.7.1" }),
            Field({ name: "LowNoise", id: 0x3, xref: "cluster§9.8.7.1" }),
            Field({ name: "LowEnergy", id: 0x4, xref: "cluster§9.8.7.1" }),
            Field({ name: "Vacation", id: 0x5, xref: "cluster§9.8.7.1" }),
            Field({ name: "Min", id: 0x6, xref: "cluster§9.8.7.1" }),
            Field({ name: "Max", id: 0x7, xref: "cluster§9.8.7.1" }),
            Field({ name: "Night", id: 0x8, xref: "cluster§9.8.7.1" }),
            Field({ name: "Day", id: 0x9, xref: "cluster§9.8.7.1" }),
            Field({
                name: "NoOptimization", id: 0x4000, xref: "cluster§9.8.7.1.1",
                details: "The device prohibits optimization of energy usage management: its energy usage is determined only by " +
                    "the user configuration and internal device needs."
            }),
            Field({
                name: "DeviceOptimization", id: 0x4001, xref: "cluster§9.8.7.1.2",
                details: "The device is permitted to manage its own energy usage. For example, using tariff information it may " +
                    "obtain."
            }),
            Field({
                name: "LocalOptimization", id: 0x4002, xref: "cluster§9.8.7.1.3",
                details: "The device permits management of energy usage by an energy manager to optimize the local energy " +
                    "usage."
            }),
            Field({
                name: "GridOptimization", id: 0x4003, xref: "cluster§9.8.7.1.4",
                details: "The device permits management of energy usage by an energy manager to optimize the grid energy " +
                    "usage."
            })
        )
    ),

    Cluster(
        {
            name: "WiFiNetworkManagement", id: 0x451, classification: "application", pics: "WIFINM",
            xref: "cluster§10.2",
            details: "This cluster provides an interface for getting information about the Wi-Fi network that a Network " +
                "Infrastructure Manager device type provides. Privileged nodes within the same fabric as a Network " +
                "Infrastructure Manager can use these interfaces to request information related to the Wi-Fi Network " +
                "such as SSID and Passphrase."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "Ssid", id: 0x0, type: "octstr", access: "R V", conformance: "M", constraint: "1 to 32",
            quality: "X N", xref: "cluster§10.2.4.1",

            details: "Indicates the SSID of the primary Wi-Fi network provided by this device." +
                "\n" +
                "A value of null shall indicate that no primary Wi-Fi network is available (e.g. because the Wi-Fi " +
                "network has not yet been configured by the user)." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> The SSID in Wi-Fi is a collection of 1-32 bytes, the text encoding of which is not specified. " +
                "  Implementations must be careful to support transferring these byte strings without requiring a " +
                "  particular encoding. The most common encoding is UTF-8, however this is just a convention. Some " +
                "  configurations may use Latin-1 or other character sets."
        }),

        Attribute({
            name: "PassphraseSurrogate", id: 0x1, type: "uint64", access: "R M", conformance: "M",
            quality: "X N", xref: "cluster§10.2.4.2",

            details: "This attribute shall contain an arbitrary numeric value; this value shall increase whenever the " +
                "passphrase or PSK associated with the primary Wi-Fi network provided by this device changes." +
                "\n" +
                "A value of null shall indicate that no primary Wi-Fi network is available." +
                "\n" +
                "Clients can subscribe to this attribute or compare its value to a locally cached copy to detect if a " +
                "cached passphrase value has become stale." +
                "\n" +
                "It is recommended that servers implement this attribute as either a timestamp or a counter. When " +
                "implemented as a counter it SHOULD be initialized with a random value." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> The passphrase itself is not exposed as an attribute to avoid its unintentional retrieval or " +
                "  caching by clients that use wildcard reads or otherwise routinely read all available attributes. " +
                "  It can be retrieved using the NetworkPassphraseRequest command."
        }),

        Command({
            name: "NetworkPassphraseRequest", id: 0x0, access: "M", conformance: "M", direction: "request",
            response: "NetworkPassphraseResponse", xref: "cluster§10.2.5.1",

            details: "This command is used to request the current WPA-Personal passphrase or PSK associated with the Wi-Fi " +
                "network provided by this device." +
                "\n" +
                "If the command is not executed via a CASE session, the command shall be rejected with a status of " +
                "UNSUPPORTED_ACCESS." +
                "\n" +
                "If no primary Wi-Fi network is available (the SSID attribute is null), the command shall be rejected " +
                "with a status of INVALID_IN_STATE." +
                "\n" +
                "Otherwise a NetworkPassphraseResponse shall be generated."
        }),

        Command(
            {
                name: "NetworkPassphraseResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "cluster§10.2.5.2",
                details: "This command shall be generated in response to a NetworkPassphraseRequest command."
            },

            Field({
                name: "Passphrase", id: 0x0, type: "octstr", conformance: "M", constraint: "max 64",
                xref: "cluster§10.2.5.2.1",

                details: "This field shall indicate the current WPA-Personal passphrase or PSK associated with the primary " +
                    "Wi-Fi network provided by this device, in one of the following formats:" +
                    "\n" +
                    "  • 8..63 bytes: WPA/WPA2/WPA3 passphrase." +
                    "\n" +
                    "  • 64 bytes: WPA/WPA2/WPA3 raw hex PSK. Each byte shall be a ASCII hexadecimal digit." +
                    "\n" +
                    "This matches the formats defined for WPA networks by the Credentials field in the Network " +
                    "Commissioning cluster (see [MatterCore])." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> WPA3-Personal permits passphrases shorter than 8 or longer than 63 characters, however the Network " +
                    "  Commissioning cluster does not currently support configuring Matter devices to connect to " +
                    "  operational networks utilizing such a passphrase."
            })
        )
    ),

    Cluster(
        {
            name: "ThreadBorderRouterManagement", id: 0x452, classification: "application", pics: "TBRM",
            xref: "cluster§10.3",
            details: "This cluster provides an interface for managing a Thread Border Router and the Thread network that " +
                "it belongs to. Privileged nodes within the same fabric as a Thread Border Router can use these " +
                "interfaces to request and set credentials information to the Thread network."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "cluster§10.3.4" },

            Field({
                name: "PC", conformance: "O", constraint: "0", title: "PanChange", xref: "cluster§10.3.4.1",

                details: "This feature shall indicate the ability of the Border Router to change its already configured PAN to " +
                    "another, by setting a pending dataset." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> This feature flag can be used to protect an already-configured network from accidental " +
                    "  configuration change, e.g. when the Thread Border Router serves non-Matter devices that do not " +
                    "  support PAN change for an implementation-specific reason."
            })
        ),

        Attribute({
            name: "BorderRouterName", id: 0x0, type: "string", access: "R V", conformance: "M",
            constraint: "1 to 63", xref: "cluster§10.3.5.1",
            details: "Indicates a user-friendly name identifying the device model or product of the Border Router in " +
                "MeshCOP (DNS-SD service name) as defined in the Thread specification, and has the following " +
                "recommended format: <VendorName> <ProductName>._meshcop._udp. An example name would be ACME Border " +
                "Router (74be)._meshcop._udp."
        }),

        Attribute({
            name: "BorderAgentId", id: 0x1, type: "octstr", access: "R V", conformance: "M", constraint: "16",
            xref: "cluster§10.3.5.2",
            details: "Indicates a 16-byte globally unique ID for a Thread Border Router device. This ID is " +
                "manufacturer-specific, and it is created and managed by the border router’s implementation."
        }),

        Attribute({
            name: "ThreadVersion", id: 0x2, type: "uint16", access: "R V", conformance: "M", quality: "F",
            xref: "cluster§10.3.5.3",
            details: "Indicates the Thread version supported by the Thread interface configured by the cluster instance." +
                "\n" +
                "The format shall match the value mapping defined in the \"Version TLV\" section of the Thread " +
                "specification. For example, Thread 1.3.0 would have ThreadVersion set to 4."
        }),

        Attribute({
            name: "InterfaceEnabled", id: 0x3, type: "bool", access: "R V", conformance: "M", quality: "N",
            xref: "cluster§10.3.5.4",
            details: "Indicates whether the associated IEEE 802.15.4 Thread interface is enabled or disabled."
        }),

        Attribute({
            name: "ActiveDatasetTimestamp", id: 0x4, type: "uint64", access: "R V", conformance: "M",
            quality: "X N", xref: "cluster§10.3.5.5",
            details: "Null if the Thread Border Router has no dataset configured, otherwise it shall be the timestamp " +
                "value extracted from the Active Dataset value configured by the Thread Node to which the border " +
                "router is connected. This attribute shall be updated when a new Active dataset is configured on the " +
                "Thread network to which the border router is connected."
        }),

        Attribute({
            name: "PendingDatasetTimestamp", id: 0x5, type: "uint64", access: "R V", conformance: "M",
            quality: "X N", xref: "cluster§10.3.5.6",
            details: "Null if the Thread Border Router has no Pending dataset configured, otherwise it shall be the " +
                "timestamp value extracted from the Pending Dataset value configured by the Thread Node to which the " +
                "border router is connected. This attribute shall be updated when a new Pending dataset is configured " +
                "on the Thread network to which the border router is connected."
        }),

        Command({
            name: "GetActiveDatasetRequest", id: 0x0, access: "M", conformance: "M", direction: "request",
            response: "DatasetResponse", xref: "cluster§10.3.6.1",

            details: "This command shall be used to request the active operational dataset of the Thread network to which " +
                "the border router is connected." +
                "\n" +
                "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                "UNSUPPORTED_ACCESS." +
                "\n" +
                "If an internal error occurs, then this command shall fail with a FAILURE status code sent back to " +
                "the initiator." +
                "\n" +
                "Otherwise, this shall generate a DatasetResponse command."
        }),

        Command({
            name: "GetPendingDatasetRequest", id: 0x1, access: "M", conformance: "M", direction: "request",
            response: "DatasetResponse", xref: "cluster§10.3.6.2",

            details: "This command shall be used to request the pending dataset of the Thread network to which the border " +
                "router is connected." +
                "\n" +
                "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                "UNSUPPORTED_ACCESS." +
                "\n" +
                "If an internal error occurs, then this command shall fail with a FAILURE status code sent back to " +
                "the initiator." +
                "\n" +
                "Otherwise, this shall generate a DatasetResponse command."
        }),

        Command(
            {
                name: "DatasetResponse", id: 0x2, conformance: "M", direction: "response", xref: "cluster§10.3.6.3",
                details: "This command is sent in response to GetActiveDatasetRequest or GetPendingDatasetRequest command."
            },

            Field({
                name: "Dataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254",
                xref: "cluster§10.3.6.3.1",
                details: "If no dataset (active or pending as requested) is configured, this field shall be set to empty." +
                    "\n" +
                    "Otherwise, this field shall contain the active or pending dataset of the Thread network to which the " +
                    "Border Router is connected as an octet string containing the raw Thread TLV value of the dataset, as " +
                    "defined in the Thread specification."
            })
        ),

        Command(
            {
                name: "SetActiveDatasetRequest", id: 0x3, access: "M T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§10.3.6.4",
                details: "This command shall be used to set the active Dataset of the Thread network to which the Border " +
                    "Router is connected, when there is no active dataset already."
            },

            Field({
                name: "ActiveDataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254",
                xref: "cluster§10.3.6.4.1",
                details: "This field shall contain the active dataset to set of the Thread network to configure in the Border " +
                    "Router as an octet string containing the raw Thread TLV value of the dataset, as defined in the " +
                    "Thread specification."
            }),

            Field({
                name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "O", xref: "cluster§10.3.6.4.2",
                details: "See Breadcrumb Attribute section of General Commissioning Cluster in [MatterCore] for usage."
            })
        ),

        Command(
            {
                name: "SetPendingDatasetRequest", id: 0x4, access: "M T", conformance: "PC", direction: "request",
                response: "status", xref: "cluster§10.3.6.5",

                details: "This command shall be used to set or update the pending Dataset of the Thread network to which the " +
                    "Border Router is connected, if the Border Router supports PAN Change." +
                    "\n" +
                    "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                    "UNSUPPORTED_ACCESS." +
                    "\n" +
                    "This PendingDataset field shall contain the pending dataset to which the Thread network should be " +
                    "updated. The format of the data shall be an octet string containing the raw Thread TLV value of the " +
                    "pending dataset, as defined in the Thread specification." +
                    "\n" +
                    "If any of the parameters in the PendingDataset is invalid, the command shall fail with a status of " +
                    "INVALID_COMMAND." +
                    "\n" +
                    "Otherwise, this command shall configure the pending dataset of the Thread network to which the " +
                    "Border Router is connected, with the value given in the PendingDataset parameter. The Border Router " +
                    "will manage activation of the pending dataset as defined in the Thread specification."
            },

            Field({ name: "PendingDataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254" })
        )
    ),

    Cluster(
        {
            name: "ThreadNetworkDirectory", id: 0x453, classification: "application", pics: "THNETDIR",
            xref: "cluster§10.4",
            details: "This cluster stores a list of Thread networks (including the credentials required to access each " +
                "network), as well as a designation of the user’s preferred network, to facilitate the sharing of " +
                "Thread networks across fabrics."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "PreferredExtendedPanId", id: 0x0, type: "octstr", access: "RW VM", conformance: "M",
            constraint: "8", quality: "X N", xref: "cluster§10.4.5.1",

            details: "Indicates the Thread Extended PAN ID value for the Thread network designated by the user to be their " +
                "preferred network for commissioning of Thread devices. If not null, the value of this attribute " +
                "shall match the ExtendedPanID of a network in the ThreadNetworks attribute. A write operation with a " +
                "non-null value that does not match any network in the ThreadNetworks list shall be rejected with a " +
                "status of CONSTRAINT_ERROR." +
                "\n" +
                "The purpose of designating one Thread network as preferred is to help a commissioner to select a " +
                "Thread network when a Thread device is within suitable range of more than one Thread network which " +
                "appears in the ThreadNetworks list. A value of null indicates that there is no current preferred " +
                "network: All networks may be treated as equally preferred by a commissioner with access to this " +
                "cluster." +
                "\n" +
                "This attribute may be automatically set to the ExtendedPanID of the first Thread network added to " +
                "the ThreadNetworks list." +
                "\n" +
                "A client shall obtain user consent before changing the value of this attribute from a non-null " +
                "value." +
                "\n" +
                "On a factory reset this attribute shall be reset to null."
        }),

        Attribute(
            {
                name: "ThreadNetworks", id: 0x1, type: "list", access: "R V", conformance: "M",
                constraint: "max threadNetworkTableSize", quality: "N", xref: "cluster§10.4.5.2",

                details: "Indicates the list of Thread Networks known about by this cluster. If the node hosting this cluster " +
                    "includes a Thread Border Router, then an entry for its Thread Network shall be included in this " +
                    "list." +
                    "\n" +
                    "The list can be modified via the AddNetwork and RemoveNetwork commands." +
                    "\n" +
                    "For each entry in the list, the cluster server also stores a Thread Operational Dataset. Clients use " +
                    "the GetOperationalDataset command to obtain the Operational Dataset for an entry in this list." +
                    "\n" +
                    "On a factory reset this list shall be cleared, and any Thread Operational datasets previously stored " +
                    "shall be removed from the Node."
            },

            Field({ name: "entry", type: "ThreadNetworkStruct" })
        ),

        Attribute({
            name: "ThreadNetworkTableSize", id: 0x2, type: "uint8", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "cluster§10.4.5.3",
            details: "Indicates the maximum number of entries that can be held in the ThreadNetworks list; it shall be at " +
                "least 2 times the number of SupportedFabrics advertised in the Operational Credentials Cluster on " +
                "the root endpoint of this node."
        }),

        Command(
            {
                name: "AddNetwork", id: 0x0, access: "M T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§10.4.6.1",
                details: "Adds an entry to the ThreadNetworks attribute with the specified Thread Operational Dataset." +
                    "\n" +
                    "If there is an existing entry with the Extended PAN ID then the Thread Operational Dataset for that " +
                    "entry is replaced. As a result, changes to the network parameters (e.g. Channel, Network Name, PSKc, " +
                    "…) of an existing entry with a given Extended PAN ID can be made using this command."
            },

            Field({
                name: "OperationalDataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254",
                xref: "cluster§10.4.6.1.1",
                details: "This field shall represent the Operational Dataset for the network, using the encoding defined in " +
                    "the Thread specification. It shall contain at least the following sub-TLVs: Active Timestamp, " +
                    "Channel, Channel Mask, Extended PAN ID, Network Key, Network Mesh-Local Prefix, Network Name, PAN " +
                    "ID, PSKc, and Security Policy."
            })
        ),

        Command(
            {
                name: "RemoveNetwork", id: 0x1, access: "M T", conformance: "M", direction: "request",
                response: "status", xref: "cluster§10.4.6.2",
                details: "Removes the network with the given Extended PAN ID from the ThreadNetworks attribute."
            },
            Field({ name: "ExtendedPanId", id: 0x0, type: "octstr", conformance: "M", constraint: "8" })
        ),

        Command(
            {
                name: "GetOperationalDataset", id: 0x2, access: "M", conformance: "M", direction: "request",
                response: "OperationalDatasetResponse", xref: "cluster§10.4.6.3",
                details: "Retrieves the Thread Operational Dataset with the given Extended PAN ID."
            },
            Field({ name: "ExtendedPanId", id: 0x0, type: "octstr", conformance: "M", constraint: "8" })
        ),

        Command(
            {
                name: "OperationalDatasetResponse", id: 0x3, conformance: "M", direction: "response",
                xref: "cluster§10.4.6.4",
                details: "Contains the Thread Operational Dataset for the Extended PAN specified in GetOperationalDataset."
            },
            Field({ name: "OperationalDataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254" })
        ),

        Datatype(
            {
                name: "ThreadNetworkStruct", type: "struct", xref: "cluster§10.4.4.1",
                details: "Represents the data associated with a Thread Network."
            },

            Field({
                name: "ExtendedPanId", id: 0x0, type: "octstr", conformance: "M", constraint: "8",
                xref: "cluster§10.4.4.1.1",
                details: "This field shall indicate the Extended PAN ID from the OperationalDataset for the given Thread " +
                    "network."
            }),

            Field({
                name: "NetworkName", id: 0x1, type: "string", conformance: "M", constraint: "1 to 16",
                xref: "cluster§10.4.4.1.2",
                details: "This field shall indicate the Network Name from the OperationalDataset for the given Thread network."
            }),
            Field({
                name: "Channel", id: 0x2, type: "uint16", conformance: "M", xref: "cluster§10.4.4.1.3",
                details: "This field shall indicate the Channel from the OperationalDataset for the given Thread network."
            }),
            Field({
                name: "ActiveTimestamp", id: 0x3, type: "uint64", conformance: "M", xref: "cluster§10.4.4.1.4",
                details: "This field shall indicate the Active Timestamp from the OperationalDataset for the given Thread " +
                    "network."
            })
        )
    ),

    Attribute({
        name: "ClusterRevision", id: 0xfffd, type: "uint16", access: "R V", conformance: "M",
        constraint: "min 1", isSeed: true, quality: "F", xref: "core§7.13.1",

        details: "The ClusterRevision attribute indicates the revision of the server cluster specification supported " +
            "by the cluster instance. An implementation of a cluster specification before the ClusterRevision " +
            "attribute was added shall have an assumed cluster revision of 0 (zero). For a new cluster " +
            "specification, the initial value for the ClusterRevision attribute shall be 1 (not zero)." +
            "\n" +
            "A history of revision numbers for a cluster specification release is listed in the Revision History " +
            "section for a cluster specification. Each new revision of a cluster specification shall specify a " +
            "new revision number incremented (by 1) from the last. The highest revision number in a cluster " +
            "specification’s Revision History is the revision number for the cluster specification. Therefore, a " +
            "ClusterRevision attribute value shall be the (highest) revision number of the cluster specification " +
            "that has been implemented."
    }),

    Attribute({
        name: "FeatureMap", id: 0xfffc, type: "map32", access: "R V", conformance: "M", default: 0,
        isSeed: true, quality: "F", xref: "core§7.13.2",

        details: "Each instance of a cluster shall support this attribute." +
            "\n" +
            "The FeatureMap attribute shall indicate whether the server supports zero or more optional cluster " +
            "features. A cluster feature is a set of cluster elements that are mandatory or optional for a " +
            "defined feature of the cluster. If a cluster feature is supported by the cluster instance, then the " +
            "corresponding bit shall be set to 1, otherwise the bit shall be set to 0 (zero). All undefined bits " +
            "in this attribute shall be set to 0 (zero)." +
            "\n" +
            "The set of cluster elements that are designated as mandatory (M) are implicitly part of the " +
            "mandatory cluster feature set, and do not have a bit in the FeatureMap attribute." +
            "\n" +
            "A cluster specification shall support this attribute if the cluster supports features. If a cluster " +
            "specification is revised to support features (and so this attribute), each bit in the FeatureMap " +
            "attribute shall have a defined default value (1 or 0), to conform with the previous revision of the " +
            "cluster specification, that did not support the FeatureMap attribute. The value of 1 means the " +
            "feature elements were mandatory (M) in the previous revision. The value of 0 (zero) means the " +
            "elements were optional in the previous revision." +
            "\n" +
            "Any newly created feature set of a cluster shall be dependent on that cluster." +
            "\n" +
            "Feature sets are revision controlled as part of a cluster using the ClusterRevision attribute. The " +
            "cluster specification is the independent element that is revision controlled. A remote application " +
            "reading the FeatureMap and ClusterRevision attribute will then know exactly what features are " +
            "supported in the cluster instance." +
            "\n" +
            "Each feature set shall be well defined within the cluster specification. Each feature shall be " +
            "mapped to a short capitalized code name for the feature set to be referenced as a conformance tag in " +
            "the cluster specification text, including the Conformance columns defining the elements of the " +
            "cluster." +
            "\n" +
            "If a cluster defines more than 32 feature sets, then it will be necessary to add another feature " +
            "bitmap attribute. Any client trying to reference the new feature set will know about the new bitmap, " +
            "because it knows about the new feature set(s). Legacy products will not know about the new feature " +
            "set nor the new bitmap." +
            "\n" +
            "For a cluster whose definition which does not define a FeatureMap, the server shall set this " +
            "attribute to 0 (zero)." +
            "\n" +
            "See Section 7.3.16, “Feature Conformance” for details on conformance."
    }),

    Attribute(
        {
            name: "AttributeList", id: 0xfffb, type: "list", access: "R V", conformance: "M", isSeed: true,
            quality: "F", xref: "core§7.13.3",
            details: "Each instance of a cluster shall support this attribute. This attribute shall be a list of the " +
                "attribute IDs of the attributes supported by the cluster instance."
        },

        Field({ name: "entry", type: "attrib-id" })
    ),

    Attribute({ name: "EventList", id: 0xfffa, conformance: "D", isSeed: true, xref: "core§7.13" }),

    Attribute(
        {
            name: "AcceptedCommandList", id: 0xfff9, type: "list", access: "R V", conformance: "M",
            isSeed: true, quality: "F", xref: "core§7.13.4",

            details: "This attribute is a list of client generated commands which are supported by this cluster server " +
                "instance." +
                "\n" +
                "Each instance of a cluster shall support this attribute." +
                "\n" +
                "This attribute shall be a list of the command IDs for client generated commands that are supported " +
                "and processed by the server." +
                "\n" +
                "For each client request command in this list that mandates a response from the server, the response " +
                "command shall be indicated in the GeneratedCommandList attribute." +
                "\n" +
                "If any attribute on a server supports atomic writes, this attribute shall contain the command ID for " +
                "AtomicRequest."
        },

        Field({ name: "entry", type: "command-id" })
    ),

    Attribute(
        {
            name: "GeneratedCommandList", id: 0xfff8, type: "list", access: "R V", conformance: "M",
            isSeed: true, quality: "F", xref: "core§7.13.5",

            details: "This attribute is a list of server generated commands. A server generated command is a server to " +
                "client command." +
                "\n" +
                "Each instance of a cluster shall support this attribute." +
                "\n" +
                "This attribute shall be a list of the command IDs for server generated commands." +
                "\n" +
                "For each command in this list that is a response to a client request command, the request command " +
                "shall be indicated in the AcceptedCommandList attribute." +
                "\n" +
                "If any attribute on a server supports atomic writes, this attribute shall contain the command ID for " +
                "AtomicResponse."
        },

        Field({ name: "entry", type: "command-id" })
    ),

    Field({
        name: "FabricIndex", id: 0xfe, type: "fabric-idx", access: "R F V", conformance: "M",
        constraint: "1 to 254", isSeed: true, xref: "core§7.13.6",

        details: "This field shall be present for fabric-scoped data. This field does not have to be defined " +
            "explicitly in the field table for fabric-scoped data." +
            "\n" +
            "This field shall NOT be present in a write interaction. For a write interaction, the server shall " +
            "provide the value of the accessing fabric-index as the FabricIndex field value to processing logic, " +
            "after receipt of the interaction. For a read interaction this field shall be included in all " +
            "reported data that is defined as fabric-scoped."
    }),

    Datatype(
        { name: "AtomicRequestTypeEnum", type: "enum8", xref: "core§7.15.4" },
        Field({ name: "BeginWrite", id: 0x0, conformance: "M", description: "Begin an atomic write" }),
        Field({ name: "CommitWrite", id: 0x1, conformance: "M", description: "Commit an atomic write" }),
        Field({
            name: "RollbackWrite", id: 0x2, conformance: "M",
            description: "Rollback an atomic write, discarding any pending changes"
        })
    ),

    Datatype(
        {
            name: "AtomicAttributeStatusStruct", type: "struct", xref: "core§7.15.5",
            details: "This struct indicates the status of an attribute during an atomic write."
        },
        Field({
            name: "AttributeId", id: 0x0, type: "attrib-id", conformance: "M", xref: "core§7.15.5.1",
            details: "This field shall indicate the ID of the attribute with the associated StatusCode."
        }),
        Field({
            name: "StatusCode", id: 0x1, type: "status", conformance: "M", xref: "core§7.15.5.2",
            details: "This field shall indicate the atomic status of an attribute."
        })
    ),

    Datatype({ name: "bool", description: "Boolean", isSeed: true, metatype: "boolean", xref: "core§7.19.1" }),
    Datatype({ name: "map8", byteSize: 1, description: "8-bit bitmap", isSeed: true, metatype: "bitmap", xref: "core§7.19.1" }),
    Datatype({ name: "map16", byteSize: 2, description: "16-bit bitmap", isSeed: true, metatype: "bitmap", xref: "core§7.19.1" }),
    Datatype({ name: "map32", byteSize: 4, description: "32-bit bitmap", isSeed: true, metatype: "bitmap", xref: "core§7.19.1" }),
    Datatype({ name: "map64", byteSize: 8, description: "64-bit bitmap", isSeed: true, metatype: "bitmap", xref: "core§7.19.1" }),
    Datatype({
        name: "uint8", byteSize: 1, description: "Unsigned 8-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint16", byteSize: 2, description: "Unsigned 16-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint24", byteSize: 3, description: "Unsigned 24-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint32", byteSize: 4, description: "Unsigned 32-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint40", byteSize: 5, description: "Unsigned 40-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint48", byteSize: 6, description: "Unsigned 48-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint56", byteSize: 7, description: "Unsigned 56-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "uint64", byteSize: 8, description: "Unsigned 64-bit integer", isSeed: true,
        metatype: "integer", xref: "core§7.19.1"
    }),
    Datatype({
        name: "int8", byteSize: 1, description: "Signed 8-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int16", byteSize: 2, description: "Signed 16-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int24", byteSize: 3, description: "Signed 24-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int32", byteSize: 4, description: "Signed 32-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int40", byteSize: 5, description: "Signed 40-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int48", byteSize: 6, description: "Signed 48-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int56", byteSize: 7, description: "Signed 56-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "int64", byteSize: 8, description: "Signed 64-bit integer", isSeed: true, metatype: "integer",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "single", byteSize: 4, description: "Single precision", isSeed: true, metatype: "float",
        xref: "core§7.19.1"
    }),
    Datatype({
        name: "double", byteSize: 8, description: "Double precision", isSeed: true, metatype: "float",
        xref: "core§7.19.1"
    }),
    Datatype({ name: "octstr", description: "Octet string", isSeed: true, metatype: "bytes", xref: "core§7.19.1" }),

    Datatype({
        name: "list", description: "List", isSeed: true, metatype: "array", xref: "core§7.19.1.8",

        details: "A list is defined as a collection of entries of the same data type, with a finite count from 0 to " +
            "65534. A cluster specification may define further constraints on the maximum possible count. The " +
            "list entry data type shall be any defined data type, except a list data type, or any data type " +
            "derived from a list." +
            "\n" +
            "The quality columns for a list definition are for the list." +
            "\n" +
            "The list entries are indicated with an index that is an unsigned integer starting at 0 (zero). The " +
            "maintained order of entries, by index, is defined in the cluster specification, or undefined. Data " +
            "that is defined as a list is indicated with \"list[X]\" where X is the entry type. The data type of " +
            "the list entry has its own qualities, constraints, and conformance." +
            "\n" +
            "### To define qualities for the list entry data type, make the list entry data type a defined local " +
            "derived data type, with a table including the columns required to define and constrain the data " +
            "type." +
            "\n" +
            "There is an inline shortcut to define the list entry data type constraints. See List Constraints." +
            "\n" +
            "It is recommended to put a maximum constraint on the list and list entry data types." +
            "\n" +
            "It is recommended that a list entry data type be a struct, to enable the addition of new fields to " +
            "the list’s entries in the future." +
            "\n" +
            "  • The cluster data version shall be incremented when the list order or entries change." +
            "\n" +
            "  • An entry shall NOT be NULL." +
            "\n" +
            "  • The list shall support reading and reporting all entries." +
            "\n" +
            "  • The list shall support reporting, updates, and/or deletion of one or more entries." +
            "\n" +
            "  • If the list is writable, it shall support writing or deleting the entire list." +
            "\n" +
            "  • If the list is writable, it shall support updating one or more individual entries by indicating " +
            "    an index per updated entry." +
            "\n" +
            "  • If the list is writable, it shall support deleting one or more individual entries by indicating " +
            "    an index per deleted entry." +
            "\n" +
            "  • If the list is writable, it shall support adding one or more individual entries." +
            "\n" +
            "  • A list may define an entry that is a struct that is fabric-scoped (see Section 7.6.4, " +
            "    “Fabric-Scoped Access”)." +
            "\n" +
            "### Fabric-Scoped List" +
            "\n" +
            "  • A fabric-scoped list shall define an entry data type that is a struct, which shall also be " +
            "    fabric-scoped (see Fabric-Scoped Struct)." +
            "\n" +
            "Each entry in a fabric-scoped list shall be fabric-scoped to a particular fabric or no fabric." +
            "\n" +
            "### Fabric-Filtered List" +
            "\n" +
            "A fabric-scoped list supports a fabric-filter that filters the view of the list for read and write " +
            "interactions. This filter simplifies client side logic that does not want to read or write fabric " +
            "data that is not associated with the accessing fabric." +
            "\n" +
            "  • An interaction upon a list with fabric-filtering shall only indicate and access entries where " +
            "    the associated fabric matches the accessing fabric, and all other entries shall be ignored." +
            "\n" +
            "  • Fabric-filtered list entries shall be in the same order as the full list." +
            "\n" +
            "  • Fabric-filtered list entries shall be indexed from 0 with no gaps, as if the other entries did " +
            "    not exist." +
            "\n" +
            "  • For a write interaction, fabric-filtering shall be enabled." +
            "\n" +
            "  • When writing to a fabric-scoped list, the write interaction shall be on an accessing fabric, " +
            "    otherwise, the write interaction shall fail (see Interaction Model Specification)." +
            "\n" +
            "  • For a read interaction on a list, fabric-filtering may be enabled." +
            "\n" +
            "  • For a read interaction on a list, with fabric-filtering disabled, the list shall be reported as " +
            "    a full list with all entries."
    }),

    Datatype({
        name: "struct", description: "Struct", isSeed: true, metatype: "object", xref: "core§7.19.1.9",

        details: "A struct is a sequence of fields of any data type. Individual fields are identified by a field ID of " +
            "unsigned integer, starting at 0 (zero), for the first field." +
            "\n" +
            "  • A struct itself shall have no constraint qualities." +
            "\n" +
            "  • Each struct field shall have its own qualities." +
            "\n" +
            "  • Access, conformance and persistence qualities, when not explicitly defined, shall be inherited " +
            "    from the instance of the struct itself." +
            "\n" +
            "  • Struct fields may have optional conformance." +
            "\n" +
            "  • A struct shall support reading and reporting of all fields." +
            "\n" +
            "  • A struct shall support reporting changes to one or more fields." +
            "\n" +
            "  • If the struct is writable, it shall support writing the entire struct." +
            "\n" +
            "  • If a field of the struct is writable, the struct shall support updating the field." +
            "\n" +
            "  • Because of optional struct field conformance, instances of the same struct may support multiple " +
            "    'flavors' of the same struct data type, but with a different set of optional fields." +
            "\n" +
            "### Fabric-Scoped Struct" +
            "\n" +
            "  • A fabric-scoped struct shall only be defined and occur as an entry in a fabric-scoped list." +
            "\n" +
            "  • A fabric-scoped struct shall support the global FabricIndex field of type fabric-index, which " +
            "    indicates the associated fabric of the struct, or indicates that there is no associated fabric." +
            "\n" +
            "  • The table that defines fields of a fabric-scoped struct shall NOT list the global FabricIndex " +
            "    field, which is a global field and defined implicitly." +
            "\n" +
            "  • The global FabricIndex field of a fabric-scoped struct SHOULD NOT be indicated in a write " +
            "    interaction." +
            "\n" +
            "  • The global FabricIndex field of a fabric-scoped struct shall be ignored in a write interaction." +
            "\n" +
            "  • The global FabricIndex field SHOULD NOT be indicated on a fabric-scoped struct contained in the " +
            "    payload of a request command." +
            "\n" +
            "  • The global FabricIndex field shall be ignored on a fabric-scoped struct contained in the payload " +
            "    of a request command." +
            "\n" +
            "  • When a write interaction creates a fabric-scoped struct entry (in a fabric-scoped list), the " +
            "    server shall implicitly load the accessing fabric-index into the global FabricIndex field of the " +
            "    struct." +
            "\n" +
            "  • When the payload of a request command contains a fabric-scoped struct, the server shall " +
            "    implicitly load the accessing fabric-index into the global FabricIndex field of the struct." +
            "\n" +
            "### • A fabric-scoped struct may be defined with some fields that are fabric-sensitive." +
            "\n" +
            "  • For interactions on a fabric-scoped struct that report back data, fabric-sensitive struct fields " +
            "    shall be omitted when reporting data back to the client, when the struct has an associated " +
            "    fabric, and it is not the accessing fabric."
    }),

    Datatype({ name: "percent", type: "uint8", description: "Percentage units 1%", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "percent100ths", type: "uint16", description: "Percentage units 0.01%", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "epoch-us", type: "uint64", description: "Epoch Time in microseconds", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "epoch-s", type: "uint32", description: "Epoch Time in seconds", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "posix-ms", type: "uint64", description: "POSIX Time in milliseconds", isSeed: true, xref: "core§7.19.2" }),
    Datatype({
        name: "systime-us", type: "uint64", description: "System Time in microseconds", isSeed: true,
        xref: "core§7.19.2"
    }),
    Datatype({
        name: "systime-ms", type: "uint64", description: "System Time in milliseconds", isSeed: true,
        xref: "core§7.19.2"
    }),
    Datatype({ name: "elapsed-s", type: "uint32", description: "Elapsed Time in seconds", isSeed: true, xref: "core§7.19.2" }),

    Datatype(
        {
            name: "temperature", type: "int16", description: "Temperature", isSeed: true, xref: "core§7.19.2.9",

            details: "This type represents a temperature on the Celsius scale with a resolution of 0.01°C." +
                "\n" +
                "  • value = (temperature in °C) x 100" +
                "\n" +
                "The range is constrained by absolute zero: -273.15°C to 327.67°C." +
                "\n" +
                "### Conversion of Temperature Values for Display" +
                "\n" +
                "When converting temperature values for display manufacturers SHOULD ensure that calculations round " +
                "to the nearest representable value. Particular care is needed when using integer arithmetic." +
                "\n" +
                "### Sample Conversion Code" +
                "\n" +
                "Sample code provided to ensure consistent Fahrenheit to Celsius and vice-versa conversion between " +
                "devices and across vendors." +
                "\n" +
                "For degF: the value is a int8u representing 2x temperature value in Fahrenheit (to get 0.5 " +
                "resolution)." +
                "\n" +
                "For degC: the value is a int16s representing Celsius in 0.01 resolution as expected by the Matter " +
                "format."
        }
    ),

    Datatype({ name: "power-mW", type: "int64", description: "Power", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "amperage-mA", type: "int64", description: "Amperage", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "voltage-mV", type: "int64", description: "Voltage", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "energy-mWh", type: "int64", description: "Energy", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "power-mVA", type: "int64", description: "Apparent Power", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "energy-mVAh", type: "int64", description: "Apparent Energy", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "power-mVAR", type: "int64", description: "Reactive Power", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "energy-mVARh", type: "int64", description: "Reactive Energy", isSeed: true, xref: "core§7.19.2" }),

    Datatype({
        name: "money", type: "int64", description: "Money", isSeed: true, xref: "core§7.19.2.18",

        details: "This type represents an amount of money." +
            "\n" +
            "The money type shall be used in concert with a CurrencyStruct to indicate the currency in use, as " +
            "well as the number of digits after the decimal point in the amount of that currency." +
            "\n" +
            "For example, if a given money value is 1015, the value of the associated Currency field is 840 " +
            "(USD), and the value of the associated DecimalPoints field is 4, then the represented amount would " +
            "be 0.1015 dollars, or 10.15 cents." +
            "\n" +
            "Similarly, if a given money value is 1015, the value of the associated Currency field is 978 (EUR), " +
            "and the value of the associated DecimalPoints field is 2, then the represented amount would be 10.15 " +
            "euros." +
            "\n" +
            "Similarly, if a given money value is 1015, the value of the associated Currency field is 392 (JPY), " +
            "and the value of the associated DecimalPoints field is 0, then the represented amount would be 1015 " +
            "yen." +
            "\n" +
            "Operations involving money types shall be done using fixed point arithmetic. The results of " +
            "arithmetic operations involving money shall be rescaled in accordance with the associated Currency " +
            "structure rather than result in altering the DecimalPoints."
    }),

    Datatype({
        name: "enum8", type: "uint8", description: "8-bit enumeration", isSeed: true, metatype: "enum",
        xref: "core§7.19.2"
    }),
    Datatype({
        name: "enum16", type: "uint16", description: "16-bit enumeration", isSeed: true, metatype: "enum",
        xref: "core§7.19.2"
    }),

    Datatype(
        {
            name: "priority", type: "enum8", description: "Priority", isSeed: true, xref: "core§7.19.2.20",
            details: "This is an enumeration of priority used to tag events and possibly other data. The data type does " +
                "not define any particular ordering among the values. Specific uses of the data type may assign " +
                "semantics to the values that imply an ordering relationship."
        },

        Field({ name: "Debug", id: 0x0, description: "Information for engineering debugging/troubleshooting" }),
        Field({
            name: "Info", id: 0x1,
            description: "Information that either drives customer facing features or provides insights into device functions that are used to drive analytics use cases"
        }),
        Field({
            name: "Critical", id: 0x2,
            description: "Information or notification that impacts safety, a critical function, or ongoing reliable operation of the node or application supported on an endpoint."
        })
    ),

    Datatype(
        {
            name: "status", type: "enum8", description: "Status Code", isSeed: true, metatype: "enum",
            xref: "core§7.19.2"
        },
        Field({ name: "Success", id: 0x0, description: "Operation was successful.", xref: "core§8.10.1" }),
        Field({ name: "Failure", id: 0x1, description: "Operation was not successful.", xref: "core§8.10.1" }),
        Field({ name: "InvalidSubscription", id: 0x7d, description: "Subscription ID is not active.", xref: "core§8.10.1" }),
        Field({
            name: "UnsupportedAccess", id: 0x7e,
            description: "The sender of the action or command does not have authorization or access.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedEndpoint", id: 0x7f,
            description: "The endpoint indicated is unsupported on the node.", xref: "core§8.10.1"
        }),
        Field({
            name: "InvalidAction", id: 0x80,
            description: "The action is malformed, has missing fields, or fields with invalid values. Action not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedCommand", id: 0x81,
            description: "The indicated command ID is not supported on the cluster instance. Command not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "InvalidCommand", id: 0x85,
            description: "The cluster command is malformed, has missing fields, or fields with invalid values. Command not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedAttribute", id: 0x86,
            description: "The indicated attribute ID, field ID or list entry does not exist for an attribute path.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "ConstraintError", id: 0x87,
            description: "Out of range error or set to a reserved value. Attribute keeps its old value. Note that an attribute value may be out of range if an attribute is related to another, e.g. with minimum and maximum attributes. See the individual attribute descriptions for specific details.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedWrite", id: 0x88, description: "Attempt to write a read-only attribute.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "ResourceExhausted", id: 0x89,
            description: "An action or operation failed due to insufficient available resources.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "NotFound", id: 0x8b, description: "The indicated data field or entry could not be found.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnreportableAttribute", id: 0x8c,
            description: "Reports cannot be issued for this attribute.", xref: "core§8.10.1"
        }),
        Field({
            name: "InvalidDataType", id: 0x8d,
            description: "The data type indicated is undefined or invalid for the indicated data field. Command or action not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedRead", id: 0x8f, description: "Attempt to read a write-only attribute.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "DataVersionMismatch", id: 0x92,
            description: "Cluster instance data version did not match request path", xref: "core§8.10.1"
        }),
        Field({
            name: "Timeout", id: 0x94, description: "The transaction was aborted due to time being exceeded.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedNode", id: 0x9b,
            description: "The node ID indicated is not supported on the node.", xref: "core§8.10.1"
        }),
        Field({
            name: "Busy", id: 0x9c,
            description: "The receiver is busy processing another action that prevents the execution of the incoming action.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "AccessRestricted", id: 0x9d,
            description: "The access to the action or command by the sender is permitted by the ACL but restricted by the ARL.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedCluster", id: 0xc3,
            description: "The cluster indicated is not supported on the endpoint.", xref: "core§8.10.1"
        }),
        Field({
            name: "NoUpstreamSubscription", id: 0xc5,
            description: "Used by proxies to convey to clients the lack of an upstream subscription to a source.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "NeedsTimedInteraction", id: 0xc6,
            description: "A Untimed Write or Untimed Invoke interaction was used for an attribute or command that requires a Timed Write or Timed Invoke.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "UnsupportedEvent", id: 0xc7,
            description: "The indicated event ID is not supported on the cluster instance.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "PathsExhausted", id: 0xc8,
            description: "The receiver has insufficient resources to support the specified number of paths in the request",
            xref: "core§8.10.1"
        }),
        Field({
            name: "TimedRequestMismatch", id: 0xc9,
            description: "A request with TimedRequest field set to TRUE was issued outside a Timed transaction or a request with TimedRequest set to FALSE was issued inside a Timed transaction.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "FailsafeRequired", id: 0xca,
            description: "A request requiring a Fail-safe context was invoked without the Fail-Safe context.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "InvalidInState", id: 0xcb,
            description: "The received request cannot be handled due to the current operational state of the device",
            xref: "core§8.10.1"
        }),
        Field({
            name: "NoCommandResponse", id: 0xcc,
            description: "A CommandDataIB is missing a response in the InvokeResponses of an Invoke Response action.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "TermsAndConditionsChanged", id: 0xcd,
            description: "The node requires updated TC acceptance. The user MAY be directed to visit the EnhancedSetupFlowMaintenanceUrl to complete this.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "MaintenanceRequired", id: 0xce,
            description: "The node requires the user to visit the EnhancedSetupFlowMaintenanceUrl for instructions on further action.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "DynamicConstraintError", id: 0xcf,
            description: "The value for the data type was not accepted due to runtime validation issues. Command or action not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "AlreadyExists", id: 0xd0,
            description: "Attempt to create an entity that already exists or create an entity with an identifier that is already in use. Command or action not carried out.",
            xref: "core§8.10.1"
        }),
        Field({
            name: "InvalidTransportType", id: 0xd1,
            description: "Attempt to process on a transport type not valid for this element. Command or action not carried out.",
            xref: "core§8.10.1"
        })
    ),

    Datatype({ name: "group-id", type: "uint16", description: "Group ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "endpoint-no", type: "uint16", description: "Endpoint Number", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "vendor-id", type: "uint16", description: "Vendor ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "devtype-id", type: "uint32", description: "Device Type ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "fabric-id", type: "uint64", description: "Fabric ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "fabric-idx", type: "uint8", description: "Fabric Index", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "cluster-id", type: "uint32", description: "Cluster ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "attrib-id", type: "uint32", description: "Attribute ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "field-id", type: "uint32", description: "Field ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "event-id", type: "uint32", description: "Event ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "command-id", type: "uint32", description: "Command ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "action-id", type: "uint8", description: "Action ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "trans-id", type: "uint32", description: "Transaction ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "node-id", type: "uint64", description: "Node ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "subject-id", type: "uint64", description: "Subject ID", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "entry-idx", type: "uint16", description: "Entry Index", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "data-ver", type: "uint32", description: "Data Version", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "event-no", type: "uint64", description: "Event Number", isSeed: true, xref: "core§7.19.2" }),

    Datatype(
        {
            name: "namespace", type: "enum8", description: "Namespace", isSeed: true, xref: "core§7.19.2.47",
            details: "The Namespace type identifies the namespace used for a semantic tag."
        },

        Field({
            name: "Closure", id: 0x1,

            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a feature of a Closure, e.g. the button to activate opening a garage door." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> This namespace has been deprecated as of Matter 1.4.2." +
                "\n" +
                "Clients SHOULD still have support for these tags, since the tags could be used by a server certified " +
                "on a previous revision of Matter."
        }),

        Field({
            name: "CompassDirection", id: 0x2,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a movement into a certain compass direction. Note the difference with Chapter 4, " +
                "Common Compass Location Semantic Tag Namespace."
        }),

        Field({
            name: "CompassLocation", id: 0x3,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position in a certain compass direction (e.g. an outdoor sensor in the North " +
                "garden). Note the difference with Chapter 3, Common Compass Direction Semantic Tag Namespace."
        }),

        Field({
            name: "Direction", id: 0x4,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a movement in a certain direction relative to the device. Note the difference with " +
                "Chapter 9, Common Position Semantic Tag Namespace."
        }),

        Field({
            name: "Level", id: 0x5,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a certain level for a feature of a device (e.g. a button to set the speed of a " +
                "fan)."
        }),

        Field({
            name: "Location", id: 0x6,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a location of a device (e.g. an outdoor temperature sensor)."
        }),
        Field({
            name: "Number", id: 0x7,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a certain numeric feature of a device (e.g. a numeric input button)."
        }),

        Field({
            name: "Position", id: 0x8,

            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position relative to the device (e.g. the temperature sensor in the top drawer of " +
                "a refrigerator, or location of the buttons on a multi-button switch device). Note the difference " +
                "with Chapter 5, Common Direction Semantic Tag Namespace." +
                "\n" +
                "When multiple endpoints are used for device types, and the associated consumer-facing locations of " +
                "those endpoints are organized in a straight line, grid or matrix, these endpoints SHOULD be " +
                "allocated in top-to-bottom, left-to-right order." +
                "\n" +
                "For grids or arrays larger than 3 elements in any direction, the Row and Column tags SHOULD be used." +
                "\n" +
                "If the Row or Column tags are used, the Label field in the same Semantic Tag structure shall be " +
                "filled with a number comprised of Arabic numerals encoded as a string to indicate the row/column of " +
                "the item. Number words (e.g. \"one\", \"two\", etc.) shall NOT be used to describe the position of the " +
                "item. The first row/column shall use Label \"1\"." +
                "\n" +
                "The following example illustrates a compound device comprised of 9 endpoints arranged in a 3x3 grid. " +
                "This example uses position tags to indicate position."
        }),

        Field({
            name: "ElectricalMeasurement", id: 0xa,
            details: "The tags contained in this namespace are restricted for use in the electrical measurement domain and " +
                "shall NOT be used in any other domain or context."
        }),
        Field({
            name: "Laundry", id: 0xe,
            details: "The tags contained in this namespace are restricted for use in the laundry domain and shall NOT be " +
                "used in any other domain or context."
        }),
        Field({
            name: "PowerSource", id: 0xf,
            details: "The tags contained in this namespace are restricted for use in the power source domain and shall NOT " +
                "be used in any other domain or context."
        }),
        Field({
            name: "AreaNamespace", id: 0x10,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with an indoor or outdoor area of a home."
        }),
        Field({
            name: "LandmarkNamespace", id: 0x11,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a home landmark."
        }),

        Field({
            name: "RelativePosition", id: 0x12,
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position relative to some reference, which must be specified by the user of these " +
                "tags. For example, the position may be relative to a household item, such as a dining table, and the " +
                "user of these tags must indicate that. Note the difference with Chapter 9, Common Position Semantic " +
                "Tag Namespace, which contains tags indicating the position relative to the device."
        }),

        Field({
            name: "Refrigerator", id: 0x41,
            details: "The tags contained in this namespace are restricted for use in the refrigerator domain and shall NOT " +
                "be used in any other domain or context."
        }),
        Field({
            name: "RoomAirConditioner", id: 0x42,
            details: "The tags contained in this namespace are restricted for use in the room air conditioner domain and " +
                "shall NOT be used in any other domain or context."
        }),

        Field({
            name: "Switches", id: 0x43,

            details: "The tags contained in this namespace are restricted for use in the switches domain and shall NOT be " +
                "used in any other domain or context. They are intended to indicate the function of a button on a " +
                "switch device to allow a client to make an optimized user interface which matches the actual device " +
                "without requiring a-priori knowledge of the layout of each specific switch device." +
                "\n" +
                "See the rules for applying these and other tags for switch devices, e.g. from the Common Position " +
                "Namespace and the Common Number Namespace in the Generic Switch device type section in the Device " +
                "Library."
        })
    ),

    Datatype({
        name: "tag", type: "enum8", description: "Tag", isSeed: true, xref: "core§7.19.2.48",
        details: "The Tag type shall identify a semantic tag located within a namespace."
    }),

    Datatype(
        {
            name: "ThreeLevelAutoEnum", type: "enum8", description: "Three-Level Auto Setting", isSeed: true,
            xref: "core§7.19.2.50",
            details: "It is used for a three-level and Auto setting of an attribute on a device. This data type has four " +
                "values as enumerated below, and cannot be expanded."
        },

        Field({ name: "Auto", id: 0x0, conformance: "M", description: "Automatic Level" }),
        Field({ name: "Low", id: 0x1, conformance: "M", description: "Low Level" }),
        Field({ name: "Medium", id: 0x2, conformance: "M", description: "Medium Level" }),
        Field({ name: "High", id: 0x3, conformance: "M", description: "High Level" })
    ),

    Datatype({
        name: "string", type: "octstr", description: "Character String", isSeed: true, metatype: "string",
        xref: "core§7.19.2"
    }),
    Datatype({ name: "ipadr", type: "octstr", description: "IP Address", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "ipv4adr", type: "octstr", description: "IPv4 Address", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "ipv6adr", type: "octstr", description: "IPv6 Address", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "ipv6pre", type: "octstr", description: "IPv6 Prefix", isSeed: true, xref: "core§7.19.2" }),
    Datatype({ name: "hwadr", type: "octstr", description: "Hardware Address", isSeed: true, xref: "core§7.19.2" }),

    Datatype(
        {
            name: "semtag", type: "struct", description: "Semantic Tag", isSeed: true, xref: "core§7.19.2.46",
            details: "This data type shall be represented by the following structure:"
        },

        Field({
            name: "MfgCode", id: 0x0, type: "vendor-id", conformance: "M", default: null, quality: "X",
            xref: "core§7.19.2.46.1",

            details: "If the MfgCode field is not NULL, it shall be the Vendor ID of the manufacturer who has defined a " +
                "certain namespace and the NamespaceID field shall be the ID of a namespace defined by the " +
                "manufacturer identified in the MfgCode field." +
                "\n" +
                "If a manufacturer specific Tag field is indicated in a list of SemanticTagStruct entries, the list " +
                "shall include at least one standard tag which is not from any manufacturer’s namespace. A standard " +
                "tag is a tag from a common namespace, a derived cluster namespace, or an applicable device-specific " +
                "namespace." +
                "\n" +
                "If MfgCode is NULL, the NamespaceID field shall indicate a standard namespace."
        }),

        Field({
            name: "NamespaceId", id: 0x1, type: "namespace", conformance: "M", xref: "core§7.19.2.46.2",
            details: "The NamespaceID field shall identify a namespace." +
                "\n" +
                "The common and device-specific semantic tag namespaces are listed in StandardNamespaces."
        }),

        Field({
            name: "Tag", id: 0x2, type: "tag", conformance: "M", xref: "core§7.19.2.46.3",
            details: "The Tag field shall be the ID of a semantic tag located within the namespace indicated by " +
                "NamespaceID." +
                "\n" +
                "A device may expose tags from the common or device-specific namespaces and from " +
                "manufacturer-specific namespaces in a single TagList."
        }),

        Field({
            name: "Label", id: 0x3, type: "string", conformance: "MfgCode != null, O", constraint: "max 64",
            default: null, quality: "X", xref: "core§7.19.2.46.4",

            details: "The Label field, if present, shall contain human-readable text suitable for display on a client. The " +
                "content of the Label field is defined by the manufacturer." +
                "\n" +
                "This field shall be present when the MfgCode is not NULL. This field SHOULD NOT be used if the Tag " +
                "is from a standard namespace, unless the Tag requires further qualification. For example: A Tag that " +
                "has the meaning of \"room\" in a location namespace, would require the a label string to qualify the " +
                "type of room, such as \"1\", \"2b\", \"Bathroom\", etc."
        })
    ),

    Datatype(
        {
            name: "locationdesc", type: "struct", description: "Location Descriptor", isSeed: true,
            xref: "core§7.19.2.49",
            details: "This data type shall be represented by the following structure:"
        },

        Field({
            name: "LocationName", id: 0x0, type: "string", conformance: "M", constraint: "max 128",
            xref: "core§7.19.2.49.1",
            details: "This field shall indicate the name of the location. For example, \"blue room\"." +
                "\n" +
                "If the location name is not user provided, the logic that generates it (clients, devices etc.) " +
                "SHOULD utilize synthesized user-friendly, understandable, names for the location, rather than opaque " +
                "values such as \"private\" or \"2fe7c241-a50a-4863-896e-c5878da5ed68\"."
        }),

        Field({
            name: "FloorNumber", id: 0x1, type: "int16", conformance: "M", quality: "X",
            xref: "core§7.19.2.49.2",

            details: "This field shall indicate the level number. Negative values correspond to basement levels." +
                "\n" +
                "Value zero indicates this is the main floor, which typically includes the main entrance to the " +
                "user’s home. For a building with multiple levels, it is the client’s responsibility to map each " +
                "level to/from a FloorNumber tag value, using the level numbering convention of the region where the " +
                "client operates. For example, if the client operates in Europe, building level 1, which is one level " +
                "up from the street level, SHOULD be mapped to FloorNumber tag value 0x1. If the client operates in " +
                "North America, building level 1, which is at street level, SHOULD be mapped to FloorNumber tag value " +
                "0x0." +
                "\n" +
                "A NULL value indicates that this information is not available." +
                "\n" +
                "When the clients present the level information for user selection, they SHOULD use the operating " +
                "region to determine how to render and map this data. For example, if the client operates in North " +
                "America it SHOULD present the user a list that includes entries labeled \"basement\", \"first\", " +
                "\"second\", and internally mapped to floor numbers -1, 0, and 1. If operating in Europe, the client " +
                "SHOULD present a list that includes entries labeled \"basement\", \"ground\", \"first\", internally mapped " +
                "to floor numbers -1, 0, and 1." +
                "\n" +
                "The floor number information is expected to be mostly useful to the clients, rather than the " +
                "devices, such as for grouping devices that are located on the same level. For example, an automation " +
                "may be defined for all devices located at the basement level (floor number -1)." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Handling complex level situations, such as half levels (side split houses), or the levels from an " +
                "  apartment building, is up to the client and/or user."
        }),

        Field({
            name: "AreaType", id: 0x2, type: "tag", conformance: "M", quality: "X", xref: "core§7.19.2.49.3",

            details: "This field shall be the ID of an area semantic tag, located within the Common Area Namespace. For " +
                "example, this tag may indicate that the location refers to a bedroom." +
                "\n" +
                "If this field is NULL, that indicates that the area type information is not available." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> This field only indicates the type of the area. Multiple areas of the same type, such as bedrooms, " +
                "  may exist in a user’s home."
        })
    ),

    Datatype(
        {
            name: "currency", type: "struct", description: "Currency", isSeed: true, xref: "core§7.19.2.51",
            details: "This data type represents a currency with an associated number of decimal points."
        },
        Field({ name: "Currency", id: 0x0, type: "uint16", conformance: "M", constraint: "max 999" }),
        Field({ name: "DecimalPoints", id: 0x1, type: "uint8", conformance: "M" })
    ),

    Datatype(
        {
            name: "price", type: "struct", description: "Price", isSeed: true, xref: "core§7.19.2.54",
            details: "This data type represents an amount of money in a given currency."
        },
        Field({ name: "Amount", id: 0x0, type: "money", conformance: "M" }),
        Field({ name: "Currency", id: 0x1, type: "currency", conformance: "M" })
    ),

    Datatype(
        {
            name: "WildcardPathFlagsBitmap", type: "map8", xref: "core§8.9.2.5",
            details: "The WildcardPathFlagsBitmap indicates flags that apply to the path, affecting wildcard expansion. " +
                "The following flags are defined:"
        },
        Field({
            name: "WildcardSkipRootNode", constraint: "0",
            description: "Skip the Root Node endpoint (endpoint 0) during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipGlobalAttributes", constraint: "1",
            description: "Skip several large global attributes during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipAttributeList", constraint: "2",
            description: "Skip the AttributeList global attribute during wildcard expansion."
        }),
        Field({ name: "DoNotUse", constraint: "3" }),
        Field({
            name: "WildcardSkipCommandLists", constraint: "4",
            description: "Skip the AcceptedCommandList and GeneratedCommandList global attributes during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipCustomElements", constraint: "5",
            description: "Skip any manufacturer-specific clusters or attributes during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipFixedAttributes", constraint: "6",
            description: "Skip any Fixed (F) quality attributes during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipChangesOmittedAttributes", constraint: "7",
            description: "Skip any Changes Omitted (C) quality attributes during wildcard expansion."
        }),
        Field({
            name: "WildcardSkipDiagnosticsClusters", constraint: "8",
            description: "Skip all clusters with the Diagnostics (K) quality during wildcard expansion."
        })
    ),

    Cluster(
        {
            name: "Descriptor", id: 0x1d, classification: "endpoint", pics: "DESC", xref: "core§9.5",

            details: "> [!NOTE]" +
                "\n" +
                "> The Descriptor cluster is meant to replace the support from the Zigbee Device Object (ZDO) for " +
                "  describing a node, its endpoints and clusters." +
                "\n" +
                "This cluster describes an endpoint instance on the node, independently from other endpoints, but " +
                "also allows composition of endpoints to conform to complex device type patterns." +
                "\n" +
                "This cluster supports a list of one or more device type identifiers that represent conformance to " +
                "device type specifications." +
                "\n" +
                "The cluster supports a PartsList attribute that is a list of zero or more endpoints to support " +
                "compound devices or composed device types."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§9.5.4" },
            Field({
                name: "TAGLIST", conformance: "desc", constraint: "0", title: "TagList", xref: "core§9.5.4.1",
                details: "See the Disambiguation section in the System Model spec for conformance requirements for this " +
                    "feature and the corresponding attribute."
            })
        ),

        Attribute(
            {
                name: "DeviceTypeList", id: 0x0, type: "list", access: "R V", conformance: "M", constraint: "min 1",
                quality: "F", xref: "core§9.5.6.1",

                details: "This is a list of device types and corresponding revisions declaring endpoint conformance (see " +
                    "Section 9.5.5.1, “DeviceTypeStruct Type”). At least one device type entry shall be present." +
                    "\n" +
                    "An endpoint shall conform to all device types listed in the DeviceTypeList. A cluster instance that " +
                    "is in common for more than one device type in the DeviceTypeList shall be supported as a shared " +
                    "cluster instance on the endpoint."
            },

            Field({ name: "entry", type: "DeviceTypeStruct" })
        ),

        Attribute(
            {
                name: "ServerList", id: 0x1, type: "list", access: "R V", conformance: "M", default: [],
                quality: "F", xref: "core§9.5.6.2",
                details: "This attribute shall list each cluster ID for the server clusters present on the endpoint instance."
            },
            Field({ name: "entry", type: "cluster-id" })
        ),

        Attribute(
            {
                name: "ClientList", id: 0x2, type: "list", access: "R V", conformance: "M", default: [],
                quality: "F", xref: "core§9.5.6.3",
                details: "This attribute shall list each cluster ID for the client clusters present on the endpoint instance."
            },
            Field({ name: "entry", type: "cluster-id" })
        ),

        Attribute(
            {
                name: "PartsList", id: 0x3, type: "list", access: "R V", conformance: "M", default: [],
                xref: "core§9.5.6.4",
                details: "This attribute indicates composition of the device type instance. Device type instance composition " +
                    "shall include the endpoints in this list." +
                    "\n" +
                    "See Endpoint Composition for more information about which endpoints to include in this list."
            },

            Field({ name: "entry", type: "endpoint-no" })
        ),

        Attribute(
            {
                name: "TagList", id: 0x4, type: "list", access: "R V", conformance: "TAGLIST", constraint: "1 to 6",
                quality: "F", xref: "core§9.5.6.5",

                details: "This attribute shall be used to disambiguate sibling endpoints in certain situations, as defined in " +
                    "the Disambiguation section in the System Model specification. An example of such a situation might " +
                    "be a device with two buttons, with this attribute being used to indicate which of the two endpoints " +
                    "corresponds to the button on the left side." +
                    "\n" +
                    "It may also be used to provide information about an endpoint (e.g. the relative location of a " +
                    "Temperature sensor in a Temperature Controlled Cabinet)." +
                    "\n" +
                    "  • A client SHOULD use these tags to convey disambiguation information and other relevant " +
                    "    information to the user (e.g. showing it in a user interface), as appropriate." +
                    "\n" +
                    "  • A client SHOULD use these tags in its logic to make decisions, as appropriate." +
                    "\n" +
                    "For example, a client may identify which endpoint maps to a certain function, orientation or " +
                    "labeling." +
                    "\n" +
                    "A client may use the Label field of each SemanticTagStruct, if present in each structure, to " +
                    "indicate characteristics of an endpoint, or to augment what is provided in the TagID field of the " +
                    "same structure."
            },

            Field({ name: "entry", type: "semtag" })
        ),

        Attribute({
            name: "EndpointUniqueId", id: 0x5, type: "string", access: "R V", conformance: "O",
            constraint: "max 32", quality: "F", xref: "core§9.5.6.6",

            details: "Indicates an identifier which allows to uniquely identify the functionality exposed on an endpoint, " +
                "and therefore shall be unique within the device. It is constructed in a manufacturer specific " +
                "manner." +
                "\n" +
                "  • If a globally unique identifier is used, the same rules as defined for the UniqueID attribute in " +
                "    the Basic Information cluster apply." +
                "\n" +
                "  • If the identifier is only unique in the scope of the device, and cannot be used to track the " +
                "    device, then it may remain unchanged at factory reset." +
                "\n" +
                "The value does not need to be human readable, since it is intended for machine to machine (M2M) " +
                "communication."
        }),

        Datatype(
            {
                name: "DeviceTypeStruct", type: "struct", xref: "core§9.5.5.1",
                details: "The device type and revision define endpoint conformance to a release of a device type definition. " +
                    "See the Data Model specification for more information."
            },
            Field({
                name: "DeviceType", id: 0x0, type: "devtype-id", conformance: "M", xref: "core§9.5.5.1.1",
                details: "This shall indicate the device type definition. The endpoint shall conform to the device type " +
                    "definition and cluster specifications required by the device type."
            }),

            Field({
                name: "Revision", id: 0x1, type: "uint16", conformance: "M", constraint: "min 1",
                xref: "core§9.5.5.1.2",
                details: "This is the implemented revision of the device type definition. The endpoint shall conform to this " +
                    "revision of the device type."
            })
        )
    ),

    Cluster(
        {
            name: "Binding", id: 0x1e, classification: "endpoint", pics: "BIND", xref: "core§9.6",

            details: "> [!NOTE]" +
                "\n" +
                "> This scope of this document is the Binding cluster as part of the Cluster Library. The Binding " +
                "  cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the " +
                "  binding table." +
                "\n" +
                "A binding represents a persistent relationship between an endpoint and one or more other local or " +
                "remote endpoints. A binding does not require that the relationship exists. It is up to the node " +
                "application to set up the relationship." +
                "\n" +
                "A binding is used to inform a client endpoint of one or more targets for a potential interaction. " +
                "For example: a light switch that controls one or more light bulbs, needs to be told the nodes and " +
                "endpoints of the bulbs, or told a group in which the bulbs are members. For example: A client that " +
                "needs to subscribe to an occupancy sensor, needs to know the node and endpoint of the sensor." +
                "\n" +
                "In such cases, a binding is used to direct a local endpoint to a target. The existence of the " +
                "Binding cluster on the client endpoint, allows the creation of one or more binding entries " +
                "(bindings) in the Binding cluster." +
                "\n" +
                "Each binding indicates another endpoint or cluster on another endpoint. Multiple bindings are " +
                "allowed, depending on the interaction." +
                "\n" +
                "A binding is either a unicast binding, where the target is a single endpoint on a single node, or a " +
                "groupcast binding, where the target is a group, which may indicate multiple endpoints on multiple " +
                "nodes. The binding may also target a single cluster on the target endpoint(s)." +
                "\n" +
                "When a client cluster requires a target for an interaction, the Binding cluster shall exist on the " +
                "same endpoint." +
                "\n" +
                "Once a binding entry is created on the Binding cluster, the client endpoint may initiate " +
                "interactions to the binding target."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "Binding", id: 0x0, type: "list", access: "RW F VM", conformance: "M", constraint: "desc",
                default: [], quality: "N", xref: "core§9.6.6.1",
                details: "Each entry shall represent a binding."
            },
            Field({ name: "entry", type: "TargetStruct" })
        ),

        Datatype(
            { name: "TargetStruct", type: "struct", xref: "core§9.6.5.1" },

            Field({
                name: "Node", id: 0x1, type: "node-id", access: "F", conformance: "Endpoint",
                xref: "core§9.6.5.1.1",
                details: "This field is the remote target node ID. If the Endpoint field is present, this field shall be " +
                    "present."
            }),

            Field({
                name: "Group", id: 0x2, type: "group-id", access: "F", conformance: "!Endpoint",
                constraint: "min 1", xref: "core§9.6.5.1.2",
                details: "This field is the target group ID that represents remote endpoints. If the Endpoint field is " +
                    "present, this field shall NOT be present."
            }),

            Field({
                name: "Endpoint", id: 0x3, type: "endpoint-no", access: "F", conformance: "!Group",
                xref: "core§9.6.5.1.3",
                details: "This field is the remote endpoint that the local endpoint is bound to. If the Group field is " +
                    "present, this field shall NOT be present."
            }),

            Field({
                name: "Cluster", id: 0x4, type: "cluster-id", access: "F", conformance: "O", xref: "core§9.6.5.1.4",
                details: "This field is the cluster ID (client & server) on the local and target endpoint(s). If this field is " +
                    "present, the client cluster shall also exist on this endpoint (with this Binding cluster). If this " +
                    "field is present, the target shall be this cluster on the target endpoint(s)."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Cluster(
        {
            name: "Label", classification: "endpoint", pics: "LABEL", xref: "core§9.7",
            details: "This cluster provides a feature to tag an endpoint with zero or more labels. This is a base cluster " +
                "that requires a derived cluster to create an instance."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "LabelList", id: 0x0, type: "list", conformance: "M", constraint: "derived", default: [],
                xref: "core§9.7.5.1",
                details: "This is a list of string tuples. Each entry is a LabelStruct."
            },
            Field({ name: "entry", type: "LabelStruct" })
        ),

        Datatype(
            {
                name: "LabelStruct", type: "struct", xref: "core§9.7.4.1",
                details: "This is a string tuple with strings that are user defined."
            },

            Field({
                name: "Label", id: 0x0, type: "string", conformance: "M", constraint: "max 16",
                xref: "core§9.7.4.1.1",
                details: "The Label or Value semantic is not defined here. Label examples: \"room\", \"zone\", \"group\", " +
                    "\"direction\"."
            }),

            Field({
                name: "Value", id: 0x1, type: "string", conformance: "M", constraint: "max 16",
                xref: "core§9.7.4.1.2",
                details: "The Label or Value semantic is not defined here. The Value is a discriminator for a Label that may " +
                    "have multiple instances." +
                    "\n" +
                    "Label:Value examples: \"room\":\"bedroom 2\", \"orientation\":\"North\", \"floor\":\"2\", \"direction\":\"up\""
            })
        )
    ),

    Cluster(
        {
            name: "FixedLabel", id: 0x40, type: "Label", classification: "endpoint", pics: "FLABEL",
            xref: "core§9.8",

            details: "This cluster is derived from the Label cluster and provides a feature for the device to tag an " +
                "endpoint with zero or more read-only labels." +
                "\n" +
                "Examples:" +
                "\n" +
                "  • A bridge can use this to indicate grouping of bridged devices. For example: All bridged devices " +
                "    whose endpoints have an entry in their LabelList \"room\":\"bedroom 2\" are in the same (bed)room." +
                "\n" +
                "  • A manufacturer can use this to identify a characteristic of an endpoint. For example to identify " +
                "    the endpoints of a luminaire, one pointing up, the other pointing down, one of the endpoints " +
                "    would have a LabelList entry \"orientation\":\"up\" while the other would have \"orientation\":\"down\". " +
                "    Using such indication, the user interface of a Node controlling this luminaire knows which of " +
                "    the endpoints is which of the lights." +
                "\n" +
                "Note that the TagList in the Descriptor cluster provides an alternative mechanism for such " +
                "self-description using standardized tags rather than manufacturer-selected strings, yielding a " +
                "standardized mechanism for features defined in the various namespaces. The second example above can " +
                "be implemented using semantic tags Direction.Upward and Direction.Downward instead of (or in " +
                "addition to) the Fixed Label cluster."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "LabelList", id: 0x0, type: "list", access: "R V", conformance: "M", default: [],
                quality: "N", xref: "core§9.8.4"
            },
            Field({ name: "entry", type: "LabelStruct" })
        )
    ),

    Cluster(
        {
            name: "UserLabel", id: 0x41, type: "Label", classification: "endpoint", pics: "ULABEL",
            xref: "core§9.9",
            details: "This cluster is derived from the Label cluster and provides a feature to tag an endpoint with zero " +
                "or more writable labels."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "LabelList", id: 0x0, type: "list", access: "RW VM", conformance: "M",
                constraint: "min 4 pernode", default: [], quality: "N", xref: "core§9.9.4.1",
                details: "An implementation shall support at least 4 list entries per node for all User Label cluster " +
                    "instances on the node."
            },

            Field({ name: "entry", type: "LabelStruct" })
        )
    ),

    Cluster(
        {
            name: "AccessControl", id: 0x1f, classification: "node", pics: "ACL", xref: "core§9.10",

            details: "The Access Control Cluster exposes a data model view of a Node’s Access Control List (ACL), which " +
                "codifies the rules used to manage and enforce Access Control for the Node’s endpoints and their " +
                "associated cluster instances. Access to this Access Control Cluster itself requires a special " +
                "Administer privilege level, such that only Nodes granted such privilege (hereafter termed " +
                "\"Administrators\") can manage the Access Control Cluster." +
                "\n" +
                "The Access Control Cluster shall be present on the root node endpoint of each Node, and shall NOT be " +
                "present on any other Endpoint of any Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§9.10.4" },
            Field({
                name: "EXTS", conformance: "O", constraint: "0", title: "Extension", xref: "core§9.10.4.1",
                details: "This feature indicates the device supports ACL Extension attribute."
            }),

            Field({
                name: "MNGD", conformance: "desc", constraint: "1", title: "ManagedDevice", xref: "core§9.10.4.2",

                details: "This feature is for a device that is managed by a service associated with the device vendor and " +
                    "which imposes default access restrictions upon each new fabric added to it. This could arise, for " +
                    "example, if the device is managed by a service provider under contract to an end-user, in such away " +
                    "that the manager of the device does not unconditionally grant universal access to all of a device’s " +
                    "functionality, even for fabric administrators. For example, many Home Routers are managed by an " +
                    "Internet Service Provider (a service), and these services often have a policy that requires them to " +
                    "obtain user consent before certain administrative functions can be delegated to a third party (e.g., " +
                    "a fabric Administrator). These restrictions are expressed using an Access Restriction List (ARL)." +
                    "\n" +
                    "The purpose of this feature on the Access Control cluster is to indicate to a fabric Administrator " +
                    "that access by it to specific attributes, commands and/or events for specific clusters is currently " +
                    "prohibited. Attempts to access these restricted data model elements shall result in an error of " +
                    "ACCESS_RESTRICTED." +
                    "\n" +
                    "A device that implements this feature shall have a mechanism to honor the ReviewFabricRestrictions " +
                    "command, such as user interfaces or service interactions associated with a service provider or the " +
                    "device manufacturer, which allows the owner (or subscriber) to manage access restrictions for each " +
                    "fabric. The user interface design, which includes the way restrictions are organized and presented " +
                    "to the user, is not specified, but SHOULD be usable by non-expert end-users from common mobile " +
                    "devices, personal computers, or an on-device user interface." +
                    "\n" +
                    "Controllers and clients SHOULD incorporate generic handling of the ACCESS_RESTRICTED error code, " +
                    "when it appears in allowed contexts, in order to gracefully handle situations where this feature is " +
                    "encountered. Device vendors that adopt this feature SHOULD be judicious in its use given the risk of " +
                    "unexpected behavior in controllers and clients." +
                    "\n" +
                    "For certification testing, a device that implements this feature shall provide a way for all " +
                    "restrictions to be removed." +
                    "\n" +
                    "The ARL attribute provides the set of restrictions currently applied to this fabric." +
                    "\n" +
                    "The ReviewFabricRestrictions command provides a way for the fabric Administrator to request that the " +
                    "server triggers a review of the current fabric restrictions, by involving external entities such as " +
                    "end-users, or other services associated with the manager of the device hosting the server. This " +
                    "review process may involve communication between external services and the user, and may take an " +
                    "unpredictable amount of time to complete since an end-user may need to visit some resources, such as " +
                    "a mobile application or web site. A FabricRestrictionReviewUpdate event will be generated by the " +
                    "device within a predictable time period of the ReviewFabricRestrictionsResponse (see Section " +
                    "9.10.8.1, “ReviewFabricRestrictions Command” for specification of this time period), and this event " +
                    "can be correlated with the ReviewFabricRestrictionsResponse using a token provided in both. The " +
                    "device may provide instructions or a Redirect URL in the FabricRestrictionReviewUpdate event in " +
                    "order to help the user access the features required for managing per-fabric restrictions." +
                    "\n" +
                    "See Section 6.6.2, “Model” for a description of how access control is impacted by the ARL attribute." +
                    "\n" +
                    "### Managed Device Feature Usage Restrictions" +
                    "\n" +
                    "Use of this feature shall be limited to the mandatory clusters of endpoints having a device type " +
                    "that explicitly permits its use in the Device Library Specification. As a reminder, the device types " +
                    "associated with an endpoint are listed in the Descriptor cluster of the endpoint." +
                    "\n" +
                    "In addition, use of this feature shall NOT restrict the following clusters on any endpoint:" +
                    "\n" +
                    "  1. the Descriptor Cluster (0x001D)" +
                    "\n" +
                    "  2. the Binding Cluster (0x001E)" +
                    "\n" +
                    "  3. the Network Commissioning Cluster (0x0031)" +
                    "\n" +
                    "  4. the Identify Cluster (0x0003)" +
                    "\n" +
                    "  5. the Groups Cluster (0x0004)" +
                    "\n" +
                    "In addition, use of this feature shall NOT restrict the global attributes of any cluster." +
                    "\n" +
                    "Because ARLs cannot be used to restrict root node access or access to any clusters required for " +
                    "commissioning, administrators may determine the current restrictions of the ARL at any point, " +
                    "including during commissioning after joining the fabric."
            })
        ),

        Attribute(
            {
                name: "Acl", id: 0x0, type: "list", access: "RW F A", conformance: "M", constraint: "desc",
                xref: "core§9.10.6.3",

                details: "An attempt to add an Access Control Entry when no more entries are available shall result in a " +
                    "RESOURCE_EXHAUSTED error being reported and the ACL attribute shall NOT have the entry added to it. " +
                    "See access control limits." +
                    "\n" +
                    "See the AccessControlEntriesPerFabric attribute for the actual value of the number of entries per " +
                    "fabric supported by the server." +
                    "\n" +
                    "Each Access Control Entry codifies a single grant of privilege on this Node, and is used by the " +
                    "Access Control Privilege Granting algorithm to determine if a subject has privilege to interact with " +
                    "targets on the Node."
            },

            Field({ name: "entry", type: "AccessControlEntryStruct" })
        ),

        Attribute(
            {
                name: "Extension", id: 0x1, type: "list", access: "RW F A", conformance: "EXTS", constraint: "desc",
                xref: "core§9.10.6.4",
                details: "If present, the Access Control Extensions may be used by Administrators to store arbitrary data " +
                    "related to fabric’s Access Control Entries." +
                    "\n" +
                    "The Access Control Extension list shall support a single extension entry per supported fabric."
            },

            Field({ name: "entry", type: "AccessControlExtensionStruct" })
        ),

        Attribute({
            name: "SubjectsPerAccessControlEntry", id: 0x2, type: "uint16", access: "R V", conformance: "M",
            constraint: "min 4", default: 4, quality: "F", xref: "core§9.10.6.5",

            details: "This attribute shall provide the minimum number of Subjects per entry that are supported by this " +
                "server." +
                "\n" +
                "Since reducing this value over time may invalidate ACL entries already written, this value shall NOT " +
                "decrease across time as software updates occur that could impact this value. If this is a concern " +
                "for a given implementation, it is recommended to only use the minimum value required and avoid " +
                "reporting a higher value than the required minimum."
        }),

        Attribute({
            name: "TargetsPerAccessControlEntry", id: 0x3, type: "uint16", access: "R V", conformance: "M",
            constraint: "min 3", default: 3, quality: "F", xref: "core§9.10.6.6",

            details: "This attribute shall provide the minimum number of Targets per entry that are supported by this " +
                "server." +
                "\n" +
                "Since reducing this value over time may invalidate ACL entries already written, this value shall NOT " +
                "decrease across time as software updates occur that could impact this value. If this is a concern " +
                "for a given implementation, it is recommended to only use the minimum value required and avoid " +
                "reporting a higher value than the required minimum."
        }),

        Attribute({
            name: "AccessControlEntriesPerFabric", id: 0x4, type: "uint16", access: "R V", conformance: "M",
            constraint: "min 4", default: 4, quality: "F", xref: "core§9.10.6.7",

            details: "This attribute shall provide the minimum number of ACL Entries per fabric that are supported by this " +
                "server." +
                "\n" +
                "Since reducing this value over time may invalidate ACL entries already written, this value shall NOT " +
                "decrease across time as software updates occur that could impact this value. If this is a concern " +
                "for a given implementation, it is recommended to only use the minimum value required and avoid " +
                "reporting a higher value than the required minimum."
        }),

        Attribute(
            {
                name: "CommissioningArl", id: 0x5, type: "list", access: "R V", conformance: "MNGD",
                constraint: "desc", default: [], quality: "F", xref: "core§9.10.6.8",

                details: "This attribute shall provide the set of CommissioningAccessRestrictionEntryStruct applied during " +
                    "commissioning on a managed device." +
                    "\n" +
                    "When present, the CommissioningARL attribute shall indicate the access restrictions applying during " +
                    "commissioning." +
                    "\n" +
                    "Attempts to access data model elements described by an entry in the CommissioningARL attribute " +
                    "during commissioning shall result in an error of ACCESS_RESTRICTED. See Access Control Model for " +
                    "more information about the features related to controlling access to a Node’s Endpoint Clusters " +
                    "(\"Targets\" hereafter) from other Nodes." +
                    "\n" +
                    "See Section 9.10.4.2.1, “Managed Device Feature Usage Restrictions” for limitations on the use of " +
                    "access restrictions."
            },

            Field({ name: "entry", type: "CommissioningAccessRestrictionEntryStruct" })
        ),

        Attribute(
            {
                name: "Arl", id: 0x6, type: "list", access: "R F V", conformance: "MNGD", constraint: "desc",
                default: [], xref: "core§9.10.6.9",

                details: "This attribute shall provide the set of AccessRestrictionEntryStruct applied to the associated " +
                    "fabric on a managed device." +
                    "\n" +
                    "When present, the ARL attribute shall indicate the access restrictions applying to the accessing " +
                    "fabric. In contrast, the CommissioningARL attribute indicates the accessing restrictions that apply " +
                    "when there is no accessing fabric, such as during commissioning." +
                    "\n" +
                    "The access restrictions are externally added/removed based on the particular relationship the device " +
                    "hosting this server has with external entities such as its owner, external service provider, or " +
                    "end-user." +
                    "\n" +
                    "Attempts to access data model elements described by an entry in the ARL attribute for the accessing " +
                    "fabric shall result in an error of ACCESS_RESTRICTED. See Access Control Model for more information " +
                    "about the features related to controlling access to a Node’s Endpoint Clusters (\"Targets\" hereafter) " +
                    "from other Nodes." +
                    "\n" +
                    "See Section 9.10.4.2.1, “Managed Device Feature Usage Restrictions” for limitations on the use of " +
                    "access restrictions."
            },

            Field({ name: "entry", type: "AccessRestrictionEntryStruct" })
        ),

        Event(
            {
                name: "AccessControlEntryChanged", id: 0x0, access: "S A", conformance: "M", priority: "info",
                xref: "core§9.10.9.1",

                details: "The cluster shall generate AccessControlEntryChanged events whenever its ACL attribute data is " +
                    "changed by an Administrator." +
                    "\n" +
                    "  • Each added entry shall generate an event with ChangeType Added." +
                    "\n" +
                    "  • Each changed entry shall generate an event with ChangeType Changed." +
                    "\n" +
                    "  • Each removed entry shall generate an event with ChangeType Removed."
            },

            Field({
                name: "AdminNodeId", id: 0x1, type: "node-id", access: "S", conformance: "M", constraint: "desc",
                quality: "X", xref: "core§9.10.9.1.1",
                details: "The Node ID of the Administrator that made the change, if the change occurred via a CASE session." +
                    "\n" +
                    "Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change " +
                    "occurred via a CASE or PASE session; the other shall be null."
            }),

            Field({
                name: "AdminPasscodeId", id: 0x2, type: "uint16", access: "S", conformance: "M", constraint: "desc",
                quality: "X", xref: "core§9.10.9.1.2",

                details: "The Passcode ID of the Administrator that made the change, if the change occurred via a PASE " +
                    "session. Non-zero values are reserved for future use (see PasscodeId generation in " +
                    "PBKDFParamRequest)." +
                    "\n" +
                    "Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change " +
                    "occurred via a CASE or PASE session; the other shall be null."
            }),

            Field({
                name: "ChangeType", id: 0x3, type: "ChangeTypeEnum", access: "S", conformance: "M",
                xref: "core§9.10.9.1.3",
                details: "The type of change as appropriate."
            }),

            Field({
                name: "LatestValue", id: 0x4, type: "AccessControlEntryStruct", access: "S", conformance: "M",
                quality: "X", xref: "core§9.10.9.1.4",
                details: "The latest value of the changed entry." +
                    "\n" +
                    "This field SHOULD be set if resources are adequate for it; otherwise it shall be set to NULL if " +
                    "resources are scarce."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Event(
            {
                name: "AccessControlExtensionChanged", id: 0x1, access: "S A", conformance: "EXTS",
                priority: "info", xref: "core§9.10.9.2",

                details: "The cluster shall generate AccessControlExtensionChanged events whenever its extension attribute " +
                    "data is changed by an Administrator." +
                    "\n" +
                    "  • Each added extension shall generate an event with ChangeType Added." +
                    "\n" +
                    "  • Each changed extension shall generate an event with ChangeType Changed." +
                    "\n" +
                    "  • Each removed extension shall generate an event with ChangeType Removed."
            },

            Field({
                name: "AdminNodeId", id: 0x1, type: "node-id", access: "S", conformance: "M", constraint: "desc",
                quality: "X", xref: "core§9.10.9.2.1",
                details: "The Node ID of the Administrator that made the change, if the change occurred via a CASE session." +
                    "\n" +
                    "Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change " +
                    "occurred via a CASE or PASE session; the other shall be null."
            }),

            Field({
                name: "AdminPasscodeId", id: 0x2, type: "uint16", access: "S", conformance: "M", constraint: "desc",
                quality: "X", xref: "core§9.10.9.2.2",

                details: "The Passcode ID of the Administrator that made the change, if the change occurred via a PASE " +
                    "session. Non-zero values are reserved for future use (see PasscodeId generation in " +
                    "PBKDFParamRequest)." +
                    "\n" +
                    "Exactly one of AdminNodeID and AdminPasscodeID shall be set, depending on whether the change " +
                    "occurred via a CASE or PASE session; the other shall be null."
            }),

            Field({
                name: "ChangeType", id: 0x3, type: "ChangeTypeEnum", access: "S", conformance: "M",
                xref: "core§9.10.9.2.3",
                details: "The type of change as appropriate."
            }),

            Field({
                name: "LatestValue", id: 0x4, type: "AccessControlExtensionStruct", access: "S", conformance: "M",
                quality: "X", xref: "core§9.10.9.2.4",
                details: "The latest value of the changed extension." +
                    "\n" +
                    "This field SHOULD be set if resources are adequate for it; otherwise it shall be set to NULL if " +
                    "resources are scarce."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Event(
            {
                name: "FabricRestrictionReviewUpdate", id: 0x2, access: "S A", conformance: "MNGD",
                priority: "info", xref: "core§9.10.9.3",
                details: "The cluster shall generate a FabricRestrictionReviewUpdate event to indicate completion of a fabric " +
                    "restriction review. Due to the requirement to generate this event within a bound time frame of " +
                    "successful receipt of the ReviewFabricRestrictions command, this event may include additional steps " +
                    "that the client may present to the user in order to help the user locate the user interface for the " +
                    "Managed Device feature."
            },

            Field({
                name: "Token", id: 0x0, type: "uint64", access: "S", conformance: "M", xref: "core§9.10.9.3.1",
                details: "This field shall indicate the Token that can be used to correlate a ReviewFabricRestrictionsResponse " +
                    "with a FabricRestrictionReviewUpdate event."
            }),

            Field({
                name: "Instruction", id: 0x1, type: "string", access: "S", conformance: "O", constraint: "max 512",
                xref: "core§9.10.9.3.2",

                details: "This field shall provide human readable text that may be displayed to the user to help them locate " +
                    "the user interface for managing access restrictions for each fabric." +
                    "\n" +
                    "A device SHOULD implement the Localization Configuration Cluster when it has no other means to " +
                    "determine the locale to use for this text." +
                    "\n" +
                    "Examples include \"Please try again and immediately access device display for further instructions.\" " +
                    "or \"Please check email associated with your Acme account.\""
            }),

            Field(
                {
                    name: "ArlRequestFlowUrl", id: 0x2, type: "string", access: "S", conformance: "O",
                    constraint: "max 256", xref: "core§9.10.9.3.3",

                    details: "This field shall indicate the URL for the service associated with the device maker which the user " +
                        "can visit to manage fabric limitations. The syntax of this field shall follow the syntax as " +
                        "specified in RFC 1738 and shall use the https scheme for internet-hosted URLs." +
                        "\n" +
                        "  • The URL may embed the token, fabric index, fabric vendor, or other information transparently in " +
                        "    order to pass context about the originating ReviewFabricRestrictions command to the service " +
                        "    associated with the URL. The service associated with the device vendor may perform vendor ID " +
                        "    verification on the fabric from which the ReviewFabricRestrictions command originated." +
                        "\n" +
                        "  • If the device grants the request, the ARL attribute in the Access Control Cluster shall be " +
                        "    updated to reflect the new access rights and a successful response shall be returned to the " +
                        "    device making the request using the MTaer field of the callbackUrl. If the request is denied, " +
                        "    the ARL attribute shall remain unchanged and a failure response shall be returned to the device " +
                        "    making the request using the MTaer field of the callbackUrl." +
                        "\n" +
                        "  • The device using this mechanism shall provide a service at the URL that can accept requests for " +
                        "    additional access and return responses indicating whether the requests were granted or denied." +
                        "\n" +
                        "  • This URL will typically lead to a server which (e.g. by looking at the User-Agent) redirects the " +
                        "    user to allow viewing, downloading, installing or using a manufacturer-provided means for " +
                        "    guiding the user through the process to review and approve or deny the request. The device " +
                        "    manufacturer may choose to use a constructed URL which is valid in a HTTP GET request (i.e. " +
                        "    dedicated for the product) such as, for example, https://domain.example/arl-app?vid=FFF1& " +
                        "    pid=1234. If a client follows or launches the ARLRequestFlowUrl, it shall expand it as described " +
                        "    in Section 9.10.9.3.4, “ARLRequestFlowUrl format”." +
                        "\n" +
                        "  • A manufacturer contemplating using this flow should realize that" +
                        "\n" +
                        "    ◦ This flow typically requires internet access to access the URL, and access extension may fail " +
                        "      when internet connectivity is not available." +
                        "\n" +
                        "    ◦ If the flow prefers to redirect the user to an app which is available on popular platforms, it " +
                        "      SHOULD also provide a fallback option such as a web browser interface to ensure users can " +
                        "      complete access extension." +
                        "\n" +
                        "### ARLRequestFlowUrl format" +
                        "\n" +
                        "The ARLRequestFlowUrl shall contain a query component (see RFC 3986 section 3.4) composed of one or " +
                        "more key-value pairs:" +
                        "\n" +
                        "  • The query shall use the & delimiter between key/value pairs." +
                        "\n" +
                        "  • The key-value pairs shall in the format name=<value> where name is the key name, and <value> is " +
                        "    the contents of the value encoded with proper URL-encoded escaping." +
                        "\n" +
                        "  • If key MTcu is present, it shall have a value of \"_\" (i.e. MTcu=_). This is the \"callback URL " +
                        "    (Call backUrl) placeholder\"." +
                        "\n" +
                        "  • Any key whose name begins with MT not mentioned in the previous bullets shall be reserved for " +
                        "    future use by this specification. Manufacturers shall NOT include query keys starting with MT in " +
                        "    the ARLRequestFlowUrl unless they are referenced by a version of this specification." +
                        "\n" +
                        "Any other element in the ARLRequestFlowUrl query field not covered by the above rules, as well as " +
                        "the fragment field (if present), shall remain including the order of query key/value pairs present." +
                        "\n" +
                        "### Expansion of ARLRequestFlowUrl by client" +
                        "\n" +
                        "Once the URL is obtained, it shall be expanded to form a final URL (ExpandedARLRequestFlowUrl) by " +
                        "proceeding with the following substitution algorithm on the original ARLRequestFlowUrl:" +
                        "\n" +
                        "  1. If key MTcu is present, compute the CallbackUrl desired (see Section 9.10.9.3.5, “CallbackUrl " +
                        "     format for ARL Request Flow response”), and substitute the placeholder value \"_\" (i.e. in " +
                        "     MTcu=_) in the ARLRequestFlowUrl with the desired contents, encoded with proper URL-encoded " +
                        "     escaping (see RFC 3986 section 2)." +
                        "\n" +
                        "The final URL after expansion (ExpandedARLRequestFlowUrl) shall be the one to follow, rather than " +
                        "the original value obtained from the FabricRestrictionReviewUpdate event." +
                        "\n" +
                        "### CallbackUrl format for ARL Request Flow response" +
                        "\n" +
                        "If a CallbackUrl field (i.e. MTcu=) query field placeholder is present in the ARLRequestFlowUrl, the " +
                        "client may replace the placeholder value \"_\" in the ExpandedARLRequestFlowUrl with a URL that the " +
                        "manufacturer flow can use to make a smooth return to the client when the ARL flow has terminated." +
                        "\n" +
                        "This URL field may contain a query component (see RFC 3986 section 3.4). If a query is present, it " +
                        "shall be composed of one or more key-value pairs:" +
                        "\n" +
                        "  • The query shall use the & delimiter between key/value pairs." +
                        "\n" +
                        "  • The key-value pairs shall follow the format name=<value> where name is the key name, and <value> " +
                        "    is the contents of the value encoded with proper URL-encoded escaping." +
                        "\n" +
                        "  • If key MTaer is present, it shall have a value of \"_\" (i.e. MTaer=_). This is the placeholder " +
                        "    for a \"access extension response\" provided by the manufacturer flow to the client. The " +
                        "    manufacturer flow shall replace this placeholder with the final status of the access extension " +
                        "    request, which shall be formatted following Expansion of CallbackUrl by the manufacturer custom " +
                        "    flow and encoded with proper URL-encoded escaping." +
                        "\n" +
                        "  • Any key whose name begins with MT not mentioned in the previous bullets shall be reserved for " +
                        "    future use by this specification." +
                        "\n" +
                        "Any other element in the CallbackUrl query field not covered by the above rules, as well as the " +
                        "fragment field (if present), shall remain as provided by the client through embedding within the " +
                        "ExpandedARLRequestFlowUrl, including the order of query key/value pairs present." +
                        "\n" +
                        "### Expansion of CallbackUrl by the manufacturer custom flow" +
                        "\n" +
                        "Once the CallbackUrl is obtained by the manufacturer flow, it may be expanded to form a final " +
                        "ExpandedARLRequestCallbackUrl URL to be used by proceeding with the following substitution algorithm " +
                        "on the provided CallbackUrl:" +
                        "\n" +
                        "  • If key MTaer is present, the manufacturer custom flow having received the initial query " +
                        "    containing the CallbackUrl shall substitute the placeholder value \"_\" (i.e. in MTaer=_) in the " +
                        "    CallbackUrl with the final status of the access extension request flow which shall be one of the " +
                        "    following. Any value returned in the MTaer field not listed above shall be considered an error " +
                        "    and shall be treated as GeneralFailure." +
                        "\n" +
                        "    ◦ Success - The flow completed successfully and the ARL attribute was updated. The client may " +
                        "      now read the ARL attribute to determine the new access restrictions." +
                        "\n" +
                        "    ◦ NoChange - The ARL attribute was already listing minimum restrictions for the requesting " +
                        "      fabric." +
                        "\n" +
                        "    ◦ GeneralFailure - The flow failed for an unspecified reason." +
                        "\n" +
                        "    ◦ FlowAuthFailure - The user failed to authenticate to the flow." +
                        "\n" +
                        "    ◦ NotFound - Access extension failed because the target fabric was not found." +
                        "\n" +
                        "A manufacturer custom flow having received an ExpandedARLRequestFlowUrl SHOULD attempt to open the " +
                        "ExpandedARLRequestCallbackUrl, on completion of the request, if an ExpandedARLRequestCallbackUrl was " +
                        "computed from the CallbackUrl and opening such a URL is supported." +
                        "\n" +
                        "### Examples of ARLRequestFlowUrl URLs" +
                        "\n" +
                        "Below are some examples of valid ExpandedARLRequestFlowUrl for several valid values of " +
                        "ARLRequestFlowUrl, as well as some examples of invalid values of ARLRequestFlowUrl:" +
                        "\n" +
                        "  • Invalid URL with no query string: http scheme is not allowed:" +
                        "\n" +
                        "    ◦ http://company.domain.example/matter/arl/vFFF1p1234" +
                        "\n" +
                        "  • Valid URL :" +
                        "\n" +
                        "    ◦ https://company.domain.example/matter/arl/vFFF1p1234" +
                        "\n" +
                        "  • Valid URL, CallbackUrl requested:" +
                        "\n" +
                        "    ◦ Before expansion:" +
                        "\n" +
                        "https://company.domain.example/matter/arl?vid=FFF1&pid=1234&MTcu=_" +
                        "\n" +
                        "  ◦ After expansion: " +
                        "    https://company.domain.example/matter/arl?vid=FFF1&pid=1234&MTcu=https%3A%2F%2Fc " +
                        "    lient.domain.example%2Fcb%3Ftoken%3DmAsJ6_vqbr-vjDiG_w%253D%253D%26MTaer%3D_" +
                        "\n" +
                        "  ◦ The ExpandedARLRequestFlowUrl URL contains:" +
                        "\n" +
                        "    ▪ A CallbackUrl with a client-provided arbitrary token= key/value pair and the MTaer= key/value " +
                        "      pair place-holder to indicate support for a return access extension completion status: " +
                        "      https://client.domain.example/cb?token=mAsJ6_vqbr-vjDiG_w%3D%3D&MTaer=_" +
                        "\n" +
                        "    ▪ After expansion of the CallbackUrl (MTcu key) into an ExpandedCallbackUrl, with an example " +
                        "      return access extension completion status of Success, the ExpandedARLRequestCallbackUrl would " +
                        "      be:" +
                        "\n" +
                        "https://client.domain.example/cb?token=mAsJ6_vqbr-vjDiG_w%3D%3D&MTaer=Success" +
                        "\n" +
                        "Note that the MTcu key/value pair was initially provided URL-encoded within the " +
                        "ExpandedARLRequestFlowUrl URL and the MTaer=_ key/value pair placeholder now contains a substituted " +
                        "returned completion status." +
                        "\n" +
                        "  • Invalid URL, due to MTza=79 key/value pair in reserved MT-prefixed keys reserved for future use:" +
                        "\n" +
                        "    ◦ https://company.domain.example/matter/arl?vid=FFF1&pid=1234&MTop=_&MTza=79"
                }
            ),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "ReviewFabricRestrictions", id: 0x0, access: "F A", conformance: "MNGD", direction: "request",
                response: "ReviewFabricRestrictionsResponse", xref: "core§9.10.8.1",

                details: "This command signals to the service associated with the device vendor that the fabric administrator " +
                    "would like a review of the current restrictions on the accessing fabric. This command includes an " +
                    "optional list of ARL entries that the fabric administrator would like removed." +
                    "\n" +
                    "In response, a ReviewFabricRestrictionsResponse is sent which contains a token that can be used to " +
                    "correlate a review request with a FabricRestrictionReviewUpdate event." +
                    "\n" +
                    "Within 1 hour of the ReviewFabricRestrictionsResponse, the FabricRestrictionReviewUpdate event shall " +
                    "be generated, in order to indicate completion of the review and any additional steps required by the " +
                    "user for the review." +
                    "\n" +
                    "A review may include obtaining consent from the user, which can take time. For example, the user may " +
                    "need to respond to an email or a push notification." +
                    "\n" +
                    "The ARL attribute may change at any time due to actions taken by the user, or the service associated " +
                    "with the device vendor."
            },

            Field(
                {
                    name: "Arl", id: 0x0, type: "list", conformance: "M", constraint: "desc", xref: "core§9.10.8.1.1",
                    details: "When the ARL field is provided, it indicates the specific restrictions that are requested for " +
                        "review. An empty list represents a generic request for review of all restrictions."
                },
                Field({ name: "entry", type: "CommissioningAccessRestrictionEntryStruct" })
            )
        ),

        Command(
            {
                name: "ReviewFabricRestrictionsResponse", id: 0x1, conformance: "MNGD", direction: "response",
                xref: "core§9.10.8.2",
                details: "Returns the review token for the request, which can be used to correlate with a " +
                    "FabricRestrictionReviewUpdate event."
            },

            Field({
                name: "Token", id: 0x0, type: "uint64", conformance: "M", xref: "core§9.10.8.2.1",
                details: "This field shall specify a Token that can be used to correlate a ReviewFabricRestrictionsResponse " +
                    "with a FabricRestrictionReviewUpdate event."
            })
        ),

        Datatype(
            { name: "ChangeTypeEnum", type: "enum8", xref: "core§9.10.5.1" },
            Field({ name: "Changed", id: 0x0, conformance: "M", description: "Entry or extension was changed" }),
            Field({ name: "Added", id: 0x1, conformance: "M", description: "Entry or extension was added" }),
            Field({ name: "Removed", id: 0x2, conformance: "M", description: "Entry or extension was removed" })
        ),

        Datatype(
            { name: "AccessControlEntryPrivilegeEnum", type: "enum8", xref: "core§9.10.5.2" },
            Field({
                name: "View", id: 0x1, conformance: "M",
                description: "Can read and observe all (except Access Control Cluster)"
            }),
            Field({ name: "ProxyView", id: 0x2, conformance: "D" }),

            Field({
                name: "Operate", id: 0x3, conformance: "M",
                description: "View privileges, and can perform the primary function of this Node (except Access Control Cluster)",
                xref: "core§9.10.5.2.1",
                details: "### This value implicitly grants View privileges"
            }),

            Field({
                name: "Manage", id: 0x4, conformance: "M",
                description: "Operate privileges, and can modify persistent configuration of this Node (except Access Control Cluster)",
                xref: "core§9.10.5.2.2",
                details: "This value implicitly grants Operate & View privileges"
            }),

            Field({
                name: "Administer", id: 0x5, conformance: "M",
                description: "Manage privileges, and can observe and modify the Access Control Cluster",
                xref: "core§9.10.5.2.3",
                details: "This value implicitly grants Manage, Operate & View privileges"
            })
        ),

        Datatype(
            { name: "AccessRestrictionTypeEnum", type: "enum8", xref: "core§9.10.5.3" },
            Field({
                name: "AttributeAccessForbidden", id: 0x0, conformance: "M",
                description: "Clients on this fabric are currently forbidden from reading and writing an attribute"
            }),
            Field({
                name: "AttributeWriteForbidden", id: 0x1, conformance: "M",
                description: "Clients on this fabric are currently forbidden from writing an attribute"
            }),
            Field({
                name: "CommandForbidden", id: 0x2, conformance: "M",
                description: "Clients on this fabric are currently forbidden from invoking a command"
            }),
            Field({
                name: "EventForbidden", id: 0x3, conformance: "M",
                description: "Clients on this fabric are currently forbidden from reading an event"
            })
        ),

        Datatype(
            { name: "AccessControlEntryAuthModeEnum", type: "enum8", xref: "core§9.10.5.4" },
            Field({ name: "Pase", id: 0x1, conformance: "M", description: "Passcode authenticated session" }),
            Field({ name: "Case", id: 0x2, conformance: "M", description: "Certificate authenticated session" }),
            Field({ name: "Group", id: 0x3, conformance: "M", description: "Group authenticated session" })
        ),

        Datatype(
            { name: "AccessControlTargetStruct", type: "struct", xref: "core§9.10.5.5" },
            Field({ name: "Cluster", id: 0x0, type: "cluster-id", conformance: "M", quality: "X" }),
            Field({ name: "Endpoint", id: 0x1, type: "endpoint-no", conformance: "M", quality: "X" }),
            Field({ name: "DeviceType", id: 0x2, type: "devtype-id", conformance: "M", quality: "X" })
        ),

        Datatype(
            { name: "AccessControlEntryStruct", type: "struct", xref: "core§9.10.5.6" },

            Field({
                name: "Privilege", id: 0x1, type: "AccessControlEntryPrivilegeEnum", access: "S", conformance: "M",
                xref: "core§9.10.5.6.1",

                details: "The privilege field shall specify the level of privilege granted by this Access Control Entry." +
                    "\n" +
                    "Each privilege builds upon its predecessor, expanding the set of actions that can be performed upon " +
                    "a Node. Administer is the highest privilege, and is special as it pertains to the administration of " +
                    "privileges itself, via the Access Control Cluster." +
                    "\n" +
                    "When a Node is granted a particular privilege, it is also implicitly granted all logically lower " +
                    "privilege levels as well. The following diagram illustrates how the higher privilege levels subsume " +
                    "the lower privilege levels:" +
                    "\n" +
                    "Individual clusters shall define whether attributes are readable, writable, or both readable and " +
                    "writable. Clusters also shall define which privilege is minimally required to be able to perform a " +
                    "particular read or write action on those attributes, or invoke particular commands. Device type " +
                    "specifications may further restrict the privilege required." +
                    "\n" +
                    "The Access Control Cluster shall require the Administer privilege to observe and modify the Access " +
                    "Control Cluster itself. The Administer privilege shall NOT be used on Access Control Entries which " +
                    "use the Group auth mode."
            }),

            Field({
                name: "AuthMode", id: 0x2, type: "AccessControlEntryAuthModeEnum", access: "S", conformance: "M",
                xref: "core§9.10.5.6.2",
                details: "The AuthMode field shall specify the authentication mode required by this Access Control Entry."
            }),

            Field(
                {
                    name: "Subjects", id: 0x3, type: "list", access: "S", conformance: "M",
                    constraint: "max subjectsPerAccessControlEntry", quality: "X", xref: "core§9.10.5.6.3",

                    details: "The subjects field shall specify a list of Subject IDs, to which this Access Control Entry grants " +
                        "access." +
                        "\n" +
                        "Device types may impose additional constraints on the minimum number of subjects per Access Control " +
                        "Entry." +
                        "\n" +
                        "An attempt to create an entry with more subjects than the node can support shall result in a " +
                        "RESOURCE_EXHAUSTED error and the entry shall NOT be created." +
                        "\n" +
                        "### Subject ID shall be of type uint64 with semantics depending on the entry’s AuthMode as follows:" +
                        "\n" +
                        "### Subject Semantics" +
                        "\n" +
                        "An empty subjects list indicates a wildcard; that is, this entry shall grant access to any Node that " +
                        "successfully authenticates via AuthMode. The subjects list shall NOT be empty if the entry’s " +
                        "AuthMode is PASE." +
                        "\n" +
                        "The PASE AuthMode is reserved for future use (see Section 6.6.2.9, “Bootstrapping of the Access " +
                        "Control Cluster”). An attempt to write an entry with AuthMode set to PASE shall fail with a status " +
                        "code of CONSTRAINT_ERROR." +
                        "\n" +
                        "For PASE authentication, the Passcode ID identifies the required passcode verifier, and shall be 0 " +
                        "for the default commissioning passcode." +
                        "\n" +
                        "For CASE authentication, the Subject ID is a distinguished name within the Operational Certificate " +
                        "shared during CASE session establishment, the type of which is determined by its range to be one of:" +
                        "\n" +
                        "  • a Node ID, which identifies the required source node directly (by ID)" +
                        "\n" +
                        "  • a CASE Authenticated Tag, which identifies the required source node indirectly (by tag)" +
                        "\n" +
                        "For Group authentication, the Group ID identifies the required group, as defined in the Group Key " +
                        "Management Cluster."
                },

                Field({ name: "entry", type: "subject-id" })
            ),

            Field(
                {
                    name: "Targets", id: 0x4, type: "list", access: "S", conformance: "M",
                    constraint: "max targetsPerAccessControlEntry", quality: "X", xref: "core§9.10.5.6.4",

                    details: "The targets field shall specify a list of AccessControlTargetStruct, which define the clusters on " +
                        "this Node to which this Access Control Entry grants access." +
                        "\n" +
                        "Device types may impose additional constraints on the minimum number of targets per Access Control " +
                        "Entry." +
                        "\n" +
                        "An attempt to create an entry with more targets than the node can support shall result in a " +
                        "RESOURCE_EXHAUSTED error and the entry shall NOT be created." +
                        "\n" +
                        "A single target shall contain at least one field (Cluster, Endpoint, or DeviceType), and shall NOT " +
                        "contain both an Endpoint field and a DeviceType field." +
                        "\n" +
                        "A target grants access based on the presence of fields as follows:" +
                        "\n" +
                        "### Target Semantics" +
                        "\n" +
                        "An empty targets list indicates a wildcard: that is, this entry shall grant access to all cluster " +
                        "instances on all endpoints on this Node."
                },

                Field({ name: "entry", type: "AccessControlTargetStruct" })
            ),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            { name: "AccessControlExtensionStruct", type: "struct", xref: "core§9.10.5.7" },

            Field({
                name: "Data", id: 0x1, type: "octstr", access: "S", conformance: "M", constraint: "max 128",
                xref: "core§9.10.5.7.1",

                details: "This field may be used by manufacturers to store arbitrary TLV-encoded data related to a fabric’s " +
                    "Access Control Entries." +
                    "\n" +
                    "The contents shall consist of a top-level anonymous list; each list element shall include a " +
                    "profile-specific tag encoded in fully-qualified form." +
                    "\n" +
                    "Administrators may iterate over this list of elements, and interpret selected elements at their " +
                    "discretion. The content of each element is not specified, but may be coordinated among manufacturers " +
                    "at their discretion."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            {
                name: "AccessRestrictionStruct", type: "struct", xref: "core§9.10.5.8",
                details: "This structure describes an access restriction that would be applied to a specific data model " +
                    "element on a given endpoint/cluster pair (see AccessRestrictionEntryStruct)."
            },
            Field({
                name: "Type", id: 0x0, type: "AccessRestrictionTypeEnum", conformance: "M", xref: "core§9.10.5.8.1",
                details: "This field shall indicate the type of restriction, for example, AttributeAccessForbidden."
            }),

            Field({
                name: "Id", id: 0x1, type: "uint32", conformance: "M", quality: "X", xref: "core§9.10.5.8.2",

                details: "This field shall indicate the element Manufacturer Extensible Identifier (MEI) associated with the " +
                    "element type subject to the access restriction, based upon the AccessRestrictionTypeEnum. When the " +
                    "Type is AttributeAccessForbidden or AttributeWriteForbidden, this value shall be considered of type " +
                    "attrib-id (i.e. an attribute identifier). When the Type is CommandForbidden, this value shall be " +
                    "considered of type command-id (i.e. an attribute identifier). When the Type is EventForbidden, this " +
                    "value shall be considered of type event-id (i.e. an event identifier)." +
                    "\n" +
                    "A null value shall indicate the wildcard value for the given value of Type (i.e. all elements " +
                    "associated with the Type under the associated endpoint and cluster for the containing " +
                    "AccessRestrictionEntryStruct)."
            })
        ),

        Datatype(
            {
                name: "AccessRestrictionEntryStruct", type: "struct", xref: "core§9.10.5.9",
                details: "This structure describes a current access restriction on the fabric."
            },

            Field({
                name: "Endpoint", id: 0x0, type: "endpoint-no", access: "S", conformance: "M",
                xref: "core§9.10.5.9.1",
                details: "This field shall indicate the endpoint having associated access restrictions scoped to the " +
                    "associated fabric of the list containing the entry."
            }),

            Field({
                name: "Cluster", id: 0x1, type: "cluster-id", access: "S", conformance: "M",
                xref: "core§9.10.5.9.2",
                details: "This field shall indicate the cluster having associated access restrictions under the entry’s " +
                    "Endpoint, scoped to the associated fabric of the list containing the entry."
            }),

            Field(
                {
                    name: "Restrictions", id: 0x2, type: "list", access: "S", conformance: "M", constraint: "min 1",
                    xref: "core§9.10.5.9.3",
                    details: "This field shall indicate the set of restrictions applying to the Cluster under the given Endpoint, " +
                        "scoped to the associated fabric of the list containing the entry." +
                        "\n" +
                        "This list shall NOT be empty."
                },

                Field({ name: "entry", type: "AccessRestrictionStruct" })
            ),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            {
                name: "CommissioningAccessRestrictionEntryStruct", type: "struct", xref: "core§9.10.5.10",
                details: "This structure describes a current access restriction when there is no accessing fabric."
            },
            Field({
                name: "Endpoint", id: 0x0, type: "endpoint-no", conformance: "M", xref: "core§9.10.5.10.1",
                details: "This field shall indicate the endpoint having associated access restrictions scoped to the " +
                    "associated fabric of the list containing the entry."
            }),
            Field({
                name: "Cluster", id: 0x1, type: "cluster-id", conformance: "M", xref: "core§9.10.5.10.2",
                details: "This field shall indicate the cluster having associated access restrictions under the entry’s " +
                    "Endpoint, scoped to the associated fabric of the list containing the entry."
            }),

            Field(
                {
                    name: "Restrictions", id: 0x2, type: "list", conformance: "M", constraint: "min 1",
                    xref: "core§9.10.5.10.3",
                    details: "This field shall indicate the set of restrictions applying to the Cluster under the given Endpoint, " +
                        "scoped to the associated fabric of the list containing the entry." +
                        "\n" +
                        "This list shall NOT be empty."
                },

                Field({ name: "entry", type: "AccessRestrictionStruct" })
            )
        )
    ),

    Cluster(
        {
            name: "BridgedDeviceBasicInformation", id: 0x39, type: "BasicInformation",
            classification: "endpoint", pics: "BRBINFO", xref: "core§9.13",

            details: "This cluster provides attributes and events for determining basic information about Bridged Nodes." +
                "\n" +
                "This cluster is derived from the Basic Information cluster and serves two purposes towards a Node " +
                "communicating with a Bridge:" +
                "\n" +
                "  • Indicate that the functionality on the Endpoint where it is placed (and its Parts) is bridged, " +
                "    and" +
                "\n" +
                "  • Provide a centralized collection of attributes that the Node may collect to aid in conveying " +
                "    information regarding the Bridged Device to a user, such as the vendor name, the model name, or " +
                "    user-assigned name." +
                "\n" +
                "This cluster shall be exposed by a Bridge on the Endpoint representing each Bridged Device. When the " +
                "functionality of a Bridged Device is represented using a set of Endpoints, this cluster shall only " +
                "be exposed on the Endpoint which is at the top of the hierarchy for the functionality of that " +
                "Bridged Device." +
                "\n" +
                "This cluster shall NOT be used on an endpoint that is not in the Descriptor cluster PartsList of an " +
                "endpoint with an Aggregator device type." +
                "\n" +
                "This cluster has been derived from the Basic Information Cluster, and provides generic information " +
                "about the Bridged Device. Not all of the attributes in the Basic Information Cluster are relevant " +
                "for a Bridged Device (e.g. ProductID since it is not a Matter device). For other attributes, the " +
                "information which is listed as Mandatory for the Basic Information Cluster, may not be available " +
                "when the Bridged Device does not provide it to the Bridge, and the Bridge has no other means to " +
                "determine it. For such cases where the information for a particular attribute is not available, the " +
                "Bridge SHOULD NOT include the attribute in the cluster for this Bridged Device. See below for " +
                "Conformance details."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 5 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§9.13.4" },
            Field({
                name: "BIS", conformance: "O", constraint: "20", title: "BridgedIcdSupport",
                details: "Support bridged ICDs."
            })
        ),

        Attribute({ name: "DataModelRevision", id: 0x0, conformance: "X", xref: "core§9.13.5" }),
        Attribute({ name: "VendorName", id: 0x1, conformance: "desc", xref: "core§9.13.5" }),
        Attribute({ name: "VendorId", id: 0x2, conformance: "desc", xref: "core§9.13.5" }),
        Attribute({ name: "ProductName", id: 0x3, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "ProductId", id: 0x4, conformance: "desc", xref: "core§9.13.5" }),
        Attribute({ name: "NodeLabel", id: 0x5, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "Location", id: 0x6, conformance: "X", xref: "core§9.13.5" }),
        Attribute({ name: "HardwareVersion", id: 0x7, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "HardwareVersionString", id: 0x8, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "SoftwareVersion", id: 0x9, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "SoftwareVersionString", id: 0xa, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "ManufacturingDate", id: 0xb, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "PartNumber", id: 0xc, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "ProductUrl", id: 0xd, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "ProductLabel", id: 0xe, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "SerialNumber", id: 0xf, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "LocalConfigDisabled", id: 0x10, conformance: "X", xref: "core§9.13.5" }),

        Attribute({
            name: "Reachable", id: 0x11, conformance: "M", xref: "core§9.13.5.2",

            details: "This attribute shall be used to indicate whether the bridged device is reachable by the bridge, so a " +
                "Matter Node which wants to communicate with a bridged device can get an indication that this might " +
                "fail (when the attribute is False). Determination of reachability might not be perfect (e.g. " +
                "depending on technology employed), so the Matter Node SHOULD be aware of the risk of false positives " +
                "and negatives on reachability determination. For example, a bridged device may be marked as " +
                "unreachable while it could actually be reached, and vice-versa. Also, detection (and indication) " +
                "that a bridged device is not longer reachable may be delayed due to the technique employed (e.g. " +
                "detecting that a number of expected messages from the bridged device did not arrive). Also see event " +
                "ReachableChanged below."
        }),

        Attribute({
            name: "UniqueId", id: 0x12, conformance: "M", xref: "core§9.13.5.3",

            details: "This attribute shall, for a Bridged Device, be updated when the Bridge is factory reset. If the " +
                "bridged device does not provide some unique id (e.g. in the case of bridging from non-Matter " +
                "devices, or in case of bridging Matter devices from an earlier revision which were not required to " +
                "provide a UniqueID attribute), the bridge shall generate a unique id on behalf of the bridged " +
                "device." +
                "\n" +
                "NOTE The UniqueID attribute was optional in cluster revisions prior to revision 4."
        }),

        Attribute({ name: "CapabilityMinima", id: 0x13, conformance: "X", xref: "core§9.13.5" }),
        Attribute({ name: "ProductAppearance", id: 0x14, conformance: "O", xref: "core§9.13.5" }),
        Attribute({ name: "SpecificationVersion", id: 0x15, conformance: "X", xref: "core§9.13.5" }),
        Attribute({ name: "MaxPathsPerInvoke", id: 0x16, conformance: "X", xref: "core§9.13.5" }),

        Attribute({
            name: "ConfigurationVersion", id: 0x18, conformance: "P, O", xref: "core§9.13.5.4",

            details: "This attribute shall contain the current version number for the configuration of the bridged device." +
                "\n" +
                "If the bridge detects a change on a bridged device, which it deems as a change in the configuration " +
                "of the bridged device, it shall increase this attribute as described in Section 9.2.9, “Node " +
                "Configuration Changes”." +
                "\n" +
                "The ability and the method used to detect such a change on a bridged device is manufacturer " +
                "specific."
        }),

        Event({ name: "StartUp", id: 0x0, conformance: "O", priority: "critical", xref: "core§9.13.7" }),
        Event({ name: "ShutDown", id: 0x1, conformance: "O", priority: "critical", xref: "core§9.13.7" }),

        Event(
            {
                name: "Leave", id: 0x2, conformance: "O", priority: "critical", xref: "core§9.13.7.1",

                details: "The Leave event SHOULD be generated by the bridge when it detects that the associated device has " +
                    "left the non-Matter network." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> The FabricIndex field has the X conformance, indicating it shall NOT be present. This event, in " +
                    "  the context of Bridged Device Basic Information cluster, has no usable fields, but the original " +
                    "  Basic Information cluster’s field definition is kept for completeness."
            },

            Field({ name: "FabricIndex", id: 0x0, conformance: "X" })
        ),

        Event({
            name: "ReachableChanged", id: 0x3, conformance: "M", priority: "critical", xref: "core§9.13.7.2",
            details: "This event shall be generated when there is a change in the Reachable attribute. Its purpose is to " +
                "provide an indication towards interested parties that the reachability of a bridged device has " +
                "changed over its native connectivity technology, so they may take appropriate action." +
                "\n" +
                "After (re)start of a bridge this event may be generated."
        }),

        Event(
            {
                name: "ActiveChanged", id: 0x80, access: "V", conformance: "BIS", priority: "info",
                xref: "core§9.13.7.3",
                details: "This event (when supported) shall be generated the next time a bridged device becomes active after a " +
                    "KeepActive command is received." +
                    "\n" +
                    "See KeepActive for more details."
            },

            Field({
                name: "PromisedActiveDuration", id: 0x0, type: "uint32", conformance: "M", constraint: "desc",
                xref: "core§9.13.7.3.1",

                details: "This field shall indicate the minimum duration, in milliseconds, that the bridged device will remain " +
                    "active after receiving the initial request from the KeepActive processing steps." +
                    "\n" +
                    "If the bridged device is a Matter Intermittently Connected Device, PromisedActiveDuration shall be " +
                    "set to the PromisedActiveDuration value returned in the StayActiveResponse command." +
                    "\n" +
                    "If the bridged device is not a Matter Intermittently Connected Device, the implementation of this is " +
                    "best-effort since it may interact with non-native protocol."
            })
        ),

        Command(
            {
                name: "KeepActive", id: 0x80, access: "O", conformance: "BIS", direction: "request",
                response: "status", xref: "core§9.13.6.1",

                details: "Upon receipt, the server shall attempt to keep the bridged device active for the duration specified " +
                    "by the command, when the device is next active." +
                    "\n" +
                    "The implementation of this is best-effort since it may interact with non-native protocols. However, " +
                    "several specific protocol requirements are:" +
                    "\n" +
                    "  • If the bridged device is a Matter Intermittently Connected Device, then the server shall send a " +
                    "    StayActiveRequest command with the StayActiveDuration field set to value of the " +
                    "    StayActiveDuration field in the received command to the bridged device when the bridged device " +
                    "    next sends a checks-in message or subscription report. See Intermittently Connected Devices " +
                    "    Behavior for details on ICD state management." +
                    "\n" +
                    "When the bridge detects that the bridged device goes into an active state, an ActiveChanged event " +
                    "shall be generated." +
                    "\n" +
                    "In order to avoid unnecessary power consumption in the bridged device:" +
                    "\n" +
                    "  • The server shall enter a \"pending active\" state for the associated device when the KeepActive " +
                    "    command is received. The server \"pending active\" state shall expire after the amount of time " +
                    "    defined by the TimeoutMs field, in milliseconds, if no subsequent KeepActive command is " +
                    "    received. When a KeepActive command is received, the \"pending active\" state is set, the " +
                    "    StayActiveDuration is updated to the greater of the new value and the previously stored value, " +
                    "    and the TimeoutMs is updated to the greater of the new value and the remaining time until the " +
                    "    prior \"pending active\" state expires." +
                    "\n" +
                    "  • The server shall only keep the bridged device active once for a request. (The server shall only " +
                    "    consider the operation performed if an associated ActiveChanged event was generated.)"
            },

            Field({
                name: "StayActiveDuration", id: 0x0, type: "uint32", conformance: "M", xref: "core§9.13.6.1.1",

                details: "This field shall indicate the duration, in milliseconds, that the device is requested to remain " +
                    "active, once the device becomes active again." +
                    "\n" +
                    "The value of this field may be longer than the value supported by the bridged device and would, " +
                    "typically, be used by the client to request the server of the bridged device to stay active and " +
                    "responsive for this period to allow a sequence of message exchanges during that period." +
                    "\n" +
                    "The client may slightly overestimate the duration it wants the bridged device to be active for, in " +
                    "order to account for network delays."
            }),

            Field({
                name: "TimeoutMs", id: 0x1, type: "uint32", conformance: "M", constraint: "30000 to 3600000",
                xref: "core§9.13.6.1.2",

                details: "This field shall indicate the period, in milliseconds, that the server will wait before the \"pending " +
                    "active\" state expires. See the KeepActive Command description for details." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> TimeoutMs is a timeout for the request, NOT the time the device will be awake for. The server will " +
                    "  wait for up to TimeoutMs for the device. If after TimeoutMs the ICD device does NOT check-in, the " +
                    "  server will not perform any actions."
            })
        )
    ),

    Cluster(
        {
            name: "Actions", id: 0x25, classification: "application", pics: "ACT", xref: "core§9.14",

            details: "This cluster provides a standardized way for a Node (typically a Bridge, but could be any Node) to " +
                "expose logical grouping and actions." +
                "\n" +
                "Specifically this cluster provides:" +
                "\n" +
                "  • Information about logical grouping of endpoints on the Node (example: lights in a room)" +
                "\n" +
                "  • Information about named actions that can be performed on such a group of endpoints (example: " +
                "    recall a scene for a group of lights by its name)" +
                "\n" +
                "  • Commands to trigger such actions" +
                "\n" +
                "  • Events to receive feedback on the state of such actions." +
                "\n" +
                "The information on grouping and available actions is typically provided by the user or Bridge " +
                "manufacturer via some means not defined in Matter, and therefore provided as read-only to Nodes. For " +
                "example: a manufacturer-provided app allows a user to set up logical grouping and create/assign " +
                "scene for such groups." +
                "\n" +
                "Using this cluster, a Node can learn about such logical grouping, provided actions, and trigger such " +
                "actions." +
                "\n" +
                "While the origin of this cluster stems from use cases with a Bridge, its server side may also be " +
                "implemented on any Node which can expose certain grouping, actions or automations to other users." +
                "\n" +
                "After defining the attributes, commands and events for this cluster, and the associated data types, " +
                "several examples are provided to illustrate the capabilities of this cluster." +
                "\n" +
                "Actions can be defined in a flexible manner to suit the needs of the various nodes implementing this " +
                "cluster. For each action, the commands available for that particular action are defined." +
                "\n" +
                "This cluster can be used to expose only the grouping of endpoints without any actions defined by " +
                "populating the EndpointList attribute accordingly and providing an empty list for ActionList." +
                "\n" +
                "The term 'action' in the description of this cluster should not be confused with the term 'action' " +
                "as used in the Interaction Model."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "ActionList", id: 0x0, type: "list", access: "R V", conformance: "M", constraint: "max 256",
                default: [], xref: "core§9.14.5.1",
                details: "The ActionList attribute holds the list of actions. Each entry shall have an unique ActionID, and " +
                    "its EndpointListID shall exist in the EndpointLists attribute."
            },

            Field({ name: "entry", type: "ActionStruct" })
        ),

        Attribute(
            {
                name: "EndpointLists", id: 0x1, type: "list", access: "R V", conformance: "M",
                constraint: "max 256", default: [], xref: "core§9.14.5.2",
                details: "The EndpointLists attribute holds the list of endpoint lists. Each entry shall have an unique " +
                    "EndpointListID."
            },

            Field({ name: "entry", type: "EndpointListStruct" })
        ),

        Attribute(
            {
                name: "SetupUrl", id: 0x2, type: "string", access: "R V", conformance: "O", constraint: "max 512",
                xref: "core§9.14.5.3",

                details: "The SetupURL attribute (when provided) shall indicate a URL; its syntax shall follow the syntax as " +
                    "specified in RFC 1738, max. 512 ASCII characters and shall use the https scheme. The location " +
                    "referenced by this URL shall provide additional information for the actions provided:" +
                    "\n" +
                    "  • When used without suffix, it shall provide information about the various actions which the " +
                    "    cluster provides." +
                    "\n" +
                    "    ◦ Example: SetupURL could take the value of example://Actions or https://domain.example/ " +
                    "      Matter/bridgev1/Actions for this generic case (access generic info how to use actions provided " +
                    "      by this cluster)." +
                    "\n" +
                    "  • When used with a suffix of \"/?a=\" and the decimal value of ActionID for one of the actions, it " +
                    "    may provide information about that particular action. This could be a deeplink to " +
                    "    manufacturer-app/website (associated somehow to the server node) with the " +
                    "    information/edit-screen for this action so that the user can view and update details of the " +
                    "    action, e.g. edit the scene, or change the wake-up experience time period." +
                    "\n" +
                    "    ◦ Example of SetupURL with suffix added: example://Actions/?a=12345 or " +
                    "      https://domain.example/Matter/bridgev1/Actions/?a=12345 for linking to specific info/editing " +
                    "      of the action with ActionID 0x3039."
            }
        ),

        Event(
            {
                name: "StateChanged", id: 0x0, access: "V", conformance: "M", priority: "info",
                xref: "core§9.14.7.1",

                details: "This event shall be generated when there is a change in the State of an ActionID during the " +
                    "execution of an action and the most recent command using that ActionID used an InvokeID data field." +
                    "\n" +
                    "It provides feedback to the client about the progress of the action." +
                    "\n" +
                    "Example: When InstantActionWithTransition is invoked (with an InvokeID data field), two StateChanged " +
                    "events will be generated:" +
                    "\n" +
                    "  • one when the transition starts (NewState=Active)" +
                    "\n" +
                    "  • one when the transition completed (NewState=Inactive)"
            },

            Field({
                name: "ActionId", id: 0x0, type: "uint16", conformance: "M", xref: "core§9.14.7.1.1",
                details: "This field shall be set to the ActionID of the action which has changed state."
            }),
            Field({
                name: "InvokeId", id: 0x1, type: "uint32", conformance: "M", xref: "core§9.14.7.1.2",
                details: "This field shall be set to the InvokeID which was provided to the most recent command referencing " +
                    "this ActionID."
            }),
            Field({
                name: "NewState", id: 0x2, type: "ActionStateEnum", conformance: "M", xref: "core§9.14.7.1.3",
                details: "This field shall be set to state that the action has changed to."
            })
        ),

        Event(
            {
                name: "ActionFailed", id: 0x1, access: "V", conformance: "M", priority: "info",
                xref: "core§9.14.7.2",

                details: "This event shall be generated when there is some error which prevents the action from its normal " +
                    "planned execution and the most recent command using that ActionID used an InvokeID data field." +
                    "\n" +
                    "It provides feedback to the client about the non-successful progress of the action." +
                    "\n" +
                    "Example: When InstantActionWithTransition is invoked (with an InvokeID data field), and another " +
                    "controller changes the state of one or more of the involved endpoints during the transition, thus " +
                    "interrupting the transition triggered by the action, two events would be generated:" +
                    "\n" +
                    "  • StateChanged when the transition starts (NewState=Active)" +
                    "\n" +
                    "  • ActionFailed when the interrupting command occurs (NewState=Inactive, Error=interrupted)" +
                    "\n" +
                    "Example: When InstantActionWithTransition is invoked (with an InvokeID data field = 1), and the same " +
                    "client invokes an InstantAction with (the same or another ActionId and) InvokeID = 2, and this " +
                    "second command interrupts the transition triggered by the first command, these events would be " +
                    "generated:" +
                    "\n" +
                    "  • StateChanged (InvokeID=1, NewState=Active) when the transition starts" +
                    "\n" +
                    "  • ActionFailed (InvokeID=2, NewState=Inactive, Error=interrupted) when the second command " +
                    "    interrupts the transition" +
                    "\n" +
                    "  • StateChanged (InvokeID=2, NewState=Inactive) upon the execution of the action for the second " +
                    "    command"
            },

            Field({
                name: "ActionId", id: 0x0, type: "uint16", conformance: "M", xref: "core§9.14.7.2.1",
                details: "This field shall be set to the ActionID of the action which encountered an error."
            }),
            Field({
                name: "InvokeId", id: 0x1, type: "uint32", conformance: "M", xref: "core§9.14.7.2.2",
                details: "This field shall be set to the InvokeID which was provided to the most recent command referencing " +
                    "this ActionID."
            }),
            Field({
                name: "NewState", id: 0x2, type: "ActionStateEnum", conformance: "M", xref: "core§9.14.7.2.3",
                details: "This field shall be set to state that the action is in at the time of generating the event."
            }),
            Field({
                name: "Error", id: 0x3, type: "ActionErrorEnum", conformance: "M", xref: "core§9.14.7.2.4",
                details: "This field shall be set to indicate the reason for non-successful progress of the action."
            })
        ),

        Command(
            {
                name: "InstantAction", id: 0x0, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.1",

                details: "This command is used to trigger an instantaneous action." +
                    "\n" +
                    "This command triggers an action (state change) on the involved endpoints, in a \"fire and forget\" " +
                    "manner. Afterwards, the action’s state shall be Inactive." +
                    "\n" +
                    "Example: recall a scene on a number of lights."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "InstantActionWithTransition", id: 0x1, access: "O", conformance: "desc",
                direction: "request", response: "status", xref: "core§9.14.6.2",

                details: "This command is used to trigger an instantaneous action with a transition over a given time." +
                    "\n" +
                    "It is recommended that, where possible (e.g., it is not possible for attributes with Boolean data " +
                    "type), a gradual transition SHOULD take place from the old to the new state over this time period. " +
                    "However, the exact transition is manufacturer dependent." +
                    "\n" +
                    "This command triggers an action (state change) on the involved endpoints, with a specified time to " +
                    "transition from the current state to the new state. During the transition, the action’s state shall " +
                    "be Active. Afterwards, the action’s state shall be Inactive." +
                    "\n" +
                    "Example: recall a scene on a number of lights, with a specified transition time."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" }),
            Field({
                name: "TransitionTime", id: 0x2, type: "uint16", conformance: "M", xref: "core§9.14.6.2.1",
                details: "This field shall indicate the transition time in 1/10th of seconds."
            })
        ),

        Command(
            {
                name: "StartAction", id: 0x2, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.3",

                details: "This command is used to trigger the commencement of an action." +
                    "\n" +
                    "This command triggers the commencement of an action on the involved endpoints. Afterwards, the " +
                    "action’s state shall be Active." +
                    "\n" +
                    "Example: start a dynamic lighting pattern (such as gradually rotating the colors around the " +
                    "setpoints of the scene) on a set of lights." +
                    "\n" +
                    "Example: start a sequence of events such as a wake-up experience involving lights moving through " +
                    "several brightness/color combinations and the window covering gradually opening."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "StartActionWithDuration", id: 0x3, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.4",

                details: "This command is used to trigger the commencement of an action with a duration." +
                    "\n" +
                    "This command triggers the commencement of an action on the involved endpoints, and shall change the " +
                    "action’s state to Active. After the specified Duration, the action will stop, and the action’s state " +
                    "shall change to Inactive." +
                    "\n" +
                    "Example: start a dynamic lighting pattern (such as gradually rotating the colors around the " +
                    "setpoints of the scene) on a set of lights for 1 hour (Duration=3600)."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" }),
            Field({
                name: "Duration", id: 0x2, type: "uint32", conformance: "M", xref: "core§9.14.6.4.1",
                details: "This field shall indicate the requested duration in seconds."
            })
        ),

        Command(
            {
                name: "StopAction", id: 0x4, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.5",

                details: "This command is used to stop an action." +
                    "\n" +
                    "This command stops the ongoing action on the involved endpoints. Afterwards, the action’s state " +
                    "shall be Inactive." +
                    "\n" +
                    "Example: stop a dynamic lighting pattern which was previously started with StartAction."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "PauseAction", id: 0x5, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.6",

                details: "This command is used to pause an action." +
                    "\n" +
                    "This command pauses an ongoing action, and shall change the action’s state to Paused." +
                    "\n" +
                    "Example: pause a dynamic lighting effect (the lights stay at their current color) which was " +
                    "previously started with StartAction."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "PauseActionWithDuration", id: 0x6, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.7",

                details: "This command is used to pause an action with a duration." +
                    "\n" +
                    "This command pauses an ongoing action, and shall change the action’s state to Paused. After the " +
                    "specified Duration, the ongoing action will be automatically resumed. which shall change the " +
                    "action’s state to Active." +
                    "\n" +
                    "Example: pause a dynamic lighting effect (the lights stay at their current color) for 10 minutes " +
                    "(Duration=600)." +
                    "\n" +
                    "The difference between Pause/Resume and Disable/Enable is on the one hand semantic (the former is " +
                    "more of a transitionary nature while the latter is more permanent) and on the other hand these can " +
                    "be implemented slightly differently in the implementation of the action (e.g. a Pause would be " +
                    "automatically resumed after some hours or during a nightly reset, while an Disable would remain in " +
                    "effect until explicitly enabled again)."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" }),
            Field({
                name: "Duration", id: 0x2, type: "uint32", conformance: "M", xref: "core§9.14.6.7.1",
                details: "This field shall indicate the requested duration in seconds."
            })
        ),

        Command(
            {
                name: "ResumeAction", id: 0x7, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.8",

                details: "This command is used to resume an action." +
                    "\n" +
                    "This command resumes a previously paused action, and shall change the action’s state to Active." +
                    "\n" +
                    "The difference between ResumeAction and StartAction is that ResumeAction will continue the action " +
                    "from the state where it was paused, while StartAction will start the action from the beginning." +
                    "\n" +
                    "Example: resume a dynamic lighting effect (the lights' colors will change gradually, continuing from " +
                    "the point they were paused)."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "EnableAction", id: 0x8, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.9",
                details: "This command is used to enable an action." +
                    "\n" +
                    "This command enables a certain action or automation. Afterwards, the action’s state shall be Active." +
                    "\n" +
                    "Example: enable a motion sensor to control the lights in an area."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "EnableActionWithDuration", id: 0x9, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.10",

                details: "This command is used to enable an action with a duration." +
                    "\n" +
                    "This command enables a certain action or automation, and shall change the action’s state to be " +
                    "Active. After the specified Duration, the action or automation will stop, and the action’s state " +
                    "shall change to Disabled." +
                    "\n" +
                    "Example: enable a \"presence mimicking\" behavior for the lights in your home during a vacation; the " +
                    "Duration field is used to indicated the length of your absence from home. After that period, the " +
                    "presence mimicking behavior will no longer control these lights."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" }),
            Field({
                name: "Duration", id: 0x2, type: "uint32", conformance: "M", xref: "core§9.14.6.10.1",
                details: "This field shall indicate the requested duration in seconds."
            })
        ),

        Command(
            {
                name: "DisableAction", id: 0xa, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.11",

                details: "This command is used to disable an action." +
                    "\n" +
                    "This command disables a certain action or automation, and shall change the action’s state to " +
                    "Inactive." +
                    "\n" +
                    "Example: disable a motion sensor to no longer control the lights in an area."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" })
        ),

        Command(
            {
                name: "DisableActionWithDuration", id: 0xb, access: "O", conformance: "desc", direction: "request",
                response: "status", xref: "core§9.14.6.12",

                details: "This command is used to disable an action with a duration." +
                    "\n" +
                    "This command disables a certain action or automation, and shall change the action’s state to " +
                    "Disabled. After the specified Duration, the action or automation will re-start, and the action’s " +
                    "state shall change to either Inactive or Active, depending on the actions (see Section 9.14.8.4, " +
                    "“Example 4: Wake-up routine” and Section 9.14.8.6, “Example 6: Alarm system”)." +
                    "\n" +
                    "Example: disable a \"wakeup\" experience for a period of 1 week when going on holiday (to prevent them " +
                    "from turning on in the morning while you’re not at home). After this period, the wakeup experience " +
                    "will control the lights as before."
            },

            Field({ name: "ActionId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "InvokeId", id: 0x1, type: "uint32", conformance: "O" }),
            Field({
                name: "Duration", id: 0x2, type: "uint32", conformance: "M", xref: "core§9.14.6.12.1",
                details: "This field shall indicate the requested duration in seconds."
            })
        ),

        Datatype(
            {
                name: "CommandBits", type: "map16", xref: "core§9.14.4.1",
                details: "Note - The bit allocation of this bitmap shall follow the ID’s of the Commands of this cluster."
            },
            Field({ name: "InstantAction", constraint: "0", description: "Indicate support for InstantAction command" }),
            Field({
                name: "InstantActionWithTransition", constraint: "1",
                description: "Indicate support for InstantActionWithTransition command"
            }),
            Field({ name: "StartAction", constraint: "2", description: "Indicate support for StartAction command" }),
            Field({
                name: "StartActionWithDuration", constraint: "3",
                description: "Indicate support for StartActionWithDuration command"
            }),
            Field({ name: "StopAction", constraint: "4", description: "Indicate support for StopAction command" }),
            Field({ name: "PauseAction", constraint: "5", description: "Indicate support for PauseAction command" }),
            Field({
                name: "PauseActionWithDuration", constraint: "6",
                description: "Indicate support for PauseActionWithDuration command"
            }),
            Field({ name: "ResumeAction", constraint: "7", description: "Indicate support for ResumeAction command" }),
            Field({ name: "EnableAction", constraint: "8", description: "Indicate support for EnableAction command" }),
            Field({
                name: "EnableActionWithDuration", constraint: "9",
                description: "Indicate support for EnableActionWithDuration command"
            }),
            Field({ name: "DisableAction", constraint: "10", description: "Indicate support for DisableAction command" }),
            Field({
                name: "DisableActionWithDuration", constraint: "11",
                description: "Indicate support for DisableActionWithDuration command"
            })
        ),

        Datatype(
            { name: "ActionTypeEnum", type: "enum8", xref: "core§9.14.4.2" },
            Field({
                name: "Other", id: 0x0, conformance: "M",
                description: "Use this only when none of the other values applies"
            }),

            Field({
                name: "Scene", id: 0x1, conformance: "M", description: "Bring the endpoints into a certain state",
                xref: "core§9.14.4.2.1",

                details: "Can be used to set a static state of the associated endpoints (typically using InstantAction or " +
                    "InstantActionWithTransition), or to bring these endpoints into a more dynamic state (typically using " +
                    "StartAction), where the endpoints would e.g. gradually cycle through certain colors for a pleasing " +
                    "effect. A voice controller could use \"set\" (to map to InstantAction) or \"play\" (to map to " +
                    "StartAction) to trigger such actions." +
                    "\n" +
                    "Example: see Section 9.14.8.1, “Example 1: Scene recall” and Section 9.14.8.2, “Example 2: Set " +
                    "dynamic light effect”."
            }),

            Field({
                name: "Sequence", id: 0x2, conformance: "M",
                description: "A sequence of states with a certain time pattern", xref: "core§9.14.4.2.2",
                details: "Indicates an action which involves a sequence of events/states of the associated endpoints, such as " +
                    "a wake-up experience." +
                    "\n" +
                    "Example: see Section 9.14.8.4, “Example 4: Wake-up routine”."
            }),

            Field({
                name: "Automation", id: 0x3, conformance: "M",
                description: "Control an automation (e.g. motion sensor controlling lights)",
                xref: "core§9.14.4.2.3",
                details: "Indications an automation (e.g. a motion sensor controlling lights, an alarm system) which can " +
                    "bee.g. started, stopped, paused, resumed." +
                    "\n" +
                    "Example: see Section 9.14.8.3, “Example 3: Pause sensor automation”."
            }),

            Field({
                name: "Exception", id: 0x4, conformance: "M",
                description: "Sequence that will run when something doesn’t happen", xref: "core§9.14.4.2.4",
                details: "Indicates some action which the server will execute when a certain condition (which normally does " +
                    "not happen) is not met." +
                    "\n" +
                    "Example: lock the doors when the server’s system has detected no one is at home while the doors are " +
                    "in the 'unlocked' state."
            }),

            Field({
                name: "Notification", id: 0x5, conformance: "M",
                description: "Use the endpoints to send a message to user", xref: "core§9.14.4.2.5",
                details: "Indicates an action that can be triggered (e.g. by InstantAction) to notify the user." +
                    "\n" +
                    "Example: play a pattern on the lights in the living room if there is someone in the garden in the " +
                    "evening."
            }),

            Field({
                name: "Alarm", id: 0x6, conformance: "M", description: "Higher priority notification",
                xref: "core§9.14.4.2.6",
                details: "Similar to Notification but with a higher priority (and might override other endpoint states which " +
                    "Type=Notification would not override)." +
                    "\n" +
                    "Example: flash all lights in the house when CO sensor triggers."
            })
        ),

        Datatype(
            {
                name: "ActionStateEnum", type: "enum8", xref: "core§9.14.4.3",
                details: "Note that some of these states are applicable only for certain actions, as determined by their " +
                    "SupportedCommands."
            },
            Field({ name: "Inactive", id: 0x0, conformance: "M", description: "The action is not active" }),
            Field({ name: "Active", id: 0x1, conformance: "M", description: "The action is active" }),
            Field({ name: "Paused", id: 0x2, conformance: "M", description: "The action has been paused" }),
            Field({ name: "Disabled", id: 0x3, conformance: "M", description: "The action has been disabled" })
        ),

        Datatype(
            { name: "ActionErrorEnum", type: "enum8", xref: "core§9.14.4.4" },
            Field({ name: "Unknown", id: 0x0, conformance: "M", description: "Other reason not listed in the row(s) below" }),
            Field({
                name: "Interrupted", id: 0x1, conformance: "M",
                description: "The action was interrupted by another command or interaction"
            })
        ),

        Datatype(
            {
                name: "EndpointListTypeEnum", type: "enum8", xref: "core§9.14.4.5",
                details: "The Room and Zone values are provided for the cases where a user (or the system on behalf of the " +
                    "user) has created logical grouping of the endpoints (e.g. bridged devices) based on location."
            },

            Field({
                name: "Other", id: 0x0, conformance: "M", description: "Another group of endpoints",
                xref: "core§9.14.4.5.1",
                details: "This value is provided for the case of an endpoint list which is tied specifically to this action " +
                    "i.e. not independently created by the user. For Type=Other the Name may be empty. A Matter " +
                    "controller would typically not use this for anything else than just to know which endpoints would be " +
                    "affected by the action."
            }),

            Field({
                name: "Room", id: 0x1, conformance: "M",
                description: "User-configured group of endpoints where an endpoint can be in only one room",
                xref: "core§9.14.4.5.2",
                details: "Is used for the situation where an endpoint can only be part of one such rooms (e.g. physical " +
                    "mapping). Using these exposed logical groups, a Matter controller who has a similar grouping concept " +
                    "can use it to place each endpoint (bridged device) in the right room automatically, without user " +
                    "having to redo that setup for each device in each system - both at first contact and upon later " +
                    "updates to the endpoints (e.g. user adds a bridged device or creates a new room)."
            }),

            Field({
                name: "Zone", id: 0x2, conformance: "M",
                description: "User-configured group of endpoints where an endpoint can be in any number of zones",
                xref: "core§9.14.4.5.3",

                details: "Is a more general concept where an endpoint can be part of multiple zones, e.g. a light in the " +
                    "living room can be part of the \"reading corner\" zone (subset of the lights in the living room) but " +
                    "also part of the \"downstairs\" zone which contains all the lights on a floor, e.g. combining living " +
                    "room, kitchen and hallway. This indicates that a user has defined this list of endpoints as " +
                    "something they logically would like to control as a group, so Matter controllers could provide the " +
                    "user with a way to do as such."
            })
        ),

        Datatype(
            {
                name: "ActionStruct", type: "struct", xref: "core§9.14.4.6",
                details: "This data type holds the details of a single action, and contains the data fields below."
            },
            Field({
                name: "ActionId", id: 0x0, type: "uint16", conformance: "M", xref: "core§9.14.4.6.1",
                details: "This field shall provide an unique identifier used to identify an action."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "M", constraint: "max 128{32}",
                xref: "core§9.14.4.6.2",
                details: "This field shall indicate the name (as assigned by the user or automatically by the server) " +
                    "associated with this action. This can be used for identifying the action to the user by the client. " +
                    "Example: \"my colorful scene\"."
            }),

            Field({
                name: "Type", id: 0x2, type: "ActionTypeEnum", conformance: "M", xref: "core§9.14.4.6.3",
                details: "This field shall indicate the type of action. The value of Type of an action, along with its " +
                    "SupportedCommands can be used by the client in its UX or logic to determine how to present or use " +
                    "such action. See ActionTypeEnum for details and examples."
            }),

            Field({
                name: "EndpointListId", id: 0x3, type: "uint16", conformance: "M", xref: "core§9.14.4.6.4",
                details: "This field shall provide a reference to the associated endpoint list, which specifies the endpoints " +
                    "on this Node which will be impacted by this ActionID."
            }),

            Field({
                name: "SupportedCommands", id: 0x4, type: "CommandBits", conformance: "M", constraint: "0 to 4095",
                xref: "core§9.14.4.6.5",
                details: "This field is a bitmap which shall be used to indicate which of the cluster’s commands are supported " +
                    "for this particular action, with a bit set to 1 for each supported command according to the table " +
                    "below. Other bits shall be set to 0."
            }),

            Field({
                name: "State", id: 0x5, type: "ActionStateEnum", conformance: "M", xref: "core§9.14.4.6.6",
                details: "This field shall indicate the current state of this action."
            })
        ),

        Datatype(
            {
                name: "EndpointListStruct", type: "struct", xref: "core§9.14.4.7",
                details: "This data type holds the details of a single endpoint list, which relates to a set of endpoints that " +
                    "have some logical relation, and contains the data fields below."
            },
            Field({
                name: "EndpointListId", id: 0x0, type: "uint16", conformance: "M", xref: "core§9.14.4.7.1",
                details: "This field shall provide an unique identifier used to identify the endpoint list."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "M", constraint: "max 128{32}",
                xref: "core§9.14.4.7.2",
                details: "This field shall indicate the name (as assigned by the user or automatically by the server) " +
                    "associated with the set of endpoints in this list. This can be used for identifying the action to " +
                    "the user by the client. Example: \"living room\"."
            }),

            Field({
                name: "Type", id: 0x2, type: "EndpointListTypeEnum", conformance: "M", xref: "core§9.14.4.7.3",
                details: "This field shall indicate the type of endpoint list, see EndpointListTypeEnum."
            }),

            Field(
                {
                    name: "Endpoints", id: 0x3, type: "list", conformance: "M", constraint: "max 256",
                    xref: "core§9.14.4.7.4",
                    details: "This field shall provide a list of endpoint numbers."
                },
                Field({ name: "entry", type: "endpoint-no" })
            )
        )
    ),

    Cluster(
        {
            name: "IcdManagement", id: 0x46, classification: "node", pics: "ICDM", xref: "core§9.16",
            details: "ICD Management Cluster enables configuration of the ICD’s behavior and ensuring that listed clients " +
                "can be notified when an intermittently connected device, ICD, is available for communication." +
                "\n" +
                "The cluster implements the requirements of the Check-In Protocol that enables the ICD Check-In use " +
                "case."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§9.16.4" },

            Field({
                name: "CIP", conformance: "LITS, O", constraint: "0", title: "CheckInProtocolSupport",
                xref: "core§9.16.4.1",
                details: "When this feature is supported, the device shall support all the associated commands and attributes " +
                    "to properly support the Check-In Protocol."
            }),

            Field({
                name: "UAT", conformance: "LITS, O", constraint: "1", title: "UserActiveModeTrigger",
                xref: "core§9.16.4.2",
                details: "This feature is supported if and only if the device has a user active mode trigger."
            }),
            Field({
                name: "LITS", conformance: "O", constraint: "2", title: "LongIdleTimeSupport",
                xref: "core§9.16.4.3",
                details: "This feature is supported if and only the device is a Long Idle Time ICD."
            }),

            Field({
                name: "DSLS", conformance: "[LITS]", constraint: "3", title: "DynamicSitLitSupport",
                xref: "core§9.16.4.4",
                details: "This feature is supported if and only if the device can switch between SIT and LIT operating modes " +
                    "even if it has a valid registered client. See the dynamic SIT / LIT operating mode switching for " +
                    "more details."
            })
        ),

        Attribute({
            name: "IdleModeDuration", id: 0x0, type: "uint32", access: "R V", conformance: "M",
            constraint: "1 to 64800", default: 1, quality: "F", xref: "core§9.16.6.1",
            details: "Indicates the maximum interval in seconds the server can stay in idle mode. The IdleModeDuration " +
                "shall NOT be smaller than the ActiveModeDuration."
        }),

        Attribute({
            name: "ActiveModeDuration", id: 0x1, type: "uint32", access: "R V", conformance: "M", default: 300,
            quality: "F", xref: "core§9.16.6.2",
            details: "Indicates the minimum interval in milliseconds the server typically will stay in active mode after " +
                "initial transition out of idle mode. The ActiveModeDuration does not include the " +
                "ActiveModeThreshold."
        }),

        Attribute({
            name: "ActiveModeThreshold", id: 0x2, type: "uint16", access: "R V", conformance: "M", default: 300,
            quality: "F", xref: "core§9.16.6.3",
            details: "Indicates the minimum amount of time in milliseconds the server typically will stay active after " +
                "network activity when in active mode."
        }),

        Attribute(
            {
                name: "RegisteredClients", id: 0x3, type: "list", access: "R F A", conformance: "CIP",
                constraint: "desc", default: [], quality: "N", xref: "core§9.16.6.4",
                details: "This attribute shall contain all clients registered to receive notification if their subscription is " +
                    "lost. The maximum number of entries that can be in the list shall be ClientsSupportedPerFabric for " +
                    "each fabric supported on the server, as indicated by the value of the SupportedFabrics attribute in " +
                    "the Operational Credentials cluster."
            },

            Field({ name: "entry", type: "MonitoringRegistrationStruct" })
        ),

        Attribute({
            name: "IcdCounter", id: 0x4, type: "uint32", access: "R A", conformance: "CIP", default: 0,
            quality: "N C", xref: "core§9.16.6.5",
            details: "This attribute returns the value of the ICD Counter."
        }),

        Attribute({
            name: "ClientsSupportedPerFabric", id: 0x5, type: "uint16", access: "R V", conformance: "CIP",
            constraint: "min 1", default: 1, quality: "F", xref: "core§9.16.6.6",
            details: "Indicates the maximum number of entries that the server is able to store for each fabric in the " +
                "RegisteredClients attribute."
        }),

        Attribute({
            name: "UserActiveModeTriggerHint", id: 0x6, type: "UserActiveModeTriggerBitmap", access: "R V",
            conformance: "UAT", constraint: "desc", default: 0, quality: "F", xref: "core§9.16.6.7",

            details: "Indicates which user action(s) will trigger the ICD to switch to Active mode. If the attribute " +
                "indicates support for a trigger that is dependent on the UserActiveModeTriggerInstruction in the " +
                "UserActiveModeTriggerHint table, the UserActiveModeTriggerInstruction attribute shall be implemented " +
                "and shall provide the required information, unless specified otherwise in the requirement column of " +
                "the UserActiveModeTriggerHint table." +
                "\n" +
                "ActuateSensorLightsBlink, ResetButtonLightsBlink and SetupButtonLightsBlink (i.e. bits 7, 9 and 14) " +
                "have a dependency on the UserActiveModeTriggerInstruction attribute but do not require the attribute " +
                "to be present." +
                "\n" +
                "### An ICD can indicate multiple ways of being put into Active Mode by setting multiple bits in the " +
                "bitmap at the same time. However, a device shall NOT set more than one bit which has a dependency on " +
                "the UserActiveModeTriggerInstruction attribute."
        }),

        Attribute({
            name: "UserActiveModeTriggerInstruction", id: 0x7, type: "string", access: "R V",
            conformance: "desc", constraint: "max 128", quality: "F", xref: "core§9.16.6.8",

            details: "The meaning of the attribute is dependent upon the UserActiveModeTriggerHint attribute value, and " +
                "the conformance is in indicated in the \"dependency\" column in UserActiveModeTriggerHint table. The " +
                "UserActiveModeTriggerInstruction attribute may give additional information on how to transition the " +
                "device to Active Mode. If the attribute is present, the value shall be encoded as a valid UTF-8 " +
                "string with a maximum length of 128 bytes. If the UserActiveModeTriggerHint has the " +
                "ActuateSensorSeconds, ActuateSensorTimes, ResetButtonSeconds, ResetButtonTimes, SetupButtonSeconds " +
                "or SetupButtonTimes set, the string shall consist solely of an encoding of N as a decimal unsigned " +
                "integer using the ASCII digits 0-9, and without leading zeros." +
                "\n" +
                "For example, given UserActiveModeTriggerHint=\"1024\", ResetButtonSeconds is set which indicates " +
                "\"Press Reset Button for N seconds\". Therefore, a value of UserActiveModeTriggerInstruction=\"6\" would " +
                "indicate that N is 6 in that context." +
                "\n" +
                "When CustomInstruction is set by the UserActiveModeTriggerHint attribute, indicating presence of a " +
                "custom string, the ICD SHOULD perform localization (translation to user’s preferred language, as " +
                "indicated in the Device’s currently configured locale). The Custom Instruction option SHOULD NOT be " +
                "used by an ICD that does not have knowledge of the user’s language preference." +
                "\n" +
                "When the UserActiveModeTriggerHint key indicates a light to blink (ActuateSensorLightsBlink, " +
                "ResetButtonLightsBlink or SetupButtonLightsBlink), information on color of light may be made " +
                "available via the UserActiveModeTriggerInstruction attribute. When using such color indication in " +
                "the UserActiveModeTriggerInstruction attribute, the string shall consist of exactly 6 hexadecimal " +
                "digits using the ASCII characters 0-F and encoding the RGB color value as used in HTML encodings."
        }),

        Attribute({
            name: "OperatingMode", id: 0x8, type: "OperatingModeEnum", access: "R V", conformance: "LITS",
            xref: "core§9.16.6.9",
            details: "Indicates the operating mode of the ICD as specified in the OperatingModeEnum." +
                "\n" +
                "  • If the ICD is operating as a LIT ICD, OperatingMode shall be LIT." +
                "\n" +
                "  • If the ICD is operating as a SIT ICD, OperatingMode shall be SIT."
        }),

        Attribute({
            name: "MaximumCheckInBackoff", id: 0x9, type: "uint32", access: "R V", conformance: "CIP",
            constraint: "idleModeDuration to 64800", default: 1, quality: "F", xref: "core§9.16.6.10",
            details: "Indicates the maximum time in seconds between two Check-In messages when back-off is active. The " +
                "MaximumCheckInBackoff shall NOT be smaller than the IdleModeDuration." +
                "\n" +
                "If the MaximumCheckInBackoff is equal to the IdleModeDuration, it means the ICD does not back-off."
        }),

        Command(
            {
                name: "RegisterClient", id: 0x0, access: "F M", conformance: "CIP", direction: "request",
                response: "RegisterClientResponse", xref: "core§9.16.7.1",
                details: "This command allows a client to register itself with the ICD to be notified when the device is " +
                    "available for communication."
            },

            Field({
                name: "CheckInNodeId", id: 0x0, type: "node-id", conformance: "M", xref: "core§9.16.7.1.1",
                details: "This field shall provide the node ID to which a Check-In message will be sent if there are no active " +
                    "subscriptions matching MonitoredSubject."
            }),
            Field({
                name: "MonitoredSubject", id: 0x1, type: "subject-id", conformance: "M", xref: "core§9.16.7.1.2",
                details: "This field shall provide the monitored subject ID."
            }),
            Field({
                name: "Key", id: 0x2, type: "octstr", conformance: "M", constraint: "16", xref: "core§9.16.7.1.3",
                details: "This field shall contain the ICDToken, a 128-bit symmetric key shared by the ICD and the ICD Client, " +
                    "used to encrypt Check-In messages from this ICD to the MonitoredSubject."
            }),

            Field({
                name: "VerificationKey", id: 0x3, type: "octstr", conformance: "O", constraint: "16",
                xref: "core§9.16.7.1.4",

                details: "This field shall provide the verification key. The verification key represents the key already " +
                    "stored on the server. The verification key provided in this field shall be used by the server to " +
                    "guarantee that a client with manage permissions can only modify entries that contain a Key equal to " +
                    "the verification key. The verification key shall be provided for clients with manage permissions. " +
                    "The verification key SHOULD NOT be provided by clients with administrator permissions for the server " +
                    "cluster. The verification key shall be ignored by the server if it is provided by a client with " +
                    "administrator permissions for the server cluster."
            }),

            Field({
                name: "ClientType", id: 0x4, type: "ClientTypeEnum", conformance: "M", xref: "core§9.16.7.1.5",

                details: "This field shall provide the client type of the client registering." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "On receipt of the RegisterClient command, the server shall perform the following procedure:" +
                    "\n" +
                    "  1. The server verifies that an entry for the fabric is available in the server’s list of " +
                    "     registered clients." +
                    "\n" +
                    "    a. If one of the entries in storage for the fabric has the same CheckInNodeID as the received " +
                    "       CheckInNodeID, the server shall continue from step 2." +
                    "\n" +
                    "    b. If there is an available entry for the fabric, an entry is created for the fabric and the " +
                    "       received CheckInNodeID, MonitoredSubject, Key and ClientType are stored. The server shall " +
                    "       continue from step 5." +
                    "\n" +
                    "    c. If there are no available entries for the fabric, the status shall be RESOURCE_EXHAUSTED and " +
                    "       the server shall continue from step 6." +
                    "\n" +
                    "  2. The server shall verify the privileges of the command’s ISD." +
                    "\n" +
                    "    a. If the ISD of the command has administrator privileges for the server cluster, the server " +
                    "       shall continue from step 4." +
                    "\n" +
                    "    b. If the ISD of the command does not have administrator privileges for the server cluster, the " +
                    "       server shall continue from step 3." +
                    "\n" +
                    "  3. The server shall verify that the received verification key is equal to the key previously " +
                    "     stored in the list of registered clients with the matching CheckInNodeID." +
                    "\n" +
                    "    a. If the verification key does not have a valid value, the status shall be FAILURE. the server " +
                    "       shall continue from step 6." +
                    "\n" +
                    "    b. If the verification key is not equal to the Key value stored in the entry, the status shall " +
                    "       be FAILURE. The server shall continue from step 6." +
                    "\n" +
                    "    c. If the verification key is equal to the Key value stored in the entry, the server shall " +
                    "       continue from step 4." +
                    "\n" +
                    "  4. The entry shall be updated with the received CheckInNodeID, MonitoredSubject, Key and " +
                    "     ClientType." +
                    "\n" +
                    "    a. If the update fails, the status shall be FAILURE. The server shall continue from step 6." +
                    "\n" +
                    "    b. If the update succeeds, the server shall continue from step 5." +
                    "\n" +
                    "  5. The server shall persist the client information." +
                    "\n" +
                    "    a. If the persistence fails, the status shall be FAILURE and the server shall continue from step " +
                    "       6." +
                    "\n" +
                    "    b. If the persistence succeeds, the status shall be SUCCESS and the server shall continue from " +
                    "       step 6." +
                    "\n" +
                    "  6. The server shall generate a response." +
                    "\n" +
                    "    a. If the status is SUCCESS, the server shall generate a RegisterClientResponse command." +
                    "\n" +
                    "    b. If the status is not SUCCESS, the server shall generate a default response with the Status " +
                    "       field set to the evaluated error status."
            })
        ),

        Command(
            {
                name: "RegisterClientResponse", id: 0x1, conformance: "CIP", direction: "response",
                xref: "core§9.16.7.2",

                details: "This command shall be sent by the ICD Management Cluster server in response to a successful " +
                    "RegisterClient command." +
                    "\n" +
                    "### When Generated" +
                    "\n" +
                    "This command shall be generated in response to a successful RegisterClient command. The ICDCounter " +
                    "field shall be set to the ICDCounter attribute of the server."
            },

            Field({ name: "IcdCounter", id: 0x0, type: "uint32", conformance: "M" })
        ),

        Command(
            {
                name: "UnregisterClient", id: 0x2, access: "F M", conformance: "CIP", direction: "request",
                response: "status", xref: "core§9.16.7.3",
                details: "This command allows a client to unregister itself with the ICD. Example: a client that is leaving " +
                    "the network (e.g. running on a phone which is leaving the home) can (and should) remove its " +
                    "subscriptions and send this UnregisterClient command before leaving to prevent the burden on the ICD " +
                    "of an absent client."
            },

            Field({
                name: "CheckInNodeId", id: 0x0, type: "node-id", conformance: "M", xref: "core§9.16.7.3.1",
                details: "This field shall provide the registered client node ID to remove from storage."
            }),

            Field({
                name: "VerificationKey", id: 0x1, type: "octstr", conformance: "O", constraint: "16",
                xref: "core§9.16.7.3.2",

                details: "This field shall provide the verification key associated with the CheckInNodeID to remove from " +
                    "storage. The verification key represents the key already stored on the server. The verification key " +
                    "provided in this field shall be used by the server to guarantee that a client with manage " +
                    "permissions can only remove entries that contain a Key equal to the stored key. The verification key " +
                    "shall be provided for clients with manage permissions. The verification key SHOULD NOT be provided " +
                    "by clients with administrator permissions for the server cluster. The verification key shall be " +
                    "ignored by the server if it is provided by a client with administrator permissions for the server " +
                    "cluster." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "On receipt of the UnregisterClient command, the server shall perform the following procedure:" +
                    "\n" +
                    "  1. The server shall check whether there is a entry stored on the device for the fabric with the " +
                    "     same CheckInNodeID." +
                    "\n" +
                    "    a. If there are no entries stored for the fabric, the status shall be NOT_FOUND. The server " +
                    "       shall continue from step 6." +
                    "\n" +
                    "    b. If there is an error when reading from storage, the status shall be FAILURE. The server shall " +
                    "       continue from step 6." +
                    "\n" +
                    "    c. If there is at least one entry stored on the server for the fabric, the server shall continue " +
                    "       from step 2." +
                    "\n" +
                    "  2. The server shall verify if one of the entries for the fabric has the corresponding " +
                    "     CheckInNodeID received in the command." +
                    "\n" +
                    "    a. If no entries have the corresponding CheckInNodeID, the status shall be NOT_FOUND. The server " +
                    "       shall continue from step 6." +
                    "\n" +
                    "    b. If an entry has the corresponding CheckInNodeID, the server shall continue to step 3." +
                    "\n" +
                    "  3. The server shall check whether the ISD of the command has administrator permissions for the " +
                    "     server cluster." +
                    "\n" +
                    "    a. If the ISD of the command has administrator privileges for the server cluster, the server " +
                    "       shall continue from step 5." +
                    "\n" +
                    "    b. If the ISD of the command does not have administrator privileges for the server cluster, the " +
                    "       server shall continue from step 4." +
                    "\n" +
                    "  4. The server shall verify that the received verification key is equal to the key previously " +
                    "     stored in the list of registered clients with the matching CheckInNodeID." +
                    "\n" +
                    "    a. If the verification key does not have a valid value, the status shall be FAILURE. the server " +
                    "       shall continue from step 6." +
                    "\n" +
                    "    b. If the verification key is not equal to the Key value stored in the entry, the status shall " +
                    "       be FAILURE. The server shall continue from step 6." +
                    "\n" +
                    "    c. If the verification key is equal to the Key value stored in the entry, the server shall " +
                    "       continue from step 5." +
                    "\n" +
                    "  5. The server shall delete the entry with the matching CheckInNodeID from storage and will persist " +
                    "     the change." +
                    "\n" +
                    "    a. If the removal of the entry fails, the status shall be FAILURE. The server shall continue " +
                    "       from step 6." +
                    "\n" +
                    "    b. If the removal succeeds, the status shall be SUCCESS and the server shall continue to step 6." +
                    "\n" +
                    "  6. The server shall generate a response with the Status field set to the evaluated status."
            })
        ),

        Command(
            {
                name: "StayActiveRequest", id: 0x3, access: "O", conformance: "LITS, O", direction: "request",
                response: "StayActiveResponse", xref: "core§9.16.7.4",

                details: "This command allows a client to request that the server stays in active mode for at least a given " +
                    "time duration (in milliseconds) from when this command is received." +
                    "\n" +
                    "This StayActiveDuration may be longer than the ActiveModeThreshold value and would, typically, be " +
                    "used by the client to request the server to stay active and responsive for this period to allow a " +
                    "sequence of message exchanges during that period. The client may slightly overestimate the duration " +
                    "it wants the ICD to be active for, in order to account for network delays." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "When receiving a StayActiveRequest command, the server shall calculate the maximum " +
                    "PromisedActiveDuration it can remain active as the greater of the following two values:" +
                    "\n" +
                    "  • StayActiveDuration: Specified in the received command by the client." +
                    "\n" +
                    "  • Remaining Active Time: The server’s planned remaining active time based on the " +
                    "    ActiveModeThreshold and its internal resources and power budget." +
                    "\n" +
                    "A server may replace StayActiveDuration with Minimum Active Duration in the above calculation." +
                    "\n" +
                    "PromisedActiveDuration represents the guaranteed minimum time the server will remain active, taking " +
                    "into account both the requested duration and the server’s capabilities." +
                    "\n" +
                    "The ICD shall report the calculated PromisedActiveDuration in a StayActiveResponse message back to " +
                    "the client."
            },

            Field({ name: "StayActiveDuration", id: 0x0, type: "uint32", conformance: "M" })
        ),

        Command(
            {
                name: "StayActiveResponse", id: 0x4, conformance: "LITS, O", direction: "response",
                xref: "core§9.16.7.5",
                details: "This message shall be sent by the ICD in response to the StayActiveRequest command and shall contain " +
                    "the computed duration (in milliseconds) that the ICD intends to stay active for."
            },

            Field({
                name: "PromisedActiveDuration", id: 0x0, type: "uint32", conformance: "M", constraint: "desc",
                xref: "core§9.16.7.5.1",

                details: "This field shall provide the actual duration that the ICD server can stay active from the time it " +
                    "receives the StayActiveRequest command." +
                    "\n" +
                    "### Minimum Value for PromisedActiveDuration" +
                    "\n" +
                    "The minimum value of the PromisedActiveDuration field shall be equal to either 30000 milliseconds or " +
                    "StayActiveDuration (from the received StayActiveRequest command), whichever is smaller."
            })
        ),

        Datatype(
            {
                name: "UserActiveModeTriggerBitmap", type: "map32", xref: "core§9.16.5.1",
                details: "See the UserActiveModeTriggerHint table for requirements associated to each bit."
            },
            Field({ name: "PowerCycle", constraint: "0", description: "Power Cycle to transition the device to ActiveMode" }),
            Field({
                name: "SettingsMenu", constraint: "1",
                description: "Settings menu on the device informs how to transition the device to ActiveMode"
            }),
            Field({
                name: "CustomInstruction", constraint: "2",
                description: "Custom Instruction on how to transition the device to ActiveMode"
            }),
            Field({
                name: "DeviceManual", constraint: "3",
                description: "Device Manual informs how to transition the device to ActiveMode"
            }),
            Field({
                name: "ActuateSensor", constraint: "4",
                description: "Actuate Sensor to transition the device to ActiveMode"
            }),
            Field({
                name: "ActuateSensorSeconds", constraint: "5",
                description: "Actuate Sensor for N seconds to transition the device to ActiveMode"
            }),
            Field({
                name: "ActuateSensorTimes", constraint: "6",
                description: "Actuate Sensor N times to transition the device to ActiveMode"
            }),
            Field({
                name: "ActuateSensorLightsBlink", constraint: "7",
                description: "Actuate Sensor until light blinks to transition the device to ActiveMode"
            }),
            Field({
                name: "ResetButton", constraint: "8",
                description: "Press Reset Button to transition the device to ActiveMode"
            }),
            Field({
                name: "ResetButtonLightsBlink", constraint: "9",
                description: "Press Reset Button until light blinks to transition the device to ActiveMode"
            }),
            Field({
                name: "ResetButtonSeconds", constraint: "10",
                description: "Press Reset Button for N seconds to transition the device to ActiveMode"
            }),
            Field({
                name: "ResetButtonTimes", constraint: "11",
                description: "Press Reset Button N times to transition the device to ActiveMode"
            }),
            Field({
                name: "SetupButton", constraint: "12",
                description: "Press Setup Button to transition the device to ActiveMode"
            }),
            Field({
                name: "SetupButtonSeconds", constraint: "13",
                description: "Press Setup Button for N seconds to transition the device to ActiveMode"
            }),
            Field({
                name: "SetupButtonLightsBlink", constraint: "14",
                description: "Press Setup Button until light blinks to transition the device to ActiveMode"
            }),
            Field({
                name: "SetupButtonTimes", constraint: "15",
                description: "Press Setup Button N times to transition the device to ActiveMode"
            }),
            Field({
                name: "AppDefinedButton", constraint: "16",
                description: "Press the N Button to transition the device to ActiveMode"
            })
        ),

        Datatype(
            { name: "ClientTypeEnum", type: "enum8", xref: "core§9.16.5.1.1" },
            Field({
                name: "Permanent", id: 0x0, conformance: "M",
                description: "The client is typically resident, always-on, fixed infrastructure in the home."
            }),
            Field({
                name: "Ephemeral", id: 0x1, conformance: "M",
                description: "The client is mobile or non-resident or not always-on and may not always be available in the home."
            })
        ),

        Datatype(
            { name: "OperatingModeEnum", type: "enum8", xref: "core§9.16.5.2" },
            Field({ name: "Sit", id: 0x0, conformance: "M", description: "ICD is operating as a Short Idle Time ICD." }),
            Field({ name: "Lit", id: 0x1, conformance: "M", description: "ICD is operating as a Long Idle Time ICD." })
        ),

        Datatype(
            { name: "MonitoringRegistrationStruct", type: "struct", xref: "core§9.16.5.3" },

            Field({
                name: "CheckInNodeId", id: 0x1, type: "node-id", access: "S", conformance: "M", quality: "N",
                xref: "core§9.16.5.3.1",
                details: "This field shall indicate the NodeID of the Node to which Check-In messages will be sent when the " +
                    "MonitoredSubject is not subscribed."
            }),

            Field({
                name: "MonitoredSubject", id: 0x2, type: "subject-id", access: "S", conformance: "M", quality: "N",
                xref: "core§9.16.5.3.2",

                details: "This field shall indicate the monitored Subject ID. This field shall be used to determine if a " +
                    "particular client has an active subscription for the given entry. The MonitoredSubject, when it is a " +
                    "NodeID, may be the same as the CheckInNodeID. The MonitoredSubject gives the registering client the " +
                    "flexibility of having a different CheckInNodeID from the MonitoredSubject. A subscription shall " +
                    "count as an active subscription for this entry if:" +
                    "\n" +
                    "  • It is on the associated fabric of this entry, and" +
                    "\n" +
                    "  • The subject of this entry matches the ISD of the SubscriptionRequest message that created the " +
                    "    subscription. Matching shall be determined using the subject_matches function defined in the " +
                    "    Access Control Privilege Granting Algorithm." +
                    "\n" +
                    "For example, if the MonitoredSubject is Node ID 0x1111_2222_3333_AAAA, and one of the subscribers to " +
                    "the server on the entry’s associated fabric bears that Node ID, then the entry matches." +
                    "\n" +
                    "Another example is if the MonitoredSubject has the value 0xFFFF_FFFD_AA12_0002, and one of the " +
                    "subscribers to the server on the entry’s associated fabric bears the CASE Authenticated TAG value " +
                    "0xAA12 and the version 0x0002 or higher within its NOC, then the entry matches."
            }),

            Field({
                name: "Key", id: 0x3, access: "F", conformance: "D", xref: "core§9.16.5.3.3",
                details: "This field is deprecated. Use the RegisterClient command to set the ICDToken."
            }),

            Field({
                name: "ClientType", id: 0x4, type: "ClientTypeEnum", access: "S", conformance: "M", default: 0,
                quality: "N", xref: "core§9.16.5.3.4",
                details: "This field shall indicate the client’s type to inform the ICD of the availability for communication " +
                    "of the client."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Cluster(
        {
            name: "EcosystemInformation", id: 0x750, classification: "endpoint", pics: "ECOINFO",
            xref: "core§9.17",

            details: "The Ecosystem Information Cluster provides extended device information for all the logical devices " +
                "represented by a Bridged Node. The Ecosystem Information Cluster presents the view of device name " +
                "and location metadata for presentation by a client of the cluster to a user. This cluster is " +
                "intended to support Fabric Synchronization and be present on an endpoint with the BridgedNode device " +
                "type listed in the DeviceTypeList of the endpoint’s Descriptor cluster." +
                "\n" +
                "This augments the Bridged Device Basic Information Cluster in the following ways:" +
                "\n" +
                "  • The Ecosystem Information Cluster adds support for providing a name and location for individual " +
                "    endpoints. (The endpoints do not need to be present on the Bridge for their name and location " +
                "    information to be present.)" +
                "\n" +
                "  • The Ecosystem Information Cluster adds metadata to support conflict resolution between multiple " +
                "    sources of the name and location data." +
                "\n" +
                "  • The Ecosystem Information Cluster supports user control for the presence of the name and " +
                "    location information by specifying more restricted access." +
                "\n" +
                "A client SHOULD use the information provided by the Ecosystem Information Cluster to help the user " +
                "organize and interact with their devices. Some examples may include:" +
                "\n" +
                "  • Directly organizing and labeling the devices in a client’s user interface." +
                "\n" +
                "  • Providing hints in the user interface, which can assist the user in organizing and labeling " +
                "    their devices." +
                "\n" +
                "For the purposes of the Ecosystem Information Cluster section, an instance of the Ecosystem " +
                "Information Cluster will be referred to as an \"instance\"."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "DeviceDirectory", id: 0x0, type: "list", access: "R F M", conformance: "M", quality: "N",
                xref: "core§9.17.5.1",
                details: "This attribute shall contain the list of logical devices represented by a Bridged Node. Most of the " +
                    "time this will contain a single entry, but may grow with more complex device compositions (e.g. " +
                    "another bridge.) An empty list indicates that the information is not available."
            },

            Field({ name: "entry", type: "EcosystemDeviceStruct" })
        ),

        Attribute(
            {
                name: "LocationDirectory", id: 0x1, type: "list", access: "R F M", conformance: "M", quality: "N",
                xref: "core§9.17.5.2",

                details: "This attribute shall contain the list of rooms, areas and groups associated with the DeviceDirectory " +
                    "entries, and shall NOT contain locations which are dynamically generated and removed by an " +
                    "ecosystem. (E.g. a location that is generated and removed based on the user being home is not " +
                    "permitted. However, an initially generated location name that does not quickly change is " +
                    "acceptable.) An empty list indicates that the information is not available." +
                    "\n" +
                    "LocationDirectory entries shall be removed if there is no DeviceDirectory that references it."
            },

            Field({ name: "entry", type: "EcosystemLocationStruct" })
        ),

        Datatype(
            {
                name: "DeviceTypeStruct", type: "struct", xref: "core§9.17.4.1",
                details: "The device type and revision define endpoint conformance to a release of a device type definition. " +
                    "See the Data Model specification for more information."
            },
            Field({
                name: "DeviceType", id: 0x0, type: "devtype-id", conformance: "M", xref: "core§9.17.4.1.1",
                details: "This shall indicate the device type definition."
            }),
            Field({
                name: "Revision", id: 0x1, type: "uint16", conformance: "M", constraint: "min 1",
                xref: "core§9.17.4.1.2",
                details: "This is the implemented revision of the device type definition."
            })
        ),

        Datatype(
            { name: "EcosystemDeviceStruct", type: "struct", xref: "core§9.17.4.2" },

            Field({
                name: "DeviceName", id: 0x0, type: "string", access: "S", conformance: "O", constraint: "max 64",
                xref: "core§9.17.4.2.1",
                details: "This field shall indicate the device’s name, which is provided externally if the user consents. (For " +
                    "example, provided by the user in an ecosystem specific interface.)"
            }),

            Field({
                name: "DeviceNameLastEdit", id: 0x1, type: "epoch-us", access: "S", conformance: "DeviceName",
                default: 0, xref: "core§9.17.4.2.2",
                details: "This field shall indicate the timestamp of when the DeviceName was last modified."
            }),

            Field({
                name: "BridgedEndpoint", id: 0x2, type: "endpoint-no", access: "S", conformance: "desc",
                constraint: "desc", xref: "core§9.17.4.2.3",
                details: "This field shall indicate the endpoint this EcosystemDeviceStruct is associated with on this Bridge." +
                    "\n" +
                    "This field shall be present and set to a valid endpoint if the device is accessible through the " +
                    "bridge."
            }),

            Field({
                name: "OriginalEndpoint", id: 0x3, type: "endpoint-no", access: "S", conformance: "desc",
                constraint: "desc", xref: "core§9.17.4.2.4",
                details: "This field shall indicate the endpoint this EcosystemDeviceStruct is associated with on the original " +
                    "device represented by this bridge’s Bridged Node. If this bridge is receiving the device from " +
                    "another bridge, then the OriginalEndpoint field value would be the same on both bridges. This field " +
                    "shall be present and set to a valid endpoint on the original device if that device is a Matter " +
                    "device."
            }),

            Field(
                {
                    name: "DeviceTypes", id: 0x4, type: "list", access: "S", conformance: "M", constraint: "desc",
                    xref: "core§9.17.4.2.5",
                    details: "This field shall indicate all of the DeviceTypes within the DeviceTypeList in the Descriptor Cluster " +
                        "associated with this EcosystemDeviceStruct entry." +
                        "\n" +
                        "This field shall contain a list of valid device type ids."
                },

                Field({ name: "entry", type: "DeviceTypeStruct" })
            ),

            Field(
                {
                    name: "UniqueLocationIDs", id: 0x5, type: "list", access: "S", conformance: "M",
                    constraint: "max 64[max 64]", xref: "core§9.17.4.2.6",
                    details: "This field shall specify the EcosystemLocationStruct entries in the LocationDirectory attribute " +
                        "associated with this EcosystemDeviceStruct."
                },

                Field({ name: "entry", type: "string" })
            ),

            Field({
                name: "UniqueLocationIDsLastEdit", id: 0x6, type: "epoch-us", access: "S", conformance: "M",
                default: 0, xref: "core§9.17.4.2.7",

                details: "This field shall indicate the timestamp of when the UniqueLocationIDs was last modified." +
                    "\n" +
                    "NOTE If multiple server instances update the UniqueLocationIDs field at the same time, it is " +
                    "possible one of the updates will be missed. This is considered an acceptable limitation to reduce " +
                    "the complexity of the design. Since this is meant to be provided from user input, it is unlikely " +
                    "these signals would be happening at one time."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            { name: "EcosystemLocationStruct", type: "struct", xref: "core§9.17.4.3" },

            Field({
                name: "UniqueLocationId", id: 0x0, type: "string", access: "S", conformance: "M",
                constraint: "max 64", xref: "core§9.17.4.3.1",

                details: "This field shall indicate a unique identifier for a specific Ecosystem Information Cluster server " +
                    "instance representing the location independent of its LocationDescriptor field." +
                    "\n" +
                    "UniqueLocationID can be used by the client to determine if the change is a relocation of the device " +
                    "or just a renaming of the location." +
                    "\n" +
                    "No guarantees are given for consistency of the ID between server instances. The same location may be " +
                    "represented by different IDs on different Ecosystem Information Cluster server instances, so only " +
                    "the history from a single server instance should be considered when evaluating a change." +
                    "\n" +
                    "UniqueLocationID shall be changed when the LocationDescriptor changes from one existing location to " +
                    "another location as a result of an external interaction. (For example, the user changes the location " +
                    "assignment.)" +
                    "\n" +
                    "UniqueLocationID shall NOT be changed when the LocationDescriptor changes name, but still represents " +
                    "the same location. (For example, the user renames a room.) UniqueLocationID shall be changed when " +
                    "LocationDescriptor changes as a result of another Ecosystem Information Cluster server instance " +
                    "changing and the UniqueLocationID on the remote server instance also changes." +
                    "\n" +
                    "UniqueLocationID shall NOT be changed when LocationDescriptor changes as a result of another " +
                    "Ecosystem Information Cluster server instance changing and the UniqueLocationID on the remote server " +
                    "instance does not change."
            }),

            Field({
                name: "LocationDescriptor", id: 0x1, type: "locationdesc", access: "S", conformance: "M",
                xref: "core§9.17.4.3.2",

                details: "This field shall indicate the location (e.g. living room, driveway) and associated metadata that is" +
                    "\n" +
                    "provided externally if the user consents. (For example, provided by the user in an ecosystem " +
                    "specific interface.)" +
                    "\n" +
                    "\"Location\" in this context is typically used by the user’s grouping into rooms, areas or other " +
                    "logical groupings of how devices are used. So a device might be part of multiple such \"Locations\"s."
            }),

            Field({
                name: "LocationDescriptorLastEdit", id: 0x2, type: "epoch-us", access: "S", conformance: "M",
                default: 0, xref: "core§9.17.4.3.3",
                details: "This field shall indicate the timestamp of when the LocationDescriptor was last modified."
            }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Cluster(
        {
            name: "BasicInformation", id: 0x28, classification: "node", pics: "BINFO", xref: "core§11.1",
            details: "This cluster provides attributes and events for determining basic information about Nodes, which " +
                "supports both Commissioning and operational determination of Node characteristics, such as Vendor " +
                "ID, Product ID and serial number, which apply to the whole Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 5 }),

        Attribute({
            name: "DataModelRevision", id: 0x0, type: "uint16", access: "R V", conformance: "M",
            constraint: "desc", quality: "F", xref: "core§11.1.5.1",
            details: "This attribute shall be set to the revision number of the Data Model against which the Node is " +
                "certified. The value of this attribute shall be one of the valid values listed in Section 7.1.1, " +
                "“Revision History”."
        }),

        Attribute({
            name: "VendorName", id: 0x1, type: "string", access: "R V", conformance: "M", constraint: "max 32",
            quality: "F", xref: "core§11.1.5.2",
            details: "This attribute shall specify a human readable (displayable) name of the vendor for the Node."
        }),
        Attribute({
            name: "VendorId", id: 0x2, type: "vendor-id", access: "R V", conformance: "M", quality: "F",
            xref: "core§11.1.5.3",
            details: "This attribute shall specify the Vendor ID."
        }),

        Attribute({
            name: "ProductName", id: 0x3, type: "string", access: "R V", conformance: "M", constraint: "max 32",
            quality: "F", xref: "core§11.1.5.4",
            details: "This attribute shall specify a human readable (displayable) name of the model for the Node such as " +
                "the model number (or other identifier) assigned by the vendor."
        }),

        Attribute({
            name: "ProductId", id: 0x4, type: "uint16", access: "R V", conformance: "M", quality: "F",
            xref: "core§11.1.5.5",
            details: "This attribute shall specify the Product ID assigned by the vendor that is unique to the specific " +
                "product of the Node."
        }),

        Attribute({
            name: "NodeLabel", id: 0x5, type: "string", access: "RW VM", conformance: "M", constraint: "max 32",
            quality: "N", xref: "core§11.1.5.6",
            details: "Indicates a user defined name for the Node. This attribute SHOULD be set during initial " +
                "commissioning and may be updated by further reconfigurations."
        }),

        Attribute({
            name: "Location", id: 0x6, type: "string", access: "RW VA", conformance: "M", constraint: "2",
            default: "XX", quality: "N", xref: "core§11.1.5.7",

            details: "This attribute shall be an ISO 3166-1 alpha-2 code to represent the country, dependent territory, or " +
                "special area of geographic interest in which the Node is located at the time of the attribute being " +
                "set. This attribute shall be set during initial commissioning (unless already set) and may be " +
                "updated by further reconfigurations. This attribute may affect some regulatory aspects of the Node’s " +
                "operation, such as radio transmission power levels in given spectrum allocation bands if " +
                "technologies where this is applicable are used. The Location’s region code shall be interpreted in a " +
                "case-insensitive manner. If the Node cannot understand the location code with which it was " +
                "configured, or the location code has not yet been configured, it shall configure itself in a " +
                "region-agnostic manner as determined by the vendor, avoiding region-specific assumptions as much as " +
                "is practical. The special value XX shall indicate that region-agnostic mode is used."
        }),

        Attribute({
            name: "HardwareVersion", id: 0x7, type: "uint16", access: "R V", conformance: "M", default: 0,
            quality: "F", xref: "core§11.1.5.8",
            details: "This attribute shall specify the version number of the hardware of the Node. The meaning of its " +
                "value, and the versioning scheme, are vendor defined."
        }),

        Attribute({
            name: "HardwareVersionString", id: 0x8, type: "string", access: "R V", conformance: "M",
            constraint: "1 to 64", quality: "F", xref: "core§11.1.5.9",
            details: "This attribute shall specify the version number of the hardware of the Node. The meaning of its " +
                "value, and the versioning scheme, are vendor defined. The HardwareVersionString attribute shall be " +
                "used to provide a more user-friendly value than that represented by the HardwareVersion attribute."
        }),

        Attribute({
            name: "SoftwareVersion", id: 0x9, type: "uint32", access: "R V", conformance: "M",
            constraint: "desc", default: 0, quality: "F", xref: "core§11.1.5.10",
            details: "This attribute shall contain the current version number for the software running on this Node. A " +
                "larger value of SoftwareVersion is newer than a lower value, from the perspective of software " +
                "updates (see Section 11.20.3.3, “Availability of Software Images”). Nodes may query this field to " +
                "determine the currently running version of software on another given Node."
        }),

        Attribute({
            name: "SoftwareVersionString", id: 0xa, type: "string", access: "R V", conformance: "M",
            constraint: "1 to 64", quality: "F", xref: "core§11.1.5.11",

            details: "This attribute shall contain a current human-readable representation for the software running on the " +
                "Node. This version information may be conveyed to users. The maximum length of the " +
                "SoftwareVersionString attribute is 64 bytes of UTF-8 characters. The contents SHOULD only use simple " +
                "7-bit ASCII alphanumeric and punctuation characters, so as to simplify the conveyance of the value " +
                "to a variety of cultures." +
                "\n" +
                "Examples of version strings include \"1.0\", \"1.2.3456\", \"1.2-2\", \"1.0b123\", \"1.2_3\"."
        }),

        Attribute({
            name: "ManufacturingDate", id: 0xb, type: "string", access: "R V", conformance: "O",
            constraint: "8 to 16", quality: "F", xref: "core§11.1.5.12",
            details: "This attribute shall specify the date that the Node was manufactured. The first 8 characters shall " +
                "specify the date of manufacture of the Node in international date notation according to ISO 8601, " +
                "i.e., YYYYMMDD, e.g., 20060814. The final 8 characters may include country, factory, line, shift or " +
                "other related information at the option of the vendor. The format of this information is vendor " +
                "defined."
        }),

        Attribute({
            name: "PartNumber", id: 0xc, type: "string", access: "R V", conformance: "O", constraint: "max 32",
            quality: "F", xref: "core§11.1.5.13",

            details: "This attribute shall specify a human-readable (displayable) vendor assigned part number for the Node " +
                "whose meaning and numbering scheme is vendor defined." +
                "\n" +
                "Multiple products (and hence PartNumbers) can share a ProductID. For instance, there may be " +
                "different packaging (with different PartNumbers) for different regions; also different colors of a " +
                "product might share the ProductID but may have a different PartNumber."
        }),

        Attribute({
            name: "ProductUrl", id: 0xd, type: "string", access: "R V", conformance: "O", constraint: "max 256",
            quality: "F", xref: "core§11.1.5.14",
            details: "This attribute shall specify a link to a product specific web page. The specified URL SHOULD resolve " +
                "to a maintained web page available for the lifetime of the product. The syntax of this attribute " +
                "shall follow the syntax as specified in RFC 1738 and shall use the https scheme. The maximum length " +
                "of this attribute is 256 ASCII characters."
        }),

        Attribute({
            name: "ProductLabel", id: 0xe, type: "string", access: "R V", conformance: "O",
            constraint: "max 64", quality: "F", xref: "core§11.1.5.15",
            details: "This attribute shall specify a vendor specific human readable (displayable) product label. The " +
                "ProductLabel attribute may be used to provide a more user-friendly value than that represented by " +
                "the ProductName attribute. The ProductLabel attribute SHOULD NOT include the name of the vendor as " +
                "defined within the VendorName attribute."
        }),

        Attribute({
            name: "SerialNumber", id: 0xf, type: "string", access: "R V", conformance: "O",
            constraint: "max 32", quality: "F", xref: "core§11.1.5.16",
            details: "This attribute shall specify a human readable (displayable) serial number."
        }),

        Attribute({
            name: "LocalConfigDisabled", id: 0x10, type: "bool", access: "RW VM", conformance: "O",
            default: false, quality: "N", xref: "core§11.1.5.17",
            details: "This attribute shall allow a local Node configuration to be disabled. When this attribute is set to " +
                "True the Node shall disable the ability to configure the Node through an on-Node user interface. The " +
                "value of the LocalConfigDisabled attribute shall NOT in any way modify, disable, or otherwise affect " +
                "the user’s ability to trigger a factory reset on the Node."
        }),

        Attribute({
            name: "Reachable", id: 0x11, type: "bool", access: "R V", conformance: "O", default: true,
            xref: "core§11.1.5.18",
            details: "This attribute (when used) shall indicate whether the Node can be reached. For a native Node this is " +
                "implicitly True (and its use is optional)." +
                "\n" +
                "Its main use case is in the derived Bridged Device Basic Information cluster where it is used to " +
                "indicate whether the bridged device is reachable by the bridge over the non-native network."
        }),

        Attribute({
            name: "UniqueId", id: 0x12, type: "string", access: "R V", conformance: "M", constraint: "max 32",
            quality: "F", xref: "core§11.1.5.19",

            details: "Indicates a unique identifier for the device, which is constructed in a manufacturer specific " +
                "manner." +
                "\n" +
                "It may be constructed using a permanent device identifier (such as device MAC address) as basis. In " +
                "order to prevent tracking," +
                "\n" +
                "  • it SHOULD NOT be identical to (or easily derived from) such permanent device identifier" +
                "\n" +
                "  • it shall be updated when the device is factory reset" +
                "\n" +
                "  • it shall NOT be identical to the SerialNumber attribute" +
                "\n" +
                "  • it shall NOT be printed on the product or delivered with the product" +
                "\n" +
                "The value does not need to be human readable, since it is intended for machine to machine (M2M) " +
                "communication." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> The conformance of the UniqueID attribute was optional in cluster revisions prior to revision 4." +
                "\n" +
                "This UniqueID attribute shall NOT be the same as the Persistent Unique ID which is used in the " +
                "Rotating Device Identifier mechanism."
        }),

        Attribute({
            name: "CapabilityMinima", id: 0x13, type: "CapabilityMinimaStruct", access: "R V", conformance: "M",
            quality: "F", xref: "core§11.1.5.20",

            details: "This attribute shall provide the minimum guaranteed value for some system-wide resource capabilities " +
                "that are not otherwise cluster-specific and do not appear elsewhere. This attribute may be used by " +
                "clients to optimize communication with Nodes by allowing them to use more than the strict minimum " +
                "values required by this specification, wherever available." +
                "\n" +
                "The values supported by the server in reality may be larger than the values provided in this " +
                "attribute, such as if a server is not resource-constrained at all. However, clients SHOULD only rely " +
                "on the amounts provided in this attribute." +
                "\n" +
                "Note that since the fixed values within this attribute may change over time, both increasing and " +
                "decreasing, as software versions change for a given Node, clients SHOULD take care not to assume " +
                "forever unchanging values and SHOULD NOT cache this value permanently at Commissioning time."
        }),

        Attribute({
            name: "ProductAppearance", id: 0x14, type: "ProductAppearanceStruct", access: "R V",
            conformance: "O", quality: "F", xref: "core§11.1.5.21",
            details: "This attribute shall provide information about the appearance of the product, which could be useful " +
                "to a user trying to locate or identify the node."
        }),

        Attribute({
            name: "SpecificationVersion", id: 0x15, type: "uint32", access: "R V", conformance: "M",
            constraint: "desc", default: 0, quality: "F", xref: "core§11.1.5.22",

            details: "This attribute shall contain the current version number for the specification version this Node was " +
                "certified against. A larger value of SpecificationVersion is newer than a lower value." +
                "\n" +
                "Nodes may query this field to determine the currently supported version of the specification on " +
                "another given Node." +
                "\n" +
                "The format of this number is segmented as its four component bytes. Bit positions for the fields are " +
                "as follows:" +
                "\n" +
                "For example, a SpecificationVersion value of 0x01040200 is composed of 4 version components, " +
                "representing a version 1.4.2.0." +
                "\n" +
                "In the example above:" +
                "\n" +
                "  • Major version is the most significant byte (0x01)." +
                "\n" +
                "  • Minor version is the second most significant byte (0x04)." +
                "\n" +
                "  • Dot version is the third most significant byte (0x02)." +
                "\n" +
                "  • Reserved1 value is the least significant byte (0x00)." +
                "\n" +
                "The initial revision (1.0) of this specification (1.0) was 0x01000000. Matter Spring 2024 release " +
                "(1.3) was 0x01030000." +
                "\n" +
                "If the SpecificationVersion is absent or zero, such as in Basic Information cluster revisions prior " +
                "to Revision 3, the specification version cannot be properly inferred unless other heuristics are " +
                "employed." +
                "\n" +
                "Comparison of SpecificationVersion shall always include the total value over 32 bits, without " +
                "masking reserved parts."
        }),

        Attribute({
            name: "MaxPathsPerInvoke", id: 0x16, type: "uint16", access: "R V", conformance: "M",
            constraint: "min 1", default: 1, quality: "F", xref: "core§11.1.5.23",

            details: "Indicates the maximum number of elements in a single InvokeRequests list (see Section 8.8.2, “Invoke " +
                "Request Action”) that the Node is able to process. Note that since this attribute may change over " +
                "time, both increasing and decreasing, as software versions change for a given Node, clients SHOULD " +
                "take care not to assume forever unchanging values and SHOULD NOT cache this value permanently at " +
                "Commissioning time." +
                "\n" +
                "If the MaxPathsPerInvoke attribute is absent or zero, such as in Basic Information cluster revisions " +
                "prior to Revision 3, clients shall assume a value of 1."
        }),

        Attribute({
            name: "ConfigurationVersion", id: 0x18, type: "uint32", access: "R V", conformance: "P, M",
            constraint: "min 1", default: 1, quality: "N", xref: "core§11.1.5.24",
            details: "This attribute shall contain the current version number for the configuration of the Node. A larger " +
                "value of ConfigurationVersion shall indicate a newer configuration than a lower value."
        }),

        Event(
            {
                name: "StartUp", id: 0x0, access: "V", conformance: "M", priority: "critical",
                xref: "core§11.1.6.1",
                details: "The StartUp event shall be generated by a Node as soon as reasonable after completing a boot or " +
                    "reboot process. The StartUp event SHOULD be the first Data Model event recorded by the Node after it " +
                    "completes a boot or reboot process."
            },

            Field({
                name: "SoftwareVersion", id: 0x0, type: "uint32", conformance: "M", xref: "core§11.1.6.1.1",
                details: "This field shall be set to the same value as the one available in the SoftwareVersion attribute."
            })
        ),

        Event({
            name: "ShutDown", id: 0x1, access: "V", conformance: "O", priority: "critical",
            xref: "core§11.1.6.2",
            details: "The ShutDown event SHOULD be generated by a Node prior to any orderly shutdown sequence on a " +
                "best-effort basis. When a ShutDown event is generated, it SHOULD be the last Data Model event " +
                "recorded by the Node. This event SHOULD be delivered urgently to current subscribers on a " +
                "best-effort basis. Any subsequent incoming interactions to the Node may be dropped until the " +
                "completion of a future boot or reboot process."
        }),

        Event(
            {
                name: "Leave", id: 0x2, access: "V", conformance: "O", priority: "info", xref: "core§11.1.6.3",

                details: "The Leave event SHOULD be generated by a Node prior to permanently leaving a given Fabric, such as " +
                    "when the RemoveFabric command is invoked for a given fabric, or triggered by factory reset or some " +
                    "other manufacturer specific action to disable or reset the operational data in the Node. When a " +
                    "Leave event is generated, it SHOULD be assumed that the fabric recorded in the event is no longer " +
                    "usable, and subsequent interactions targeting that fabric will most likely fail." +
                    "\n" +
                    "Upon receipt of Leave Event on a subscription, the receiving Node may update other nodes in the " +
                    "fabric by removing related bindings, access control list entries and other data referencing the " +
                    "leaving Node."
            },

            Field({
                name: "FabricIndex", id: 0x0, type: "fabric-idx", conformance: "M", constraint: "1 to 254",
                xref: "core§11.1.6.3.1",
                details: "This field shall contain the local fabric-index of the fabric which the node is about to leave."
            })
        ),

        Event(
            {
                name: "ReachableChanged", id: 0x3, access: "V", conformance: "Reachable", priority: "info",
                xref: "core§11.1.6.4",
                details: "This event (when supported) shall be generated when there is a change in the Reachable attribute." +
                    "\n" +
                    "Its main use case is in the derived Bridged Device Basic Information cluster."
            },

            Field({
                name: "ReachableNewValue", id: 0x0, type: "bool", conformance: "M", xref: "core§11.1.6.4.1",
                details: "This field shall indicate the value of the Reachable attribute after it was changed."
            })
        ),

        Datatype(
            {
                name: "ProductFinishEnum", type: "enum8", xref: "core§11.1.4.1",
                details: "The data type of ProductFinishEnum is derived from enum8."
            },
            Field({
                name: "Other", id: 0x0, conformance: "M",
                description: "Product has some other finish not listed below."
            }),
            Field({ name: "Matte", id: 0x1, conformance: "M", description: "Product has a matte finish." }),
            Field({ name: "Satin", id: 0x2, conformance: "M", description: "Product has a satin finish." }),
            Field({ name: "Polished", id: 0x3, conformance: "M", description: "Product has a polished or shiny finish." }),
            Field({ name: "Rugged", id: 0x4, conformance: "M", description: "Product has a rugged finish." }),
            Field({ name: "Fabric", id: 0x5, conformance: "M", description: "Product has a fabric finish." })
        ),

        Datatype(
            {
                name: "ColorEnum", type: "enum8", xref: "core§11.1.4.2",
                details: "The data type of ColorEnum is derived from enum8."
            },
            Field({ name: "Black", id: 0x0, conformance: "M", description: "Approximately RGB #000000." }),
            Field({ name: "Navy", id: 0x1, conformance: "M", description: "Approximately RGB #000080." }),
            Field({ name: "Green", id: 0x2, conformance: "M", description: "Approximately RGB #008000." }),
            Field({ name: "Teal", id: 0x3, conformance: "M", description: "Approximately RGB #008080." }),
            Field({ name: "Maroon", id: 0x4, conformance: "M", description: "Approximately RGB #800080." }),
            Field({ name: "Purple", id: 0x5, conformance: "M", description: "Approximately RGB #800080." }),
            Field({ name: "Olive", id: 0x6, conformance: "M", description: "Approximately RGB #808000." }),
            Field({ name: "Gray", id: 0x7, conformance: "M", description: "Approximately RGB #808080." }),
            Field({ name: "Blue", id: 0x8, conformance: "M", description: "Approximately RGB #0000FF." }),
            Field({ name: "Lime", id: 0x9, conformance: "M", description: "Approximately RGB #00FF00." }),
            Field({ name: "Aqua", id: 0xa, conformance: "M", description: "Approximately RGB #00FFFF." }),
            Field({ name: "Red", id: 0xb, conformance: "M", description: "Approximately RGB #FF0000." }),
            Field({ name: "Fuchsia", id: 0xc, conformance: "M", description: "Approximately RGB #FF00FF." }),
            Field({ name: "Yellow", id: 0xd, conformance: "M", description: "Approximately RGB #FFFF00." }),
            Field({ name: "White", id: 0xe, conformance: "M", description: "Approximately RGB #FFFFFF." }),
            Field({ name: "Nickel", id: 0xf, conformance: "M", description: "Typical hardware \"Nickel\" color." }),
            Field({ name: "Chrome", id: 0x10, conformance: "M", description: "Typical hardware \"Chrome\" color." }),
            Field({ name: "Brass", id: 0x11, conformance: "M", description: "Typical hardware \"Brass\" color." }),
            Field({ name: "Copper", id: 0x12, conformance: "M", description: "Typical hardware \"Copper\" color." }),
            Field({ name: "Silver", id: 0x13, conformance: "M", description: "Typical hardware \"Silver\" color." }),
            Field({ name: "Gold", id: 0x14, conformance: "M", description: "Typical hardware \"Gold\" color." })
        ),

        Datatype(
            {
                name: "ProductAppearanceStruct", type: "struct", xref: "core§11.1.4.3",
                details: "This structure provides a description of the product’s appearance."
            },
            Field({
                name: "Finish", id: 0x0, type: "ProductFinishEnum", conformance: "M", xref: "core§11.1.4.3.1",
                details: "This field shall indicate the visible finish of the product."
            }),

            Field({
                name: "PrimaryColor", id: 0x1, type: "ColorEnum", conformance: "M", quality: "X",
                xref: "core§11.1.4.3.2",
                details: "This field indicates the representative color of the visible parts of the product. If the product " +
                    "has no representative color, the field shall be null."
            })
        ),

        Datatype(
            {
                name: "CapabilityMinimaStruct", type: "struct", xref: "core§11.1.4.4",
                details: "This structure provides constant values related to overall global capabilities of this Node, that " +
                    "are not cluster-specific."
            },

            Field({
                name: "CaseSessionsPerFabric", id: 0x0, type: "uint16", conformance: "M", constraint: "min 3",
                default: 3, xref: "core§11.1.4.4.1",
                details: "This field shall indicate the actual minimum number of concurrent CASE sessions that are supported " +
                    "per fabric." +
                    "\n" +
                    "This value shall NOT be smaller than the required minimum indicated in Section 4.14.2.8, “Minimal " +
                    "Number of CASE Sessions”."
            }),

            Field({
                name: "SubscriptionsPerFabric", id: 0x1, type: "uint16", conformance: "M", constraint: "min 3",
                default: 3, xref: "core§11.1.4.4.2",
                details: "This field shall indicate the actual minimum number of concurrent subscriptions supported per " +
                    "fabric." +
                    "\n" +
                    "This value shall NOT be smaller than the required minimum indicated in Section 8.5.1, “Subscribe " +
                    "Transaction”."
            })
        )
    ),

    Cluster(
        {
            name: "GroupKeyManagement", id: 0x3f, classification: "node", pics: "GRPKEY", xref: "core§11.2",

            details: "The Group Key Management cluster manages group keys for the node. The cluster is scoped to the node " +
                "and is a singleton for the node. This cluster maintains a list of groups supported by the node. Each " +
                "group list entry supports a single group, with a single group ID and single group key. Duplicate " +
                "groups are not allowed in the list. Additions or removal of a group entry are performed via " +
                "modifications of the list. Such modifications require Administer privilege." +
                "\n" +
                "Each group entry includes a membership list of zero of more endpoints that are members of the group " +
                "on the node. Modification of this membership list is done via the Groups cluster, which is scoped to " +
                "an endpoint. See the Chapter 9, System Model Specification specification for more information on " +
                "groups."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.2.4" },
            Field({
                name: "CS", conformance: "P", constraint: "0", title: "CacheAndSync",
                details: "The ability to support CacheAndSync security policy and MCSP."
            })
        ),

        Attribute(
            {
                name: "GroupKeyMap", id: 0x0, type: "list", access: "RW F VM", conformance: "M", constraint: "desc",
                default: [], quality: "N", xref: "core§11.2.6.1",
                details: "This attribute is a list of GroupKeyMapStruct entries. Each entry associates a logical Group Id with " +
                    "a particular group key set."
            },

            Field({ name: "entry", type: "GroupKeyMapStruct" })
        ),

        Attribute(
            {
                name: "GroupTable", id: 0x1, type: "list", access: "R F V", conformance: "M", constraint: "desc",
                default: [], xref: "core§11.2.6.2",

                details: "This attribute is a list of GroupInfoMapStruct entries. Each entry provides read-only information " +
                    "about how a given logical Group ID maps to a particular set of endpoints, and a name for the group." +
                    "\n" +
                    "The content of this attribute reflects data managed via the Groups cluster (see AppClusters), and is " +
                    "in general terms referred to as the 'node-wide Group Table'." +
                    "\n" +
                    "The GroupTable shall NOT contain any entry whose GroupInfoMapStruct has an empty Endpoints list. If " +
                    "a RemoveGroup or RemoveAllGroups command causes the removal of a group mapping from its last mapped " +
                    "endpoint, the entire GroupTable entry for that given GroupId shall be removed."
            },

            Field({ name: "entry", type: "GroupInfoMapStruct" })
        ),

        Attribute({
            name: "MaxGroupsPerFabric", id: 0x2, type: "uint16", access: "R V", conformance: "M", default: 0,
            quality: "F", xref: "core§11.2.6.3",
            details: "Indicates the maximum number of groups that this node supports per fabric. The value of this " +
                "attribute shall be set to be no less than the required minimum supported groups as specified in " +
                "Section 2.11.1.2, “Group Limits”. The length of the GroupKeyMap and GroupTable list attributes shall " +
                "NOT exceed the value of the MaxGroupsPerFabric attribute multiplied by the number of supported " +
                "fabrics."
        }),

        Attribute({
            name: "MaxGroupKeysPerFabric", id: 0x3, type: "uint16", access: "R V", conformance: "M",
            constraint: "1 to 65535", default: 1, quality: "F", xref: "core§11.2.6.4",
            details: "Indicates the maximum number of group key sets this node supports per fabric. The value of this " +
                "attribute shall be set according to the minimum number of group key sets to support as specified in " +
                "Section 2.11.1.2, “Group Limits”."
        }),

        Command(
            {
                name: "KeySetWrite", id: 0x0, access: "F A", conformance: "M", direction: "request",
                response: "status", xref: "core§11.2.7.1",

                details: "This command is used by Administrators to set the state of a given Group Key Set, including " +
                    "atomically updating the state of all epoch keys." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "The following validations shall be done against the content of the GroupKeySet field:" +
                    "\n" +
                    "  • If the EpochKey0 field is null or its associated EpochStartTime0 field is null, then this " +
                    "    command shall fail with an INVALID_COMMAND status code responded to the client." +
                    "\n" +
                    "  • If the EpochKey0 field’s length is not exactly 16 bytes, then this command shall fail with a " +
                    "    CONSTRAINT_ERROR status code responded to the client." +
                    "\n" +
                    "  • If the EpochStartTime0 is set to 0, then this command shall fail with an INVALID_COMMAND status " +
                    "    code responded to the client. Note that internally, a GroupKeySetStruct’s EpochStartTime0 may be " +
                    "    set to zero, due to the behavior of the AddNOC command which synthesizes a GroupKeySetStruct " +
                    "    (see Section 11.18.6.8.1, “IPKValue Field”). However, the value 0 is illegal in the GroupKeySet " +
                    "    field sent by a client." +
                    "\n" +
                    "  • If the EpochKey1 field is not null, then the EpochKey0 field shall NOT be null. Otherwise this " +
                    "    command shall fail with an INVALID_COMMAND status code responded to the client." +
                    "\n" +
                    "  • If the EpochKey1 field is not null, and the field’s length is not exactly 16 bytes, then this " +
                    "    command shall fail with a CONSTRAINT_ERROR status code responded to the client." +
                    "\n" +
                    "  • If the EpochKey1 field is not null, its associated EpochStartTime1 field shall NOT be null and " +
                    "    shall contain a later epoch start time than the epoch start time found in the EpochStartTime0 " +
                    "    field. Otherwise this command shall fail with an INVALID_COMMAND status code responded to the " +
                    "    client." +
                    "\n" +
                    "  • If exactly one of the EpochKey1 or EpochStartTime1 is null, rather than both being null, or " +
                    "    neither being null, then this command shall fail with an INVALID_COMMAND status code responded " +
                    "    to the client." +
                    "\n" +
                    "  • If the EpochKey2 field is not null, then the EpochKey1 and EpochKey0 fields shall NOT be null. " +
                    "    Otherwise this command shall fail with an INVALID_COMMAND status code responded to the client." +
                    "\n" +
                    "  • If the EpochKey2 field is not null, and the field’s length is not exactly 16 bytes, then this " +
                    "    command shall fail with a CONSTRAINT_ERROR status code responded to the client." +
                    "\n" +
                    "  • If the EpochKey2 field is not null, its associated EpochStartTime2 field shall NOT be null and " +
                    "    shall contain a later epoch start time than the epoch start time found in the EpochStartTime1 " +
                    "    field. Otherwise this command shall fail with an INVALID_COMMAND status code responded to the " +
                    "    client." +
                    "\n" +
                    "  • If exactly one of the EpochKey2 or EpochStartTime2 is null, rather than both being null, or " +
                    "    neither being null, then this command shall fail with an INVALID_COMMAND status code responded " +
                    "    to the client." +
                    "\n" +
                    "If there exists a Group Key Set associated with the accessing fabric which has the same " +
                    "GroupKeySetID as that provided in the GroupKeySet field, then the contents of that group key set " +
                    "shall be replaced. A replacement shall be done by executing the equivalent of entirely removing the " +
                    "previous Group Key Set with the given GroupKeySetID, followed by an addition of a Group Key Set with " +
                    "the provided configuration. Otherwise, if the GroupKeySetID did not match an existing entry, a new " +
                    "Group Key Set associated with the accessing fabric shall be created with the provided data. The " +
                    "Group Key Set shall be written to non-volatile storage." +
                    "\n" +
                    "Upon completion, this command shall send a status code back to the initiator:" +
                    "\n" +
                    "  • If the Group Key Set was properly installed or updated on the Node, the status code shall be set " +
                    "    to SUCCESS." +
                    "\n" +
                    "  • If there are insufficient resources on the receiver to store an additional Group Key Set, the " +
                    "    status code shall be set to RESOURCE_EXHAUSTED (see Section 2.11.1.2, “Group Limits”);" +
                    "\n" +
                    "  • Otherwise, this status code shall be set to FAILURE."
            },

            Field({ name: "GroupKeySet", id: 0x0, type: "GroupKeySetStruct", conformance: "M" })
        ),

        Command(
            {
                name: "KeySetRead", id: 0x1, access: "F A", conformance: "M", direction: "request",
                response: "KeySetReadResponse", xref: "core§11.2.7.2",

                details: "This command is used by Administrators to read the state of a given Group Key Set." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If there exists a Group Key Set associated with the accessing fabric which has the same " +
                    "GroupKeySetID as that provided in the GroupKeySetID field, then the contents of that Group Key Set " +
                    "shall be sent in a KeySetReadResponse command, but with the EpochKey0, EpochKey1 and EpochKey2 " +
                    "fields replaced by null." +
                    "\n" +
                    "Otherwise, if the GroupKeySetID does not refer to a Group Key Set associated with the accessing " +
                    "fabric, then this command shall fail with a NOT_FOUND status code."
            },

            Field({ name: "GroupKeySetId", id: 0x0, type: "uint16", conformance: "M" })
        ),

        Command(
            {
                name: "KeySetReadResponse", id: 0x2, conformance: "M", direction: "response", xref: "core§11.2.7.3",
                details: "This command shall be generated in response to the KeySetRead command, if a valid Group Key Set was " +
                    "found. It shall contain the configuration of the requested Group Key Set, with the EpochKey0, " +
                    "EpochKey1 and EpochKey2 key contents replaced by null."
            },

            Field({ name: "GroupKeySet", id: 0x0, type: "GroupKeySetStruct", conformance: "M" })
        ),

        Command(
            {
                name: "KeySetRemove", id: 0x3, access: "F A", conformance: "M", direction: "request",
                response: "status", xref: "core§11.2.7.4",

                details: "This command is used by Administrators to remove all state of a given Group Key Set." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If there exists a Group Key Set associated with the accessing fabric which has the same " +
                    "GroupKeySetID as that provided in the GroupKeySetID field, then the contents of that Group Key Set " +
                    "shall be removed, including all epoch keys it contains." +
                    "\n" +
                    "If there exist any entries for the accessing fabric within the GroupKeyMap attribute that refer to " +
                    "the GroupKeySetID just removed, then these entries shall be removed from that list." +
                    "\n" +
                    "This command shall fail with an INVALID_COMMAND status code back to the initiator if the " +
                    "GroupKeySetID being removed is 0, which is the Key Set associated with the Identity Protection Key " +
                    "(IPK). The only method to remove the IPK is usage of the RemoveFabric command or any operation which " +
                    "causes the equivalent of a RemoveFabric to occur by side-effect." +
                    "\n" +
                    "This command shall send a SUCCESS status code back to the initiator on success, or NOT_FOUND if the " +
                    "GroupKeySetID requested did not exist."
            },

            Field({ name: "GroupKeySetId", id: 0x0, type: "uint16", conformance: "M" })
        ),

        Command(
            {
                name: "KeySetReadAllIndices", id: 0x4, access: "F A", conformance: "M", direction: "request",
                response: "KeySetReadAllIndicesResponse", xref: "core§11.2.7.5",

                details: "This command is used by Administrators to query a list of all Group Key Sets associated with the " +
                    "accessing fabric." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "Upon receipt, this command shall iterate all stored GroupKeySetStruct associated with the accessing " +
                    "fabric and generate a KeySetReadAllIndicesResponse command containing the list of GroupKeySetID " +
                    "values from those structs."
            },

            Field({ name: "DoNotUse", id: 0x0, conformance: "X" })
        ),

        Command(
            {
                name: "KeySetReadAllIndicesResponse", id: 0x5, conformance: "M", direction: "response",
                xref: "core§11.2.7.6",
                details: "This command shall be generated in response to KeySetReadAllIndices and it shall contain the list of " +
                    "GroupKeySetID for all Group Key Sets associated with the scoped Fabric."
            },

            Field(
                {
                    name: "GroupKeySetIDs", id: 0x0, type: "list", conformance: "M", xref: "core§11.2.7.6.1",
                    details: "This field references the set of group keys that generate operational group keys for use with the " +
                        "accessing fabric." +
                        "\n" +
                        "Each entry in GroupKeySetIDs is a GroupKeySetID field."
                },

                Field({ name: "entry", type: "uint16" })
            )
        ),

        Datatype(
            { name: "GroupKeySecurityPolicyEnum", type: "enum8", xref: "core§11.2.5.1" },
            Field({
                name: "TrustFirst", id: 0x0, conformance: "M",
                description: "Message counter synchronization using trust-first"
            }),
            Field({
                name: "CacheAndSync", id: 0x1, conformance: "CS",
                description: "Message counter synchronization using cache-and-sync"
            })
        ),

        Datatype(
            { name: "GroupKeyMulticastPolicyEnum", type: "enum8", xref: "core§11.2.5.2" },

            Field({
                name: "PerGroupId", id: 0x0, conformance: "M",
                description: "Indicates filtering of multicast messages for a specific Group ID",
                xref: "core§11.2.5.2.1",
                details: "The 16-bit Group Identifier of the Multicast Address shall be the Group ID of the group."
            }),

            Field({
                name: "AllNodes", id: 0x1, conformance: "M",
                description: "Indicates not filtering of multicast messages", xref: "core§11.2.5.2.2",
                details: "The 16-bit Group Identifier of the Multicast Address shall be 0xFFFF."
            })
        ),

        Datatype(
            { name: "GroupKeyMapStruct", type: "struct", xref: "core§11.2.5.3" },
            Field({
                name: "GroupId", id: 0x1, type: "group-id", access: "F", conformance: "M", xref: "core§11.2.5.3.1",
                details: "This field uniquely identifies the group within the scope of the given Fabric."
            }),

            Field({
                name: "GroupKeySetId", id: 0x2, type: "uint16", access: "F", conformance: "M",
                constraint: "1 to 65535", xref: "core§11.2.5.3.2",
                details: "This field references the set of group keys that generate operational group keys for use with this " +
                    "group, as specified in Section 4.17.3.5.1, “Group Key Set ID”." +
                    "\n" +
                    "A GroupKeyMapStruct shall NOT accept GroupKeySetID of 0, which is reserved for the IPK."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            { name: "GroupKeySetStruct", type: "struct", xref: "core§11.2.5.4" },
            Field({
                name: "GroupKeySetId", id: 0x0, type: "uint16", conformance: "M", xref: "core§11.2.5.4.1",
                details: "This field shall provide the fabric-unique index for the associated group key set, as specified in " +
                    "Section 4.17.3.5.1, “Group Key Set ID”."
            }),

            Field({
                name: "GroupKeySecurityPolicy", id: 0x1, type: "GroupKeySecurityPolicyEnum", access: "S",
                conformance: "M", xref: "core§11.2.5.4.2",
                details: "This field shall provide the security policy for an operational group key set." +
                    "\n" +
                    "When CacheAndSync is not supported in the FeatureMap of this cluster, any action attempting to set " +
                    "CacheAndSync in the GroupKeySecurityPolicy field shall fail with an INVALID_COMMAND error."
            }),

            Field({
                name: "EpochKey0", id: 0x2, type: "octstr", access: "S", conformance: "M", constraint: "16",
                quality: "X", xref: "core§11.2.5.4.3",
                details: "This field, if not null, shall be the root credential used in the derivation of an operational group " +
                    "key for epoch slot 0 of the given group key set. If EpochKey0 is not null, EpochStartTime0 shall NOT " +
                    "be null."
            }),

            Field({
                name: "EpochStartTime0", id: 0x3, type: "epoch-us", access: "S", conformance: "M", quality: "X",
                xref: "core§11.2.5.4.4",
                details: "This field, if not null, shall define when EpochKey0 becomes valid as specified by Section 4.17.3, " +
                    "“Epoch Keys”. Units are absolute UTC time in microseconds encoded using the epoch-us representation."
            }),

            Field({
                name: "EpochKey1", id: 0x4, type: "octstr", access: "S", conformance: "M", constraint: "16",
                quality: "X", xref: "core§11.2.5.4.5",
                details: "This field, if not null, shall be the root credential used in the derivation of an operational group " +
                    "key for epoch slot 1 of the given group key set. If EpochKey1 is not null, EpochStartTime1 shall NOT " +
                    "be null."
            }),

            Field({
                name: "EpochStartTime1", id: 0x5, type: "epoch-us", access: "S", conformance: "M", quality: "X",
                xref: "core§11.2.5.4.6",
                details: "This field, if not null, shall define when EpochKey1 becomes valid as specified by Section 4.17.3, " +
                    "“Epoch Keys”. Units are absolute UTC time in microseconds encoded using the epoch-us representation."
            }),

            Field({
                name: "EpochKey2", id: 0x6, type: "octstr", access: "S", conformance: "M", constraint: "16",
                quality: "X", xref: "core§11.2.5.4.7",
                details: "This field, if not null, shall be the root credential used in the derivation of an operational group " +
                    "key for epoch slot 2 of the given group key set. If EpochKey2 is not null, EpochStartTime2 shall NOT " +
                    "be null."
            }),

            Field({
                name: "EpochStartTime2", id: 0x7, type: "epoch-us", access: "S", conformance: "M", quality: "X",
                xref: "core§11.2.5.4.8",
                details: "This field, if not null, shall define when EpochKey2 becomes valid as specified by Section 4.17.3, " +
                    "“Epoch Keys”. Units are absolute UTC time in microseconds encoded using the epoch-us representation."
            }),

            Field({
                name: "GroupKeyMulticastPolicy", id: 0x8, type: "GroupKeyMulticastPolicyEnum", access: "S",
                conformance: "P, M", xref: "core§11.2.5.4.9",

                details: "This field specifies how the IPv6 Multicast Address shall be formed for groups using this " +
                    "operational group key set." +
                    "\n" +
                    "The PerGroupID method maximizes filtering of multicast messages, so that receiving nodes receive " +
                    "only multicast messages for groups to which they are subscribed." +
                    "\n" +
                    "The AllNodes method minimizes the number of multicast addresses to which a receiver node needs to " +
                    "subscribe." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Support for GroupKeyMulticastPolicy is provisional. Correct default behavior is that implied by " +
                    "  value PerGroupID."
            })
        ),

        Datatype(
            { name: "GroupInfoMapStruct", type: "struct", xref: "core§11.2.5.5" },
            Field({
                name: "GroupId", id: 0x1, type: "group-id", access: "F", conformance: "M", xref: "core§11.2.5.5.1",
                details: "This field uniquely identifies the group within the scope of the given Fabric."
            }),

            Field(
                {
                    name: "Endpoints", id: 0x2, type: "list", access: "F", conformance: "M", constraint: "min 1",
                    xref: "core§11.2.5.5.2",
                    details: "This field provides the list of Endpoint IDs on the Node to which messages to this group shall be " +
                        "forwarded."
                },

                Field({ name: "entry", type: "endpoint-no" })
            ),

            Field({
                name: "GroupName", id: 0x3, type: "string", access: "F", conformance: "O", constraint: "max 16",
                xref: "core§11.2.5.5.3",
                details: "This field provides a name for the group. This field shall contain the last GroupName written for a " +
                    "given GroupId on any Endpoint via the Groups cluster."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Cluster(
        {
            name: "LocalizationConfiguration", id: 0x2b, classification: "node", pics: "LCFG",
            xref: "core§11.3",

            details: "Nodes should be expected to be deployed to any and all regions of the world. These global regions " +
                "may have differing common languages, units of measurements, and numerical formatting standards. As " +
                "such, Nodes that visually or audibly convey information need a mechanism by which they can be " +
                "configured to use a user’s preferred language, units, etc." +
                "\n" +
                "This cluster supports an interface to a Node. It provides attributes for determining and configuring " +
                "localization information that a Node shall utilize when conveying values to a user."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "ActiveLocale", id: 0x0, type: "string", access: "RW VM", conformance: "M",
            constraint: "max 35", quality: "N", xref: "core§11.3.4.1",

            details: "The ActiveLocale attribute shall represent the locale that the Node is currently configured to use " +
                "when conveying information. The ActiveLocale attribute shall be a Language Tag as defined by BCP47. " +
                "The ActiveLocale attribute shall have a default value assigned by the Vendor and shall be a value " +
                "contained within the SupportedLocales attribute." +
                "\n" +
                "An attempt to write a value to ActiveLocale that is not present in SupportedLocales shall result in " +
                "a CONSTRAINT_ERROR error."
        }),

        Attribute(
            {
                name: "SupportedLocales", id: 0x1, type: "list", access: "R V", conformance: "M",
                constraint: "max 32[max 35]", quality: "F", xref: "core§11.3.4.2",
                details: "The SupportedLocales attribute shall represent a list of locale strings that are valid values for " +
                    "the ActiveLocale attribute. The list shall NOT contain any duplicate entries. The ordering of items " +
                    "within the list SHOULD NOT express any meaning."
            },

            Field({ name: "entry", type: "string" })
        )
    ),

    Cluster(
        {
            name: "TimeFormatLocalization", id: 0x2c, classification: "node", pics: "LTIME", xref: "core§11.4",

            details: "Nodes should be expected to be deployed to any and all regions of the world. These global regions " +
                "may have differing preferences for how dates and times are conveyed. As such, Nodes that visually or " +
                "audibly convey time information need a mechanism by which they can be configured to use a user’s " +
                "preferred format." +
                "\n" +
                "This cluster supports an interface to a Node. It provides attributes for determining and configuring " +
                "time and date formatting information that a Node shall utilize when conveying values to a user."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.4.4" },
            Field({
                name: "CALFMT", constraint: "0", title: "CalendarFormat",
                details: "The Node can be configured to use different calendar formats when conveying values to a user."
            })
        ),

        Attribute({
            name: "HourFormat", id: 0x0, type: "HourFormatEnum", access: "RW VM", conformance: "M",
            quality: "N", xref: "core§11.4.6.1",

            details: "Indicates the format that the Node is currently configured to use when conveying the hour unit of " +
                "time." +
                "\n" +
                "If not UseActiveLocale, this value shall take priority over any unit implied through the " +
                "ActiveLocale attribute." +
                "\n" +
                "If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the hour format, " +
                "and if ActiveLocale is not present, the hour format is unknown."
        }),

        Attribute({
            name: "ActiveCalendarType", id: 0x1, type: "CalendarTypeEnum", access: "RW VM",
            conformance: "CALFMT", quality: "N", xref: "core§11.4.6.2",

            details: "Indicates the calendar format that the Node is currently configured to use when conveying dates." +
                "\n" +
                "If not UseActiveLocale, this value shall take priority over any unit implied through the " +
                "ActiveLocale attribute." +
                "\n" +
                "If UseActiveLocale, any unit implied through the ActiveLocale attribute is used as the calendar " +
                "type, and if ActiveLocale is not present, the calendar type is unknown."
        }),

        Attribute(
            {
                name: "SupportedCalendarTypes", id: 0x2, type: "list", access: "R V", conformance: "CALFMT",
                constraint: "desc", quality: "F", xref: "core§11.4.6.3",
                details: "Indicates a list of CalendarTypeEnum values that are supported by the Node. The list shall NOT " +
                    "contain any duplicate entries. The ordering of items within the list SHOULD NOT express any meaning. " +
                    "The maximum length of the SupportedCalendarTypes list shall be equivalent to the number of " +
                    "enumerations within CalendarTypeEnum."
            },

            Field({ name: "entry", type: "CalendarTypeEnum" })
        ),

        Datatype(
            { name: "HourFormatEnum", type: "enum8", xref: "core§11.4.5.1" },
            Field({ name: "12Hr", id: 0x0, conformance: "M", description: "Time conveyed with a 12-hour clock" }),
            Field({ name: "24Hr", id: 0x1, conformance: "M", description: "Time conveyed with a 24-hour clock" }),
            Field({ name: "UseActiveLocale", id: 0xff, conformance: "M", description: "Use active locale clock" })
        ),

        Datatype(
            { name: "CalendarTypeEnum", type: "enum8", xref: "core§11.4.5.2" },
            Field({
                name: "Buddhist", id: 0x0, conformance: "O.a+",
                description: "Dates conveyed using the Buddhist calendar"
            }),
            Field({ name: "Chinese", id: 0x1, conformance: "O.a+", description: "Dates conveyed using the Chinese calendar" }),
            Field({ name: "Coptic", id: 0x2, conformance: "O.a+", description: "Dates conveyed using the Coptic calendar" }),
            Field({
                name: "Ethiopian", id: 0x3, conformance: "O.a+",
                description: "Dates conveyed using the Ethiopian calendar"
            }),
            Field({
                name: "Gregorian", id: 0x4, conformance: "O.a+",
                description: "Dates conveyed using the Gregorian calendar"
            }),
            Field({ name: "Hebrew", id: 0x5, conformance: "O.a+", description: "Dates conveyed using the Hebrew calendar" }),
            Field({ name: "Indian", id: 0x6, conformance: "O.a+", description: "Dates conveyed using the Indian calendar" }),
            Field({ name: "Islamic", id: 0x7, conformance: "O.a+", description: "Dates conveyed using the Islamic calendar" }),
            Field({
                name: "Japanese", id: 0x8, conformance: "O.a+",
                description: "Dates conveyed using the Japanese calendar"
            }),
            Field({ name: "Korean", id: 0x9, conformance: "O.a+", description: "Dates conveyed using the Korean calendar" }),
            Field({ name: "Persian", id: 0xa, conformance: "O.a+", description: "Dates conveyed using the Persian calendar" }),
            Field({
                name: "Taiwanese", id: 0xb, conformance: "O.a+",
                description: "Dates conveyed using the Taiwanese calendar"
            }),
            Field({
                name: "UseActiveLocale", id: 0xff, conformance: "O.a+",
                description: "calendar implied from active locale"
            })
        )
    ),

    Cluster(
        {
            name: "UnitLocalization", id: 0x2d, classification: "node", pics: "LUNIT", xref: "core§11.5",

            details: "Nodes should be expected to be deployed to any and all regions of the world. These global regions " +
                "may have differing preferences for the units in which values are conveyed in communication to a " +
                "user. As such, Nodes that visually or audibly convey measurable values to the user need a mechanism " +
                "by which they can be configured to use a user’s preferred unit." +
                "\n" +
                "This cluster supports an interface to a Node. It provides attributes for determining and configuring " +
                "the units that a Node shall utilize when conveying values in communication to a user."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.5.4" },
            Field({
                name: "TEMP", constraint: "0", title: "TemperatureUnit",
                details: "The Node can be configured to use different units of temperature when conveying values to a user."
            })
        ),

        Attribute({
            name: "TemperatureUnit", id: 0x0, type: "TempUnitEnum", access: "RW VM", conformance: "TEMP",
            quality: "N", xref: "core§11.5.6.1",

            details: "Indicates the unit for the Node to use only when conveying temperature in communication to the user, " +
                "for example such as via a user interface on the device. If provided, this value shall take priority " +
                "over any unit implied through the ActiveLocale Attribute." +
                "\n" +
                "An attempt to write to this attribute with a value not included in the SupportedTemperatureUnits " +
                "attribute list shall result in a CONSTRAINT_ERROR."
        }),

        Attribute(
            {
                name: "SupportedTemperatureUnits", id: 0x1, type: "list", access: "R V", conformance: "P, TEMP",
                constraint: "2 to 3", quality: "F", xref: "core§11.5.6.2",
                details: "Indicates a list of units supported by the Node to be used when writing the TemperatureUnit " +
                    "attribute of this cluster. Each entry in the list shall be unique."
            },

            Field({ name: "entry", type: "TempUnitEnum" })
        ),

        Datatype(
            { name: "TempUnitEnum", type: "enum8", xref: "core§11.5.5.1" },
            Field({ name: "Fahrenheit", id: 0x0, conformance: "O.a2+", description: "Temperature conveyed in Fahrenheit" }),
            Field({ name: "Celsius", id: 0x1, conformance: "O.a2+", description: "Temperature conveyed in Celsius" }),
            Field({ name: "Kelvin", id: 0x2, conformance: "O.a2+", description: "Temperature conveyed in Kelvin" })
        )
    ),

    Cluster(
        {
            name: "PowerSourceConfiguration", id: 0x2e, classification: "node", pics: "PSCFG",
            xref: "core§11.6",
            details: "This cluster is used to describe the configuration and capabilities of a Device’s power system. It " +
                "provides an ordering overview as well as linking to the one or more endpoints each supporting a " +
                "Power Source cluster."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "Sources", id: 0x0, type: "list", access: "R V", conformance: "M", constraint: "max 6",
                quality: "N", xref: "core§11.6.4.1",

                details: "This list shall contain the set of all power sources capable of participating in the power system of " +
                    "this Node. Each entry in the list shall be the endpoint number of an endpoint having a Power Source " +
                    "cluster, which corresponds to a physical power source. The endpoint number shall be unique within " +
                    "the list." +
                    "\n" +
                    "The order of power sources on a Node is defined by the Order attribute of its associated Power " +
                    "Source cluster provided on the endpoint. List entries shall be sorted in increasing order, that is, " +
                    "an entry with a lower order shall have a lower index than any entry with a higher order. Multiple " +
                    "entries may have the same order, there are no restrictions on their relative sorting."
            },

            Field({ name: "entry", type: "endpoint-no" })
        )
    ),

    Cluster(
        {
            name: "PowerSource", id: 0x2f, classification: "node", pics: "PS", xref: "core§11.7",
            details: "This cluster is used to describe the configuration and capabilities of a physical power source that " +
                "provides power to one or more endpoints on a node. In case the node has multiple power sources, each " +
                "shall be described by its own cluster instance. Each instance of this cluster may be associated with " +
                "one or more endpoints or the entire node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.7.4" },
            Field({ name: "WIRED", conformance: "O.a", constraint: "0", title: "Wired", details: "A wired power source" }),
            Field({ name: "BAT", conformance: "O.a", constraint: "1", title: "Battery", details: "A battery power source" }),
            Field({
                name: "RECHG", conformance: "[BAT]", constraint: "2", title: "Rechargeable",
                details: "A rechargeable battery power source"
            }),
            Field({
                name: "REPLC", conformance: "[BAT]", constraint: "3", title: "Replaceable",
                details: "A replaceable battery power source"
            })
        ),

        Attribute({
            name: "Status", id: 0x0, type: "PowerSourceStatusEnum", access: "R V", conformance: "M",
            constraint: "desc", xref: "core§11.7.7.1",
            details: "Indicates the participation of this power source in providing power to the Node as specified in " +
                "PowerSourceStatusEnum."
        }),

        Attribute({
            name: "Order", id: 0x1, type: "uint8", access: "R V", conformance: "M", quality: "N",
            xref: "core§11.7.7.2",

            details: "Indicates the relative preference with which the Node will select this source to provide power. A " +
                "source with a lower order shall be selected by the Node to provide power before any other source " +
                "with a higher order, if the lower order source is available (see Section 11.7.7.1, “Status " +
                "Attribute”)." +
                "\n" +
                "Note, Order is read-only and therefore NOT intended to allow clients control over power source " +
                "selection."
        }),

        Attribute({
            name: "Description", id: 0x2, type: "string", access: "R V", conformance: "M", constraint: "max 60",
            quality: "F", xref: "core§11.7.7.3",
            details: "This attribute shall provide a user-facing description of this source, used to distinguish it from " +
                "other power sources, e.g. \"DC Power\", \"Primary Battery\" or \"Battery back-up\". This attribute shall " +
                "NOT be used to convey information such as battery form factor, or chemistry."
        }),

        Attribute({
            name: "WiredAssessedInputVoltage", id: 0x3, type: "uint32", access: "R V", conformance: "[WIRED]",
            quality: "X C", xref: "core§11.7.7.4",
            details: "Indicates the assessed RMS or DC voltage currently provided by the hard-wired source, in mV " +
                "(millivolts). A value of NULL shall indicate the Node is currently unable to assess the value. If " +
                "the wired source is not connected, but the Node is still able to assess a value, then the assessed " +
                "value may be reported."
        }),

        Attribute({
            name: "WiredAssessedInputFrequency", id: 0x4, type: "uint16", access: "R V", conformance: "[WIRED]",
            quality: "X C", xref: "core§11.7.7.5",
            details: "Indicates the assessed frequency of the voltage, currently provided by the hard-wired source, in Hz. " +
                "A value of NULL shall indicate the Node is currently unable to assess the value. If the wired source " +
                "is not connected, but the Node is still able to assess a value, then the assessed value may be " +
                "reported."
        }),

        Attribute({
            name: "WiredCurrentType", id: 0x5, type: "WiredCurrentTypeEnum", access: "R V",
            conformance: "WIRED", constraint: "desc", quality: "F", xref: "core§11.7.7.6",
            details: "Indicates the type of current the Node expects to be provided by the hard-wired source as specified " +
                "in WiredCurrentTypeEnum."
        }),

        Attribute({
            name: "WiredAssessedCurrent", id: 0x6, type: "uint32", access: "R V", conformance: "[WIRED]",
            quality: "X C", xref: "core§11.7.7.7",
            details: "Indicates the assessed instantaneous current draw of the Node on the hard-wired source, in mA " +
                "(milliamps). A value of NULL shall indicate the Node is currently unable to assess the value. If the " +
                "wired source is not connected, but the Node is still able to assess a value, then the assessed value " +
                "may be reported."
        }),

        Attribute({
            name: "WiredNominalVoltage", id: 0x7, type: "uint32", access: "R V", conformance: "[WIRED]",
            quality: "F", xref: "core§11.7.7.8",
            details: "Indicates the nominal voltage, printed as part of the Node’s regulatory compliance label in mV " +
                "(millivolts), expected to be provided by the hard-wired source."
        }),

        Attribute({
            name: "WiredMaximumCurrent", id: 0x8, type: "uint32", access: "R V", conformance: "[WIRED]",
            quality: "F", xref: "core§11.7.7.9",
            details: "Indicates the maximum current, printed as part of the Node’s regulatory compliance label in mA " +
                "(milliamps), expected to be provided by the hard-wired source."
        }),

        Attribute({
            name: "WiredPresent", id: 0x9, type: "bool", access: "R V", conformance: "[WIRED]",
            xref: "core§11.7.7.10",
            details: "Indicates if the Node detects that the hard-wired power source is properly connected."
        }),

        Attribute(
            {
                name: "ActiveWiredFaults", id: 0xa, type: "list", access: "R V", conformance: "[WIRED]",
                constraint: "max 8", xref: "core§11.7.7.11",

                details: "Indicates the set of wired faults currently detected by the Node on this power source. This set is " +
                    "represented as a list of WiredFaultEnum. When the Node detects a fault has been raised, the " +
                    "appropriate WiredFaultEnum value shall be added to this list, provided it is not already present. " +
                    "This list shall NOT contain more than one instance of a specific WiredFaultEnum value. When the Node " +
                    "detects all conditions contributing to a fault have been cleared, the corresponding WiredFaultEnum " +
                    "value shall be removed from this list. An empty list shall indicate there are currently no active " +
                    "faults. The order of this list SHOULD have no significance. Clients interested in monitoring changes " +
                    "in active faults may subscribe to this attribute, or they may subscribe to WiredFaultChange."
            },

            Field({ name: "entry", type: "WiredFaultEnum" })
        ),

        Attribute({
            name: "BatVoltage", id: 0xb, type: "uint32", access: "R V", conformance: "[BAT]", quality: "X C",
            xref: "core§11.7.7.12",
            details: "Indicates the currently measured output voltage of the battery in mV (millivolts). A value of NULL " +
                "shall indicate the Node is currently unable to assess the value."
        }),

        Attribute({
            name: "BatPercentRemaining", id: 0xc, type: "uint8", access: "R V", conformance: "[BAT]",
            constraint: "max 200", quality: "X Q", xref: "core§11.7.7.13",

            details: "Indicates the estimated percentage of battery charge remaining until the battery will no longer be " +
                "able to provide power to the Node. Values are expressed in half percent units, ranging from 0 to " +
                "200. E.g. a value of 48 is equivalent to 24%. A value of NULL shall indicate the Node is currently " +
                "unable to assess the value." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once every 10 seconds, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa." +
                "\n" +
                "Since reporting consumes power, devices SHOULD be careful not to over-report."
        }),

        Attribute({
            name: "BatTimeRemaining", id: 0xd, type: "uint32", access: "R V", conformance: "[BAT]",
            quality: "X Q", xref: "core§11.7.7.14",

            details: "Indicates the estimated time in seconds before the battery will no longer be able to provide power " +
                "to the Node. A value of NULL shall indicate the Node is currently unable to assess the value." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once every 10 seconds, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa." +
                "\n" +
                "Since reporting consumes power, devices SHOULD be careful not to over-report."
        }),

        Attribute({
            name: "BatChargeLevel", id: 0xe, type: "BatChargeLevelEnum", access: "R V", conformance: "BAT",
            constraint: "desc", xref: "core§11.7.7.15",
            details: "Indicates a coarse ranking of the charge level of the battery, used to indicate when intervention is " +
                "required as specified in BatChargeLevelEnum."
        }),

        Attribute({
            name: "BatReplacementNeeded", id: 0xf, type: "bool", access: "R V", conformance: "BAT",
            xref: "core§11.7.7.16",
            details: "Indicates if the battery needs to be replaced. Replacement may be simple routine maintenance, such " +
                "as with a single use, non-rechargeable cell. Replacement, however, may also indicate end of life, or " +
                "serious fault with a rechargeable or even non-replaceable cell."
        }),

        Attribute({
            name: "BatReplaceability", id: 0x10, type: "BatReplaceabilityEnum", access: "R V",
            conformance: "BAT", quality: "F", xref: "core§11.7.7.17",
            details: "Indicates the replaceability of the battery as specified in BatReplaceabilityEnum."
        }),
        Attribute({
            name: "BatPresent", id: 0x11, type: "bool", access: "R V", conformance: "[BAT]",
            xref: "core§11.7.7.18",
            details: "Indicates whether the Node detects that the batteries are properly installed."
        }),

        Attribute(
            {
                name: "ActiveBatFaults", id: 0x12, type: "list", access: "R V", conformance: "[BAT]",
                constraint: "max 8", xref: "core§11.7.7.19",

                details: "Indicates the set of battery faults currently detected by the Node on this power source. This set is " +
                    "represented as a list of BatFaultEnum. When the Node detects a fault has been raised, the " +
                    "appropriate BatFaultEnum value shall be added to this list, provided it is not already present. This " +
                    "list shall NOT contain more than one instance of a specific BatFaultEnum value. When the Node " +
                    "detects all conditions contributing to a fault have been cleared, the corresponding BatFaultEnum " +
                    "value shall be removed from this list. An empty list shall indicate there are currently no active " +
                    "faults. The order of this list SHOULD have no significance. Clients interested in monitoring changes " +
                    "in active faults may subscribe to this attribute, or they may subscribe to BatFaultChange."
            },

            Field({ name: "entry", type: "BatFaultEnum" })
        ),

        Attribute({
            name: "BatReplacementDescription", id: 0x13, type: "string", access: "R V", conformance: "REPLC",
            constraint: "max 60", quality: "F", xref: "core§11.7.7.20",
            details: "This attribute shall provide a user-facing description of this battery, which SHOULD contain " +
                "information required to identify a replacement, such as form factor, chemistry or preferred " +
                "manufacturer."
        }),

        Attribute({
            name: "BatCommonDesignation", id: 0x14, type: "BatCommonDesignationEnum", access: "R V",
            conformance: "[REPLC]", constraint: "desc", quality: "F", xref: "core§11.7.7.21",
            details: "Indicates the ID of the common or colloquial designation of the battery, as specified in " +
                "BatCommonDesignationEnum."
        }),

        Attribute({
            name: "BatAnsiDesignation", id: 0x15, type: "string", access: "R V", conformance: "[REPLC]",
            constraint: "max 20", quality: "F", xref: "core§11.7.7.22",
            details: "Indicates the string representing the ANSI designation for the battery as specified in ANSI C18."
        }),
        Attribute({
            name: "BatIecDesignation", id: 0x16, type: "string", access: "R V", conformance: "[REPLC]",
            constraint: "max 20", quality: "F", xref: "core§11.7.7.23",
            details: "Indicates the string representing the IEC designation for the battery as specified in IEC 60086."
        }),

        Attribute({
            name: "BatApprovedChemistry", id: 0x17, type: "BatApprovedChemistryEnum", access: "R V",
            conformance: "[REPLC]", constraint: "desc", quality: "F", xref: "core§11.7.7.24",
            details: "Indicates the ID of the preferred chemistry of the battery source as specified in " +
                "BatApprovedChemistryEnum."
        }),

        Attribute({
            name: "BatCapacity", id: 0x18, type: "uint32", access: "R V", conformance: "[REPLC | RECHG]",
            quality: "F", xref: "core§11.7.7.25",
            details: "Indicates the preferred minimum charge capacity rating in mAh of individual, user- or " +
                "factory-serviceable battery cells or packs in the battery source."
        }),

        Attribute({
            name: "BatQuantity", id: 0x19, type: "uint8", access: "R V", conformance: "REPLC", quality: "F",
            xref: "core§11.7.7.26",
            details: "Indicates the quantity of individual, user- or factory-serviceable battery cells or packs in the " +
                "battery source."
        }),

        Attribute({
            name: "BatChargeState", id: 0x1a, type: "BatChargeStateEnum", access: "R V", conformance: "RECHG",
            constraint: "desc", xref: "core§11.7.7.27",
            details: "Indicates the current state of the battery source with respect to charging as specified in " +
                "BatChargeStateEnum."
        }),

        Attribute({
            name: "BatTimeToFullCharge", id: 0x1b, type: "uint32", access: "R V", conformance: "[RECHG]",
            quality: "X Q", xref: "core§11.7.7.28",

            details: "Indicates the estimated time in seconds before the battery source will be at full charge. A value of " +
                "NULL shall indicate the Node is currently unable to assess the value." +
                "\n" +
                "Changes to this attribute shall only be marked as reportable in the following cases:" +
                "\n" +
                "  • At most once every 10 seconds, or" +
                "\n" +
                "  • When it changes from null to any other value and vice versa." +
                "\n" +
                "Since reporting consumes power, devices SHOULD be careful not to over-report."
        }),

        Attribute({
            name: "BatFunctionalWhileCharging", id: 0x1c, type: "bool", access: "R V", conformance: "RECHG",
            xref: "core§11.7.7.29",
            details: "Indicates whether the Node can remain operational while the battery source is charging."
        }),

        Attribute({
            name: "BatChargingCurrent", id: 0x1d, type: "uint32", access: "R V", conformance: "[RECHG]",
            quality: "X C", xref: "core§11.7.7.30",
            details: "Indicates assessed current in mA (milliamps) presently supplied to charge the battery source. A " +
                "value of NULL shall indicate the Node is currently unable to assess the value."
        }),

        Attribute(
            {
                name: "ActiveBatChargeFaults", id: 0x1e, type: "list", access: "R V", conformance: "[RECHG]",
                constraint: "max 16", xref: "core§11.7.7.31",

                details: "Indicates the set of charge faults currently detected by the Node on this power source. This set is " +
                    "represented as a list of BatChargeFaultEnum. When the Node detects a fault has been raised, the " +
                    "appropriate BatChargeFaultEnum value shall be added to this list, provided it is not already " +
                    "present. This list shall NOT contain more than one instance of a specific BatChargeFaultEnum value. " +
                    "When the Node detects all conditions contributing to a fault have been cleared, the corresponding " +
                    "BatChargeFaultEnum value shall be removed from this list. An empty list shall indicate there are " +
                    "currently no active faults. The order of this list SHOULD have no significance. Clients interested " +
                    "in monitoring changes in active faults may subscribe to this attribute, or they may subscribe to the " +
                    "BatFaultChange event."
            },

            Field({ name: "entry", type: "BatChargeFaultEnum" })
        ),

        Attribute(
            {
                name: "EndpointList", id: 0x1f, type: "list", access: "R V", conformance: "M",
                xref: "core§11.7.7.32",

                details: "Indicates a list of endpoints that are powered by the source defined by this cluster. Multiple " +
                    "instances of this cluster may list the same endpoint, because it is possible for power for an " +
                    "endpoint to come from multiple sources. In that case the Order attribute indicates their priority." +
                    "\n" +
                    "For each power source on a node, there shall only be one instance of this cluster." +
                    "\n" +
                    "A cluster instance with an empty list shall indicate that the power source is for the entire node, " +
                    "which includes all endpoints." +
                    "\n" +
                    "A cluster instance with a non-empty list shall include the endpoint, upon which the cluster instance " +
                    "resides." +
                    "\n" +
                    "The above rules allow that some endpoints can have an unknown power source, and therefore would not " +
                    "be indicated by any instance of this cluster." +
                    "\n" +
                    "### Empty list examples" +
                    "\n" +
                    "Typically, there is one power source for the node. Also common is mains power for the node with " +
                    "battery backup power for the node. In both these common cases, for each cluster instance described, " +
                    "the list is empty." +
                    "\n" +
                    "### Populated list example" +
                    "\n" +
                    "A node has a mains power source with Order as 0 (zero), but some application endpoints (not all) " +
                    "have a battery back up source with Order as 1, which means this list is empty for the Power Source " +
                    "cluster associated with the mains power, because it indicates the entire node, but the Power Source " +
                    "cluster instance associated with the battery backup would list the endpoints that have a battery " +
                    "backup."
            },

            Field({ name: "entry", type: "endpoint-no" })
        ),

        Event(
            {
                name: "WiredFaultChange", id: 0x0, access: "V", conformance: "[WIRED]", priority: "info",
                xref: "core§11.7.8.1",
                details: "The WiredFaultChange Event shall be generated when the set of wired faults currently detected by the " +
                    "Node on this wired power source changes. This event shall correspond to a change in value of " +
                    "ActiveWiredFaults."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 8", default: [],
                    xref: "core§11.7.8.1.1",
                    details: "This field shall represent the set of faults currently detected, as per ActiveWiredFaults."
                },
                Field({ name: "entry", type: "WiredFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 8", default: [],
                    xref: "core§11.7.8.1.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "ActiveWiredFaults."
                },

                Field({ name: "entry", type: "WiredFaultEnum" })
            )
        ),

        Event(
            {
                name: "BatFaultChange", id: 0x1, access: "V", conformance: "[BAT]", priority: "info",
                xref: "core§11.7.8.2",
                details: "The BatFaultChange Event shall be generated when the set of battery faults currently detected by the " +
                    "Node on this battery power source changes. This event shall correspond to a change in value of " +
                    "ActiveBatFaults."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 8", default: [],
                    xref: "core§11.7.8.2.1",
                    details: "This field shall represent the set of faults currently detected, as per ActiveBatFaults."
                },
                Field({ name: "entry", type: "BatFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 8", default: [],
                    xref: "core§11.7.8.2.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "ActiveBatFaults."
                },

                Field({ name: "entry", type: "BatFaultEnum" })
            )
        ),

        Event(
            {
                name: "BatChargeFaultChange", id: 0x2, access: "V", conformance: "[RECHG]", priority: "info",
                xref: "core§11.7.8.3",
                details: "The BatChargeFaultChange Event shall be generated when the set of charge faults currently detected " +
                    "by the Node on this battery power source changes. This event shall correspond to a change in value " +
                    "of ActiveBatChargeFaults."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 16", default: [],
                    xref: "core§11.7.8.3.1",
                    details: "This field shall represent the set of faults currently detected, as per ActiveBatChargeFaults."
                },
                Field({ name: "entry", type: "BatChargeFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 16", default: [],
                    xref: "core§11.7.8.3.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "ActiveBatChargeFaults."
                },

                Field({ name: "entry", type: "BatChargeFaultEnum" })
            )
        ),

        Datatype(
            { name: "WiredFaultEnum", type: "enum8", xref: "core§11.7.6.1" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node detects an unspecified fault on this wired power source."
            }),
            Field({
                name: "OverVoltage", id: 0x1, conformance: "M",
                description: "The Node detects the supplied voltage is above maximum supported value for this wired power source."
            }),
            Field({
                name: "UnderVoltage", id: 0x2, conformance: "M",
                description: "The Node detects the supplied voltage is below maximum supported value for this wired power source."
            })
        ),

        Datatype(
            { name: "BatFaultEnum", type: "enum8", xref: "core§11.7.6.2" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node detects an unspecified fault on this battery power source."
            }),
            Field({
                name: "OverTemp", id: 0x1, conformance: "M",
                description: "The Node detects the temperature of this battery power source is above ideal operating conditions."
            }),
            Field({
                name: "UnderTemp", id: 0x2, conformance: "M",
                description: "The Node detects the temperature of this battery power source is below ideal operating conditions."
            })
        ),

        Datatype(
            { name: "BatChargeFaultEnum", type: "enum8", xref: "core§11.7.6.3" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node detects an unspecified fault on this battery source."
            }),
            Field({
                name: "AmbientTooHot", id: 0x1, conformance: "M",
                description: "The Node detects the ambient temperature is above the nominal range for this battery source."
            }),
            Field({
                name: "AmbientTooCold", id: 0x2, conformance: "M",
                description: "The Node detects the ambient temperature is below the nominal range for this battery source."
            }),
            Field({
                name: "BatteryTooHot", id: 0x3, conformance: "M",
                description: "The Node detects the temperature of this battery source is above the nominal range."
            }),
            Field({
                name: "BatteryTooCold", id: 0x4, conformance: "M",
                description: "The Node detects the temperature of this battery source is below the nominal range."
            }),
            Field({
                name: "BatteryAbsent", id: 0x5, conformance: "M",
                description: "The Node detects this battery source is not present."
            }),
            Field({
                name: "BatteryOverVoltage", id: 0x6, conformance: "M",
                description: "The Node detects this battery source is over voltage."
            }),
            Field({
                name: "BatteryUnderVoltage", id: 0x7, conformance: "M",
                description: "The Node detects this battery source is under voltage."
            }),
            Field({
                name: "ChargerOverVoltage", id: 0x8, conformance: "M",
                description: "The Node detects the charger for this battery source is over voltage."
            }),
            Field({
                name: "ChargerUnderVoltage", id: 0x9, conformance: "M",
                description: "The Node detects the charger for this battery source is under voltage."
            }),
            Field({
                name: "SafetyTimeout", id: 0xa, conformance: "M",
                description: "The Node detects a charging safety timeout for this battery source."
            })
        ),

        Datatype(
            { name: "PowerSourceStatusEnum", type: "enum8", xref: "core§11.7.6.4" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "Indicate the source status is not specified"
            }),
            Field({
                name: "Active", id: 0x1, conformance: "M",
                description: "Indicate the source is available and currently supplying power"
            }),
            Field({
                name: "Standby", id: 0x2, conformance: "M",
                description: "Indicate the source is available, but is not currently supplying power"
            }),
            Field({
                name: "Unavailable", id: 0x3, conformance: "M",
                description: "Indicate the source is not currently available to supply power"
            })
        ),

        Datatype(
            { name: "WiredCurrentTypeEnum", type: "enum8", xref: "core§11.7.6.5" },
            Field({ name: "Ac", id: 0x0, conformance: "M", description: "Indicates AC current" }),
            Field({ name: "Dc", id: 0x1, conformance: "M", description: "Indicates DC current" })
        ),

        Datatype(
            { name: "BatChargeLevelEnum", type: "enum8", xref: "core§11.7.6.6" },
            Field({ name: "Ok", id: 0x0, conformance: "M", description: "Charge level is nominal" }),
            Field({
                name: "Warning", id: 0x1, conformance: "M",
                description: "Charge level is low, intervention may soon be required."
            }),
            Field({
                name: "Critical", id: 0x2, conformance: "M",
                description: "Charge level is critical, immediate intervention is required"
            })
        ),

        Datatype(
            { name: "BatReplaceabilityEnum", type: "enum8", xref: "core§11.7.6.7" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The replaceability is unspecified or unknown."
            }),
            Field({ name: "NotReplaceable", id: 0x1, conformance: "M", description: "The battery is not replaceable." }),
            Field({
                name: "UserReplaceable", id: 0x2, conformance: "M",
                description: "The battery is replaceable by the user or customer."
            }),
            Field({
                name: "FactoryReplaceable", id: 0x3, conformance: "M",
                description: "The battery is replaceable by an authorized factory technician."
            })
        ),

        Datatype(
            { name: "BatCommonDesignationEnum", type: "enum16", xref: "core§11.7.6.8" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M", description: "Common type is unknown or unspecified" }),
            Field({ name: "Aaa", id: 0x1, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Aa", id: 0x2, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "C", id: 0x3, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "D", id: 0x4, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "4V5", id: 0x5, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "6V0", id: 0x6, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "9V0", id: 0x7, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "12Aa", id: 0x8, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Aaaa", id: 0x9, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A", id: 0xa, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "B", id: 0xb, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "F", id: 0xc, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "N", id: 0xd, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "No6", id: 0xe, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "SubC", id: 0xf, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A23", id: 0x10, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A27", id: 0x11, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Ba5800", id: 0x12, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Duplex", id: 0x13, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "4Sr44", id: 0x14, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "523", id: 0x15, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "531", id: 0x16, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "15V0", id: 0x17, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "22V5", id: 0x18, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "30V0", id: 0x19, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "45V0", id: 0x1a, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "67V5", id: 0x1b, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "J", id: 0x1c, conformance: "M", title: "Common type is as specified" }),
            Field({ name: "Cr123A", id: 0x1d, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Cr2", id: 0x1e, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "2Cr5", id: 0x1f, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "CrP2", id: 0x20, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "CrV3", id: 0x21, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr41", id: 0x22, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr43", id: 0x23, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr44", id: 0x24, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr45", id: 0x25, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr48", id: 0x26, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr54", id: 0x27, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr55", id: 0x28, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr57", id: 0x29, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr58", id: 0x2a, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr59", id: 0x2b, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr60", id: 0x2c, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr63", id: 0x2d, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr64", id: 0x2e, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr65", id: 0x2f, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr66", id: 0x30, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr67", id: 0x31, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr68", id: 0x32, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr69", id: 0x33, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr516", id: 0x34, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr731", id: 0x35, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Sr712", id: 0x36, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Lr932", id: 0x37, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A5", id: 0x38, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A10", id: 0x39, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A13", id: 0x3a, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A312", id: 0x3b, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "A675", id: 0x3c, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Ac41E", id: 0x3d, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "10180", id: 0x3e, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "10280", id: 0x3f, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "10440", id: 0x40, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "14250", id: 0x41, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "14430", id: 0x42, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "14500", id: 0x43, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "14650", id: 0x44, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "15270", id: 0x45, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "16340", id: 0x46, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "Rcr123A", id: 0x47, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "17500", id: 0x48, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "17670", id: 0x49, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "18350", id: 0x4a, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "18500", id: 0x4b, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "18650", id: 0x4c, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "19670", id: 0x4d, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "25500", id: 0x4e, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "26650", id: 0x4f, conformance: "M", description: "Common type is as specified" }),
            Field({ name: "32600", id: 0x50, conformance: "M", description: "Common type is as specified" })
        ),

        Datatype(
            { name: "BatApprovedChemistryEnum", type: "enum16", xref: "core§11.7.6.9" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M", description: "Cell chemistry is unspecified or unknown" }),
            Field({ name: "Alkaline", id: 0x1, conformance: "M", description: "Cell chemistry is alkaline" }),
            Field({
                name: "LithiumCarbonFluoride", id: 0x2, conformance: "M",
                description: "Cell chemistry is lithium carbon fluoride"
            }),
            Field({
                name: "LithiumChromiumOxide", id: 0x3, conformance: "M",
                description: "Cell chemistry is lithium chromium oxide"
            }),
            Field({
                name: "LithiumCopperOxide", id: 0x4, conformance: "M",
                description: "Cell chemistry is lithium copper oxide"
            }),
            Field({
                name: "LithiumIronDisulfide", id: 0x5, conformance: "M",
                description: "Cell chemistry is lithium iron disulfide"
            }),
            Field({
                name: "LithiumManganeseDioxide", id: 0x6, conformance: "M",
                description: "Cell chemistry is lithium manganese dioxide"
            }),
            Field({
                name: "LithiumThionylChloride", id: 0x7, conformance: "M",
                description: "Cell chemistry is lithium thionyl chloride"
            }),
            Field({ name: "Magnesium", id: 0x8, conformance: "M", description: "Cell chemistry is magnesium" }),
            Field({ name: "MercuryOxide", id: 0x9, conformance: "M", description: "Cell chemistry is mercury oxide" }),
            Field({ name: "NickelOxyhydride", id: 0xa, conformance: "M", description: "Cell chemistry is nickel oxyhydride" }),
            Field({ name: "SilverOxide", id: 0xb, conformance: "M", description: "Cell chemistry is silver oxide" }),
            Field({ name: "ZincAir", id: 0xc, conformance: "M", description: "Cell chemistry is zinc air" }),
            Field({ name: "ZincCarbon", id: 0xd, conformance: "M", description: "Cell chemistry is zinc carbon" }),
            Field({ name: "ZincChloride", id: 0xe, conformance: "M", description: "Cell chemistry is zinc chloride" }),
            Field({
                name: "ZincManganeseDioxide", id: 0xf, conformance: "M",
                description: "Cell chemistry is zinc manganese dioxide"
            }),
            Field({ name: "LeadAcid", id: 0x10, conformance: "M", description: "Cell chemistry is lead acid" }),
            Field({
                name: "LithiumCobaltOxide", id: 0x11, conformance: "M",
                description: "Cell chemistry is lithium cobalt oxide"
            }),
            Field({ name: "LithiumIon", id: 0x12, conformance: "M", description: "Cell chemistry is lithium ion" }),
            Field({
                name: "LithiumIonPolymer", id: 0x13, conformance: "M",
                description: "Cell chemistry is lithium ion polymer"
            }),
            Field({
                name: "LithiumIronPhosphate", id: 0x14, conformance: "M",
                description: "Cell chemistry is lithium iron phosphate"
            }),
            Field({ name: "LithiumSulfur", id: 0x15, conformance: "M", description: "Cell chemistry is lithium sulfur" }),
            Field({ name: "LithiumTitanate", id: 0x16, conformance: "M", description: "Cell chemistry is lithium titanate" }),
            Field({ name: "NickelCadmium", id: 0x17, conformance: "M", description: "Cell chemistry is nickel cadmium" }),
            Field({ name: "NickelHydrogen", id: 0x18, conformance: "M", description: "Cell chemistry is nickel hydrogen" }),
            Field({ name: "NickelIron", id: 0x19, conformance: "M", description: "Cell chemistry is nickel iron" }),
            Field({
                name: "NickelMetalHydride", id: 0x1a, conformance: "M",
                description: "Cell chemistry is nickel metal hydride"
            }),
            Field({ name: "NickelZinc", id: 0x1b, conformance: "M", description: "Cell chemistry is nickel zinc" }),
            Field({ name: "SilverZinc", id: 0x1c, conformance: "M", description: "Cell chemistry is silver zinc" }),
            Field({ name: "SodiumIon", id: 0x1d, conformance: "M", description: "Cell chemistry is sodium ion" }),
            Field({ name: "SodiumSulfur", id: 0x1e, conformance: "M", description: "Cell chemistry is sodium sulfur" }),
            Field({ name: "ZincBromide", id: 0x1f, conformance: "M", description: "Cell chemistry is zinc bromide" }),
            Field({ name: "ZincCerium", id: 0x20, conformance: "M", description: "Cell chemistry is zinc cerium" })
        ),

        Datatype(
            { name: "BatChargeStateEnum", type: "enum8", xref: "core§11.7.6.10" },
            Field({ name: "Unknown", id: 0x0, conformance: "M", description: "Unable to determine the charging state" }),
            Field({ name: "IsCharging", id: 0x1, conformance: "M", description: "The battery is charging" }),
            Field({ name: "IsAtFullCharge", id: 0x2, conformance: "M", description: "The battery is at full charge" }),
            Field({ name: "IsNotCharging", id: 0x3, conformance: "M", description: "The battery is not charging" })
        )
    ),

    Cluster(
        {
            name: "PowerTopology", id: 0x9c, classification: "application", pics: "PWRTL", xref: "core§11.8",
            details: "The Power Topology Cluster provides a mechanism for expressing how power is flowing between " +
                "endpoints."
        },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.8.4" },
            Field({
                name: "NODE", conformance: "O.a", constraint: "0", title: "NodeTopology",
                details: "This endpoint provides or consumes power to/from the entire node"
            }),
            Field({
                name: "TREE", conformance: "O.a", constraint: "1", title: "TreeTopology",
                details: "This endpoint provides or consumes power to/from itself and its child endpoints"
            }),
            Field({
                name: "SET", conformance: "O.a", constraint: "2", title: "SetTopology",
                details: "This endpoint provides or consumes power to/from a specified set of endpoints"
            }),
            Field({
                name: "DYPF", conformance: "[SET]", constraint: "3", title: "DynamicPowerFlow",
                details: "The specified set of endpoints may change"
            })
        ),

        Attribute(
            {
                name: "AvailableEndpoints", id: 0x0, type: "list", access: "R V", conformance: "SET",
                constraint: "max 20", quality: "F", xref: "core§11.8.5.1",
                details: "Indicates the list of endpoints capable of providing power to and/or consuming power from the " +
                    "endpoint hosting this server."
            },

            Field({ name: "entry", type: "endpoint-no" })
        ),

        Attribute(
            {
                name: "ActiveEndpoints", id: 0x1, type: "list", access: "R V", conformance: "DYPF",
                constraint: "max 20", quality: "N", xref: "core§11.8.5.2",
                details: "Indicates the current list of endpoints currently providing or consuming power to or from the " +
                    "endpoint hosting this server. This list shall be a subset of the value of the AvailableEndpoints " +
                    "attribute."
            },

            Field({ name: "entry", type: "endpoint-no" })
        )
    ),

    Cluster(
        {
            name: "NetworkCommissioning", id: 0x31, classification: "node", pics: "CNET", xref: "core§11.9",

            details: "Network commissioning is part of the overall Node commissioning. The main goal of Network " +
                "Commissioning Cluster is to associate a Node with or manage a Node’s one or more network interfaces. " +
                "These network interfaces can include the following types." +
                "\n" +
                "  • Wi-Fi (IEEE 802.11-2020)" +
                "\n" +
                "  • Ethernet (802.3)" +
                "\n" +
                "  • Thread (802.15.4)" +
                "\n" +
                "An instance of the Network Commissioning Cluster only applies to a single network interface instance " +
                "present. An interface, in this context, is a unique entity that can have an IPv6 address assigned to " +
                "it and ingress and egress IP packets."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.9.4" },
            Field({
                name: "WI", conformance: "O.a", constraint: "0", title: "WiFiNetworkInterface",
                details: "Wi-Fi related features"
            }),
            Field({
                name: "TH", conformance: "O.a", constraint: "1", title: "ThreadNetworkInterface",
                details: "Thread related features"
            }),
            Field({
                name: "ET", conformance: "O.a", constraint: "2", title: "EthernetNetworkInterface",
                details: "Ethernet related features"
            })
        ),

        Attribute({
            name: "MaxNetworks", id: 0x0, type: "uint8", access: "R A", conformance: "M", constraint: "min 1",
            quality: "F", xref: "core§11.9.6.1",
            details: "This shall indicate the maximum number of network configuration entries that can be added, based on " +
                "available device resources. The length of the Networks attribute shall be less than or equal to this " +
                "value."
        }),

        Attribute(
            {
                name: "Networks", id: 0x1, type: "list", access: "R A", conformance: "M",
                constraint: "max maxNetworks", default: [], xref: "core§11.9.6.2",

                details: "Indicates the network configurations that are usable on the network interface represented by this " +
                    "cluster server instance." +
                    "\n" +
                    "The order of configurations in the list reflects precedence. That is, any time the Node attempts to " +
                    "connect to the network it shall attempt to do so using the configurations in Networks Attribute in " +
                    "the order as they appear in the list." +
                    "\n" +
                    "The order of list items shall only be modified by the AddOrUpdateThreadNetwork, " +
                    "AddOrUpdateWiFiNetwork and ReorderNetwork commands. In other words, the list shall be stable over " +
                    "time, unless mutated externally." +
                    "\n" +
                    "Ethernet networks shall be automatically populated by the cluster server. Ethernet Network " +
                    "Commissioning Cluster instances shall always have exactly one NetworkInfoStruct instance in their " +
                    "Networks attribute. There shall be no way to add, update or remove Ethernet network configurations " +
                    "to those Cluster instances."
            },

            Field({ name: "entry", type: "NetworkInfoStruct" })
        ),

        Attribute({
            name: "ScanMaxTimeSeconds", id: 0x2, type: "uint8", access: "R V", conformance: "WI | TH",
            constraint: "desc", quality: "F", xref: "core§11.9.6.3",
            details: "Indicates the maximum duration taken, in seconds, by the network interface on this cluster server " +
                "instance to provide scan results." +
                "\n" +
                "See Section 11.9.7.1, “ScanNetworks Command” for usage."
        }),

        Attribute({
            name: "ConnectMaxTimeSeconds", id: 0x3, type: "uint8", access: "R V", conformance: "WI | TH",
            constraint: "desc", quality: "F", xref: "core§11.9.6.4",
            details: "Indicates the maximum duration taken, in seconds, by the network interface on this cluster server " +
                "instance to report a successful or failed network connection indication. This maximum time shall " +
                "account for all operations needed until a successful network connection is deemed to have occurred, " +
                "including, for example, obtaining IP addresses, or the execution of necessary internal retries."
        }),

        Attribute({
            name: "InterfaceEnabled", id: 0x4, type: "bool", access: "RW VA", conformance: "M", default: true,
            quality: "N", xref: "core§11.9.6.5",

            details: "Indicates whether the associated network interface is enabled or not. By default all network " +
                "interfaces SHOULD be enabled during initial commissioning (InterfaceEnabled set to true)." +
                "\n" +
                "It is undefined what happens if InterfaceEnabled is written to false on the same interface as that " +
                "which is used to write the value. In that case, it is possible that the Administrator would have to " +
                "await expiry of the fail-safe, and associated recovery of network configuration to prior safe " +
                "values, before being able to communicate with the node again (see Section 11.10.7.2, “ArmFailSafe " +
                "Command”)." +
                "\n" +
                "It may be possible to disable Ethernet interfaces but it is implementation-defined. If not " +
                "supported, a write to this attribute with a value of false shall fail with a status of " +
                "INVALID_ACTION. When disabled, an Ethernet interface would longer employ media detection. That is, a " +
                "simple unplug and replug of the cable shall NOT re-enable the interface." +
                "\n" +
                "On Ethernet-only Nodes, there shall always be at least one of the Network Commissioning server " +
                "cluster instances with InterfaceEnabled set to true."
        }),

        Attribute({
            name: "LastNetworkingStatus", id: 0x5, type: "NetworkCommissioningStatusEnum", access: "R A",
            conformance: "M", default: null, quality: "X", xref: "core§11.9.6.6",

            details: "Indicates the status of the last attempt either scan or connect to an operational network, using " +
                "this interface, whether by invocation of the ConnectNetwork command or by autonomous connection " +
                "after loss of connectivity or during initial establishment. If no such attempt was made, or no " +
                "network configurations exist in the Networks attribute, then this attribute shall be set to null." +
                "\n" +
                "This attribute is present to assist with error recovery during Network commissioning and to assist " +
                "in non-concurrent networking commissioning flows."
        }),

        Attribute({
            name: "LastNetworkId", id: 0x6, type: "octstr", access: "R A", conformance: "M",
            constraint: "1 to 32", default: null, quality: "X", xref: "core§11.9.6.7",

            details: "Indicates the NetworkID used in the last attempt to connect to an operational network, using this " +
                "interface, whether by invocation of the ConnectNetwork command or by autonomous connection after " +
                "loss of connectivity or during initial establishment. If no such attempt was made, or no network " +
                "configurations exist in the Networks attribute, then this attribute shall be set to null." +
                "\n" +
                "If a network configuration is removed from the Networks attribute using the RemoveNetwork command " +
                "after a connection attempt, this field may indicate a NetworkID that is no longer configured on the " +
                "Node." +
                "\n" +
                "This attribute is present to assist with error recovery during Network commissioning and to assist " +
                "in non-concurrent networking commissioning flows."
        }),

        Attribute({
            name: "LastConnectErrorValue", id: 0x7, type: "int32", access: "R A", conformance: "M",
            default: null, quality: "X", xref: "core§11.9.6.8",

            details: "Indicates the ErrorValue used in the last failed attempt to connect to an operational network, using " +
                "this interface, whether by invocation of the ConnectNetwork command or by autonomous connection " +
                "after loss of connectivity or during initial establishment. If no such attempt was made, or no " +
                "network configurations exist in the Networks attribute, then this attribute shall be set to null." +
                "\n" +
                "If the last connection succeeded, as indicated by a value of Success in the LastNetworkingStatus " +
                "attribute, then this field shall be set to null." +
                "\n" +
                "This attribute is present to assist with error recovery during Network commissioning and to assist " +
                "in non-concurrent networking commissioning flows."
        }),

        Attribute(
            {
                name: "SupportedWiFiBands", id: 0x8, type: "list", access: "R V", conformance: "WI",
                constraint: "min 1", quality: "F", xref: "core§11.9.6.9",
                details: "Indicates all the frequency bands supported by the Wi-Fi interface configured by the cluster " +
                    "instance."
            },

            Field({ name: "entry", type: "WiFiBandEnum" })
        ),

        Attribute({
            name: "SupportedThreadFeatures", id: 0x9, type: "ThreadCapabilitiesBitmap", access: "R V",
            conformance: "TH", quality: "F", xref: "core§11.9.6.10",

            details: "Indicates all of the Thread features supported by the Thread interface configured by the cluster " +
                "instance." +
                "\n" +
                "This attribute is primarily used to determine the most important general capabilities of the Thread " +
                "interface associated with the cluster instance, as opposed to the current runtime dynamic " +
                "configuration. Note that most run-time details of the actual Thread interface are found in the " +
                "Thread Network Diagnostics cluster, if supported."
        }),

        Attribute({
            name: "ThreadVersion", id: 0xa, type: "uint16", access: "R V", conformance: "TH", quality: "F",
            xref: "core§11.9.6.11",
            details: "Indicates the Thread version supported by the Thread interface configured by the cluster instance." +
                "\n" +
                "The format shall match the value mapping found in the \"Version TLV\" section of Thread specification. " +
                "For example, Thread 1.3.0 would have ThreadVersion set to 4."
        }),

        Command(
            {
                name: "ScanNetworks", id: 0x0, access: "A", conformance: "WI | TH", direction: "request",
                response: "ScanNetworksResponse", xref: "core§11.9.7.1",

                details: "This command is used to scan for available networks on the network interface associated with the " +
                    "cluster instance." +
                    "\n" +
                    "This command shall scan on the Cluster instance’s associated network interface for either of:" +
                    "\n" +
                    "  • All available networks (non-directed scanning)" +
                    "\n" +
                    "  • Specific networks (directed scanning)" +
                    "\n" +
                    "Scanning for available networks detects all networks of the type corresponding to the cluster server " +
                    "instance’s associated network interface that are possible to join, such as all visible Wi-Fi access " +
                    "points for Wi-Fi cluster server instances, all Thread PANs for Thread cluster server instances, " +
                    "within bounds of the maximum response size." +
                    "\n" +
                    "Scanning for a specific network (i.e. directed scanning) takes place if a network identifier (e.g. " +
                    "Wi-Fi SSID) is provided in the command arguments. Directed scanning shall restrict the result set to " +
                    "the specified network only." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "The client shall NOT expect the server to be done scanning and have responded with " +
                    "ScanNetworksResponse before ScanMaxTimeSeconds seconds have elapsed. Enough transport time " +
                    "affordances for retries SHOULD be expected before a client determines the operation to have " +
                    "timed-out." +
                    "\n" +
                    "This command shall fail with a status code of BUSY if the server determines that it will fail to " +
                    "reliably send a response due to changes of networking interface configuration at runtime for the " +
                    "interface over which the command was invoked, or if it is currently unable to proceed with such an " +
                    "operation." +
                    "\n" +
                    "For Wi-Fi-supporting servers (WI feature) the server shall always honor directed scans, and attempt " +
                    "to provide all matching BSSID which are reachable on the bands which would otherwise be attempted if " +
                    "a ConnectNetwork having the specified SSID were to take place. This command is useful for clients to " +
                    "determine reachability capabilities as seen by the server’s own radios." +
                    "\n" +
                    "For Wi-Fi-supporting servers the server shall always scan on all bands supported by the interface " +
                    "associated with the cluster instance on which the command was invoked." +
                    "\n" +
                    "If the command was invoked over the same link whose configuration is managed by a given server " +
                    "cluster instance, there may be an impact on other communication from the invoking client, as well as " +
                    "other clients, while the network interface is processing the scan. Clients SHOULD NOT use this " +
                    "command unless actively in the process of re-configuring network connectivity."
            },

            Field({
                name: "Ssid", id: 0x0, type: "octstr", conformance: "[WI]", constraint: "1 to 32", default: null,
                quality: "X", xref: "core§11.9.7.1.1",
                details: "This field, if present, shall contain the SSID for a directed scan of that particular Wi-Fi SSID. " +
                    "Otherwise, if the field is absent, or if it is null, this shall indicate scanning of all BSSID in " +
                    "range. This field shall be ignored for ScanNetworks invocations on non-Wi-Fi server instances."
            }),

            Field({
                name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "O", xref: "core§11.9.7.1.2",
                details: "The Breadcrumb field, if present, shall be used to atomically set the Breadcrumb attribute in the " +
                    "General Commissioning cluster on success of the associated command. If the command fails, the " +
                    "Breadcrumb attribute in the General Commissioning cluster shall be left unchanged."
            })
        ),

        Command(
            {
                name: "ScanNetworksResponse", id: 0x1, conformance: "WI | TH", direction: "response",
                xref: "core§11.9.7.2",

                details: "This command is used to report the results of a ScanNetworks command." +
                    "\n" +
                    "This command shall contain the status of the last ScanNetworks command, and the associated scan " +
                    "results if the operation was successful." +
                    "\n" +
                    "Results are valid only if NetworkingStatus is Success." +
                    "\n" +
                    "Before generating a ScanNetworksResponse, the server shall set the LastNetworkingStatus attribute " +
                    "value to the NetworkingStatus matching the response."
            },

            Field({
                name: "NetworkingStatus", id: 0x0, type: "NetworkCommissioningStatusEnum", conformance: "M",
                constraint: "desc", xref: "core§11.9.7.2.1",

                details: "The NetworkingStatus field shall indicate the status of the last scan operation, taking one of these " +
                    "values:" +
                    "\n" +
                    "  • Success: Scanning succeeded." +
                    "\n" +
                    "  • NetworkNotFound: No instance of an explicitly-provided network identifier was found during the " +
                    "    scan. This error cannot occur if no network identifier was provided, such as when scanning for " +
                    "    all available networks." +
                    "\n" +
                    "  • OutOfRange: Network identifier was invalid (e.g. empty, too long, etc)." +
                    "\n" +
                    "  • RegulatoryError: Could not scan on any bands due to lack of regulatory configuration." +
                    "\n" +
                    "  • UnknownError: An internal error occurred during scanning."
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "O", constraint: "max 512",
                xref: "core§11.9.7.2.2",
                details: "This field, if present and non-empty, may contain error information which may be communicated to the " +
                    "user in case the NetworkingStatus was not Success. Its purpose is to help developers in " +
                    "troubleshooting errors and may go into logs or crash reports."
            }),

            Field(
                {
                    name: "WiFiScanResults", id: 0x2, type: "list", conformance: "WI", constraint: "desc",
                    xref: "core§11.9.7.2.3",

                    details: "If NetworkingStatus was Success, this field shall contain the Wi-Fi network scan results. The list " +
                        "may be empty if none were found in range on the bands supported by the interface, or if directed " +
                        "scanning had been used and the desired SSID was not found in range." +
                        "\n" +
                        "The maximum number of results present in the result list supported may depend on memory and may " +
                        "contain a subset of possibilities, to avoid memory exhaustion on the cluster server and avoid " +
                        "crossing the maximum command response size supported (see Section 4.4.4, “Message Size " +
                        "Requirements”)." +
                        "\n" +
                        "The order in which results are reported is implementation-specific. Results SHOULD be reported in " +
                        "decreasing RSSI order, even if RSSI is not reported in the response, to maximize the likelihood that " +
                        "most likely to be reachable elements are included within the size limits of the response."
                },

                Field({ name: "entry", type: "WiFiInterfaceScanResultStruct" })
            ),

            Field(
                {
                    name: "ThreadScanResults", id: 0x3, type: "list", conformance: "TH", constraint: "desc",
                    xref: "core§11.9.7.2.4",

                    details: "If NetworkingStatus was Success, this field shall contain the Thread network scan results. The list " +
                        "may be empty if none were found in range on the bands supported by the interface." +
                        "\n" +
                        "The maximum number of results present in the result list supported may depend on memory and may " +
                        "contain a subset of possibilities, to avoid memory exhaustion on the cluster server and avoid " +
                        "crossing the maximum command response size supported (see Section 4.4.4, “Message Size " +
                        "Requirements”)." +
                        "\n" +
                        "The order in which results are reported is implementation-specific. Results SHOULD be reported in " +
                        "decreasing LQI order, to maximize the likelihood that most likely to be reachable elements are " +
                        "included within the size limits of the response."
                },

                Field({ name: "entry", type: "ThreadInterfaceScanResultStruct" })
            )
        ),

        Command(
            {
                name: "AddOrUpdateWiFiNetwork", id: 0x2, access: "A", conformance: "WI", direction: "request",
                response: "NetworkConfigResponse", xref: "core§11.9.7.3",

                details: "This command is used to add or update a Wi-Fi network configuration." +
                    "\n" +
                    "This command shall be used to add or modify Wi-Fi network configurations." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "The Credentials associated with the network are not readable after execution of this command, as " +
                    "they do not appear in the Networks attribute, for security reasons." +
                    "\n" +
                    "If this command contains a ClientIdentifier, and the Networks list does not contain an entry with a " +
                    "matching ClientIdentifier, then this command shall fail with a status of NOT_FOUND." +
                    "\n" +
                    "See Section 11.9.7.5, “Common processing of AddOrUpdateWiFiNetwork and AddOrUpdateThreadNetwork” for " +
                    "behavior of addition/update."
            },

            Field({
                name: "Ssid", id: 0x0, type: "octstr", conformance: "M", constraint: "max 32",
                xref: "core§11.9.7.3.1",
                details: "This field shall contain the SSID to which to attempt connection. Specific BSSID selection is not " +
                    "supported by this cluster."
            }),

            Field({
                name: "Credentials", id: 0x1, type: "octstr", conformance: "M", constraint: "max 64",
                xref: "core§11.9.7.3.2",

                details: "Credentials is the passphrase or PSK for the network (if any is needed)." +
                    "\n" +
                    "Security type, cipher and credential format (passphrase or PSK) shall be contextually auto-selected " +
                    "during execution of the ConnectNetwork command and during subsequent operational state network " +
                    "connections, based on the most secure Wi-Fi security type available within beacons and probe " +
                    "responses for the set of all discovered BSSIDs for the configured SSID. The type of PSK or " +
                    "passphrase used shall be inferred based on the length and contents of the Credentials field " +
                    "provided, matching the security type chosen." +
                    "\n" +
                    "Valid Credentials length are:" +
                    "\n" +
                    "  • 0 bytes: Unsecured (open) connection" +
                    "\n" +
                    "  • 5 bytes: WEP-64 passphrase" +
                    "\n" +
                    "  • 10 hexadecimal ASCII characters: WEP-64 40-bit hex raw PSK" +
                    "\n" +
                    "  • 13 bytes: WEP-128 passphrase" +
                    "\n" +
                    "  • 26 hexadecimal ASCII characters: WEP-128 104-bit hex raw PSK" +
                    "\n" +
                    "  • 8..63 bytes: WPA/WPA2/WPA3 passphrase" +
                    "\n" +
                    "  • 64 bytes: WPA/WPA2/WPA3 raw hex PSK These lengths shall be contextually interpreted based on the " +
                    "    security type of the BSSID where connection will occur." +
                    "\n" +
                    "When the length of Credentials and available set of BSSID admits more than one option, such as the " +
                    "presence of both WPA2 and WPA security type within the result set, WPA2 shall be considered more " +
                    "secure." +
                    "\n" +
                    "Note that it may occur that a station cannot connect to a particular access point with higher " +
                    "security and selects a lower security connectivity type if the link quality is deemed to be too low " +
                    "to achieve successful operation, or if all retry attempts fail."
            }),

            Field({
                name: "Breadcrumb", id: 0x2, type: "uint64", conformance: "O", xref: "core§11.9.7.3.3",
                details: "See Section 11.9.7.1.2, “Breadcrumb Field” for usage."
            })
        ),

        Command(
            {
                name: "AddOrUpdateThreadNetwork", id: 0x3, access: "A", conformance: "TH", direction: "request",
                response: "NetworkConfigResponse", xref: "core§11.9.7.4",

                details: "This command is used to add or update a Thread network configuration." +
                    "\n" +
                    "This command shall be used to add or modify Thread network configurations." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "See Section 11.9.7.5, “Common processing of AddOrUpdateWiFiNetwork and AddOrUpdateThreadNetwork” for " +
                    "behavior of addition/update." +
                    "\n" +
                    "The XPAN ID in the OperationalDataset serves as the NetworkID for the network configuration to be " +
                    "added or updated." +
                    "\n" +
                    "If the Networks attribute does not contain an entry with the same NetworkID as the one provided in " +
                    "the OperationalDataset, the operation shall be considered an addition, otherwise, it shall be " +
                    "considered an update."
            },

            Field({
                name: "OperationalDataset", id: 0x0, type: "octstr", conformance: "M", constraint: "max 254",
                xref: "core§11.9.7.4.1",
                details: "The OperationalDataset field shall contain the Thread Network Parameters, including channel, PAN ID, " +
                    "and Extended PAN ID." +
                    "\n" +
                    "The encoding for the OperationalDataset field is defined in the Thread specification. The client " +
                    "shall pass the OperationalDataset as an opaque octet string."
            }),

            Field({
                name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "O", xref: "core§11.9.7.4.2",
                details: "See Section 11.9.7.1.2, “Breadcrumb Field” for usage."
            })
        ),

        Command(
            {
                name: "RemoveNetwork", id: 0x4, access: "A", conformance: "WI | TH", direction: "request",
                response: "NetworkConfigResponse", xref: "core§11.9.7.6",

                details: "This command is used to remove a network configuration on the network interface associated with the " +
                    "cluster instance." +
                    "\n" +
                    "This command shall remove the network configuration from the Cluster if there was already a network " +
                    "configuration with the same NetworkID. The relative order of the entries in the Networks attribute " +
                    "shall remain unchanged, except for the removal of the requested network configuration." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "If the Networks attribute does not contain a matching entry, the command shall immediately respond " +
                    "with NetworkConfigResponse having NetworkingStatus status field set to NetworkIdNotFound." +
                    "\n" +
                    "On success, the NetworkConfigResponse command shall have its NetworkIndex field set to the 0- based " +
                    "index of the entry in the Networks attribute that was just removed, and a NetworkingStatus status " +
                    "field set to Success."
            },

            Field({
                name: "NetworkId", id: 0x0, type: "octstr", conformance: "M", constraint: "1 to 32",
                xref: "core§11.9.7.6.1",
                details: "This field shall contain the NetworkID for the entry to remove: the SSID for Wi-Fi and XPAN ID for " +
                    "Thread."
            }),

            Field({
                name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "O", xref: "core§11.9.7.6.2",
                details: "See Section 11.9.7.1.2, “Breadcrumb Field” for usage."
            })
        ),

        Command(
            {
                name: "NetworkConfigResponse", id: 0x5, conformance: "WI | TH", direction: "response",
                xref: "core§11.9.7.7",

                details: "This command is used to report the results of a network configuration command " +
                    "(AddOrUpdateWiFiNetwork, AddOrUpdateThreadNetwork, or RemoveNetwork)." +
                    "\n" +
                    "This response command relates status information for some commands which require it as their " +
                    "response command. See each individual cluster server command for the situations that may cause a " +
                    "NetworkingStatus different than Success." +
                    "\n" +
                    "Before generating a NetworkConfigResponse, the server shall set the LastNetworkingStatus attribute " +
                    "value to the NetworkingStatus matching the response." +
                    "\n" +
                    "Before generating a NetworkConfigResponse, the server shall set the LastNetworkID attribute value to " +
                    "the NetworkID that was used in the command for which an invocation caused the response to be " +
                    "generated."
            },

            Field({
                name: "NetworkingStatus", id: 0x0, type: "NetworkCommissioningStatusEnum", conformance: "M",
                constraint: "desc", xref: "core§11.9.7.7.1",

                details: "The NetworkingStatus field shall indicate the status of the last operation attempting to modify the " +
                    "Networks attribute configuration, taking one of these values:" +
                    "\n" +
                    "  • Success: Operation succeeded." +
                    "\n" +
                    "  • OutOfRange: Network identifier was invalid (e.g. empty, too long, etc)." +
                    "\n" +
                    "  • BoundsExceeded: Adding this network configuration would exceed the limit defined by MaxNetworks." +
                    "\n" +
                    "  • NetworkIdNotFound: The network identifier was expected to be found, but was not found among the " +
                    "    added network configurations in Networks attribute." +
                    "\n" +
                    "  • UnknownError: An internal error occurred during the operation."
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "O", constraint: "max 512",
                xref: "core§11.9.7.7.2",
                details: "See Section 11.9.7.2.2, “DebugText Field” for usage."
            }),

            Field({
                name: "NetworkIndex", id: 0x2, type: "uint8", conformance: "NetworkingStatus == Success",
                constraint: "max maxNetworks - 1", xref: "core§11.9.7.7.3",
                details: "This field shall contain the 0-based index of the entry in the Networks attribute that was last " +
                    "added, updated or removed successfully by the associated request command."
            })
        ),

        Command(
            {
                name: "ConnectNetwork", id: 0x6, access: "A", conformance: "WI | TH", direction: "request",
                response: "ConnectNetworkResponse", xref: "core§11.9.7.8",

                details: "This command is used to connect to a network on the network interface associated with the cluster " +
                    "instance." +
                    "\n" +
                    "This command shall attempt to connect to a network whose configuration was previously added by " +
                    "either the AddOrUpdateWiFiNetwork or AddOrUpdateThreadNetwork commands. Network is identified by its " +
                    "NetworkID." +
                    "\n" +
                    "This command shall fail with a BUSY status code returned to the initiator if the server is currently " +
                    "unable to proceed with such an operation, such as if it is currently attempting to connect in the " +
                    "background, or is already proceeding with a prior ConnectNetwork." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "Before connecting to the new network, the Node shall disconnect the operational network connections " +
                    "managed by any other Network Commissioning cluster instances (whether under the Root Node or a " +
                    "Secondary Network Interface), where those connections are not represented by an entry in the " +
                    "Networks attribute of the corresponding cluster instance. This ensures that an Administrator or " +
                    "Commissioner can reliably reconfigure the operational network connection of a device that has one or " +
                    "more Secondary Network interfaces, for example by removing the active network configuration from one " +
                    "cluster instance, followed by adding a new configuration and calling ConnectNetwork on a different " +
                    "cluster instance." +
                    "\n" +
                    "Success or failure of this command shall be communicated by the ConnectNetworkResponse command, " +
                    "unless some data model validations caused a FAILURE status to be sent prior to finishing execution " +
                    "of the command. The ConnectNetworkResponse shall indicate the value Success in the NetworkingStatus " +
                    "field on successful connection. On failure to connect, the ConnectNetworkResponse shall contain an " +
                    "appropriate NetworkingStatus, DebugText and ErrorValue indicating the reason for failure." +
                    "\n" +
                    "The amount of time needed to determine successful or failing connectivity on the cluster server’s " +
                    "associated interface is provided by the ConnectMaxTimeSeconds attribute. Clients shall NOT consider " +
                    "the connection to have timed-out until at least that duration has taken place. For non-concurrent " +
                    "commissioning situations, the client SHOULD allow additional margin of time to account for its delay " +
                    "in executing operational discovery of the Node once it is connected to the new network." +
                    "\n" +
                    "On successful connection, the entry associated with the given Network configuration in the Networks " +
                    "attribute shall indicate its Connected field set to true, and all other entries, if any exist, shall " +
                    "indicate their Connected field set to false." +
                    "\n" +
                    "On failure to connect, the entry associated with the given Network configuration in the Networks " +
                    "attribute shall indicate its Connected field set to false." +
                    "\n" +
                    "The precedence order of any entry subject to ConnectNetwork shall NOT change within the Networks " +
                    "attribute." +
                    "\n" +
                    "Even after successfully connecting to a network, the configuration shall revert to the prior state " +
                    "of configuration if the CommissioningComplete command (see Section 11.10.7.6, “CommissioningComplete " +
                    "Command”) is not successfully invoked before expiry of the Fail-Safe timer." +
                    "\n" +
                    "When non-concurrent commissioning is being used by a Commissioner or Administrator, the " +
                    "ConnectNetworkResponse shall be sent with the NetworkingStatus field set to Success prior to closing " +
                    "the commissioning channel, even if not yet connected to the operational network, unless the device " +
                    "would be incapable of joining that network, in which case the usual failure path described in the " +
                    "prior paragraphs shall be followed. Once the commissioning channel is closed, the operational " +
                    "channel will be started. It is possible that the only method to determine success of the operation " +
                    "is operational discovery of the Node on the new operational network. Therefore, before invoking the " +
                    "ConnectNetwork command, the client SHOULD re-invoke the Arm Fail-Safe command with a duration that " +
                    "meets the following:" +
                    "\n" +
                    "  1. Sufficient time to meet the minimum required time (see Section 11.9.6.4, “ConnectMaxTimeSeconds " +
                    "     Attribute”) that may be taken by the server to connect to the desired network." +
                    "\n" +
                    "  2. Sufficient time to account for possible message-layer retries when a response is requested." +
                    "\n" +
                    "  3. Sufficient time to allow operational discovery on the new network by a Commissioner or " +
                    "     Administrator." +
                    "\n" +
                    "  4. Sufficient time to establish a CASE session after operational discovery" +
                    "\n" +
                    "  5. Not so long that, in error situations, the delay to reverting back to being discoverable for " +
                    "     commissioning with a previous configuration would cause significant user-perceived delay." +
                    "\n" +
                    "Note as well that the CommissioningTimeout duration provided in a prior OpenCommissioningWindow or " +
                    "OpenBasicCommissioningWindow command may impact the total time available to proceed with error " +
                    "recovery after a connection failure." +
                    "\n" +
                    "The LastNetworkingStatus, LastNetworkID and LastConnectErrorValue attributes may assist the client " +
                    "in determining the reason for a failure after reconnecting over a Commissioning channel, especially " +
                    "in non-concurrent commissioning situations."
            },

            Field({
                name: "NetworkId", id: 0x0, type: "octstr", conformance: "M", constraint: "1 to 32",
                xref: "core§11.9.7.8.1",
                details: "This field shall contain the NetworkID for the entry used to configure the connection: the SSID for " +
                    "Wi-Fi and XPAN ID for Thread."
            }),

            Field({
                name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "O", xref: "core§11.9.7.8.2",
                details: "See Section 11.9.7.1.2, “Breadcrumb Field” for usage."
            })
        ),

        Command(
            {
                name: "ConnectNetworkResponse", id: 0x7, conformance: "WI | TH", direction: "response",
                xref: "core§11.9.7.9",

                details: "This command is used to report the results of a ConnectNetwork command." +
                    "\n" +
                    "Before generating a ConnectNetworkResponse, the server shall:" +
                    "\n" +
                    "  • Set the LastNetworkingStatus attribute value to the NetworkingStatus matching the response." +
                    "\n" +
                    "  • Set the LastNetworkID attribute value to the NetworkID that was used in the ConnectNetwork " +
                    "    command which caused the response to be generated." +
                    "\n" +
                    "  • Set the LastConnectErrorValue attribute value to the ErrorValue matching the response, including " +
                    "    setting it to null if the ErrorValue is not applicable."
            },

            Field({
                name: "NetworkingStatus", id: 0x0, type: "NetworkCommissioningStatusEnum", conformance: "M",
                xref: "core§11.9.7.9.1",

                details: "The NetworkingStatus field shall indicate the status of the last connection attempt, taking one of " +
                    "these values:" +
                    "\n" +
                    "  • Success: Connection succeeded." +
                    "\n" +
                    "  • NetworkNotFound: No instance of an explicitly-provided network identifier was found during the " +
                    "    attempt to join the network." +
                    "\n" +
                    "  • OutOfRange: Network identifier was invalid (e.g. empty, too long, etc)." +
                    "\n" +
                    "  • NetworkIdNotFound: The network identifier was not found among the added network configurations " +
                    "    in Networks attribute." +
                    "\n" +
                    "  • RegulatoryError: Could not connect to a network due to lack of regulatory configuration." +
                    "\n" +
                    "  • UnknownError: An internal error occurred during the operation." +
                    "\n" +
                    "  • Association errors (see also description of errors in NetworkCommissioningStatusEnum): " +
                    "    AuthFailure, UnsupportedSecurity, OtherConnectionFailure, IPV6Failed, IPBindFailed"
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "O", xref: "core§11.9.7.9.2",
                details: "See Section 11.9.7.2.2, “DebugText Field” for usage."
            }),

            Field({
                name: "ErrorValue", id: 0x2, type: "int32", conformance: "M", quality: "X", xref: "core§11.9.7.9.3",

                details: "  • ErrorValue interpretation for Wi-Fi association errors:" +
                    "\n" +
                    "    ◦ On any association failure during enabling of a network, the ErrorValue field shall be set to " +
                    "      the Status Code value that was present in the last frame related to association where Status " +
                    "      Code was not equal to zero and which caused the failure of a final retry attempt, if this " +
                    "      final failure was due to one of the following Management frames:" +
                    "\n" +
                    "      ▪ Association Response (Type 0, Subtype 1)" +
                    "\n" +
                    "      ▪ Reassociation Response (Type 0, Subtype 3)" +
                    "\n" +
                    "      ▪ Authentication (Type 0, Subtype 11)" +
                    "\n" +
                    "    ◦ Table 9-50 \"Status Codes\" in IEEE 802.11-2020 contains a description of all values possible, " +
                    "      which can unambiguously be used to determine the cause, such as an invalid security type, " +
                    "      unsupported rate, etc." +
                    "\n" +
                    "  • Otherwise, the ErrorValue field shall contain an implementation-dependent value which may be " +
                    "    used by a reader of the structure to record, report or diagnose the failure."
            })
        ),

        Command(
            {
                name: "ReorderNetwork", id: 0x8, access: "A", conformance: "WI | TH", direction: "request",
                response: "NetworkConfigResponse", xref: "core§11.9.7.10",
                details: "This command is used to re-order the network configuration list." +
                    "\n" +
                    "This command shall set the specific order of the network configuration selected by its NetworkID in " +
                    "the Networks attribute to match the position given by NetworkIndex."
            },

            Field({
                name: "NetworkId", id: 0x0, type: "octstr", conformance: "M", constraint: "1 to 32",
                xref: "core§11.9.7.10.1",
                details: "This field shall contain the NetworkID for the entry to reorder: the SSID for Wi-Fi and XPAN ID for " +
                    "Thread."
            }),

            Field({
                name: "NetworkIndex", id: 0x1, type: "uint8", conformance: "M", constraint: "desc",
                xref: "core§11.9.7.10.2",
                details: "This field shall contain the 0-based index of the new desired position of the entry in the Networks " +
                    "attribute."
            }),

            Field(
                {
                    name: "Breadcrumb", id: 0x2, type: "uint64", conformance: "O", xref: "core§11.9.7.10.3",

                    details: "See Section 11.9.7.1.2, “Breadcrumb Field” for usage." +
                        "\n" +
                        "### Effect when received" +
                        "\n" +
                        "If the Networks attribute does not contain a matching entry, the command shall immediately respond " +
                        "with NetworkConfigResponse having NetworkingStatus status field set to NetworkIdNotFound." +
                        "\n" +
                        "If the NetworkIndex field has a value larger or equal to the current number of entries in the " +
                        "Networks attribute, the command shall immediately respond with NetworkConfigResponse having " +
                        "NetworkingStatus status field set to OutOfRange." +
                        "\n" +
                        "On success, the NetworkConfigResponse command shall have its NetworkIndex field set to the 0- based " +
                        "index of the entry in the Networks attribute that was just updated, matching the incoming " +
                        "NetworkIndex, and a NetworkingStatus status field set to Success." +
                        "\n" +
                        "The entry selected shall be inserted at the new position in the list. All other entries, if any " +
                        "exist, shall be moved to allow the insertion, in a way that they all retain their existing relative " +
                        "order between each other, with the exception of the newly re-ordered entry." +
                        "\n" +
                        "Re-ordering to the same NetworkIndex as the current location shall be considered as a success and " +
                        "yield no visible changes of the Networks attribute." +
                        "\n" +
                        "### Examples of re-ordering" +
                        "\n" +
                        "To better illustrate the re-ordering operation, consider this initial state, exemplary of a Wi-Fi " +
                        "device:" +
                        "\n" +
                        "On receiving ReorderNetwork with:" +
                        "\n" +
                        "  • NetworkID = Home-Guest" +
                        "\n" +
                        "  • NetworkIndex = 0" +
                        "\n" +
                        "The outcome, after applying to the initial state would be:" +
                        "\n" +
                        "In the above outcome, FancyCat and BlueDolphin moved \"down\" and Home-Guest became the highest " +
                        "priority network in the list." +
                        "\n" +
                        "On receiving ReorderNetwork with:" +
                        "\n" +
                        "  • NetworkID = FancyCat" +
                        "\n" +
                        "  • NetworkIndex = 3" +
                        "\n" +
                        "The outcome, after applying to the initial state would be:" +
                        "\n" +
                        "In the above outcome, BlueDolphin, Home-Guest and WillowTree moved \"up\" and FancyCat became the " +
                        "lowest priority network in the list."
                }
            )
        ),

        Datatype(
            {
                name: "WiFiSecurityBitmap", type: "map8", xref: "core§11.9.5.1",
                details: "WiFiSecurityBitmap encodes the supported Wi-Fi security types present in the Security field of the " +
                    "WiFiInterfaceScanResultStruct."
            },
            Field({ name: "Unencrypted", constraint: "0", description: "Supports unencrypted Wi-Fi" }),
            Field({ name: "Wep", constraint: "1", description: "Supports Wi-Fi using WEP security" }),
            Field({ name: "WpaPersonal", constraint: "2", description: "Supports Wi-Fi using WPA-Personal security" }),
            Field({ name: "Wpa2Personal", constraint: "3", description: "Supports Wi-Fi using WPA2-Personal security" }),
            Field({ name: "Wpa3Personal", constraint: "4", description: "Supports Wi-Fi using WPA3-Personal security" })
        ),

        Datatype(
            {
                name: "ThreadCapabilitiesBitmap", type: "map16", xref: "core§11.9.5.2",
                details: "The ThreadCapabilitiesBitmap encodes the supported Thread features and capabilities of a " +
                    "Thread-enabled network interface." +
                    "\n" +
                    "NOTE The valid combinations of capabilities are restricted and dependent on Thread version."
            },

            Field({
                name: "IsBorderRouterCapable", constraint: "0",
                description: "Thread Border Router functionality is present"
            }),
            Field({
                name: "IsRouterCapable", constraint: "1",
                description: "Router mode is supported (interface could be in router or REED mode)"
            }),
            Field({ name: "IsSleepyEndDeviceCapable", constraint: "2", description: "Sleepy end-device mode is supported" }),
            Field({
                name: "IsFullThreadDevice", constraint: "3",
                description: "Device is a full Thread device (opposite of Minimal Thread Device)"
            }),
            Field({
                name: "IsSynchronizedSleepyEndDeviceCapable", constraint: "4",
                description: "Synchronized sleepy end-device mode is supported"
            })
        ),

        Datatype(
            {
                name: "WiFiBandEnum", type: "enum8", xref: "core§11.9.5.3",
                details: "WiFiBandEnum encodes a supported Wi-Fi frequency band present in the WiFiBand field of the " +
                    "WiFiInterfaceScanResultStruct."
            },
            Field({ name: "2G4", id: 0x0, conformance: "O.b+", description: "2.4GHz - 2.401GHz to2.495GHz(802.11b/g/n/ax)" }),
            Field({ name: "3G65", id: 0x1, conformance: "O.b+", description: "3.65GHz - 3.655GHz to3.695GHz (802.11y)" }),
            Field({ name: "5G", id: 0x2, conformance: "O.b+", description: "5GHz - 5.150GHz to5.895GHz(802.11a/n/ac/ax)" }),
            Field({
                name: "6G", id: 0x3, conformance: "O.b+",
                description: "6GHz - 5.925GHz to7.125GHz (802.11ax / Wi-Fi 6E)"
            }),
            Field({ name: "60G", id: 0x4, conformance: "O.b+", description: "60GHz - 57.24GHz to70.20GHz (802.11ad/ay)" }),
            Field({ name: "1G", id: 0x5, conformance: "O.b+", description: "Sub-1GHz - 755MHz to 931MHz (802.11ah)" })
        ),

        Datatype(
            { name: "NetworkCommissioningStatusEnum", type: "enum8", xref: "core§11.9.5.4" },
            Field({ name: "Success", id: 0x0, conformance: "M", description: "OK, no error" }),
            Field({ name: "OutOfRange", id: 0x1, conformance: "M", description: "Value Outside Range" }),
            Field({
                name: "BoundsExceeded", id: 0x2, conformance: "M",
                description: "A collection would exceed its size limit"
            }),
            Field({
                name: "NetworkIdNotFound", id: 0x3, conformance: "M",
                description: "The NetworkID is not among the collection of added networks"
            }),
            Field({
                name: "DuplicateNetworkId", id: 0x4, conformance: "M",
                description: "The NetworkID is already among the collection of added networks"
            }),
            Field({ name: "NetworkNotFound", id: 0x5, conformance: "M", description: "Cannot find AP: SSID Not found" }),
            Field({
                name: "RegulatoryError", id: 0x6, conformance: "M",
                description: "Cannot find AP: Mismatch on band/channels/regulatory domain/ 2.4GHz vs 5GHz"
            }),
            Field({
                name: "AuthFailure", id: 0x7, conformance: "M",
                description: "Cannot associate due to authentication failure"
            }),
            Field({
                name: "UnsupportedSecurity", id: 0x8, conformance: "M",
                description: "Cannot associate due to unsupported security mode"
            }),
            Field({ name: "OtherConnectionFailure", id: 0x9, conformance: "M", description: "Other association failure" }),
            Field({ name: "Ipv6Failed", id: 0xa, conformance: "M", description: "Failure to generate an IPv6 address" }),
            Field({ name: "IpBindFailed", id: 0xb, conformance: "M", description: "Failure to bind Wi-Fi <-> IP interfaces" }),
            Field({ name: "UnknownError", id: 0xc, conformance: "M", description: "Unknown error" })
        ),

        Datatype(
            {
                name: "NetworkInfoStruct", type: "struct", xref: "core§11.9.5.5",
                details: "NetworkInfoStruct struct describes an existing network configuration, as provided in the Networks " +
                    "attribute."
            },

            Field({
                name: "NetworkId", id: 0x0, type: "octstr", conformance: "M", constraint: "1 to 32",
                xref: "core§11.9.5.5.1",

                details: "Every network is uniquely identified (for purposes of commissioning) by a NetworkID mapping to the " +
                    "following technology-specific properties:" +
                    "\n" +
                    "  • SSID for Wi-Fi" +
                    "\n" +
                    "  • Extended PAN ID for Thread" +
                    "\n" +
                    "  • Network interface instance name at operating system (or equivalent unique name) for Ethernet." +
                    "\n" +
                    "The semantics of the NetworkID field therefore varies between network types accordingly. It contains " +
                    "SSID for Wi-Fi networks, Extended PAN ID (XPAN ID) for Thread networks and netif name for Ethernet " +
                    "networks." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> SSID in Wi-Fi is a collection of 1-32 bytes, the text encoding of which is not specified. " +
                    "  Implementations must be careful to support reporting byte strings without requiring a particular " +
                    "  encoding for transfer. Only the commissioner should try to potentially decode the bytes. The most " +
                    "  common encoding is UTF-8, however this is just a convention. Some configurations may use Latin-1 " +
                    "  or other character sets. A commissioner may decode using UTF-8, replacing encoding errors with \"?\" " +
                    "  at the application level while retaining the underlying representation." +
                    "\n" +
                    "XPAN ID is a big-endian 64-bit unsigned number, represented on the first 8 octets of the octet " +
                    "string."
            }),

            Field({
                name: "Connected", id: 0x1, type: "bool", conformance: "M", xref: "core§11.9.5.5.2",
                details: "This field shall indicate the connected status of the associated network, where \"connected\" means " +
                    "currently linked to the network technology (e.g. Associated for a Wi-Fi network, media connected for " +
                    "an Ethernet network)."
            })
        ),

        Datatype(
            {
                name: "WiFiInterfaceScanResultStruct", type: "struct", xref: "core§11.9.5.6",
                details: "WiFiInterfaceScanResultStruct represents a single Wi-Fi network scan result."
            },
            Field({ name: "Security", id: 0x0, type: "WiFiSecurityBitmap", conformance: "WI" }),
            Field({ name: "Ssid", id: 0x1, type: "octstr", conformance: "WI", constraint: "max 32" }),
            Field({ name: "Bssid", id: 0x2, type: "octstr", conformance: "WI", constraint: "6" }),
            Field({ name: "Channel", id: 0x3, type: "uint16", conformance: "WI" }),
            Field({
                name: "WiFiBand", id: 0x4, type: "WiFiBandEnum", conformance: "[WI]", xref: "core§11.9.5.6.1",
                details: "This field, if present, may be used to differentiate overlapping channel number values across " +
                    "different Wi-Fi frequency bands."
            }),
            Field({
                name: "Rssi", id: 0x5, type: "int8", conformance: "[WI]", xref: "core§11.9.5.6.2",
                details: "This field, if present, shall denote the signal strength in dBm of the associated scan result."
            })
        ),

        Datatype(
            {
                name: "ThreadInterfaceScanResultStruct", type: "struct", xref: "core§11.9.5.7",
                details: "ThreadInterfaceScanResultStruct represents a single Thread network scan result."
            },
            Field({ name: "PanId", id: 0x0, type: "uint16", conformance: "TH", constraint: "max 65534" }),
            Field({ name: "ExtendedPanId", id: 0x1, type: "uint64", conformance: "TH" }),
            Field({ name: "NetworkName", id: 0x2, type: "string", conformance: "TH", constraint: "1 to 16" }),
            Field({ name: "Channel", id: 0x3, type: "uint16", conformance: "TH" }),
            Field({ name: "Version", id: 0x4, type: "uint8", conformance: "TH" }),
            Field({
                name: "ExtendedAddress", id: 0x5, type: "hwadr", conformance: "TH", xref: "core§11.9.5.7.1",
                details: "ExtendedAddress stands for an IEEE 802.15.4 Extended Address."
            }),
            Field({ name: "Rssi", id: 0x6, type: "int8", conformance: "TH" }),
            Field({ name: "Lqi", id: 0x7, type: "uint8", conformance: "TH" })
        )
    ),

    Cluster(
        {
            name: "GeneralCommissioning", id: 0x30, classification: "node", pics: "CGEN", xref: "core§11.10",
            details: "This cluster is used to manage basic commissioning lifecycle." +
                "\n" +
                "This cluster also represents responsibilities related to commissioning that don’t well fit other " +
                "commissioning clusters, like Section 11.9, “Network Commissioning Cluster”. It also hosts " +
                "functionalities those other clusters may depend on."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.10.4" },
            Field({
                name: "TC", conformance: "O", constraint: "0", title: "TermsAndConditions",
                details: "Supports Terms & Conditions acknowledgement"
            })
        ),

        Attribute({
            name: "Breadcrumb", id: 0x0, type: "uint64", access: "RW VA", conformance: "M", default: 0,
            xref: "core§11.10.6.1",

            details: "This attribute allows for the storage of a client-provided small payload which Administrators and " +
                "Commissioners may write and then subsequently read, to keep track of their own progress. This may be " +
                "used by the Commissioner to avoid repeating already-executed actions upon re-establishing a " +
                "commissioning link after an error." +
                "\n" +
                "On start/restart of the server, such as when a device is power-cycled, this attribute shall be reset " +
                "to zero." +
                "\n" +
                "Some commands related to commissioning also have a side-effect of updating or resetting this " +
                "attribute and this is specified in their respective functional descriptions." +
                "\n" +
                "The format of the value within this attribute is unspecified and its value is not otherwise used by " +
                "the functioning of any cluster, other than being set as a side-effect of commands where this " +
                "behavior is described."
        }),

        Attribute({
            name: "BasicCommissioningInfo", id: 0x1, type: "BasicCommissioningInfo", access: "R V",
            conformance: "M", constraint: "desc", quality: "F", xref: "core§11.10.6.2",
            details: "This attribute shall describe critical parameters needed at the beginning of commissioning flow." +
                "\n" +
                "See Section 11.10.5.3, “BasicCommissioningInfo Type” for more information."
        }),

        Attribute({
            name: "RegulatoryConfig", id: 0x2, type: "RegulatoryLocationTypeEnum", access: "R V",
            conformance: "M", default: { type: "reference", name: "LocationCapability" },
            xref: "core§11.10.6.3",
            details: "Indicates the regulatory configuration for the product." +
                "\n" +
                "Note that the country code is part of Basic Information Cluster and therefore NOT listed on the " +
                "RegulatoryConfig attribute."
        }),

        Attribute({
            name: "LocationCapability", id: 0x3, type: "RegulatoryLocationTypeEnum", access: "R V",
            conformance: "M", default: 2, quality: "F", xref: "core§11.10.6.4",

            details: "LocationCapability is statically set by the manufacturer and indicates if this Node needs to be told " +
                "an exact RegulatoryLocation. For example a Node which is \"Indoor Only\" would not be certified for " +
                "outdoor use at all, and thus there is no need for a commissioner to set or ask the user about " +
                "whether the device will be used inside or outside. However a device which states its capability is " +
                "\"Indoor/Outdoor\" means it would like clarification if possible." +
                "\n" +
                "For Nodes without radio network interfaces (e.g. Ethernet-only devices), the value IndoorOutdoor " +
                "shall always be used." +
                "\n" +
                "The default value of the RegulatoryConfig attribute is the value of LocationCapability attribute. " +
                "This means devices always have a safe default value, and Commissioners which choose to implement " +
                "smarter handling can."
        }),

        Attribute({
            name: "SupportsConcurrentConnection", id: 0x4, type: "bool", access: "R V", conformance: "M",
            default: true, quality: "F", xref: "core§11.10.6.5",
            details: "Indicates whether this device supports \"concurrent connection flow\" commissioning mode (see Section " +
                "5.5, “Commissioning Flows”). If false, the device only supports \"non-concurrent connection flow\" " +
                "mode."
        }),

        Attribute({
            name: "TcAcceptedVersion", id: 0x5, type: "uint16", access: "R A", conformance: "TC", quality: "N",
            xref: "core§11.10.6.6",

            details: "Indicates the last version of the T&Cs for which the device received user acknowledgements. On " +
                "factory reset this field shall be reset to 0." +
                "\n" +
                "When Custom Commissioning Flow is used to obtain user consent (e. g. because the Commissioner does " +
                "not support the TC feature), the manufacturer-provided means for obtaining user consent shall ensure " +
                "that this attribute is set to a value which is greater than or equal to TCMinRequiredVersion before " +
                "returning the user back to the originating Commissioner (see Section 5.7.4, “Enhanced Setup Flow " +
                "(ESF)”)."
        }),

        Attribute({
            name: "TcMinRequiredVersion", id: 0x6, type: "uint16", access: "R A", conformance: "TC",
            quality: "N", xref: "core§11.10.6.7",

            details: "Indicates the minimum version of the texts presented by the Enhanced Setup Flow that need to be " +
                "accepted by the user for this device. This attribute may change as the result of an OTA update." +
                "\n" +
                "If an event such as a software update causes TCAcceptedVersion to become less than " +
                "TCMinRequiredVersion, then the device shall update TCAcknowledgementsRequired to True so that an " +
                "administrator can detect that a newer version of the texts needs to be presented to the user."
        }),

        Attribute({
            name: "TcAcknowledgements", id: 0x7, type: "map16", access: "R A", conformance: "TC", quality: "N",
            xref: "core§11.10.6.8",

            details: "Indicates the user’s response to the presented terms. Each bit position corresponds to a user " +
                "response for the associated index of matching text, such that bit 0 (bit value 1) is for text index " +
                "0. Bit 15 (bit value 0x8000) is for text index 15. A bit value of 1 indicates acceptance and a value " +
                "of 0 indicates non-acceptance. For example, if there are two texts that were presented where the " +
                "first (bit 0, value 1) was declined and the second accepted (bit 1, value 2), we would expect the " +
                "resulting value of the map to be 2." +
                "\n" +
                "Whenever a user provides responses to newly presented terms and conditions, this attribute shall be " +
                "updated with the latest responses. This may happen in response to updated terms that were presented " +
                "to the user. On a factory reset this field shall be reset with all bits set to 0."
        }),

        Attribute({
            name: "TcAcknowledgementsRequired", id: 0x8, type: "bool", access: "R A", conformance: "TC",
            default: true, quality: "N", xref: "core§11.10.6.9",

            details: "Indicates whether SetTCAcknowledgements is currently required to be called with the inclusion of " +
                "mandatory terms accepted." +
                "\n" +
                "This attribute may be present and False in the case where no terms and conditions are currently " +
                "mandatory to accept for CommissioningComplete command to succeed." +
                "\n" +
                "This attribute may appear, or become True after commissioning (e.g. due to a firmware update) to " +
                "indicate that new Terms & Conditions are available that the user must accept." +
                "\n" +
                "Upon Factory Data Reset, this attribute shall be set to a value of True." +
                "\n" +
                "When Custom Commissioning Flow is used to obtain user consent (e.g. because the Commissioner does " +
                "not support the TC feature), the manufacturer-provided means for obtaining user consent shall ensure " +
                "that this attribute is set to False before returning the user back to the original Commissioner (see " +
                "Section 5.7.4, “Enhanced Setup Flow (ESF)”)."
        }),

        Attribute({
            name: "TcUpdateDeadline", id: 0x9, type: "uint32", access: "R A", conformance: "TC", quality: "X N",
            xref: "core§11.10.6.10",
            details: "Indicates the System Time in seconds when any functionality limitations will begin due to a lack of " +
                "acceptance of updated Terms and Conditions, as described in Section 5.7.4.6, “Presenting Updated " +
                "Terms and Conditions”." +
                "\n" +
                "A null value indicates that there is no pending deadline for updated TC acceptance."
        }),

        Command(
            {
                name: "ArmFailSafe", id: 0x0, access: "A", conformance: "M", direction: "request",
                response: "ArmFailSafeResponse", xref: "core§11.10.7.2",

                details: "This command is used to arm or disarm the fail-safe timer." +
                    "\n" +
                    "Success or failure of this command shall be communicated by the ArmFailSafeResponse command, unless " +
                    "some data model validations caused a failure status code to be issued during the processing of the " +
                    "command." +
                    "\n" +
                    "If the fail-safe timer is not currently armed, the commissioning window is open, and the command was " +
                    "received over a CASE session, the command shall leave the current fail-safe state unchanged and " +
                    "immediately respond with an ArmFailSafeResponse containing an ErrorCode value of BusyWithOtherAdmin. " +
                    "This is done to allow commissioners, which use PASE connections, the opportunity to use the failsafe " +
                    "during the relatively short commissioning window." +
                    "\n" +
                    "Otherwise, the command shall arm or re-arm the \"fail-safe timer\" with an expiry time set for a " +
                    "duration of ExpiryLengthSeconds, or disarm it, depending on the situation:" +
                    "\n" +
                    "  • If ExpiryLengthSeconds is 0 and the fail-safe timer was already armed and the accessing fabric " +
                    "    matches the Fabric currently associated with the fail-safe context, then the fail-safe timer " +
                    "    shall be immediately expired (see further below for side-effects of expiration)." +
                    "\n" +
                    "  • If ExpiryLengthSeconds is 0 and the fail-safe timer was not armed, then this command invocation " +
                    "    shall lead to a success response with no side-effects against the fail-safe context." +
                    "\n" +
                    "  • If ExpiryLengthSeconds is non-zero and the fail-safe timer was not currently armed, then the " +
                    "    fail-safe timer shall be armed for that duration." +
                    "\n" +
                    "  • If ExpiryLengthSeconds is non-zero and the fail-safe timer was currently armed, and the " +
                    "    accessing Fabric matches the fail-safe context’s associated Fabric, then the fail-safe timer " +
                    "    shall be re-armed to expire in ExpiryLengthSeconds." +
                    "\n" +
                    "  • Otherwise, the command shall leave the current fail-safe state unchanged and immediately respond " +
                    "    with ArmFailSafeResponse containing an ErrorCode value of BusyWithOtherAdmin, indicating a " +
                    "    likely conflict between commissioners." +
                    "\n" +
                    "The value of the Breadcrumb field shall be written to the Breadcrumb on successful execution of the " +
                    "command." +
                    "\n" +
                    "If the receiver restarts unexpectedly (e.g., power interruption, software crash, or other reset) the " +
                    "receiver shall behave as if the fail-safe timer expired and perform the sequence of clean-up steps " +
                    "listed below." +
                    "\n" +
                    "On successful execution of the command, the ErrorCode field of the ArmFailSafeResponse shall be set " +
                    "to OK." +
                    "\n" +
                    "### Fail Safe Context" +
                    "\n" +
                    "When first arming the fail-safe timer, a 'Fail Safe Context' shall be created on the receiver, to " +
                    "track the following state information while the fail-safe is armed:" +
                    "\n" +
                    "  • The fail-safe timer duration." +
                    "\n" +
                    "  • The state of all Network Commissioning Networks attribute configurations, to allow recovery of " +
                    "    connectivity after Fail-Safe expiry." +
                    "\n" +
                    "  • Whether an AddNOC command or UpdateNOC command has taken place." +
                    "\n" +
                    "  • A fabric-index for the fabric-scoping of the context, starting at the accessing fabric index for " +
                    "    the ArmFailSafe command, and updated with the Fabric Index associated with an AddNOC or an " +
                    "    UpdateNOC command being invoked successfully during the ongoing Fail-Safe timer period." +
                    "\n" +
                    "  • The operational credentials associated with any Fabric whose configuration is affected by the " +
                    "    UpdateNOC command." +
                    "\n" +
                    "  • Optionally: the previous state of non-fabric-scoped data that is mutated during the fail-safe " +
                    "    period." +
                    "\n" +
                    "Note the following to assist in understanding the above state-keeping, which summarizes other " +
                    "normative requirements in the respective sections:" +
                    "\n" +
                    "  • The AddNOC command can only be invoked once per contiguous non-expiring fail-safe timer period, " +
                    "    and only if no UpdateNOC command was previously processed within the same fail-safe timer " +
                    "    period." +
                    "\n" +
                    "  • The UpdateNOC command can only be invoked once per contiguous non-expiring fail-safe timer " +
                    "    period, can only be invoked over a CASE session, and only if no AddNOC command was previously " +
                    "    processed in the same fail-safe timer period." +
                    "\n" +
                    "On creation of the Fail Safe Context a second timer shall be created to expire at " +
                    "MaxCumulativeFailsafeSeconds as specified in BasicCommissioningInfo. This Cumulative Fail Safe " +
                    "Context timer (CFSC timer) serves to limit the lifetime of any particular Fail Safe Context; it " +
                    "shall NOT be extended or modified on subsequent invocations of ArmFailSafe associated with this Fail " +
                    "Safe Context. Upon expiry of the CFSC timer, the receiver shall execute cleanup behavior equivalent " +
                    "to that of fail-safe timer expiration as detailed in Section 11.10.7.2.2, “Behavior on expiry of " +
                    "Fail-Safe timer”. Termination of the session prior to the expiration of that timer for any reason " +
                    "(including a successful end of commissioning or an expiry of a fail-safe timer) shall also delete " +
                    "the CFSC timer." +
                    "\n" +
                    "### Behavior on expiry of Fail-Safe timer" +
                    "\n" +
                    "If the fail-safe timer expires before the CommissioningComplete command is successfully invoked, the " +
                    "following sequence of clean-up steps shall be executed, in order, by the receiver:" +
                    "\n" +
                    "  1. Terminate any open PASE secure session by clearing any associated Secure Session Context at the " +
                    "     Server." +
                    "\n" +
                    "  2. Revoke the temporary administrative privileges granted to any open PASE session (see Section " +
                    "     6.6.2.9, “Bootstrapping of the Access Control Cluster”) at the Server." +
                    "\n" +
                    "  3. If an AddNOC or UpdateNOC command has been successfully invoked, terminate all CASE sessions " +
                    "     associated with the Fabric whose Fabric Index is recorded in the Fail-Safe context (see Section " +
                    "     11.10.7.2, “ArmFailSafe Command”) by clearing any associated Secure Session Context at the " +
                    "     Server." +
                    "\n" +
                    "  4. Reset the configuration of all Network Commissioning Networks attribute to their state prior to " +
                    "     the Fail-Safe being armed." +
                    "\n" +
                    "  5. If an UpdateNOC command had been successfully invoked, revert the state of operational key " +
                    "     pair, NOC and ICAC for that Fabric to the state prior to the Fail-Safe timer being armed, for " +
                    "     the Fabric Index that was the subject of the UpdateNOC command." +
                    "\n" +
                    "  6. If an AddNOC command had been successfully invoked, achieve the equivalent effect of invoking " +
                    "     the RemoveFabric command against the fabric-index stored in the Fail-Safe Context for the " +
                    "     Fabric Index that was the subject of the AddNOC command. This shall remove all associations to " +
                    "     that Fabric including all fabric-scoped data, and may possibly factory-reset the device " +
                    "     depending on current device state. This shall only apply to Fabrics added during the fail-safe " +
                    "     period as the result of the AddNOC command." +
                    "\n" +
                    "  7. If the CSRRequest command had been successfully invoked, but no AddNOC or UpdateNOC command had " +
                    "     been successfully invoked, then the new operational key pair temporarily generated for the " +
                    "     purposes of NOC addition or update (see Section 6.4.6.1, “Node Operational Certificate Signing " +
                    "     Request (NOCSR) Procedure”) shall be removed as it is no longer needed." +
                    "\n" +
                    "  8. Remove any RCACs added by the AddTrustedRootCertificate command that are not currently " +
                    "     referenced by any entry in the Fabrics attribute." +
                    "\n" +
                    "  9. Reset the Breadcrumb attribute to zero." +
                    "\n" +
                    "  10. Optionally: if no factory-reset resulted from the previous steps, it is recommended that the " +
                    "      Node rollback the state of all non fabric-scoped data present in the Fail-Safe context."
            },

            Field({ name: "ExpiryLengthSeconds", id: 0x0, type: "uint16", conformance: "M", default: 900 }),
            Field({ name: "Breadcrumb", id: 0x1, type: "uint64", conformance: "M" })
        ),

        Command(
            {
                name: "ArmFailSafeResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "core§11.10.7.3",
                details: "This command is used to report the result of the ArmFailSafe command."
            },

            Field({
                name: "ErrorCode", id: 0x0, type: "CommissioningErrorEnum", conformance: "M", default: 0,
                xref: "core§11.10.7.3.1",
                details: "This field shall contain the result of the operation, based on the behavior specified in the " +
                    "functional description of the ArmFailSafe command."
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "M", constraint: "max 128",
                xref: "core§11.10.7.3.2",
                details: "See Section 11.10.7.1, “Common fields in General Commissioning cluster responses”."
            })
        ),

        Command(
            {
                name: "SetRegulatoryConfig", id: 0x2, access: "A", conformance: "M", direction: "request",
                response: "SetRegulatoryConfigResponse", xref: "core§11.10.7.4",

                details: "This command is used to set the regulatory configuration for the device." +
                    "\n" +
                    "This shall add or update the regulatory configuration in the RegulatoryConfig Attribute to the value " +
                    "provided in the NewRegulatoryConfig field." +
                    "\n" +
                    "Success or failure of this command shall be communicated by the SetRegulatoryConfigResponse command, " +
                    "unless some data model validations caused a failure status code to be issued during the processing " +
                    "of the command." +
                    "\n" +
                    "The CountryCode field shall conforms to ISO 3166-1 alpha-2 and shall be used to set the Location " +
                    "attribute reflected by the Basic Information Cluster." +
                    "\n" +
                    "If the server limits some of the values (e.g. locked to a particular country, with no regulatory " +
                    "data for others), then setting regulatory information outside a valid country or location shall " +
                    "still set the Location attribute reflected by the Basic Information Cluster configuration, but the " +
                    "SetRegulatoryConfigResponse replied shall have the ErrorCode field set to ValueOutsideRange error." +
                    "\n" +
                    "If the LocationCapability attribute is not Indoor/Outdoor and the NewRegulatoryConfig value received " +
                    "does not match either the Indoor or Outdoor fixed value in LocationCapability, then the " +
                    "SetRegulatoryConfigResponse replied shall have the ErrorCode field set to ValueOutsideRange error " +
                    "and the RegulatoryConfig attribute and associated internal radio configuration shall remain " +
                    "unchanged." +
                    "\n" +
                    "If the LocationCapability attribute is set to Indoor/Outdoor, then the RegulatoryConfig attribute " +
                    "shall be set to match the NewRegulatoryConfig field." +
                    "\n" +
                    "On successful execution of the command, the ErrorCode field of the SetRegulatoryConfigResponse shall " +
                    "be set to OK." +
                    "\n" +
                    "The Breadcrumb field shall be used to atomically set the Breadcrumb attribute on success of this " +
                    "command, when SetRegulatoryConfigResponse has the ErrorCode field set to OK. If the command fails, " +
                    "the Breadcrumb attribute shall be left unchanged."
            },

            Field({ name: "NewRegulatoryConfig", id: 0x0, type: "RegulatoryLocationTypeEnum", conformance: "M" }),
            Field({ name: "CountryCode", id: 0x1, type: "string", conformance: "M", constraint: "2" }),
            Field({ name: "Breadcrumb", id: 0x2, type: "uint64", conformance: "M" })
        ),

        Command(
            {
                name: "SetRegulatoryConfigResponse", id: 0x3, conformance: "M", direction: "response",
                xref: "core§11.10.7.5",
                details: "This command is used to report the result of the SetRegulatoryConfig command."
            },

            Field({
                name: "ErrorCode", id: 0x0, type: "CommissioningErrorEnum", conformance: "M", default: 0,
                xref: "core§11.10.7.5.1",
                details: "This field shall contain the result of the operation, based on the behavior specified in the " +
                    "functional description of the SetRegulatoryConfig command."
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "M", xref: "core§11.10.7.5.2",
                details: "See Section 11.10.7.1, “Common fields in General Commissioning cluster responses”."
            })
        ),

        Command({
            name: "CommissioningComplete", id: 0x4, access: "F A", conformance: "M", direction: "request",
            response: "CommissioningCompleteResponse", xref: "core§11.10.7.6",

            details: "This command is used to indicate that the commissioning process is complete." +
                "\n" +
                "Success or failure of this command shall be communicated by the CommissioningCompleteResponse " +
                "command, unless some data model validations caused a failure status code to be issued during the " +
                "processing of the command." +
                "\n" +
                "This command signals the Server that the Commissioner or Administrator has successfully completed " +
                "all steps needed during the Fail-Safe period, such as commissioning (see Section 5.5, “Commissioning " +
                "Flows”) or other Administrator operations requiring usage of the Fail Safe timer. It ensures that " +
                "the Server is configured in a state such that it still has all necessary elements to be fully " +
                "operable within a Fabric, such as ACL entries (see Section 9.10, “Access Control Cluster”) and " +
                "operational credentials (see Section 6.4, “Node Operational Credentials Specification”), and that " +
                "the Node is reachable using CASE (see Section 4.14.2, “Certificate Authenticated Session " +
                "Establishment (CASE)”) over an operational network." +
                "\n" +
                "An ErrorCode of NoFailSafe shall be responded to the invoker if the CommissioningComplete command " +
                "was received when no Fail-Safe context exists." +
                "\n" +
                "If Terms and Conditions are required, then an ErrorCode of TCAcknowledgementsNotReceived shall be " +
                "responded to the invoker if the user acknowledgements to the required Terms and Conditions have not " +
                "been provided." +
                "\n" +
                "This command is fabric-scoped, so cannot be issued over a session that does not have an associated " +
                "fabric, i.e. over PASE session prior to an AddNOC command. In addition, this command is only " +
                "permitted over CASE and must be issued by a node associated with the ongoing Fail-Safe context. An " +
                "ErrorCode of InvalidAuthentication shall be responded to the invoker if the CommissioningComplete " +
                "command was received outside a CASE session (e.g., over Group messaging, or PASE session after " +
                "AddNOC), or if the accessing fabric is not the one associated with the ongoing Fail-Safe context." +
                "\n" +
                "This command shall only result in success with an ErrorCode value of OK in the " +
                "CommissioningCompleteResponse if received over a CASE session and the accessing fabric index matches " +
                "the Fabric Index associated with the current Fail-Safe context. In other words:" +
                "\n" +
                "  • If no AddNOC command had been successfully invoked, the CommissioningComplete command must " +
                "    originate from the Fabric that initiated the Fail-Safe context." +
                "\n" +
                "  • After an AddNOC command has been successfully invoked, the CommissioningComplete command must " +
                "    originate from the Fabric which was joined through the execution of that command, which updated " +
                "    the Fail-Safe context’s Fabric Index." +
                "\n" +
                "On successful execution of the CommissioningComplete command, where the " +
                "CommissioningCompleteResponse has an ErrorCode of OK, the following actions shall be undertaken on " +
                "the Server:" +
                "\n" +
                "  1. The Fail-Safe timer associated with the current Fail-Safe context shall be disarmed." +
                "\n" +
                "  2. The commissioning window at the Server shall be closed." +
                "\n" +
                "  3. Any temporary administrative privileges automatically granted to any open PASE session shall be " +
                "     revoked (see Section 6.6.2.9, “Bootstrapping of the Access Control Cluster”)." +
                "\n" +
                "  4. The Secure Session Context of any PASE session still established at the Server shall be " +
                "     cleared." +
                "\n" +
                "  5. The Breadcrumb attribute shall be reset to zero." +
                "\n" +
                "After receipt of a CommissioningCompleteResponse with an ErrorCode value of OK, a client cannot " +
                "expect any previously established PASE session to still be usable, due to the server having cleared " +
                "such sessions."
        }),

        Command(
            {
                name: "CommissioningCompleteResponse", id: 0x5, conformance: "M", direction: "response",
                xref: "core§11.10.7.7",
                details: "This command is used to report the result of the CommissioningComplete command."
            },

            Field({
                name: "ErrorCode", id: 0x0, type: "CommissioningErrorEnum", conformance: "M", default: 0,
                xref: "core§11.10.7.7.1",
                details: "This field shall contain the result of the operation, based on the behavior specified in the " +
                    "functional description of the CommissioningComplete command."
            }),

            Field({
                name: "DebugText", id: 0x1, type: "string", conformance: "M", xref: "core§11.10.7.7.2",
                details: "See Section 11.10.7.1, “Common fields in General Commissioning cluster responses”."
            })
        ),

        Command(
            {
                name: "SetTcAcknowledgements", id: 0x6, access: "A", conformance: "TC", direction: "request",
                response: "SetTcAcknowledgementsResponse", xref: "core§11.10.7.8",
                details: "This command is used to set the user acknowledgements received in the Enhanced Setup Flow Terms & " +
                    "Conditions into the node."
            },

            Field({
                name: "TcVersion", id: 0x0, type: "uint16", conformance: "M", xref: "core§11.10.7.8.1",
                details: "This field shall contain the version of the Enhanced Setup Flow Terms & Conditions that were " +
                    "presented to the user."
            }),

            Field({
                name: "TcUserResponse", id: 0x1, type: "map16", conformance: "M", xref: "core§11.10.7.8.2",

                details: "This field shall contain the user responses to the Enhanced Setup Flow Terms & Conditions as a map " +
                    "where each bit set in the bitmap corresponds to an accepted term in the file located at " +
                    "EnhancedSetupFlowTCUrl." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "This command shall copy the user responses and accepted version to the presented Enhanced Setup Flow " +
                    "Terms & Conditions from the values provided in the TCUserResponse and TCVersion fields to the " +
                    "TCAcknowledgements Attribute and the TCAcceptedVersion Attribute fields respectively." +
                    "\n" +
                    "This command shall result in success with an ErrorCode value of OK in the " +
                    "SetTCAcknowledgementsResponse if all required terms were accepted by the user. Specifically, all " +
                    "bits have a value of 1 in TCAcknowledgements whose ordinal is marked as required in the file located " +
                    "at EnhancedSetupFlowTCUrl." +
                    "\n" +
                    "If the TCVersion field is less than the TCMinRequiredVersion, then the ErrorCode of " +
                    "TCMinVersionNotMet shall be returned and TCAcknowledgements shall remain unchanged." +
                    "\n" +
                    "If TCVersion is greater than or equal to TCMinRequiredVersion, but the TCUserResponse value " +
                    "indicates that not all required terms were accepted by the user, then the ErrorCode of " +
                    "RequiredTCNotAccepted shall be returned and TCAcknowledgements shall remain unchanged."
            })
        ),

        Command(
            {
                name: "SetTcAcknowledgementsResponse", id: 0x7, conformance: "TC", direction: "response",
                xref: "core§11.10.7.9",
                details: "This command is used to report the result of the SetTCAcknowledgements command."
            },

            Field({
                name: "ErrorCode", id: 0x0, type: "CommissioningErrorEnum", conformance: "M", default: 0,
                xref: "core§11.10.7.9.1",
                details: "This field shall contain the result of the operation, based on the behavior specified in the " +
                    "functional description of the SetTCAcknowledgements command."
            })
        ),

        Datatype(
            {
                name: "CommissioningErrorEnum", type: "enum8", xref: "core§11.10.5.1",
                details: "This enumeration is used by several response commands in this cluster to indicate particular errors."
            },
            Field({ name: "Ok", id: 0x0, conformance: "M", description: "No error" }),
            Field({
                name: "ValueOutsideRange", id: 0x1, conformance: "M",
                description: "Attempting to set regulatory configuration to a region or indoor/outdoor mode for which the server does not have proper configuration."
            }),
            Field({
                name: "InvalidAuthentication", id: 0x2, conformance: "M",
                description: "Executed CommissioningComplete outside CASE session."
            }),
            Field({
                name: "NoFailSafe", id: 0x3, conformance: "M",
                description: "Executed CommissioningComplete when there was no active Fail-Safe context."
            }),
            Field({
                name: "BusyWithOtherAdmin", id: 0x4, conformance: "M",
                description: "Attempting to arm fail-safe or execute CommissioningComplete from a fabric different than the one associated with the current fail-safe context."
            }),
            Field({
                name: "RequiredTcNotAccepted", id: 0x5, conformance: "TC",
                description: "One or more required TC features from the Enhanced Setup Flow were not accepted."
            }),
            Field({
                name: "TcAcknowledgementsNotReceived", id: 0x6, conformance: "TC",
                description: "No or insufficient acknowledgements from the user for the TC features were received."
            }),
            Field({
                name: "TcMinVersionNotMet", id: 0x7, conformance: "TC",
                description: "The version of the TC features acknowledged by the user did not meet the minimum required version."
            })
        ),

        Datatype(
            {
                name: "RegulatoryLocationTypeEnum", type: "enum8", xref: "core§11.10.5.2",
                details: "This enumeration is used by the RegulatoryConfig and LocationCapability attributes to indicate " +
                    "possible radio usage."
            },
            Field({ name: "Indoor", id: 0x0, conformance: "M", description: "Indoor only" }),
            Field({ name: "Outdoor", id: 0x1, conformance: "M", description: "Outdoor only" }),
            Field({ name: "IndoorOutdoor", id: 0x2, conformance: "M", description: "Indoor/Outdoor" })
        ),

        Datatype(
            {
                name: "BasicCommissioningInfo", type: "struct", xref: "core§11.10.5.3",
                details: "This structure provides some constant values that may be of use to all commissioners."
            },

            Field({
                name: "FailSafeExpiryLengthSeconds", id: 0x0, type: "uint16", conformance: "M",
                xref: "core§11.10.5.3.1",
                details: "This field shall contain a conservative initial duration (in seconds) to set in the FailSafe for the " +
                    "commissioning flow to complete successfully. This may vary depending on the speed or sleepiness of " +
                    "the Commissionee. This value, if used in the ArmFailSafe command’s ExpiryLengthSeconds field SHOULD " +
                    "allow a Commissioner to proceed with a nominal commissioning without having to-rearm the fail-safe, " +
                    "with some margin."
            }),

            Field({
                name: "MaxCumulativeFailsafeSeconds", id: 0x1, type: "uint16", conformance: "M", constraint: "desc",
                xref: "core§11.10.5.3.2",

                details: "This field shall contain a conservative value in seconds denoting the maximum total duration for " +
                    "which a fail safe timer can be re-armed. See Section 11.10.7.2.1, “Fail Safe Context”." +
                    "\n" +
                    "The value of this field shall be greater than or equal to the FailSafeExpiryLengthSeconds. Absent " +
                    "additional guidelines, it is recommended that the value of this field be aligned with the initial " +
                    "Announcement Duration and default to 900 seconds."
            })
        )
    ),

    Cluster(
        {
            name: "DiagnosticLogs", id: 0x32, classification: "node", pics: "DLOG", quality: "K",
            xref: "core§11.11",
            details: "This Cluster supports an interface to a Node. It provides commands for retrieving unstructured " +
                "diagnostic logs from a Node that may be used to aid in diagnostics. It will often be the case that " +
                "unstructured diagnostic logs will be Node-wide and not specific to any subset of Endpoints. When " +
                "present, this Cluster shall be implemented once for the Node. The Node SHOULD also implement the BDX " +
                "Initiator and BDX Sender roles as defined in the BDX Protocol."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Command(
            {
                name: "RetrieveLogsRequest", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "RetrieveLogsResponse", xref: "core§11.11.5.1",
                details: "Reception of this command starts the process of retrieving diagnostic logs from a Node."
            },
            Field({
                name: "Intent", id: 0x0, type: "IntentEnum", conformance: "M", xref: "core§11.11.5.1.1",
                details: "This field shall indicate why the diagnostic logs are being retrieved from the Node. A Node may " +
                    "utilize this field to selectively determine the logs to transfer."
            }),

            Field({
                name: "RequestedProtocol", id: 0x1, type: "TransferProtocolEnum", conformance: "M",
                xref: "core§11.11.5.1.2",

                details: "This field shall be used to indicate how the log transfer is to be realized. If the field is set to " +
                    "BDX, then if the receiving Node supports BDX it shall attempt to use BDX to transfer any potential " +
                    "diagnostic logs; if the receiving Node does not support BDX then the Node shall follow the " +
                    "requirements defined for a TransferProtocolEnum of ResponsePayload. If this field is set to " +
                    "ResponsePayload the receiving Node shall only utilize the LogContent field of the " +
                    "RetrieveLogsResponse command to transfer diagnostic log information."
            }),

            Field({
                name: "TransferFileDesignator", id: 0x2, type: "string", conformance: "O", constraint: "max 32",
                xref: "core§11.11.5.1.3",

                details: "This field shall be present if the RequestedProtocol is BDX. The TransferFileDesignator shall be set " +
                    "as the File Designator of the BDX transfer if initiated." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "On receipt of this command, the Node shall respond with a RetrieveLogsResponse command." +
                    "\n" +
                    "If the RequestedProtocol is set to BDX the Node SHOULD immediately realize the RetrieveLogsResponse " +
                    "command by initiating a BDX Transfer, sending a BDX SendInit message with the File Designator field " +
                    "of the message set to the value of the TransferFileDesignator field of the RetrieveLogsRequest. On " +
                    "reception of a BDX SendAccept message the Node shall send a RetrieveLogsResponse command with a " +
                    "Status field set to Success and proceed with the log transfer over BDX. If a failure StatusReport is " +
                    "received in response to the SendInit message, the Node shall send a RetrieveLogsResponse command " +
                    "with a Status of Denied. In the case where the Node is able to fit the entirety of the requested " +
                    "logs within the LogContent field, the Status field of the RetrieveLogsResponse shall be set to " +
                    "Exhausted and a BDX session shall NOT be initiated." +
                    "\n" +
                    "If the RequestedProtocol is set to BDX and either the Node does not support BDX or it is not " +
                    "possible for the Node to establish a BDX session, then the Node shall utilize the LogContent field " +
                    "of the RetrieveLogsResponse command to transfer as much of the current logs as it can fit within the " +
                    "response, and the Status field of the RetrieveLogsResponse shall be set to Exhausted." +
                    "\n" +
                    "If the RequestedProtocol is set to ResponsePayload the Node shall utilize the LogContent field of " +
                    "the RetrieveLogsResponse command to transfer as much of the current logs as it can fit within the " +
                    "response, and a BDX session shall NOT be initiated." +
                    "\n" +
                    "If the RequestedProtocol is set to BDX and there is no TransferFileDesignator the command shall fail " +
                    "with a Status Code of INVALID_COMMAND." +
                    "\n" +
                    "If the Intent and/or the RequestedProtocol arguments contain invalid (out of range) values the " +
                    "command shall fail with a Status Code of INVALID_COMMAND."
            })
        ),

        Command(
            {
                name: "RetrieveLogsResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "core§11.11.5.2",
                details: "This shall be generated as a response to the RetrieveLogsRequest. The data for this command is shown " +
                    "in the following."
            },

            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "core§11.11.5.2.1",
                details: "This field shall indicate the result of an attempt to retrieve diagnostic logs."
            }),

            Field({
                name: "LogContent", id: 0x1, type: "octstr", conformance: "M", constraint: "max 1024",
                xref: "core§11.11.5.2.2",
                details: "This field shall be included in the command if the Status field has a value of Success or Exhausted. " +
                    "A Node SHOULD utilize this field to transfer the newest diagnostic log entries. This field shall be " +
                    "empty if BDX is requested and the Status field has a value of Success."
            }),

            Field({
                name: "UtcTimeStamp", id: 0x2, type: "epoch-us", conformance: "O", xref: "core§11.11.5.2.3",
                details: "This field SHOULD be included in the command if the Status field has a value of Success and the Node " +
                    "maintains a wall clock. When included, the UTCTimeStamp field shall contain the value of the oldest " +
                    "log entry in the diagnostic logs that are being transferred."
            }),

            Field({
                name: "TimeSinceBoot", id: 0x3, type: "systime-us", conformance: "O", xref: "core§11.11.5.2.4",
                details: "This field SHOULD be included in the command if the Status field has a value of Success. When " +
                    "included, the TimeSinceBoot field shall contain the time of the oldest log entry in the diagnostic " +
                    "logs that are being transferred represented by the number of microseconds since the last time the " +
                    "Node went through a reboot."
            })
        ),

        Datatype(
            { name: "IntentEnum", type: "enum8", xref: "core§11.11.4.1" },

            Field({
                name: "EndUserSupport", id: 0x0, conformance: "M",
                description: "Logs to be used for end-user support", xref: "core§11.11.4.1.1",
                details: "shall indicate that the purpose of the log request is to retrieve logs for the intention of " +
                    "providing support to an end-user."
            }),

            Field({
                name: "NetworkDiag", id: 0x1, conformance: "M",
                description: "Logs to be used for network diagnostics", xref: "core§11.11.4.1.2",
                details: "shall indicate that the purpose of the log request is to diagnose the network(s) for which the Node " +
                    "is currently commissioned (and/or connected) or has previously been commissioned (and/or connected)."
            }),

            Field({
                name: "CrashLogs", id: 0x2, conformance: "M", description: "Obtain crash logs from the Node",
                xref: "core§11.11.4.1.3",
                details: "shall indicate that the purpose of the log request is to retrieve any crash logs that may be present " +
                    "on a Node."
            })
        ),

        Datatype(
            { name: "StatusEnum", type: "enum8", xref: "core§11.11.4.2" },
            Field({
                name: "Success", id: 0x0, conformance: "M", description: "Successful transfer of logs",
                xref: "core§11.11.4.2.1",
                details: "shall be used if diagnostic logs will be or are being transferred."
            }),

            Field({
                name: "Exhausted", id: 0x1, conformance: "M", description: "All logs has been transferred",
                xref: "core§11.11.4.2.2",
                details: "shall be used when a BDX session is requested, however, all available logs were provided in a " +
                    "LogContent field."
            }),

            Field({
                name: "NoLogs", id: 0x2, conformance: "M", description: "No logs of the requested type available",
                xref: "core§11.11.4.2.3",
                details: "shall be used if the Node does not currently have any diagnostic logs of the requested type (Intent) " +
                    "to transfer."
            }),

            Field({
                name: "Busy", id: 0x3, conformance: "M", description: "Unable to handle request, retry later",
                xref: "core§11.11.4.2.4",
                details: "shall be used if the Node is unable to handle the request (e.g. in the process of another transfer) " +
                    "and the Client SHOULD re-attempt the request later."
            }),

            Field({
                name: "Denied", id: 0x4, conformance: "M",
                description: "The request is denied, no logs being transferred", xref: "core§11.11.4.2.5",
                details: "shall be used if the Node is denying the current transfer of diagnostic logs for any reason."
            })
        ),

        Datatype(
            { name: "TransferProtocolEnum", type: "enum8", xref: "core§11.11.4.3" },

            Field({
                name: "ResponsePayload", id: 0x0, conformance: "M",
                description: "Logs to be returned as a response", xref: "core§11.11.4.3.1",
                details: "shall be used by a Client to request that logs are transferred using the LogContent attribute of the " +
                    "response"
            }),

            Field({
                name: "Bdx", id: 0x1, conformance: "M", description: "Logs to be returned using BDX",
                xref: "core§11.11.4.3.2",
                details: "shall be used by a Client to request that logs are transferred using BDX as defined in BDX Protocol"
            })
        )
    ),

    Cluster(
        {
            name: "GeneralDiagnostics", id: 0x33, classification: "node", pics: "DGGEN", quality: "K",
            xref: "core§11.12",
            details: "The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire " +
                "standardized diagnostics metrics that may be used by a Node to assist a user or Administrator in " +
                "diagnosing potential problems. The General Diagnostics Cluster attempts to centralize all metrics " +
                "that are broadly relevant to the majority of Nodes."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.12.4" },

            Field({
                name: "DMTEST", conformance: "desc", constraint: "0", title: "DataModelTest",
                xref: "core§11.12.4.1",
                details: "This feature indicates support for extended Data Model testing commands, which are required in some " +
                    "situations." +
                    "\n" +
                    "This feature shall be supported if the MaxPathsPerInvoke attribute of the Basic Information Cluster " +
                    "has a value > 1."
            })
        ),

        Attribute(
            {
                name: "NetworkInterfaces", id: 0x0, type: "list", access: "R V", conformance: "M",
                constraint: "max 8", xref: "core§11.12.6.1",
                details: "The NetworkInterfaces attribute shall be a list of NetworkInterface structs. Each logical network " +
                    "interface on the Node shall be represented by a single entry within the NetworkInterfaces attribute."
            },

            Field({ name: "entry", type: "NetworkInterface" })
        ),

        Attribute({
            name: "RebootCount", id: 0x1, type: "uint16", access: "R V", conformance: "M", quality: "N",
            xref: "core§11.12.6.2",
            details: "The RebootCount attribute shall indicate a best-effort count of the number of times the Node has " +
                "rebooted. The RebootCount attribute SHOULD be incremented each time the Node reboots. The " +
                "RebootCount attribute shall NOT be incremented when a Node wakes from a low-power or sleep state. " +
                "The RebootCount attribute shall only be reset to 0 upon a factory reset of the Node."
        }),

        Attribute({
            name: "UpTime", id: 0x2, type: "uint64", access: "R V", conformance: "M", quality: "C",
            xref: "core§11.12.6.3",
            details: "The UpTime attribute shall indicate a best-effort assessment of the length of time, in seconds, " +
                "since the Node’s last reboot. This attribute SHOULD be incremented to account for the periods of " +
                "time that a Node is in a low-power or sleep state. This attribute shall only be reset upon a device " +
                "reboot. This attribute shall be based on the same System Time source as those used to fulfill any " +
                "usage of the systime-us and systime-ms data types within the server."
        }),

        Attribute({
            name: "TotalOperationalHours", id: 0x3, type: "uint32", access: "R V", conformance: "O",
            quality: "N C", xref: "core§11.12.6.4",
            details: "The TotalOperationalHours attribute shall indicate a best-effort attempt at tracking the length of " +
                "time, in hours, that the Node has been operational. The TotalOperationalHours attribute SHOULD be " +
                "incremented to account for the periods of time that a Node is in a low-power or sleep state. The " +
                "TotalOperationalHours attribute shall only be reset upon a factory reset of the Node."
        }),

        Attribute({
            name: "BootReason", id: 0x4, type: "BootReasonEnum", access: "R V", conformance: "O",
            xref: "core§11.12.6.5",
            details: "The BootReason attribute shall indicate the reason for the Node’s most recent boot."
        }),

        Attribute(
            {
                name: "ActiveHardwareFaults", id: 0x5, type: "list", access: "R V", conformance: "O",
                constraint: "max 11", xref: "core§11.12.6.6",

                details: "The ActiveHardwareFaults attribute shall indicate the set of faults currently detected by the Node. " +
                    "When the Node detects a fault has been raised, the appropriate HardwareFaultEnum value shall be " +
                    "added to this list. This list shall NOT contain more than one instance of a specific " +
                    "HardwareFaultEnum value. When the Node detects that all conditions contributing to a fault has been " +
                    "cleared, the corresponding HardwareFaultEnum value shall be removed from this list. An empty list " +
                    "shall indicate there are currently no active faults. The order of this list SHOULD have no " +
                    "significance. Clients interested in monitoring changes in active faults may subscribe to this " +
                    "attribute, or they may subscribe to HardwareFaultChange."
            },

            Field({ name: "entry", type: "HardwareFaultEnum" })
        ),

        Attribute(
            {
                name: "ActiveRadioFaults", id: 0x6, type: "list", access: "R V", conformance: "O",
                constraint: "max 7", xref: "core§11.12.6.7",

                details: "The ActiveRadioFaults attribute shall indicate the set of faults currently detected by the Node. " +
                    "When the Node detects a fault has been raised, the appropriate RadioFaultEnum value shall be added " +
                    "to this list. This list shall NOT contain more than one instance of a specific RadioFaultEnum value. " +
                    "When the Node detects that all conditions contributing to a fault has been cleared, the " +
                    "corresponding RadioFaultEnum value shall be removed from this list. An empty list shall indicate " +
                    "there are currently no active faults. The order of this list SHOULD have no significance. Clients " +
                    "interested in monitoring changes in active faults may subscribe to this attribute, or they may " +
                    "subscribe to RadioFaultChange."
            },

            Field({ name: "entry", type: "RadioFaultEnum" })
        ),

        Attribute(
            {
                name: "ActiveNetworkFaults", id: 0x7, type: "list", access: "R V", conformance: "O",
                constraint: "max 4", xref: "core§11.12.6.8",

                details: "The ActiveNetworkFaults attribute shall indicate the set of faults currently detected by the Node. " +
                    "When the Node detects a fault has been raised, the appropriate NetworkFaultEnum value shall be added " +
                    "to this list. This list shall NOT contain more than one instance of a specific NetworkFaultEnum " +
                    "value. When the Node detects that all conditions contributing to a fault has been cleared, the " +
                    "corresponding NetworkFaultEnum value shall be removed from this list. An empty list shall indicate " +
                    "there are currently no active faults. The order of this list SHOULD have no significance. Clients " +
                    "interested in monitoring changes in active faults may subscribe to this attribute, or they may " +
                    "subscribe to NetworkFaultChange."
            },

            Field({ name: "entry", type: "NetworkFaultEnum" })
        ),

        Attribute({
            name: "TestEventTriggersEnabled", id: 0x8, type: "bool", access: "R V", conformance: "M",
            xref: "core§11.12.6.9",

            details: "The TestEventTriggersEnabled attribute shall indicate whether the Node has any TestEventTrigger " +
                "configured. When this attribute is true, the Node has been configured with one or more test event " +
                "triggers by virtue of the internally programmed EnableKey value (see Section 11.12.7.1, " +
                "“TestEventTrigger Command”) being set to a non-zero value. This attribute can be used by " +
                "Administrators to detect if a device was inadvertently commissioned with test event trigger mode " +
                "enabled, and take appropriate action (e.g. warn the user and/or offer to remove all fabrics on the " +
                "Node)."
        }),

        Attribute({ name: "DoNotUse", id: 0x9, conformance: "X", xref: "core§11.12.6" }),

        Event(
            {
                name: "HardwareFaultChange", id: 0x0, access: "V", conformance: "O", priority: "critical",
                xref: "core§11.12.8.1",
                details: "The HardwareFaultChange Event shall indicate a change in the set of hardware faults currently " +
                    "detected by the Node."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 11",
                    xref: "core§11.12.8.1.1",
                    details: "This field shall represent the set of faults currently detected, as per HardwareFaultEnum."
                },
                Field({ name: "entry", type: "HardwareFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 11",
                    xref: "core§11.12.8.1.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "HardwareFaultEnum."
                },

                Field({ name: "entry", type: "HardwareFaultEnum" })
            )
        ),

        Event(
            {
                name: "RadioFaultChange", id: 0x1, access: "V", conformance: "O", priority: "critical",
                xref: "core§11.12.8.2",
                details: "The RadioFaultChange Event shall indicate a change in the set of radio faults currently detected by " +
                    "the Node."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 7",
                    xref: "core§11.12.8.2.1",
                    details: "This field shall represent the set of faults currently detected, as per RadioFaultEnum."
                },
                Field({ name: "entry", type: "RadioFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 7",
                    xref: "core§11.12.8.2.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "RadioFaultEnum."
                },

                Field({ name: "entry", type: "RadioFaultEnum" })
            )
        ),

        Event(
            {
                name: "NetworkFaultChange", id: 0x2, access: "V", conformance: "O", priority: "critical",
                xref: "core§11.12.8.3",
                details: "The NetworkFaultChange Event shall indicate a change in the set of network faults currently detected " +
                    "by the Node."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 4",
                    xref: "core§11.12.8.3.1",
                    details: "This field shall represent the set of faults currently detected, as per NetworkFaultEnum."
                },
                Field({ name: "entry", type: "NetworkFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 4",
                    xref: "core§11.12.8.3.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per " +
                        "NetworkFaultEnum."
                },

                Field({ name: "entry", type: "NetworkFaultEnum" })
            )
        ),

        Event(
            {
                name: "BootReason", id: 0x3, access: "V", conformance: "M", priority: "critical",
                xref: "core§11.12.8.4",
                details: "The BootReason Event shall indicate the reason that caused the device to start-up."
            },
            Field({
                name: "BootReason", id: 0x0, type: "BootReasonEnum", conformance: "M", xref: "core§11.12.8.4.1",
                details: "This field shall contain the reason for this BootReason event."
            })
        ),

        Command(
            {
                name: "TestEventTrigger", id: 0x0, access: "M", conformance: "M", direction: "request",
                response: "status", xref: "core§11.12.7.1",

                details: "This command shall be supported to provide a means for certification tests to trigger some " +
                    "test-plan-specific events, necessary to assist in automation of device interactions for some " +
                    "certification test cases. This command shall NOT cause any changes to the state of the device that " +
                    "persist after the last fabric is removed." +
                    "\n" +
                    "The fields for the TestEventTrigger command are as follows:"
            },

            Field({
                name: "EnableKey", id: 0x0, type: "octstr", conformance: "M", constraint: "16",
                xref: "core§11.12.7.1.1",

                details: "The EnableKey is a 128 bit value provided by the client in this command, which needs to match a " +
                    "value chosen by the manufacturer and configured on the server using manufacturer-specific means, " +
                    "such as pre-provisioning. The value of all zeroes is reserved to indicate that no EnableKey is set. " +
                    "Therefore, if the EnableKey field is received with all zeroes, this command shall FAIL with a " +
                    "response status of CONSTRAINT_ERROR." +
                    "\n" +
                    "The EnableKey SHOULD be unique per exact set of devices going to a certification test." +
                    "\n" +
                    "Devices not targeted towards going to a certification test event shall NOT have a non-zero EnableKey " +
                    "value configured, so that only devices in test environments are responsive to this command." +
                    "\n" +
                    "In order to prevent unwittingly actuating a particular trigger, this command shall respond with a " +
                    "response status of CONSTRAINT_ERROR if the EnableKey field does not match the a-priori value " +
                    "configured on the device."
            }),

            Field({
                name: "EventTrigger", id: 0x1, type: "uint64", conformance: "M", xref: "core§11.12.7.1.2",

                details: "This field shall indicate the test or test mode which the client wants to trigger." +
                    "\n" +
                    "The expected side-effects of EventTrigger values are out of scope of this specification and will be " +
                    "described within appropriate certification test literature provided to manufacturers by the " +
                    "Connectivity Standards Alliance, in conjunction with certification test cases documentation." +
                    "\n" +
                    "Values of EventTrigger in the range 0xFFFF_FFFF_0000_0000 through 0xFFFF_FFFF_FFFF_FFFF are reserved " +
                    "for testing use by manufacturers and will not appear in the Connectivity Standards Alliance " +
                    "certification test literature." +
                    "\n" +
                    "If the value of EventTrigger received is not supported by the receiving Node, this command shall " +
                    "fail with a status code of INVALID_COMMAND." +
                    "\n" +
                    "Otherwise, if the EnableKey value matches the configured internal value for a particular Node, and " +
                    "the EventTrigger value matches a supported test event trigger value, the command shall succeed and " +
                    "execute the expected trigger action." +
                    "\n" +
                    "If no specific test event triggers are required to be supported by certification test requirements " +
                    "for the features that a given product will be certified against, this command may always fail with " +
                    "the INVALID_COMMAND status, equivalent to the situation of receiving an unknown EventTrigger, for " +
                    "all possible EventTrigger values."
            })
        ),

        Command({
            name: "TimeSnapshot", id: 0x1, access: "O", conformance: "M", direction: "request",
            response: "TimeSnapshotResponse", xref: "core§11.12.7.2",

            details: "This command may be used by a client to obtain a correlated view of both System Time, and, if " +
                "currently synchronized and supported, \"wall clock time\" of the server. This can help clients " +
                "establish time correlation between their concept of time and the server’s concept of time. This is " +
                "especially useful when processing event histories where some events only contain System Time." +
                "\n" +
                "Upon command invocation, the server shall respond with a TimeSnapshotResponse."
        }),

        Command(
            {
                name: "TimeSnapshotResponse", id: 0x2, conformance: "M", direction: "response",
                xref: "core§11.12.7.3",

                details: "This command shall be generated in response to a TimeSnapshot command." +
                    "\n" +
                    "When generating this response, all fields shall be gathered as close together in time as possible, " +
                    "so that the time jitter between the values is minimized." +
                    "\n" +
                    "If the Time Synchronization cluster is supported by the node, the PosixTimeMs field shall NOT be " +
                    "null unless the UTCTime attribute in the Time Synchronization cluster is also null."
            },

            Field({
                name: "SystemTimeMs", id: 0x0, type: "systime-ms", conformance: "M", xref: "core§11.12.7.3.1",
                details: "This shall indicate the current System Time in milliseconds (type systime-ms), with the value taken " +
                    "at the time of processing of the TimeSnapshot command that generated this response." +
                    "\n" +
                    "The value shall be taken from the same clock which populates the Timestamp field in events when " +
                    "using System Time for the field."
            }),

            Field({
                name: "PosixTimeMs", id: 0x1, type: "posix-ms", conformance: "M", default: null, quality: "X",
                xref: "core§11.12.7.3.2",

                details: "This shall indicate the current time in POSIX Time in milliseconds, with the value taken from the " +
                    "same source that could populate the Timestamp field of events. This value shall only be null when " +
                    "any the following are true:" +
                    "\n" +
                    "  • The node doesn’t support the Time Synchronization cluster." +
                    "\n" +
                    "  • The node’s Time Synchronization cluster instance’s UTCTime attribute is null."
            })
        ),

        Command(
            {
                name: "PayloadTestRequest", id: 0x3, access: "M", conformance: "DMTEST", direction: "request",
                response: "PayloadTestResponse", xref: "core§11.12.7.4",

                details: "This command provides a means for certification tests or manufacturer’s internal tests to validate " +
                    "particular command handling and encoding constraints by generating a response of a given size." +
                    "\n" +
                    "This command shall use the same EnableKey behavior as the TestEventTrigger command, whereby " +
                    "processing of the command is only enabled when the TestEventTriggersEnabled field is true, which " +
                    "shall NOT be true outside of certification testing or manufacturer’s internal tests." +
                    "\n" +
                    "The fields for the PayloadTestRequest command are as follows:"
            },

            Field({
                name: "EnableKey", id: 0x0, type: "octstr", conformance: "M", constraint: "16",
                xref: "core§11.12.7.4.1",
                details: "This field shall have the same meaning and usage as the TestEventTrigger EnableKey field."
            }),
            Field({
                name: "Value", id: 0x1, type: "uint8", conformance: "M", xref: "core§11.12.7.4.2",
                details: "This field shall indicate the value to use in every byte of the PayloadTestResponse’s Payload field."
            }),

            Field({
                name: "Count", id: 0x2, type: "uint16", conformance: "M", constraint: "max 2048",
                xref: "core§11.12.7.4.3",

                details: "This field shall indicate the number of times to repeat the Value in the PayloadTestResponse’s " +
                    "Payload field." +
                    "\n" +
                    "### Effect upon receipt" +
                    "\n" +
                    "This command shall respond with a response status of CONSTRAINT_ERROR if either:" +
                    "\n" +
                    "  • The EnableKey field does not match the a-priori value configured on the device." +
                    "\n" +
                    "  • The TestEventTriggersEnabled field is currently false. Otherwise, the server shall respond with " +
                    "    a PayloadTestResponse command with a Payload field value containing Count instances of the Value " +
                    "    byte. If the response is too large to send, the server shall fail the command and respond with a " +
                    "    response status of RESOURCE_EXHAUSTED." +
                    "\n" +
                    "For example:" +
                    "\n" +
                    "  • If Value is 0x55 and the Count is zero, then the PayloadTestResponse would have the Payload " +
                    "    field set to an empty octet string." +
                    "\n" +
                    "  • If Value is 0xA5 and the Count is 10, the PayloadTestResponse would have the Payload field set " +
                    "    to a content whose hexadecimal representation would be A5A5A5A5A5A5A5A5A5A5, and base64 " +
                    "    representation would be paWlpaWlpaWlpQ==."
            })
        ),

        Command(
            {
                name: "PayloadTestResponse", id: 0x4, conformance: "DMTEST", direction: "response",
                xref: "core§11.12.7.5",
                details: "This command is sent by the server on receipt of the PayloadTestRequest command."
            },
            Field({
                name: "Payload", id: 0x0, type: "octstr", conformance: "M", constraint: "max 2048",
                xref: "core§11.12.7.5.1",
                details: "This field shall contain the computed response of the PayloadTestRequest command."
            })
        ),

        Datatype(
            { name: "HardwareFaultEnum", type: "enum8", xref: "core§11.12.5.1" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node has encountered an unspecified fault."
            }),
            Field({
                name: "Radio", id: 0x1, conformance: "O",
                description: "The Node has encountered a fault with at least one of its radios."
            }),
            Field({
                name: "Sensor", id: 0x2, conformance: "O",
                description: "The Node has encountered a fault with at least one of its sensors."
            }),
            Field({
                name: "ResettableOverTemp", id: 0x3, conformance: "O",
                description: "The Node has encountered an over-temperature fault that is resettable."
            }),
            Field({
                name: "NonResettableOverTemp", id: 0x4, conformance: "O",
                description: "The Node has encountered an over-temperature fault that is not resettable."
            }),
            Field({
                name: "PowerSource", id: 0x5, conformance: "O",
                description: "The Node has encountered a fault with at least one of its power sources."
            }),
            Field({
                name: "VisualDisplayFault", id: 0x6, conformance: "O",
                description: "The Node has encountered a fault with at least one of its visual displays."
            }),
            Field({
                name: "AudioOutputFault", id: 0x7, conformance: "O",
                description: "The Node has encountered a fault with at least one of its audio outputs."
            }),
            Field({
                name: "UserInterfaceFault", id: 0x8, conformance: "O",
                description: "The Node has encountered a fault with at least one of its user interfaces."
            }),
            Field({
                name: "NonVolatileMemoryError", id: 0x9, conformance: "O",
                description: "The Node has encountered a fault with its non-volatile memory."
            }),
            Field({
                name: "TamperDetected", id: 0xa, conformance: "O",
                description: "The Node has encountered disallowed physical tampering."
            })
        ),

        Datatype(
            { name: "RadioFaultEnum", type: "enum8", xref: "core§11.12.5.2" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node has encountered an unspecified radio fault."
            }),
            Field({
                name: "WiFiFault", id: 0x1, conformance: "O",
                description: "The Node has encountered a fault with its Wi-Fi radio."
            }),
            Field({
                name: "CellularFault", id: 0x2, conformance: "O",
                description: "The Node has encountered a fault with its cellular radio."
            }),
            Field({
                name: "ThreadFault", id: 0x3, conformance: "O",
                description: "The Node has encountered a fault with its802.15.4 radio."
            }),
            Field({
                name: "NfcFault", id: 0x4, conformance: "O",
                description: "The Node has encountered a fault with its NFC radio."
            }),
            Field({
                name: "BleFault", id: 0x5, conformance: "O",
                description: "The Node has encountered a fault with its BLE radio."
            }),
            Field({
                name: "EthernetFault", id: 0x6, conformance: "O",
                description: "The Node has encountered a fault with its Ethernet controller."
            })
        ),

        Datatype(
            { name: "NetworkFaultEnum", type: "enum8", xref: "core§11.12.5.3" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node has encountered an unspecified fault."
            }),
            Field({
                name: "HardwareFailure", id: 0x1, conformance: "O",
                description: "The Node has encountered a network fault as a result of a hardware failure."
            }),
            Field({
                name: "NetworkJammed", id: 0x2, conformance: "O",
                description: "The Node has encountered a network fault as a result of a jammed network."
            }),
            Field({
                name: "ConnectionFailed", id: 0x3, conformance: "O",
                description: "The Node has encountered a network fault as a result of a failure to establish a connection."
            })
        ),

        Datatype(
            { name: "InterfaceTypeEnum", type: "enum8", xref: "core§11.12.5.4" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "Indicates an interface of an unspecified type."
            }),
            Field({ name: "WiFi", id: 0x1, conformance: "O", description: "Indicates a Wi-Fi interface." }),
            Field({ name: "Ethernet", id: 0x2, conformance: "O", description: "Indicates a Ethernet interface." }),
            Field({ name: "Cellular", id: 0x3, conformance: "O", description: "Indicates a Cellular interface." }),
            Field({ name: "Thread", id: 0x4, conformance: "O", description: "Indicates a Thread interface." })
        ),

        Datatype(
            { name: "BootReasonEnum", type: "enum8", xref: "core§11.12.5.5" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "The Node is unable to identify the Power-On reason as one of the other provided enumeration values."
            }),
            Field({
                name: "PowerOnReboot", id: 0x1, conformance: "M",
                description: "The Node has booted as the result of physical interaction with the device resulting in a reboot."
            }),
            Field({
                name: "BrownOutReset", id: 0x2, conformance: "M",
                description: "The Node has rebooted as the result of a brown-out of the Node’s power supply."
            }),
            Field({
                name: "SoftwareWatchdogReset", id: 0x3, conformance: "M",
                description: "The Node has rebooted as the result of a software watchdog timer."
            }),
            Field({
                name: "HardwareWatchdogReset", id: 0x4, conformance: "M",
                description: "The Node has rebooted as the result of a hardware watchdog timer."
            }),
            Field({
                name: "SoftwareUpdateCompleted", id: 0x5, conformance: "M",
                description: "The Node has rebooted as the result of a completed software update."
            }),
            Field({
                name: "SoftwareReset", id: 0x6, conformance: "M",
                description: "The Node has rebooted as the result of a software initiated reboot."
            })
        ),

        Datatype(
            {
                name: "NetworkInterface", type: "struct", xref: "core§11.12.5.6",
                details: "This structure describes a network interface supported by the Node, as provided in the " +
                    "NetworkInterfaces attribute."
            },

            Field({
                name: "Name", id: 0x0, type: "string", conformance: "M", constraint: "max 32",
                xref: "core§11.12.5.6.1",
                details: "This field shall indicate a human-readable (displayable) name for the network interface, that is " +
                    "different from all other interfaces."
            }),

            Field({
                name: "IsOperational", id: 0x1, type: "bool", conformance: "M", xref: "core§11.12.5.6.2",
                details: "This field shall indicate if the Node is currently advertising itself operationally on this network " +
                    "interface and is capable of successfully receiving incoming traffic from other Nodes."
            }),

            Field({
                name: "OffPremiseServicesReachableIPv4", id: 0x2, type: "bool", conformance: "M", default: null,
                quality: "X", xref: "core§11.12.5.6.3",
                details: "This field shall indicate whether the Node is currently able to reach off-premise services it uses " +
                    "by utilizing IPv4. The value shall be null if the Node does not use such services or does not know " +
                    "whether it can reach them."
            }),

            Field({
                name: "OffPremiseServicesReachableIPv6", id: 0x3, type: "bool", conformance: "M", default: null,
                quality: "X", xref: "core§11.12.5.6.4",
                details: "This field shall indicate whether the Node is currently able to reach off-premise services it uses " +
                    "by utilizing IPv6. The value shall be null if the Node does not use such services or does not know " +
                    "whether it can reach them."
            }),

            Field({
                name: "HardwareAddress", id: 0x4, type: "hwadr", conformance: "M", xref: "core§11.12.5.6.5",
                details: "This field shall contain the current link-layer address for a 802.3 or IEEE 802.11-2020 network " +
                    "interface and contain the current extended MAC address for a 802.15.4 interface. The byte order of " +
                    "the octstr shall be in wire byte order. For addresses values less than 64 bits, the first two bytes " +
                    "shall be zero."
            }),

            Field(
                {
                    name: "IPv4Addresses", id: 0x5, type: "list", conformance: "M", constraint: "max 4",
                    xref: "core§11.12.5.6.6",
                    details: "This field shall provide a list of the IPv4 addresses that are currently assigned to the network " +
                        "interface."
                },

                Field({ name: "entry", type: "ipv4adr" })
            ),

            Field(
                {
                    name: "IPv6Addresses", id: 0x6, type: "list", conformance: "M", constraint: "max 8",
                    xref: "core§11.12.5.6.7",
                    details: "This field shall provide a list of the unicast IPv6 addresses that are currently assigned to the " +
                        "network interface. This list shall include the Node’s link-local address and SHOULD include any " +
                        "assigned GUA and ULA addresses. This list shall NOT include any multicast group addresses to which " +
                        "the Node is subscribed."
                },

                Field({ name: "entry", type: "ipv6adr" })
            ),

            Field({
                name: "Type", id: 0x7, type: "InterfaceTypeEnum", conformance: "M", xref: "core§11.12.5.6.8",
                details: "This field shall indicate the type of the interface using the InterfaceTypeEnum."
            })
        )
    ),

    Cluster(
        {
            name: "SoftwareDiagnostics", id: 0x34, classification: "node", pics: "DGSW", quality: "K",
            xref: "core§11.13",
            details: "The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that " +
                "may be used by a Node to assist a user or Administrator in diagnosing potential problems. The " +
                "Software Diagnostics Cluster attempts to centralize all metrics that are relevant to the software " +
                "that may be running on a Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.13.4" },
            Field({
                name: "WTRMRK", constraint: "0", title: "Watermarks",
                details: "Node makes available the metrics for high watermark related to memory consumption."
            })
        ),

        Attribute(
            {
                name: "ThreadMetrics", id: 0x0, type: "list", access: "R V", conformance: "O", constraint: "max 64",
                xref: "core§11.13.6.1",
                details: "This attribute shall be a list of ThreadMetricsStruct structs. Each active thread on the Node shall " +
                    "be represented by a single entry within the ThreadMetrics attribute."
            },

            Field({ name: "entry", type: "ThreadMetricsStruct" })
        ),

        Attribute({
            name: "CurrentHeapFree", id: 0x1, type: "uint64", access: "R V", conformance: "O",
            xref: "core§11.13.6.2",
            details: "Indicates the current amount of heap memory, in bytes, that are free for allocation. The effective " +
                "amount may be smaller due to heap fragmentation or other reasons."
        }),

        Attribute({
            name: "CurrentHeapUsed", id: 0x2, type: "uint64", access: "R V", conformance: "O",
            xref: "core§11.13.6.3",
            details: "Indicates the current amount of heap memory, in bytes, that is being used."
        }),

        Attribute({
            name: "CurrentHeapHighWatermark", id: 0x3, type: "uint64", access: "R V", conformance: "WTRMRK",
            xref: "core§11.13.6.4",
            details: "Indicates the maximum amount of heap memory, in bytes, that has been used by the Node. This value " +
                "shall only be reset upon a Node reboot or upon receiving of the ResetWatermarks command."
        }),

        Event(
            {
                name: "SoftwareFault", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "core§11.13.8.1",
                details: "This Event shall be generated when a software fault occurs on the Node."
            },
            Field({
                name: "Id", id: 0x0, type: "uint64", conformance: "M", default: 0, xref: "core§11.13.8.1.1",
                details: "This field shall be set to the ID of the software thread in which the last software fault occurred."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "O", constraint: "max 8",
                xref: "core§11.13.8.1.2",
                details: "This field shall be set to a manufacturer-specified name or prefix of the software thread in which " +
                    "the last software fault occurred."
            }),

            Field({
                name: "FaultRecording", id: 0x2, type: "octstr", conformance: "O", constraint: "max 1024",
                xref: "core§11.13.8.1.3",
                details: "This field shall be a manufacturer-specified payload intended to convey information to assist in " +
                    "further diagnosing or debugging a software fault. The FaultRecording field may be used to convey " +
                    "information such as, but not limited to, thread backtraces or register contents."
            })
        ),

        Command({
            name: "ResetWatermarks", id: 0x0, access: "M", conformance: "WTRMRK", direction: "request",
            response: "status", xref: "core§11.13.7.1",

            details: "This command is used to reset the high watermarks for heap and stack memory." +
                "\n" +
                "Receipt of this command shall reset the following values which track high and lower watermarks:" +
                "\n" +
                "  • The StackFreeMinimum field of the ThreadMetrics attribute" +
                "\n" +
                "  • The CurrentHeapHighWatermark attribute" +
                "\n" +
                "### Effect on Receipt" +
                "\n" +
                "On receipt of this command, the Node shall make the following modifications to attributes it " +
                "supports:" +
                "\n" +
                "If implemented, the server shall set the value of the CurrentHeapHighWatermark attribute to the " +
                "value of the CurrentHeapUsed attribute." +
                "\n" +
                "If implemented, the server shall set the value of the StackFreeMinimum field for every thread to the " +
                "value of the corresponding thread’s StackFreeCurrent field."
        }),

        Datatype(
            { name: "ThreadMetricsStruct", type: "struct", xref: "core§11.13.5.1" },
            Field({
                name: "Id", id: 0x0, type: "uint64", conformance: "M", xref: "core§11.13.5.1.1",
                details: "The Id field shall be a server-assigned per-thread unique ID that is constant for the duration of " +
                    "the thread. Efforts SHOULD be made to avoid reusing ID values when possible."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "O", constraint: "max 8",
                xref: "core§11.13.5.1.2",
                details: "The Name field shall be set to a vendor defined name or prefix of the software thread that is static " +
                    "for the duration of the thread."
            }),

            Field({
                name: "StackFreeCurrent", id: 0x2, type: "uint32", conformance: "O", xref: "core§11.13.5.1.3",
                details: "The StackFreeCurrent field shall indicate the current amount of stack memory, in bytes, that are not " +
                    "being utilized on the respective thread."
            }),

            Field({
                name: "StackFreeMinimum", id: 0x3, type: "uint32", conformance: "O", xref: "core§11.13.5.1.4",
                details: "The StackFreeMinimum field shall indicate the minimum amount of stack memory, in bytes, that has " +
                    "been available at any point between the current time and this attribute being reset or initialized " +
                    "on the respective thread. This value shall only be reset upon a Node reboot or upon receiving of the " +
                    "ResetWatermarks command."
            }),

            Field({
                name: "StackSize", id: 0x4, type: "uint32", conformance: "O", xref: "core§11.13.5.1.5",
                details: "The StackSize field shall indicate the amount of stack memory, in bytes, that has been allocated for " +
                    "use by the respective thread."
            })
        )
    ),

    Cluster(
        {
            name: "ThreadNetworkDiagnostics", id: 0x35, classification: "node", pics: "DGTHREAD", quality: "K",
            xref: "core§11.14",
            details: "The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics " +
                "that may be used by a Node to assist a user or Administrator in diagnosing potential problems. The " +
                "Thread Network Diagnostics Cluster attempts to centralize all metrics that are relevant to a " +
                "potential Thread radio running on a Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 3 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.14.4" },
            Field({
                name: "PKTCNT", constraint: "0", title: "PacketCounts",
                details: "Server supports the counts for the number of received and transmitted packets on the Thread " +
                    "interface."
            }),
            Field({
                name: "ERRCNT", constraint: "1", title: "ErrorCounts",
                details: "Server supports the counts for the number of errors that have occurred during the reception and " +
                    "transmission of packets on the Thread interface."
            }),
            Field({
                name: "MLECNT", constraint: "2", title: "MleCounts",
                details: "Server supports the counts for various MLE layer happenings."
            }),
            Field({
                name: "MACCNT", constraint: "3", title: "MacCounts",
                details: "Server supports the counts for various MAC layer happenings."
            })
        ),

        Attribute({
            name: "Channel", id: 0x0, type: "uint16", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.14.6.1",
            details: "Indicates the 802.15.4 channel number configured on the Node’s Thread interface (that is, the Active " +
                "Operational Dataset’s current Channel value). A value of null shall indicate that the Thread " +
                "interface is not currently configured or operational."
        }),

        Attribute({
            name: "RoutingRole", id: 0x1, type: "RoutingRoleEnum", access: "R V", conformance: "M",
            quality: "X", xref: "core§11.14.6.2",
            details: "Indicates the role that this Node has within the routing of messages through the Thread network, as " +
                "defined by RoutingRoleEnum. The potential roles are defined in the following table. A value of null " +
                "shall indicate that the Thread interface is not currently configured or operational."
        }),

        Attribute({
            name: "NetworkName", id: 0x2, type: "string", access: "R V", conformance: "M", constraint: "max 16",
            quality: "X", xref: "core§11.14.6.3",
            details: "Indicates a human-readable (displayable) name for the Thread network that the Node has been " +
                "configured to join to. A value of null shall indicate that the Thread interface is not currently " +
                "configured or operational."
        }),

        Attribute({
            name: "PanId", id: 0x3, type: "uint16", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.14.6.4",
            details: "Indicates the 16-bit identifier of the Node on the Thread network. A value of null shall indicate " +
                "that the Thread interface is not currently configured or operational."
        }),

        Attribute({
            name: "ExtendedPanId", id: 0x4, type: "uint64", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.14.6.5",
            details: "Indicates the unique 64-bit identifier of the Node on the Thread network. A value of null shall " +
                "indicate that the Thread interface is not currently configured or operational."
        }),

        Attribute({
            name: "MeshLocalPrefix", id: 0x5, type: "ipv6pre", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.14.6.6",
            details: "Indicates the mesh-local IPv6 prefix for the Thread network that the Node has been configured to " +
                "join to. A value of null shall indicate that the Thread interface is not currently configured or " +
                "operational."
        }),

        Attribute({
            name: "OverrunCount", id: 0x6, type: "uint64", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "C", xref: "core§11.14.6.7",
            details: "Indicates the number of packets dropped either at ingress or egress, due to lack of buffer memory to " +
                "retain all packets on the ethernet network interface. The OverrunCount attribute shall be reset to 0 " +
                "upon a reboot of the Node."
        }),

        Attribute(
            {
                name: "NeighborTable", id: 0x7, type: "list", access: "R V", conformance: "M", default: [],
                xref: "core§11.14.6.8",
                details: "Indicates the current list of Nodes that comprise the neighbor table on the Node."
            },
            Field({ name: "entry", type: "NeighborTableStruct" })
        ),

        Attribute(
            {
                name: "RouteTable", id: 0x8, type: "list", access: "R V", conformance: "M", default: [],
                xref: "core§11.14.6.9",
                details: "Indicates the current list of router capable Nodes for which routes have been established."
            },
            Field({ name: "entry", type: "RouteTableStruct" })
        ),

        Attribute({
            name: "PartitionId", id: 0x9, type: "uint32", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.14.6.10",
            details: "Indicates the Thread Leader Partition Id for the Thread network to which the Node is joined. Null if " +
                "not attached to a Thread network."
        }),

        Attribute({
            name: "Weighting", id: 0xa, type: "uint16", access: "R V", conformance: "M", constraint: "max 255",
            quality: "X", xref: "core§11.14.6.11",
            details: "Indicates the Thread Leader Weight used when operating in the Leader role. Null if not attached to a " +
                "Thread network."
        }),

        Attribute({
            name: "DataVersion", id: 0xb, type: "uint16", access: "R V", conformance: "M",
            constraint: "max 255", quality: "X", xref: "core§11.14.6.12",
            details: "Indicates the full Network Data Version the Node currently uses. Null if not attached to a Thread " +
                "network."
        }),

        Attribute({
            name: "StableDataVersion", id: 0xc, type: "uint16", access: "R V", conformance: "M",
            constraint: "max 255", quality: "X", xref: "core§11.14.6.13",
            details: "Indicates the Network Data Version for the stable subset of data the Node currently uses. Null if " +
                "not attached to a Thread network."
        }),

        Attribute({
            name: "LeaderRouterId", id: 0xd, type: "uint8", access: "R V", conformance: "M",
            constraint: "max 62", quality: "X", xref: "core§11.14.6.14",
            details: "Indicates the 8-bit LeaderRouterId the Node shall attempt to utilize upon becoming a router or " +
                "leader on the Thread network. Null if not attached to a Thread network."
        }),

        Attribute({
            name: "DetachedRoleCount", id: 0xe, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.15",
            details: "Indicates the number of times the Node entered the OT_DEVICE_ROLE_DETACHED role as specified within " +
                "the Thread specification. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "ChildRoleCount", id: 0xf, type: "uint16", access: "R V", conformance: "[MLECNT]", default: 0,
            quality: "C", xref: "core§11.14.6.16",
            details: "Indicates the number of times the Node entered the OT_DEVICE_ROLE_CHILD role as specified within the " +
                "Thread specification. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RouterRoleCount", id: 0x10, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.17",
            details: "Indicates the number of times the Node entered the OT_DEVICE_ROLE_ROUTER role as specified within " +
                "the Thread specification. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "LeaderRoleCount", id: 0x11, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.18",
            details: "Indicates the number of times the Node entered the OT_DEVICE_ROLE_LEADER role as specified within " +
                "the Thread specification. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "AttachAttemptCount", id: 0x12, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.19",
            details: "Indicates the number of attempts that have been made to attach to a Thread network while the Node " +
                "was detached from all Thread networks. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "PartitionIdChangeCount", id: 0x13, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.20",
            details: "Indicates the number of times that the Thread network that the Node is connected to has changed its " +
                "Partition ID. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "BetterPartitionAttachAttemptCount", id: 0x14, type: "uint16", access: "R V",
            conformance: "[MLECNT]", default: 0, quality: "C", xref: "core§11.14.6.21",
            details: "Indicates the number of times a Node has attempted to attach to a different Thread partition that it " +
                "has determined is better than the partition it is currently attached to. This value shall only be " +
                "reset upon a Node reboot."
        }),

        Attribute({
            name: "ParentChangeCount", id: 0x15, type: "uint16", access: "R V", conformance: "[MLECNT]",
            default: 0, quality: "C", xref: "core§11.14.6.22",
            details: "Indicates the number of times a Node has changed its parent. This value shall only be reset upon a " +
                "Node reboot."
        }),

        Attribute({
            name: "TxTotalCount", id: 0x16, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.23",
            details: "Indicates the total number of unique MAC frame transmission requests. The attribute shall only be " +
                "incremented by 1 for each MAC transmission request regardless of the amount of CCA failures, CSMA-CA " +
                "attempts, or retransmissions. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxUnicastCount", id: 0x17, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.24",
            details: "Indicates the total number of unique unicast MAC frame transmission requests. The attribute shall " +
                "only be incremented by 1 for each unicast MAC transmission request regardless of the amount of CCA " +
                "failures, CSMA-CA attempts, or retransmissions. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxBroadcastCount", id: 0x18, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.25",
            details: "Indicates the total number of unique broadcast MAC frame transmission requests. The attribute shall " +
                "only be incremented by 1 for each broadcast MAC transmission request regardless of the amount of CCA " +
                "failures, CSMA-CA attempts, or retransmissions. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxAckRequestedCount", id: 0x19, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.26",
            details: "Indicates the total number of unique MAC frame transmission requests with requested acknowledgment. " +
                "The attribute shall only be incremented by 1 for each MAC transmission request with requested " +
                "acknowledgment regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions. This " +
                "value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxAckedCount", id: 0x1a, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.27",
            details: "Indicates the total number of unique MAC frame transmission requests that were acked. The attribute " +
                "shall only be incremented by 1 for each MAC transmission request that is acked regardless of the " +
                "amount of CCA failures, CSMA-CA attempts, or retransmissions. This value shall only be reset upon a " +
                "Node reboot."
        }),

        Attribute({
            name: "TxNoAckRequestedCount", id: 0x1b, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.28",
            details: "Indicates the total number of unique MAC frame transmission requests without requested " +
                "acknowledgment. The attribute shall only be incremented by 1 for each MAC transmission request that " +
                "is does not request acknowledgement regardless of the amount of CCA failures, CSMA-CA attempts, or " +
                "retransmissions."
        }),

        Attribute({
            name: "TxDataCount", id: 0x1c, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.29",
            details: "Indicates the total number of unique MAC Data frame transmission requests. The attribute shall only " +
                "be incremented by 1 for each MAC Data frame transmission request regardless of the amount of CCA " +
                "failures, CSMA-CA attempts, or retransmissions. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxDataPollCount", id: 0x1d, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.30",
            details: "Indicates the total number of unique MAC Data Poll frame transmission requests. The attribute shall " +
                "only be incremented by 1 for each MAC Data Poll frame transmission request regardless of the amount " +
                "of CCA failures, CSMA-CA attempts, or retransmissions. This value shall only be reset upon a Node " +
                "reboot."
        }),

        Attribute({
            name: "TxBeaconCount", id: 0x1e, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.31",
            details: "Indicates the total number of unique MAC Beacon frame transmission requests. The attribute shall " +
                "only be incremented by 1 for each MAC Beacon frame transmission request regardless of the amount of " +
                "CCA failures, CSMA-CA attempts, or retransmissions."
        }),

        Attribute({
            name: "TxBeaconRequestCount", id: 0x1f, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.32",
            details: "Indicates the total number of unique MAC Beacon Request frame transmission requests. The attribute " +
                "shall only be incremented by 1 for each MAC Beacon Request frame transmission request regardless of " +
                "the amount of CCA failures, CSMA-CA attempts, or retransmissions. This value shall only be reset " +
                "upon a Node reboot."
        }),

        Attribute({
            name: "TxOtherCount", id: 0x20, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.33",
            details: "Indicates the total number of unique MAC frame transmission requests that are not counted by any " +
                "other attribute. The attribute shall only be incremented by 1 for each MAC frame transmission " +
                "request regardless of the amount of CCA failures, CSMA-CA attempts, or retransmissions. This value " +
                "shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxRetryCount", id: 0x21, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.34",
            details: "Indicates the total number of MAC retransmission attempts. The attribute shall only be incremented " +
                "by 1 for each retransmission attempt that may be triggered by lack of acknowledgement, CSMA/CA " +
                "failure, or other type of transmission error. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxDirectMaxRetryExpiryCount", id: 0x22, type: "uint32", access: "R V",
            conformance: "[MACCNT]", default: 0, quality: "C", xref: "core§11.14.6.35",
            details: "Indicates the total number of unique MAC transmission packets that meet maximal retry limit for " +
                "direct packets. The attribute shall only be incremented by 1 for each unique MAC transmission " +
                "packets that meets the maximal retry limit for direct packets. This value shall only be reset upon a " +
                "Node reboot."
        }),

        Attribute({
            name: "TxIndirectMaxRetryExpiryCount", id: 0x23, type: "uint32", access: "R V",
            conformance: "[MACCNT]", default: 0, quality: "C", xref: "core§11.14.6.36",
            details: "Indicates the total number of unique MAC transmission packets that meet maximal retry limit for " +
                "indirect packets. The attribute shall only be incremented by 1 for each unique MAC transmission " +
                "packets that meets the maximal retry limit for indirect packets. This value shall only be reset upon " +
                "a Node reboot."
        }),

        Attribute({
            name: "TxErrCcaCount", id: 0x24, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.37",
            details: "Indicates the total number of CCA failures. The TxErrCcaCount attribute shall only be incremented by " +
                "1 for each instance of a CCA failure. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "TxErrAbortCount", id: 0x25, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.38",
            details: "Indicates the total number of unique MAC transmission request failures caused by an abort error. The " +
                "attribute shall only be incremented by 1 for each unique MAC transmission request failure caused by " +
                "an abort error."
        }),

        Attribute({
            name: "TxErrBusyChannelCount", id: 0x26, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.39",
            details: "Indicates the total number of unique MAC transmission request failures caused by an error as the " +
                "result of a busy channel (a CSMA/CA fail). The attribute shall only be incremented by 1 for each " +
                "unique MAC transmission request failure caused by a busy channel such as a CSMA/CA failure."
        }),

        Attribute({
            name: "RxTotalCount", id: 0x27, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.40",
            details: "Indicates the total number of received unique MAC frames. This value shall only be reset upon a Node " +
                "reboot."
        }),

        Attribute({
            name: "RxUnicastCount", id: 0x28, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.41",
            details: "Indicates the total number of received unique unicast MAC frames. This value shall only be reset " +
                "upon a Node reboot."
        }),

        Attribute({
            name: "RxBroadcastCount", id: 0x29, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.42",
            details: "Indicates the total number of received unique broadcast MAC frames. This value shall only be reset " +
                "upon a Node reboot."
        }),

        Attribute({
            name: "RxDataCount", id: 0x2a, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.43",
            details: "Indicates the total number of received unique MAC Data frames. This value shall only be reset upon a " +
                "Node reboot."
        }),

        Attribute({
            name: "RxDataPollCount", id: 0x2b, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.44",
            details: "Indicates the total number of received unique MAC Data Poll frames. This value shall only be reset " +
                "upon a Node reboot."
        }),

        Attribute({
            name: "RxBeaconCount", id: 0x2c, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.45",
            details: "Indicates the total number of received unique MAC Beacon frames. This value shall only be reset upon " +
                "a Node reboot."
        }),

        Attribute({
            name: "RxBeaconRequestCount", id: 0x2d, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.46",
            details: "Indicates the total number of received unique MAC Beacon Request frames. This value shall only be " +
                "reset upon a Node reboot."
        }),

        Attribute({
            name: "RxOtherCount", id: 0x2e, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.47",
            details: "Indicates the total number of received unique MAC frame requests that are not counted by any other " +
                "attribute. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxAddressFilteredCount", id: 0x2f, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.48",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of MAC filtering. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxDestAddrFilteredCount", id: 0x30, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.49",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of a destination address check. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxDuplicatedCount", id: 0x31, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.50",
            details: "Indicates the total number of received MAC frame requests that have been dropped as a result of " +
                "being a duplicate of a previously received MAC frame request. This value shall only be reset upon a " +
                "Node reboot."
        }),

        Attribute({
            name: "RxErrNoFrameCount", id: 0x32, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.51",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of missing or malformed frame contents. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxErrUnknownNeighborCount", id: 0x33, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.52",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of originating from an unknown neighbor device. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxErrInvalidSrcAddrCount", id: 0x34, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.53",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of containing an invalid source address. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxErrSecCount", id: 0x35, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.54",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of an error with the security of the received frame. This value shall only be reset upon a Node " +
                "reboot."
        }),

        Attribute({
            name: "RxErrFcsCount", id: 0x36, type: "uint32", access: "R V", conformance: "[MACCNT]", default: 0,
            quality: "C", xref: "core§11.14.6.55",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of an error with the FCS of the received frame. This value shall only be reset upon a Node reboot."
        }),

        Attribute({
            name: "RxErrOtherCount", id: 0x37, type: "uint32", access: "R V", conformance: "[MACCNT]",
            default: 0, quality: "C", xref: "core§11.14.6.56",
            details: "Indicates the total number of received unique MAC frame requests that have been dropped as a result " +
                "of an error that is not counted by any other attribute. This value shall only be reset upon a Node " +
                "reboot."
        }),

        Attribute({
            name: "ActiveTimestamp", id: 0x38, type: "uint64", access: "R V", conformance: "O", default: 0,
            quality: "X", xref: "core§11.14.6.57",
            details: "Null when there is no dataset configured."
        }),
        Attribute({
            name: "PendingTimestamp", id: 0x39, type: "uint64", access: "R V", conformance: "O", default: 0,
            quality: "X", xref: "core§11.14.6.58",
            details: "Null when there is no dataset configured."
        }),
        Attribute({
            name: "Delay", id: 0x3a, type: "uint32", access: "R V", conformance: "O", default: 0, quality: "X",
            xref: "core§11.14.6.59",
            details: "Null when there is no dataset configured."
        }),

        Attribute({
            name: "SecurityPolicy", id: 0x3b, type: "SecurityPolicy", access: "R V", conformance: "M",
            quality: "X", xref: "core§11.14.6.60",
            details: "Indicates the current security policies for the Thread partition to which a Node is connected. Null " +
                "when there is no dataset configured."
        }),

        Attribute({
            name: "ChannelPage0Mask", id: 0x3c, type: "octstr", access: "R V", conformance: "M",
            constraint: "4", quality: "X", xref: "core§11.14.6.61",

            details: "Indicates the channels within channel page 0, in the 2.4GHz ISM band. The channels are represented " +
                "in most significant bit order, with bit value 1 meaning selected, bit value 0 meaning unselected. " +
                "For example, the most significant bit of the left-most byte indicates channel" +
                "\n" +
                "0. If channel 0 and channel 10 are selected, the mask would be: 80 20 00 00. Null when there is no " +
                "dataset configured."
        }),

        Attribute({
            name: "OperationalDatasetComponents", id: 0x3d, type: "OperationalDatasetComponents", access: "R V",
            conformance: "M", quality: "X", xref: "core§11.14.6.62",
            details: "Indicates a collection of flags to indicate the presence of various operationally acquired values."
        }),

        Attribute(
            {
                name: "ActiveNetworkFaultsList", id: 0x3e, type: "list", access: "R V", conformance: "M",
                constraint: "max 4", xref: "core§11.14.6"
            },
            Field({ name: "entry", type: "NetworkFaultEnum" })
        ),

        Attribute({
            name: "ExtAddress", id: 0x3f, type: "uint64", access: "R V", conformance: "P, M", quality: "X",
            xref: "core§11.14.6.64",
            details: "Indicates the IEEE 802.15.4 extended address for the Node. A value of null shall indicate that the " +
                "extended address is not yet known. The uint64 value is composed by taking the 8 octets of the " +
                "extended address EUI-64 and treating them as a big-endian integer. For example, octet string (in " +
                "hexadecimal, from first octet to last) 00112233AABBCCDD would lead to a value of 0x00112233AABBCCDD."
        }),

        Attribute({
            name: "Rloc16", id: 0x40, type: "uint16", access: "R V", conformance: "P, M", quality: "X",
            xref: "core§11.14.6.65",
            details: "Indicates the RLOC16 of the Node. A value of null shall indicate that the Thread interface is not " +
                "currently configured or operational. The uint16 value is composed by taking the two RLOC16 and " +
                "treating the octet string as if it was encoding a big-endian integer. For example, octet string (in " +
                "hexadecimal, from first octet to last) 44AA would lead to a value of 0x44AA."
        }),

        Event(
            {
                name: "ConnectionStatus", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "core§11.14.8.2",
                details: "The ConnectionStatus Event shall indicate that a Node’s connection status to a Thread network has " +
                    "changed."
            },

            Field({ name: "ConnectionStatus", id: 0x0, type: "ConnectionStatusEnum", conformance: "M" })
        ),

        Event(
            {
                name: "NetworkFaultChange", id: 0x1, access: "V", conformance: "O", priority: "info",
                xref: "core§11.14.8.1",
                details: "The NetworkFaultChange Event shall indicate a change in the set of network faults currently detected " +
                    "by the Node."
            },

            Field(
                {
                    name: "Current", id: 0x0, type: "list", conformance: "M", constraint: "max 4",
                    xref: "core§11.14.8.1.1",
                    details: "This field shall represent the set of faults currently detected, as per Section 11.14.5.1, " +
                        "“NetworkFaultEnum Type”."
                },

                Field({ name: "entry", type: "NetworkFaultEnum" })
            ),

            Field(
                {
                    name: "Previous", id: 0x1, type: "list", conformance: "M", constraint: "max 4",
                    xref: "core§11.14.8.1.2",
                    details: "This field shall represent the set of faults detected prior to this change event, as per Section " +
                        "11.14.5.1, “NetworkFaultEnum Type”."
                },

                Field({ name: "entry", type: "NetworkFaultEnum" })
            )
        ),

        Command({
            name: "ResetCounts", id: 0x0, access: "M", conformance: "ERRCNT", direction: "request",
            response: "status", xref: "core§11.14.7.1",

            details: "This command is used to reset the count attributes." +
                "\n" +
                "Reception of this command shall reset the following attributes to 0:" +
                "\n" +
                "  • OverrunCount" +
                "\n" +
                "Upon completion, this command shall send a status code of SUCCESS back to the initiator."
        }),

        Datatype(
            { name: "NetworkFaultEnum", type: "enum8", xref: "core§11.14.5.1" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M", description: "Indicates an unspecified fault." }),
            Field({ name: "LinkDown", id: 0x1, conformance: "M", description: "Indicates the Thread link is down." }),
            Field({
                name: "HardwareFailure", id: 0x2, conformance: "M",
                description: "Indicates there has been Thread hardware failure."
            }),
            Field({
                name: "NetworkJammed", id: 0x3, conformance: "M",
                description: "Indicates the Thread network is jammed."
            })
        ),

        Datatype(
            { name: "ConnectionStatusEnum", type: "enum8", xref: "core§11.14.5.2" },
            Field({ name: "Connected", id: 0x0, conformance: "M", description: "Node is connected" }),
            Field({ name: "NotConnected", id: 0x1, conformance: "M", description: "Node is not connected" })
        ),

        Datatype(
            { name: "RoutingRoleEnum", type: "enum8", xref: "core§11.14.5.3" },
            Field({ name: "Unspecified", id: 0x0, conformance: "M", description: "Unspecified routing role." }),
            Field({
                name: "Unassigned", id: 0x1, conformance: "M",
                description: "The Node does not currently have a role as a result of the Thread interface not currently being configured or operational."
            }),
            Field({
                name: "SleepyEndDevice", id: 0x2, conformance: "M",
                description: "The Node acts as a Sleepy End Device with RX-off-when-idle sleepy radio behavior."
            }),
            Field({
                name: "EndDevice", id: 0x3, conformance: "M",
                description: "The Node acts as an End Device without RX- off-when-idle sleepy radio behavior."
            }),
            Field({ name: "Reed", id: 0x4, conformance: "M", description: "The Node acts as an Router Eligible End Device." }),
            Field({ name: "Router", id: 0x5, conformance: "M", description: "The Node acts as a Router Device." }),
            Field({ name: "Leader", id: 0x6, conformance: "M", description: "The Node acts as a Leader Device." })
        ),

        Datatype(
            { name: "NeighborTableStruct", type: "struct", xref: "core§11.14.5.4" },

            Field({
                name: "ExtAddress", id: 0x0, type: "uint64", conformance: "M", xref: "core§11.14.5.4.1",
                details: "This field shall specify the IEEE 802.15.4 extended address for the neighboring Node. The uint64 " +
                    "value is composed by taking the 8 octets of the extended address EUI-64 and treating them as a " +
                    "big-endian integer. For example, octet string (in hexadecimal, from first octet to last) " +
                    "00112233AABBCCDD would lead to a value of 0x00112233AABBCCDD."
            }),

            Field({
                name: "Age", id: 0x1, type: "uint32", conformance: "M", xref: "core§11.14.5.4.2",
                details: "This field shall specify the duration of time, in seconds, since a frame has been received from the " +
                    "neighboring Node."
            }),

            Field({
                name: "Rloc16", id: 0x2, type: "uint16", conformance: "M", xref: "core§11.14.5.4.3",
                details: "This field shall specify the RLOC16 of the neighboring Node. The uint16 value is composed by taking " +
                    "the two RLOC16 and treating the octet string as if it was encoding a big-endian integer. For " +
                    "example, octet string (in hexadecimal, from first octet to last) 44AA would lead to a value of " +
                    "0x44AA."
            }),

            Field({
                name: "LinkFrameCounter", id: 0x3, type: "uint32", conformance: "M", xref: "core§11.14.5.4.4",
                details: "This field shall specify the number of link layer frames that have been received from the " +
                    "neighboring node. This field shall be reset to 0 upon a reboot of the Node."
            }),
            Field({
                name: "MleFrameCounter", id: 0x4, type: "uint32", conformance: "M", xref: "core§11.14.5.4.5",
                details: "This field shall specify the number of Mesh Link Establishment frames that have been received from " +
                    "the neighboring node. This field shall be reset to 0 upon a reboot of the Node."
            }),

            Field({
                name: "Lqi", id: 0x5, type: "uint8", conformance: "M", constraint: "0 to 255",
                xref: "core§11.14.5.4.6",
                details: "This field shall specify the implementation specific mix of IEEE 802.15.4 PDU receive quality " +
                    "indicators, scaled from 0 to 255."
            }),

            Field({
                name: "AverageRssi", id: 0x6, type: "int8", conformance: "M", constraint: "-128 to 0",
                default: null, quality: "X", xref: "core§11.14.5.4.7",
                details: "This field SHOULD specify the average RSSI across all received frames from the neighboring Node " +
                    "since the receiving Node’s last reboot. If there is no known received frames this field SHOULD have " +
                    "the value of null. This field shall have the units of dBm, having the range -128 dBm to 0 dBm."
            }),

            Field({
                name: "LastRssi", id: 0x7, type: "int8", conformance: "M", constraint: "-128 to 0", default: null,
                quality: "X", xref: "core§11.14.5.4.8",
                details: "This field shall specify the RSSI of the most recently received frame from the neighboring Node. If " +
                    "there is no known last received frame the LastRssi field SHOULD have the value of null. This field " +
                    "shall have the units of dBm, having the range -128 dBm to 0 dBm."
            }),

            Field({
                name: "FrameErrorRate", id: 0x8, type: "uint8", conformance: "M", constraint: "0 to 100",
                default: 0, xref: "core§11.14.5.4.9",
                details: "This field shall specify the percentage of received frames from the neighboring Node that have " +
                    "resulted in errors."
            }),

            Field({
                name: "MessageErrorRate", id: 0x9, type: "uint8", conformance: "M", constraint: "0 to 100",
                default: 0, xref: "core§11.14.5.4.10",
                details: "This field shall specify the percentage of received messages from the neighboring Node that have " +
                    "resulted in errors."
            }),

            Field({
                name: "RxOnWhenIdle", id: 0xa, type: "bool", conformance: "M", xref: "core§11.14.5.4.11",
                details: "This field shall specify if the neighboring Node is capable of receiving frames while the Node is in " +
                    "an idle state."
            }),
            Field({
                name: "FullThreadDevice", id: 0xb, type: "bool", conformance: "M", xref: "core§11.14.5.4.12",
                details: "This field shall specify if the neighboring Node is a full Thread device."
            }),
            Field({
                name: "FullNetworkData", id: 0xc, type: "bool", conformance: "M", xref: "core§11.14.5.4.13",
                details: "This field shall specify if the neighboring Node requires the full Network Data. If set to False, " +
                    "the neighboring Node only requires the stable Network Data."
            }),
            Field({
                name: "IsChild", id: 0xd, type: "bool", conformance: "M", xref: "core§11.14.5.4.14",
                details: "This field shall specify if the neighboring Node is a direct child of the Node reporting the " +
                    "NeighborTable attribute."
            })
        ),

        Datatype(
            { name: "RouteTableStruct", type: "struct", xref: "core§11.14.5.5" },

            Field({
                name: "ExtAddress", id: 0x0, type: "uint64", conformance: "M", xref: "core§11.14.5.5.1",
                details: "This field shall specify the IEEE 802.15.4 extended address for the Node for which this route table " +
                    "entry corresponds. The uint64 value is composed by taking the 8 octets of the extended address EUI- " +
                    "64 and treating them as a big-endian integer. For example, octet string (in hexadecimal, from first " +
                    "octet to last) 00112233AABBCCDD would lead to a value of 0x00112233AABBCCDD."
            }),

            Field({
                name: "Rloc16", id: 0x1, type: "uint16", conformance: "M", xref: "core§11.14.5.5.2",
                details: "This field shall specify the RLOC16 for the Node for which this route table entry corresponds. The " +
                    "uint16 value is composed by taking the two RLOC16 and treating the octet string as if it was " +
                    "encoding a big-endian integer. For example, octet string (in hexadecimal, from first octet to last) " +
                    "44AA would lead to a value of 0x44AA."
            }),

            Field({
                name: "RouterId", id: 0x2, type: "uint8", conformance: "M", xref: "core§11.14.5.5.3",
                details: "This field shall specify the Router ID for the Node for which this route table entry corresponds."
            }),
            Field({
                name: "NextHop", id: 0x3, type: "uint8", conformance: "M", xref: "core§11.14.5.5.4",
                details: "This field shall specify the Router ID for the next hop in the route to the Node for which this " +
                    "route table entry corresponds."
            }),
            Field({
                name: "PathCost", id: 0x4, type: "uint8", conformance: "M", xref: "core§11.14.5.5.5",
                details: "This Field shall specify the cost of the route to the Node for which this route table entry " +
                    "corresponds."
            }),
            Field({
                name: "LqiIn", id: 0x5, type: "uint8", conformance: "M", xref: "core§11.14.5.5.6",
                details: "This field shall specify the implementation specific mix of IEEE 802.15.4 PDU receive quality " +
                    "indicators, scaled from 0 to 255, from the perspective of the Node reporting the neighbor table."
            }),

            Field({
                name: "LqiOut", id: 0x6, type: "uint8", conformance: "M", xref: "core§11.14.5.5.7",
                details: "This field shall specify the implementation specific mix of IEEE 802.15.4 PDU receive quality " +
                    "indicators, scaled from 0 to 255, from the perspective of the Node specified within the NextHop " +
                    "field."
            }),

            Field({
                name: "Age", id: 0x7, type: "uint8", conformance: "M", xref: "core§11.14.5.5.8",
                details: "This field shall specify the duration of time, in seconds, since a frame has been received from the " +
                    "Node for which this route table entry corresponds."
            }),
            Field({
                name: "Allocated", id: 0x8, type: "bool", conformance: "M", xref: "core§11.14.5.5.9",
                details: "This field shall specify if the router ID as defined within the RouterId field has been allocated."
            }),
            Field({
                name: "LinkEstablished", id: 0x9, type: "bool", conformance: "M", xref: "core§11.14.5.5.10",
                details: "This field shall specify if a link has been established to the Node for which this route table entry " +
                    "corresponds."
            })
        ),

        Datatype(
            { name: "SecurityPolicy", type: "struct", xref: "core§11.14.5.6" },
            Field({
                name: "RotationTime", id: 0x0, type: "uint16", conformance: "M", xref: "core§11.14.5.6.1",
                details: "This field shall specify the interval of time, in hours, that Thread security keys are rotated. Null " +
                    "when there is no dataset configured."
            }),
            Field({
                name: "Flags", id: 0x1, type: "uint16", conformance: "M", xref: "core§11.14.5.6.2",
                details: "This field shall specify the flags as specified in Thread 1.3.0 section 8.10.1.15. Null when there " +
                    "is no dataset configured."
            })
        ),

        Datatype(
            { name: "OperationalDatasetComponents", type: "struct", xref: "core§11.14.5.7" },
            Field({
                name: "ActiveTimestampPresent", id: 0x0, type: "bool", conformance: "M", xref: "core§11.14.5.7.1",
                details: "This field shall be True if the Node has an active timestamp present, else False."
            }),
            Field({
                name: "PendingTimestampPresent", id: 0x1, type: "bool", conformance: "M", xref: "core§11.14.5.7.2",
                details: "This field shall be True if the Node has a pending timestamp is present, else False."
            }),
            Field({
                name: "MasterKeyPresent", id: 0x2, type: "bool", conformance: "M", xref: "core§11.14.5.7.3",
                details: "This field shall be True if the Node has the Thread master key, else False."
            }),
            Field({
                name: "NetworkNamePresent", id: 0x3, type: "bool", conformance: "M", xref: "core§11.14.5.7.4",
                details: "This field shall be True if the Node has the Thread network’s name, else False."
            }),
            Field({
                name: "ExtendedPanIdPresent", id: 0x4, type: "bool", conformance: "M", xref: "core§11.14.5.7.5",
                details: "This field shall be True if the Node has an extended Pan ID, else False."
            }),
            Field({
                name: "MeshLocalPrefixPresent", id: 0x5, type: "bool", conformance: "M", xref: "core§11.14.5.7.6",
                details: "This field shall be True if the Node has the mesh local prefix, else False."
            }),
            Field({
                name: "DelayPresent", id: 0x6, type: "bool", conformance: "M", xref: "core§11.14.5.7.7",
                details: "This field shall be True if the Node has the Thread network delay set, else False."
            }),
            Field({
                name: "PanIdPresent", id: 0x7, type: "bool", conformance: "M", xref: "core§11.14.5.7.8",
                details: "This field shall be True if the Node has a Pan ID, else False."
            }),
            Field({
                name: "ChannelPresent", id: 0x8, type: "bool", conformance: "M", xref: "core§11.14.5.7.9",
                details: "This field shall be True if the Node has configured an operational channel for the Thread network, " +
                    "else False."
            }),
            Field({
                name: "PskcPresent", id: 0x9, type: "bool", conformance: "M", xref: "core§11.14.5.7.10",
                details: "This field shall be True if the Node has been configured with the Thread network Pskc, else False."
            }),
            Field({
                name: "SecurityPolicyPresent", id: 0xa, type: "bool", conformance: "M", xref: "core§11.14.5.7.11",
                details: "This field shall be True if the Node has been configured with the Thread network security policies, " +
                    "else False."
            }),
            Field({
                name: "ChannelMaskPresent", id: 0xb, type: "bool", conformance: "M", xref: "core§11.14.5.7.12",
                details: "This field shall be True if the Node has available a mask of available channels, else False."
            })
        )
    ),

    Cluster(
        {
            name: "WiFiNetworkDiagnostics", id: 0x36, classification: "node", pics: "DGWIFI", quality: "K",
            xref: "core§11.15",
            details: "The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics " +
                "that may be used by a Node to assist a user or Administrator in diagnosing potential problems. The " +
                "Wi-Fi Network Diagnostics Cluster attempts to centralize all metrics that are relevant to a " +
                "potential Wi-Fi radio running on a Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.15.4" },
            Field({
                name: "PKTCNT", constraint: "0", title: "PacketCounts",
                details: "Node makes available the counts for the number of received and transmitted packets on the Wi-Fi " +
                    "interface."
            }),
            Field({
                name: "ERRCNT", constraint: "1", title: "ErrorCounts",
                details: "Node makes available the counts for the number of errors that have occurred during the reception and " +
                    "transmission of packets on the Wi-Fi interface."
            })
        ),

        Attribute({
            name: "Bssid", id: 0x0, type: "octstr", access: "R V", conformance: "M", constraint: "6",
            default: null, quality: "X", xref: "core§11.15.6.1",
            details: "Indicates the BSSID for which the Wi-Fi network the Node is currently connected."
        }),
        Attribute({
            name: "SecurityType", id: 0x1, type: "SecurityTypeEnum", access: "R V", conformance: "M",
            default: null, quality: "X", xref: "core§11.15.6.2",
            details: "Indicates the current type of Wi-Fi security used."
        }),
        Attribute({
            name: "WiFiVersion", id: 0x2, type: "WiFiVersionEnum", access: "R V", conformance: "M",
            default: null, quality: "X", xref: "core§11.15.6.3",
            details: "Indicates the current IEEE 802.11 standard version in use by the Node, per the table below."
        }),
        Attribute({
            name: "ChannelNumber", id: 0x3, type: "uint16", access: "R V", conformance: "M", default: null,
            quality: "X", xref: "core§11.15.6.4",
            details: "Indicates the channel that Wi-Fi communication is currently operating on."
        }),
        Attribute({
            name: "Rssi", id: 0x4, type: "int8", access: "R V", conformance: "M", constraint: "-120 to 0",
            default: null, quality: "X C", xref: "core§11.15.6.5",
            details: "Indicates the current RSSI of the Node’s Wi-Fi radio in dBm."
        }),

        Attribute({
            name: "BeaconLostCount", id: 0x5, type: "uint32", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "X C", xref: "core§11.15.6.6",
            details: "Indicates the count of the number of missed beacons the Node has detected. If the Node does not have " +
                "an ability to count beacons expected and not received, this value may remain set to zero."
        }),

        Attribute({
            name: "BeaconRxCount", id: 0x6, type: "uint32", access: "R V", conformance: "PKTCNT", default: 0,
            quality: "X C", xref: "core§11.15.6.7",
            details: "Indicates the count of the number of received beacons. The total number of expected beacons that " +
                "could have been received during the interval since association SHOULD match the sum of BeaconRxCount " +
                "and BeaconLostCount. If the Node does not have an ability to report count of beacons received, this " +
                "value may remain set to zero."
        }),

        Attribute({
            name: "PacketMulticastRxCount", id: 0x7, type: "uint32", access: "R V", conformance: "PKTCNT",
            default: 0, quality: "X C", xref: "core§11.15.6.8",
            details: "Indicates the number of multicast packets received by the Node."
        }),
        Attribute({
            name: "PacketMulticastTxCount", id: 0x8, type: "uint32", access: "R V", conformance: "PKTCNT",
            default: 0, quality: "X C", xref: "core§11.15.6.9",
            details: "Indicates the number of multicast packets transmitted by the Node."
        }),
        Attribute({
            name: "PacketUnicastRxCount", id: 0x9, type: "uint32", access: "R V", conformance: "PKTCNT",
            default: 0, quality: "X C", xref: "core§11.15.6.10",
            details: "Indicates the number of unicast packets received by the Node."
        }),
        Attribute({
            name: "PacketUnicastTxCount", id: 0xa, type: "uint32", access: "R V", conformance: "PKTCNT",
            default: 0, quality: "X C", xref: "core§11.15.6.11",
            details: "Indicates the number of unicast packets transmitted by the Node."
        }),
        Attribute({
            name: "CurrentMaxRate", id: 0xb, type: "uint64", access: "R V", conformance: "O", default: 0,
            quality: "X C", xref: "core§11.15.6.12",
            details: "Indicates the current maximum PHY rate of transfer of data in bits-per-second."
        }),

        Attribute({
            name: "OverrunCount", id: 0xc, type: "uint64", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "X C", xref: "core§11.15.6.13",
            details: "Indicates the number of packets dropped either at ingress or egress, due to lack of buffer memory to " +
                "retain all packets on the network interface. The attribute shall be reset to 0 upon a reboot of the " +
                "Node."
        }),

        Event(
            {
                name: "Disconnection", id: 0x0, access: "V", conformance: "O", priority: "info",
                xref: "core§11.15.8.1",
                details: "The Disconnection Event shall indicate that a Node’s Wi-Fi connection has been disconnected as a " +
                    "result of de-authenticated or dis-association and indicates the reason."
            },

            Field({
                name: "ReasonCode", id: 0x0, type: "uint16", conformance: "M", xref: "core§11.15.8.1.1",
                details: "This field shall contain the Reason Code field value for the Disassociation or Deauthentication " +
                    "event that caused the disconnection and the value shall align with Table 9-49 \"Reason codes\" of IEEE " +
                    "802.11-2020."
            })
        ),

        Event(
            {
                name: "AssociationFailure", id: 0x1, access: "V", conformance: "O", priority: "info",
                xref: "core§11.15.8.2",
                details: "The AssociationFailure event shall indicate that a Node has attempted to connect, or reconnect, to a " +
                    "Wi-Fi access point, but is unable to successfully associate or authenticate, after exhausting all " +
                    "internal retries of its supplicant."
            },

            Field({
                name: "AssociationFailureCause", id: 0x0, type: "AssociationFailureCauseEnum", conformance: "M",
                xref: "core§11.15.8.2.1",
                details: "The Status field shall be set to a value from the AssociationFailureCauseEnum."
            }),

            Field({
                name: "Status", id: 0x1, type: "uint16", conformance: "M", xref: "core§11.15.8.2.2",

                details: "The Status field shall be set to the Status Code value that was present in the last frame related to " +
                    "association where Status Code was not equal to zero and which caused the failure of a last trial " +
                    "attempt, if this last failure was due to one of the following Management frames:" +
                    "\n" +
                    "  • Association Response (Type 0, Subtype 1)" +
                    "\n" +
                    "  • Reassociation Response (Type 0, Subtype 3)" +
                    "\n" +
                    "  • Authentication (Type 0, Subtype 11)" +
                    "\n" +
                    "Table 9-50 \"Status codes\" of IEEE 802.11-2020 contains a description of all values possible."
            })
        ),

        Event(
            {
                name: "ConnectionStatus", id: 0x2, access: "V", conformance: "O", priority: "info",
                xref: "core§11.15.8.3",
                details: "The ConnectionStatus Event shall indicate that a Node’s connection status to a Wi-Fi network has " +
                    "changed. Connected, in this context, shall mean that a Node acting as a Wi-Fi station is " +
                    "successfully associated to a Wi-Fi Access Point."
            },

            Field({ name: "ConnectionStatus", id: 0x0, type: "ConnectionStatusEnum", conformance: "M" })
        ),

        Command({
            name: "ResetCounts", id: 0x0, access: "O", conformance: "ERRCNT", direction: "request",
            response: "status", xref: "core§11.15.7.1",

            details: "This command is used to reset the count attributes." +
                "\n" +
                "Reception of this command shall reset the following attributes to 0:" +
                "\n" +
                "  • BeaconLostCount" +
                "\n" +
                "  • BeaconRxCount" +
                "\n" +
                "  • PacketMulticastRxCount" +
                "\n" +
                "  • PacketMulticastTxCount" +
                "\n" +
                "  • PacketUnicastRxCount" +
                "\n" +
                "  • PacketUnicastTxCount"
        }),

        Datatype(
            { name: "SecurityTypeEnum", type: "enum8", xref: "core§11.15.5.1" },
            Field({
                name: "Unspecified", id: 0x0, conformance: "M",
                description: "Indicate the usage of an unspecified Wi-Fi security type"
            }),
            Field({ name: "None", id: 0x1, conformance: "M", description: "Indicate the usage of no Wi-Fi security" }),
            Field({ name: "Wep", id: 0x2, conformance: "M", description: "Indicate the usage of WEP Wi-Fi security" }),
            Field({ name: "Wpa", id: 0x3, conformance: "M", description: "Indicate the usage of WPA Wi-Fi security" }),
            Field({ name: "Wpa2", id: 0x4, conformance: "M", description: "Indicate the usage of WPA2 Wi-Fi security" }),
            Field({ name: "Wpa3", id: 0x5, conformance: "M", description: "Indicate the usage of WPA3 Wi-Fi security" })
        ),

        Datatype(
            { name: "WiFiVersionEnum", type: "enum8", xref: "core§11.15.5.2" },
            Field({
                name: "A", id: 0x0, conformance: "M",
                title: "Indicate the network interface is currently using IEEE 802.11a against the wireless access point."
            }),
            Field({
                name: "B", id: 0x1, conformance: "M",
                title: "Indicate the network interface is currently using IEEE 802.11b against the wireless access point."
            }),
            Field({
                name: "G", id: 0x2, conformance: "M",
                title: "Indicate the network interface is currently using IEEE 802.11g against the wireless access point."
            }),
            Field({
                name: "N", id: 0x3, conformance: "M",
                title: "Indicate the network interface is currently using IEEE 802.11n against the wireless access point."
            }),
            Field({
                name: "Ac", id: 0x4, conformance: "M",
                description: "Indicate the network interface is currently using IEEE 802.11ac against the wireless access point."
            }),
            Field({
                name: "Ax", id: 0x5, conformance: "M",
                description: "Indicate the network interface is currently using IEEE 802.11ax against the wireless access point."
            }),
            Field({
                name: "Ah", id: 0x6, conformance: "M",
                description: "Indicate the network interface is currently using IEEE 802.11ah against the wireless access point."
            })
        ),

        Datatype(
            { name: "AssociationFailureCauseEnum", type: "enum8", xref: "core§11.15.5.3" },
            Field({ name: "Unknown", id: 0x0, conformance: "M", description: "The reason for the failure is unknown." }),
            Field({
                name: "AssociationFailed", id: 0x1, conformance: "M",
                description: "An error occurred during association."
            }),
            Field({
                name: "AuthenticationFailed", id: 0x2, conformance: "M",
                description: "An error occurred during authentication."
            }),
            Field({ name: "SsidNotFound", id: 0x3, conformance: "M", description: "The specified SSID could not be found." })
        ),

        Datatype(
            { name: "ConnectionStatusEnum", type: "enum8", xref: "core§11.15.5.4" },
            Field({ name: "Connected", id: 0x0, conformance: "M", description: "Indicate the node is connected" }),
            Field({ name: "NotConnected", id: 0x1, conformance: "M", description: "Indicate the node is not connected" })
        )
    ),

    Cluster(
        {
            name: "EthernetNetworkDiagnostics", id: 0x37, classification: "node", pics: "DGETH", quality: "K",
            xref: "core§11.16",
            details: "The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics " +
                "metrics that may be used by a Node to assist a user or Administrator in diagnosing potential " +
                "problems. The Ethernet Network Diagnostics Cluster attempts to centralize all metrics that are " +
                "relevant to a potential Ethernet connection to a Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.16.4" },
            Field({
                name: "PKTCNT", constraint: "0", title: "PacketCounts",
                details: "Node makes available the counts for the number of received and transmitted packets on the ethernet " +
                    "interface."
            }),
            Field({
                name: "ERRCNT", constraint: "1", title: "ErrorCounts",
                details: "Node makes available the counts for the number of errors that have occurred during the reception and " +
                    "transmission of packets on the ethernet interface."
            })
        ),

        Attribute({
            name: "PhyRate", id: 0x0, type: "PHYRateEnum", access: "R V", conformance: "O", default: null,
            quality: "X", xref: "core§11.16.6.1",
            details: "Indicates the current nominal, usable speed at the top of the physical layer of the Node. A value of " +
                "null shall indicate that the interface is not currently configured or operational."
        }),

        Attribute({
            name: "FullDuplex", id: 0x1, type: "bool", access: "R V", conformance: "O", default: null,
            quality: "X", xref: "core§11.16.6.2",
            details: "Indicates if the Node is currently utilizing the full-duplex operating mode. A value of null shall " +
                "indicate that the interface is not currently configured or operational."
        }),

        Attribute({
            name: "PacketRxCount", id: 0x2, type: "uint64", access: "R V", conformance: "PKTCNT", default: 0,
            quality: "C", xref: "core§11.16.6.3",
            details: "Indicates the number of packets that have been received on the ethernet network interface. The " +
                "attribute shall be reset to 0 upon a reboot of the Node."
        }),

        Attribute({
            name: "PacketTxCount", id: 0x3, type: "uint64", access: "R V", conformance: "PKTCNT", default: 0,
            quality: "C", xref: "core§11.16.6.4",
            details: "Indicates the number of packets that have been successfully transferred on the ethernet network " +
                "interface. The attribute shall be reset to 0 upon a reboot of the Node."
        }),

        Attribute({
            name: "TxErrCount", id: 0x4, type: "uint64", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "C", xref: "core§11.16.6.5",
            details: "Indicates the number of failed packet transmissions that have occurred on the ethernet network " +
                "interface. The attribute shall be reset to 0 upon a reboot of the Node."
        }),

        Attribute({
            name: "CollisionCount", id: 0x5, type: "uint64", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "C", xref: "core§11.16.6.6",
            details: "Indicates the number of collisions that have occurred while attempting to transmit a packet on the " +
                "ethernet network interface. The attribute shall be reset to 0 upon a reboot of the Node."
        }),

        Attribute({
            name: "OverrunCount", id: 0x6, type: "uint64", access: "R V", conformance: "ERRCNT", default: 0,
            quality: "C", xref: "core§11.16.6.7",
            details: "Indicates the number of packets dropped either at ingress or egress, due to lack of buffer memory to " +
                "retain all packets on the ethernet network interface. The attribute shall be reset to 0 upon a " +
                "reboot of the Node."
        }),

        Attribute({
            name: "CarrierDetect", id: 0x7, type: "bool", access: "R V", conformance: "O", default: null,
            quality: "X C", xref: "core§11.16.6.8",
            details: "Indicates the value of the Carrier Detect control signal present on the ethernet network interface. " +
                "A value of null shall indicate that the interface is not currently configured or operational."
        }),

        Attribute({
            name: "TimeSinceReset", id: 0x8, type: "uint64", access: "R V", conformance: "O", default: 0,
            quality: "C", xref: "core§11.16.6.9",
            details: "Indicates the duration of time, in minutes, that it has been since the ethernet network interface " +
                "has reset for any reason."
        }),

        Command({
            name: "ResetCounts", id: 0x0, access: "M", conformance: "PKTCNT | ERRCNT", direction: "request",
            response: "status", xref: "core§11.16.7.1",

            details: "This command is used to reset the count attributes." +
                "\n" +
                "Reception of this command shall reset the following attributes to 0:" +
                "\n" +
                "  • PacketRxCount" +
                "\n" +
                "  • PacketTxCount" +
                "\n" +
                "  • TxErrCount" +
                "\n" +
                "  • CollisionCount" +
                "\n" +
                "  • OverrunCount"
        }),

        Datatype(
            { name: "PHYRateEnum", type: "enum8", xref: "core§11.16.5.1" },
            Field({ name: "Rate10M", id: 0x0, conformance: "M", description: "PHY rate is 10Mbps" }),
            Field({ name: "Rate100M", id: 0x1, conformance: "M", description: "PHY rate is 100Mbps" }),
            Field({ name: "Rate1G", id: 0x2, conformance: "M", description: "PHY rate is 1Gbps" }),
            Field({ name: "Rate25G", id: 0x3, conformance: "M", description: "PHY rate is 2.5Gbps" }),
            Field({ name: "Rate5G", id: 0x4, conformance: "M", description: "PHY rate is 5Gbps" }),
            Field({ name: "Rate10G", id: 0x5, conformance: "M", description: "PHY rate is 10Gbps" }),
            Field({ name: "Rate40G", id: 0x6, conformance: "M", description: "PHY rate is 40Gbps" }),
            Field({ name: "Rate100G", id: 0x7, conformance: "M", description: "PHY rate is 100Gbps" }),
            Field({ name: "Rate200G", id: 0x8, conformance: "M", description: "PHY rate is 200Gbps" }),
            Field({ name: "Rate400G", id: 0x9, conformance: "M", description: "PHY rate is 400Gbps" })
        )
    ),

    Cluster(
        {
            name: "TimeSynchronization", id: 0x38, classification: "node", pics: "TIMESYNC", xref: "core§11.17",

            details: "Accurate time is required for a number of reasons, including scheduling, display and validating " +
                "security materials." +
                "\n" +
                "This section describes a mechanism for Nodes to achieve and maintain time synchronization. The Time " +
                "Synchronization cluster provides attributes for reading a Node’s current time. It also allows " +
                "Administrators to set current time, time zone and daylight savings time (DST) settings." +
                "\n" +
                "The Time Synchronization cluster may be present on the root node endpoint, and shall NOT be present " +
                "on any other Endpoint of any Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.17.5" },

            Field({
                name: "TZ", constraint: "0", title: "TimeZone", xref: "core§11.17.5.1",
                details: "Allows a server to translate a UTC time to a local time using the time zone and daylight savings " +
                    "time (DST) offsets. If a server supports the TimeZone feature, it shall support the SetTimeZone and " +
                    "SetDSTOffset commands, and TimeZone and DSTOffset attributes, and shall expose the local time " +
                    "through the LocalTime attribute."
            }),

            Field({
                name: "NTPC", constraint: "1", title: "NtpClient", xref: "core§11.17.5.2",
                details: "Allows a node to use NTP/SNTP for time synchronization."
            }),
            Field({
                name: "NTPS", constraint: "2", title: "NtpServer", xref: "core§11.17.5.3",
                details: "Allows a Node to host an NTP server for the network so that other Nodes can achieve a high accuracy " +
                    "time synchronization within the network. See Section 11.17.15, “Acting as an NTP Server”."
            }),
            Field({
                name: "TSC", constraint: "3", title: "TimeSyncClient", xref: "core§11.17.5.4",
                details: "This node also supports a time synchronization client and can connect to and read time from other " +
                    "nodes."
            })
        ),

        Attribute({
            name: "UtcTime", id: 0x0, type: "epoch-us", access: "R V", conformance: "M", default: null,
            quality: "X C", xref: "core§11.17.8.1",
            details: "If the node has achieved time synchronization, this attribute shall indicate the current time as a " +
                "UTC epoch-us (Epoch Time in Microseconds)." +
                "\n" +
                "If the node has not achieved time synchronization, this attribute shall be null. This attribute may " +
                "be set when a SetUTCTime is received."
        }),

        Attribute({
            name: "Granularity", id: 0x1, type: "GranularityEnum", access: "R V", conformance: "M",
            constraint: "desc", default: 0, xref: "core§11.17.8.2",
            details: "Indicates granularity of the error that the node is willing to guarantee on the time " +
                "synchronization. It is of type GranularityEnum." +
                "\n" +
                "This value shall be set to NoTimeGranularity if UTCTime is null and shall NOT be set to " +
                "NoTimeGranularity if UTCTime is non-null."
        }),

        Attribute({
            name: "TimeSource", id: 0x2, type: "TimeSourceEnum", access: "R V", conformance: "O",
            constraint: "desc", default: 0, xref: "core§11.17.8.3",

            details: "Indicates the node’s time source. This attribute indicates what method the node is using to sync, " +
                "whether the source uses NTS or not and whether the source is internal or external to the Matter " +
                "network. This attribute may be used by a client to determine its level of trust in the UTCTime. It " +
                "is of type TimeSourceEnum." +
                "\n" +
                "If a node is unsure if the selected NTP server is within the Matter network, it SHOULD select one of " +
                "the NonMatter* values." +
                "\n" +
                "This value shall be set to None if UTCTime is null and shall NOT be set to None if UTCTime is " +
                "non-null."
        }),

        Attribute({
            name: "TrustedTimeSource", id: 0x3, type: "TrustedTimeSourceStruct", access: "R V",
            conformance: "TSC", default: null, quality: "X N", xref: "core§11.17.8.4",
            details: "Indicates the Node ID, endpoint, and associated fabric index of a Node that may be used as trusted " +
                "time source. See Section 11.17.13, “Time source prioritization”. This attribute reflects the last " +
                "value set by an administrator using the SetTrustedTimeSource command. If the value is null, no " +
                "trusted time source has yet been set."
        }),

        Attribute({
            name: "DefaultNtp", id: 0x4, type: "string", access: "R V", conformance: "NTPC",
            constraint: "max 128", default: null, quality: "X N", xref: "core§11.17.8.5",

            details: "Indicates the default NTP server that this Node may use if other time sources are unavailable. This " +
                "attribute is settable by an Administrator using the SetDefaultNTP command. It SHOULD be set by the " +
                "Commissioner during commissioning. If no default NTP server is available, the Commissioner may set " +
                "this value to null. The default IANA assigned NTP port of 123 shall be used to access the NTP " +
                "server." +
                "\n" +
                "If set, the format of this attribute shall be a domain name or a static IPv6 address with no port, " +
                "in text format, as specified in RFC 5952. The address format shall follow the recommendations in " +
                "Section 4 and shall NOT contain a port number."
        }),

        Attribute(
            {
                name: "TimeZone", id: 0x5, type: "list", access: "R V", conformance: "TZ", constraint: "1 to 2",
                default: "[{0,0}]", quality: "N", xref: "core§11.17.8.6",

                details: "This attribute shall contain a list of time zone offsets from UTC and when they shall take effect." +
                    "\n" +
                    "This attribute uses a list of time offset configurations to allow Nodes to handle scheduled " +
                    "regulatory time zone changes. This attribute shall NOT be used to indicate daylight savings time " +
                    "changes (see Section 11.17.8.7, “DSTOffset Attribute” for daylight savings time)." +
                    "\n" +
                    "The first entry shall have a ValidAt entry of 0. If there is a second entry, it shall have a " +
                    "non-zero ValidAt time." +
                    "\n" +
                    "If a node supports a TimeZoneDatabase, and it has data for the given time zone Name and the given " +
                    "Offset matches, the node may update its own DSTOffset attribute to add new DST change times as " +
                    "required, based on the Name fields of the TimeZoneStruct. Administrators may add additional entries " +
                    "to the DSTOffset of other Nodes with the same time zone, if required." +
                    "\n" +
                    "If a node does not support a TimeZoneDatabase, the Name field of the TimeZoneStruct is only " +
                    "applicable for client-side localization. In particular:" +
                    "\n" +
                    "  • If the node does not support a TimeZoneDatabase, the Name field shall NOT be used to calculate " +
                    "    the local time." +
                    "\n" +
                    "  • If the node does not support a TimeZoneDatabase, the Name field shall NOT be used to calculate " +
                    "    DST start or end dates." +
                    "\n" +
                    "When time passes, the node SHOULD remove any entries which are no longer active and change the " +
                    "ValidAt time for the currently used TimeZoneStruct list item to zero." +
                    "\n" +
                    "This attribute shall have at least one entry. If the node does not have a default time zone and no " +
                    "time zone has been set, it may set this value to a list containing a single TimeZoneStruct with an " +
                    "offset of 0 (UTC) and a ValidAt time of 0."
            },

            Field({ name: "entry", type: "TimeZoneStruct" })
        ),

        Attribute(
            {
                name: "DstOffset", id: 0x6, type: "list", access: "R V", conformance: "TZ", default: [],
                quality: "N", xref: "core§11.17.8.7",

                details: "This attribute shall contain a list of offsets to apply for daylight savings time, and their " +
                    "validity period." +
                    "\n" +
                    "List entries shall be sorted by ValidStarting time." +
                    "\n" +
                    "A list entry shall NOT have a ValidStarting time that is smaller than the ValidUntil time of the " +
                    "previous entry. There shall be at most one list entry with a null ValidUntil time and, if such an " +
                    "entry is present, it shall appear last in the list." +
                    "\n" +
                    "Over time, the node SHOULD remove any entries which are no longer active from the list." +
                    "\n" +
                    "Over time, if the node supports a TimeZoneDatabase and it has information available for the given " +
                    "time zone name, it may update its own list to add additional entries." +
                    "\n" +
                    "If a time zone does not use DST, this shall be indicated by a single entry with a 0 offset and a " +
                    "null ValidUntil field."
            },

            Field({ name: "entry", type: "DSTOffsetStruct" })
        ),

        Attribute({
            name: "LocalTime", id: 0x7, type: "epoch-us", access: "R V", conformance: "TZ", default: null,
            quality: "X C", xref: "core§11.17.8.8",

            details: "Indicates the computed current local time of the node as a epoch-us (Epoch Time in Microseconds). " +
                "The value of LocalTime shall be the sum of the UTCTime, the offset of the currently valid " +
                "TimeZoneStruct from the TimeZone attribute (converted to microseconds), and the offset of the " +
                "currently valid DSTOffsetStruct from the DSTOffset attribute (converted to microseconds), if such an " +
                "entry exists." +
                "\n" +
                "If the node has not achieved time synchronization, this shall be null. If the node has an empty " +
                "DSTOffset, this shall be null."
        }),

        Attribute({
            name: "TimeZoneDatabase", id: 0x8, type: "TimeZoneDatabaseEnum", access: "R V", conformance: "TZ",
            default: 2, quality: "F", xref: "core§11.17.8.9",
            details: "Indicates whether the node has access to a time zone database. Nodes with a time zone database may " +
                "update their own DSTOffset attribute to add new entries and may push DSTOffset updates to other " +
                "Nodes in the same time zone as required."
        }),

        Attribute({
            name: "NtpServerAvailable", id: 0x9, type: "bool", access: "R V", conformance: "NTPS",
            default: false, xref: "core§11.17.8.10",
            details: "Indicates if the node is running an RFC 5905 NTPv4 compliant server on port 123, this value shall be " +
                "True." +
                "\n" +
                "If the node is not currently running an NTP server, this value shall be False."
        }),

        Attribute({
            name: "TimeZoneListMaxSize", id: 0xa, type: "uint8", access: "R V", conformance: "TZ",
            constraint: "1 to 2", quality: "F", xref: "core§11.17.8.11",
            details: "Indicates the number of supported list entries in the TimeZone attribute. This attribute may take " +
                "the value of 1 or 2, where the optional second list entry may be used to handle scheduled regulatory " +
                "time zone changes."
        }),

        Attribute({
            name: "DstOffsetListMaxSize", id: 0xb, type: "uint8", access: "R V", conformance: "TZ",
            constraint: "min 1", quality: "F", xref: "core§11.17.8.12",
            details: "Indicates the number of supported list entries in DSTOffset attribute. This value must be at least " +
                "1."
        }),

        Attribute({
            name: "SupportsDnsResolve", id: 0xc, type: "bool", access: "R V", conformance: "NTPC",
            default: false, quality: "F", xref: "core§11.17.8.13",
            details: "Indicates if the node supports resolving a domain name. DefaultNTP Address values for these nodes " +
                "may include domain names. If this is False, the Address for a DefaultNTP shall be an IPv6 address."
        }),

        Event({
            name: "DstTableEmpty", id: 0x0, access: "V", conformance: "TZ", priority: "info",
            xref: "core§11.17.10.1",

            details: "This event shall be generated when the node stops applying the current DSTOffset and there are no " +
                "entries in the list with a larger ValidStarting time, indicating the need to possibly get new DST " +
                "data. This event shall also be generated if the DSTOffset list is cleared either by a SetTimeZone " +
                "command, or by a SetDSTOffset command with an empty list." +
                "\n" +
                "The node shall generate this event if the node has not generated a DSTTableEmpty event in the last " +
                "hour, and the DSTOffset list is empty when the node attempts to update its time. DSTTableEmpty " +
                "events corresponding to a time update SHOULD NOT be generated more often than once per hour." +
                "\n" +
                "There is no data for this event."
        }),

        Event(
            {
                name: "DstStatus", id: 0x1, access: "V", conformance: "TZ", priority: "info",
                xref: "core§11.17.10.2",
                details: "This event shall be generated when the node starts or stops applying a DST offset."
            },
            Field({
                name: "DstOffsetActive", id: 0x0, type: "bool", conformance: "M", xref: "core§11.17.10.2.1",
                details: "Indicates whether the current DST offset is being applied (i.e, daylight savings time is applied, as " +
                    "opposed to standard time)."
            })
        ),

        Event(
            {
                name: "TimeZoneStatus", id: 0x2, access: "V", conformance: "TZ", priority: "info",
                xref: "core§11.17.10.3",
                details: "This event shall be generated when the node changes its time zone offset or name. It shall NOT be " +
                    "sent for DST changes that are not accompanied by a time zone change."
            },

            Field({
                name: "Offset", id: 0x0, type: "int32", conformance: "M", constraint: "-43200 to 50400",
                xref: "core§11.17.10.3.1",
                details: "Current time zone offset from UTC in seconds."
            }),

            Field({
                name: "Name", id: 0x1, type: "string", conformance: "O", constraint: "0 to 64",
                xref: "core§11.17.10.3.2",
                details: "Current time zone name. This name SHOULD use the country/city format specified by the IANA Time Zone " +
                    "Database."
            })
        ),

        Event({
            name: "TimeFailure", id: 0x3, access: "V", conformance: "M", priority: "info",
            xref: "core§11.17.10.4",
            details: "This event shall be generated if the node has not generated a TimeFailure event in the last hour, " +
                "and the node is unable to get a time from any source. This event SHOULD NOT be generated more often " +
                "than once per hour."
        }),

        Event({
            name: "MissingTrustedTimeSource", id: 0x4, access: "V", conformance: "TSC", priority: "info",
            xref: "core§11.17.10.5",

            details: "This event shall be generated if the TrustedTimeSource is set to null upon fabric removal or by a " +
                "SetTrustedTimeSource command." +
                "\n" +
                "This event shall also be generated if the node has not generated a MissingTrustedTimeSource event in " +
                "the last hour, and the node fails to update its time from the TrustedTimeSource because the " +
                "TrustedTimeSource is null or the specified peer cannot be reached. MissingTrustedTimeSource events " +
                "corresponding to a time update SHOULD NOT be generated more often than once per hour."
        }),

        Command(
            {
                name: "SetUtcTime", id: 0x0, access: "A", conformance: "M", direction: "request",
                response: "status", xref: "core§11.17.9.1",

                details: "This command is used to set the UTC time of the node." +
                    "\n" +
                    "This command may be issued by Administrator to set the time. If the Commissioner does not have a " +
                    "valid time source, it may send a Granularity of NoTimeGranularity." +
                    "\n" +
                    "Upon receipt of this command, the node may update its UTCTime attribute to match the time specified " +
                    "in the command, if the stated Granularity and TimeSource are acceptable. The node shall update its " +
                    "UTCTime attribute if its current Granularity is NoTimeGranularity." +
                    "\n" +
                    "If the time is updated, the node shall also update its Granularity attribute based on the " +
                    "granularity specified in the command and the expected clock drift of the node. This SHOULD normally " +
                    "be one level lower than the stated command Granularity. It shall also update its TimeSource " +
                    "attribute to Admin. It shall also update its Last Known Good UTC Time as defined in Section 3.5.6.1, " +
                    "“Last Known Good UTC Time”." +
                    "\n" +
                    "If the node updates its UTCTime attribute, it shall accept the command with a status code of " +
                    "SUCCESS. If it opts to not update its time, it shall fail the command with a cluster specific Status " +
                    "Code of TimeNotAccepted."
            },

            Field({
                name: "UtcTime", id: 0x0, type: "epoch-us", conformance: "M", default: 0, xref: "core§11.17.9.1.1",
                details: "This field shall give the Client’s UTC Time."
            }),
            Field({
                name: "Granularity", id: 0x1, type: "GranularityEnum", conformance: "M", default: 0,
                xref: "core§11.17.9.1.2",
                details: "This field shall give the Client’s Granularity, as described in Granularity."
            }),
            Field({
                name: "TimeSource", id: 0x2, type: "TimeSourceEnum", conformance: "O", default: 0,
                xref: "core§11.17.9.1.3",
                details: "This field shall give the Client’s TimeSource, as described in TimeSource."
            })
        ),

        Command(
            {
                name: "SetTrustedTimeSource", id: 0x1, access: "F A", conformance: "TSC", direction: "request",
                response: "status", xref: "core§11.17.9.2",

                details: "This command is used to set the TrustedTimeSource attribute. Upon receipt of this command:" +
                    "\n" +
                    "  • If the TrustedTimeSource field in the command is null, the node shall set the TrustedTimeSource " +
                    "    attribute to null and shall generate a MissingTrustedTimeSource event." +
                    "\n" +
                    "  • Otherwise, the node shall set the TrustedTimeSource attribute to a struct which has NodeID and " +
                    "    Endpoint fields matching those in the TrustedTimeSource field and has its FabricIndex field set " +
                    "    to the command’s accessing fabric index."
            },

            Field({
                name: "TrustedTimeSource", id: 0x0, type: "FabricScopedTrustedTimeSourceStruct", access: "F",
                conformance: "M", quality: "X", xref: "core§11.17.9.2.1",
                details: "This field contains the Node ID and endpoint of a trusted time source on the accessing fabric."
            }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "SetTimeZone", id: 0x2, access: "M", conformance: "TZ", direction: "request",
                response: "SetTimeZoneResponse", xref: "core§11.17.9.3",

                details: "This command is used to set the time zone of the node." +
                    "\n" +
                    "If the given list is larger than the TimeZoneListMaxSize, the node shall respond with " +
                    "RESOURCE_EXHAUSTED and the TimeZone attribute shall NOT be updated." +
                    "\n" +
                    "If the given list does not conform to the list requirements in TimeZone attribute the node shall " +
                    "respond with a CONSTRAINT_ERROR and the TimeZone attribute shall NOT be updated." +
                    "\n" +
                    "If there are no errors in the list, the TimeZone field shall be copied to the TimeZone attribute. A " +
                    "TimeZoneStatus event shall be generated with the new time zone information." +
                    "\n" +
                    "If the node supports a time zone database and it has information available for the time zone that " +
                    "will be applied, it may set its DSTOffset attribute, otherwise the DSTOffset attribute shall be set " +
                    "to an empty list. A DSTTableEmpty event shall be generated if the DSTOffset attribute is empty. A " +
                    "DSTStatus event shall be generated if the node was previously applying a DST offset."
            },

            Field(
                { name: "TimeZone", id: 0x0, type: "list", conformance: "M", constraint: "1 to 2" },
                Field({ name: "entry", type: "TimeZoneStruct" })
            )
        ),

        Command(
            {
                name: "SetTimeZoneResponse", id: 0x3, conformance: "TZ", direction: "response",
                xref: "core§11.17.9.4",
                details: "THis command is used to report the result of a SetTimeZone command. This command shall be generated " +
                    "in response to a SetTimeZone command."
            },

            Field({
                name: "DstOffsetRequired", id: 0x0, type: "bool", conformance: "M", default: true,
                xref: "core§11.17.9.4.1",
                details: "If the node supports a time zone database with information for the time zone that will be applied, " +
                    "it may use this information to set the DSTOffset attribute. If the node is setting its own DSTOffset " +
                    "attribute, the DSTOffsetRequired field shall be set to false, otherwise it shall be set to true."
            })
        ),

        Command(
            {
                name: "SetDstOffset", id: 0x4, access: "M", conformance: "TZ", direction: "request",
                response: "status", xref: "core§11.17.9.5",

                details: "This command is used to set the DST offsets for a node." +
                    "\n" +
                    "  • If the length of DSTOffset is larger than DSTOffsetListMaxSize, the node shall respond with " +
                    "    RESOURCE_EXHAUSTED." +
                    "\n" +
                    "  • Else if the list entries do not conform to the list requirements for DSTOffset attribute, the " +
                    "    node shall respond with CONSTRAINT_ERROR." +
                    "\n" +
                    "If there are no errors in the list, the DSTOffset field shall be copied to the DSTOffset attribute." +
                    "\n" +
                    "If the DSTOffset attribute change causes a corresponding change to the DST state, a DSTStatus event " +
                    "shall be generated. If the list is empty, the node shall generate a DSTTableEmpty event."
            },

            Field(
                { name: "DstOffset", id: 0x0, type: "list", conformance: "M" },
                Field({ name: "entry", type: "DSTOffsetStruct" })
            )
        ),

        Command(
            {
                name: "SetDefaultNtp", id: 0x5, access: "A", conformance: "NTPC", direction: "request",
                response: "status", xref: "core§11.17.9.6",

                details: "This command is used to set the DefaultNTP attribute." +
                    "\n" +
                    "If the DefaultNTP Address field does not conform to the requirements in the DefaultNTP attribute " +
                    "description, the command shall fail with a status code of INVALID_COMMAND. If the node does not " +
                    "support DNS resolution (as specified in SupportsDNSResolve) and the provided Address is a domain " +
                    "name, the command shall fail with a status code of INVALID_COMMAND. Otherwise, the node shall set " +
                    "the DefaultNTP attribute to match the DefaultNTP provided in this command."
            },

            Field({
                name: "DefaultNtp", id: 0x0, type: "string", conformance: "M", constraint: "max 128", quality: "X",
                xref: "core§11.17.9.6.1",
                details: "This field contains the address of an NTP server than can be used as a fallback for time " +
                    "synchronization. The format of this field shall follow the requirements in the DefaultNTP attribute " +
                    "description."
            })
        ),

        Datatype(
            { name: "GranularityEnum", type: "enum8", xref: "core§11.17.6.1" },
            Field({
                name: "NoTimeGranularity", id: 0x0, conformance: "M",
                description: "This indicates that the node is not currently synchronized with a UTC Time source and its clock is based on the Last Known Good UTC Time only."
            }),
            Field({
                name: "MinutesGranularity", id: 0x1, conformance: "M",
                description: "This indicates the node was synchronized to an upstream source in the past, but sufficient clock drift has occurred such that the clock error is now > 5 seconds."
            }),
            Field({
                name: "SecondsGranularity", id: 0x2, conformance: "M",
                description: "This indicates the node is synchronized to an upstream source using a low resolution protocol. UTC Time is accurate to ± 5 seconds."
            }),
            Field({
                name: "MillisecondsGranularity", id: 0x3, conformance: "M",
                description: "This indicates the node is synchronized to an upstream source using high resolution time-synchronization protocol such as NTP, or has built-in GNSS with some amount of jitter applying its GNSS timestamp. UTC Time is accurate to ± 50 ms."
            }),
            Field({
                name: "MicrosecondsGranularity", id: 0x4, conformance: "M",
                description: "This indicates the node is synchronized to an upstream source using a highly precise time-synchronization protocol such as PTP, or has built-in GNSS. UTC time is accurate to ± 10 μs."
            })
        ),

        Datatype(
            { name: "TimeSourceEnum", type: "enum8", xref: "core§11.17.6.2" },
            Field({
                name: "None", id: 0x0, conformance: "M",
                description: "Node is not currently synchronized with a UTC Time source."
            }),
            Field({ name: "Unknown", id: 0x1, conformance: "M", description: "Node uses an unlisted time source." }),
            Field({
                name: "Admin", id: 0x2, conformance: "M",
                description: "Node received time from a client using the SetUTCTime Command."
            }),
            Field({
                name: "NodeTimeCluster", id: 0x3, conformance: "M",
                description: "Synchronized time by querying the Time Synchronization cluster of another Node."
            }),
            Field({
                name: "NonMatterSntp", id: 0x4, conformance: "M",
                description: "SNTP from a server not in the Matter network. NTS is not used."
            }),
            Field({
                name: "NonMatterNtp", id: 0x5, conformance: "M",
                description: "NTP from servers not in the Matter network. None of the servers used NTS."
            }),
            Field({
                name: "MatterSntp", id: 0x6, conformance: "M",
                description: "SNTP from a server within the Matter network. NTS is not used."
            }),
            Field({
                name: "MatterNtp", id: 0x7, conformance: "M",
                description: "NTP from servers within the Matter network. None of the servers used NTS."
            }),
            Field({
                name: "MixedNtp", id: 0x8, conformance: "M",
                description: "NTP from multiple servers in the Matter network and external. None of the servers used NTS."
            }),
            Field({
                name: "NonMatterSntpnts", id: 0x9, conformance: "M",
                description: "SNTP from a server not in the Matter network. NTS is used."
            }),
            Field({
                name: "NonMatterNtpnts", id: 0xa, conformance: "M",
                description: "NTP from servers not in the Matter network. NTS is used on at least one server."
            }),
            Field({
                name: "MatterSntpnts", id: 0xb, conformance: "M",
                description: "SNTP from a server within the Matter network. NTS is used."
            }),
            Field({
                name: "MatterNtpnts", id: 0xc, conformance: "M",
                description: "NTP from a server within the Matter network. NTS is used on at least one server."
            }),
            Field({
                name: "MixedNtpnts", id: 0xd, conformance: "M",
                description: "NTP from multiple servers in the Matter network and external. NTS is used on at least one server."
            }),
            Field({
                name: "CloudSource", id: 0xe, conformance: "M",
                description: "Time synchronization comes from a vendor cloud-based source (e.g. \"Date\" header in authenticated HTTPS connection)."
            }),
            Field({ name: "Ptp", id: 0xf, conformance: "M", description: "Time synchronization comes from PTP." }),
            Field({ name: "Gnss", id: 0x10, conformance: "M", description: "Time synchronization comes from a GNSS source." })
        ),

        Datatype(
            {
                name: "TimeZoneDatabaseEnum", type: "enum8", xref: "core§11.17.6.3",
                details: "It indicates what the device knows about the contents of the IANA Time Zone Database. Partial " +
                    "support on a device may be used to omit historical data, less commonly used time zones, and/or time " +
                    "zones not related to the region a product is sold in."
            },

            Field({
                name: "Full", id: 0x0, conformance: "M",
                description: "Node has a full list of the available time zones"
            }),
            Field({
                name: "Partial", id: 0x1, conformance: "M",
                description: "Node has a partial list of the available time zones"
            }),
            Field({ name: "None", id: 0x2, conformance: "M", description: "Node does not have a time zone database" })
        ),

        Datatype(
            { name: "TrustedTimeSourceStruct", type: "struct", xref: "core§11.17.6.4" },
            Field({
                name: "FabricIndex", id: 0x0, type: "fabric-idx", conformance: "M", xref: "core§11.17.6.4.1",
                details: "The Fabric Index associated with the Fabric of the client which last set the value of the trusted " +
                    "time source node."
            }),
            Field({
                name: "NodeId", id: 0x1, type: "node-id", conformance: "M", xref: "core§11.17.6.4.2",
                details: "Node ID of the trusted time source node on the Fabric associated with the entry."
            }),
            Field({
                name: "Endpoint", id: 0x2, type: "endpoint-no", conformance: "M", xref: "core§11.17.6.4.3",
                details: "Endpoint on the trusted time source node that contains the Time Synchronization cluster server."
            })
        ),

        Datatype(
            { name: "FabricScopedTrustedTimeSourceStruct", type: "struct", xref: "core§11.17.6.5" },
            Field({
                name: "NodeId", id: 0x0, type: "node-id", conformance: "M", xref: "core§11.17.6.5.1",
                details: "Node ID of the trusted time source node on the Fabric of the issuer."
            }),

            Field({
                name: "Endpoint", id: 0x1, type: "endpoint-no", conformance: "M", xref: "core§11.17.6.5.2",
                details: "Endpoint on the trusted time source node that contains the Time Synchronization cluster server. This " +
                    "is provided to avoid having to do discovery of the location of that endpoint by walking over all " +
                    "endpoints and checking their Descriptor Cluster."
            })
        ),

        Datatype(
            { name: "TimeZoneStruct", type: "struct", xref: "core§11.17.6.6" },
            Field({
                name: "Offset", id: 0x0, type: "int32", conformance: "M", constraint: "-43200 to 50400",
                xref: "core§11.17.6.6.1",
                details: "The time zone offset from UTC in seconds."
            }),
            Field({
                name: "ValidAt", id: 0x1, type: "epoch-us", conformance: "M", xref: "core§11.17.6.6.2",
                details: "The UTC time when the offset shall be applied."
            }),

            Field({
                name: "Name", id: 0x2, type: "string", conformance: "O", constraint: "0 to 64",
                xref: "core§11.17.6.6.3",
                details: "The time zone name SHOULD provide a human-readable time zone name and it SHOULD use the country/city " +
                    "format specified by the IANA Time Zone Database. The Name field may be used for display. If the node " +
                    "supports a TimeZoneDatabase it may use the Name field to set its own DST offsets if it has database " +
                    "information for the supplied time zone Name and the given Offset matches."
            })
        ),

        Datatype(
            { name: "DSTOffsetStruct", type: "struct", xref: "core§11.17.6.7" },

            Field({
                name: "Offset", id: 0x0, type: "int32", conformance: "M", constraint: "desc",
                xref: "core§11.17.6.7.1",
                details: "The DST offset in seconds. Normally this is in the range of 0 to 3600 seconds (1 hour), but this " +
                    "field will accept any values in the int32 range to accommodate potential future legislation that " +
                    "does not fit with these assumptions."
            }),

            Field({
                name: "ValidStarting", id: 0x1, type: "epoch-us", conformance: "M", xref: "core§11.17.6.7.2",
                details: "The UTC time when the offset shall be applied."
            }),

            Field({
                name: "ValidUntil", id: 0x2, type: "epoch-us", conformance: "M", quality: "X",
                xref: "core§11.17.6.7.3",
                details: "The UTC time when the offset shall stop being applied. Providing a null value here indicates a " +
                    "permanent DST change. If this value is non-null the value shall be larger than the ValidStarting " +
                    "time."
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "core§11.17.7.1" },
            Field({
                name: "TimeNotAccepted", id: 0x2, conformance: "M",
                description: "Node rejected the attempt to set the UTC time"
            })
        )
    ),

    Cluster(
        {
            name: "OperationalCredentials", id: 0x3e, classification: "node", pics: "OPCREDS",
            xref: "core§11.18",
            details: "This cluster is used to add or remove Node Operational credentials on a Commissionee or " +
                "already-configured Node, as well as manage the associated Fabrics."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 2 }),

        Attribute(
            {
                name: "NoCs", id: 0x0, type: "list", access: "R F A", conformance: "M",
                constraint: "max supportedFabrics", quality: "N C", xref: "core§11.18.5.1",

                details: "This attribute shall contain all NOCs applicable to this Node, encoded as a read-only list of " +
                    "NOCStruct." +
                    "\n" +
                    "Operational Certificates shall be added through the AddNOC command, and shall be removed through the " +
                    "RemoveFabric command." +
                    "\n" +
                    "Upon Factory Data Reset, this attribute shall be set to a default value of an empty list." +
                    "\n" +
                    "The number of entries in this list shall match the number of entries in the Fabrics attribute."
            },

            Field({ name: "entry", type: "NOCStruct" })
        ),

        Attribute(
            {
                name: "Fabrics", id: 0x1, type: "list", access: "R F V", conformance: "M",
                constraint: "max supportedFabrics", quality: "N", xref: "core§11.18.5.2",

                details: "Indicates all fabrics to which this Node is commissioned, encoded as a read-only list of " +
                    "FabricDescriptorStruct. This information may be computed directly from the NOCs attribute." +
                    "\n" +
                    "The Fabrics attribute is also known as \"the fabric table\"." +
                    "\n" +
                    "Upon Factory Data Reset, this attribute shall be set to a default value of an empty list." +
                    "\n" +
                    "The number of entries in this list shall match the number of entries in the NOCs attribute."
            },

            Field({ name: "entry", type: "FabricDescriptorStruct" })
        ),

        Attribute({
            name: "SupportedFabrics", id: 0x2, type: "uint8", access: "R V", conformance: "M",
            constraint: "5 to 254", quality: "F", xref: "core§11.18.5.3",
            details: "Indicates the number of Fabrics that are supported by the device. This value is fixed for a " +
                "particular device."
        }),

        Attribute({
            name: "CommissionedFabrics", id: 0x3, type: "uint8", access: "R V", conformance: "M",
            constraint: "max supportedFabrics", quality: "N", xref: "core§11.18.5.4",

            details: "Indicates the number of Fabrics to which the device is currently commissioned. This attribute shall " +
                "be equal to the following:" +
                "\n" +
                "  • The number of entries in the NOCs attribute." +
                "\n" +
                "  • The number of entries in the Fabrics attribute." +
                "\n" +
                "Upon Factory Data Reset, this attribute shall be set to a default value of 0."
        }),

        Attribute(
            {
                name: "TrustedRootCertificates", id: 0x4, type: "list", access: "R V", conformance: "M",
                constraint: "max supportedFabrics[max 400]", quality: "N C", xref: "core§11.18.5.5",

                details: "This attribute shall contain the list of Trusted Root CA Certificates (RCAC) installed on the Node, " +
                    "as octet strings containing their Matter Certificate Encoding representation." +
                    "\n" +
                    "These certificates are installed through the AddTrustedRootCertificate command." +
                    "\n" +
                    "Depending on the method of storage employed by the server, either shared storage for identical root " +
                    "certificates shared by many fabrics, or individually stored root certificate per fabric, multiple " +
                    "identical root certificates may legally appear within the list." +
                    "\n" +
                    "To match a root with a given fabric, the root certificate’s subject and subject public key need to " +
                    "be cross-referenced with the NOC or ICAC certificates that appear in the NOCs attribute for a given " +
                    "fabric." +
                    "\n" +
                    "Upon Factory Data Reset, this attribute shall be set to a default value whereby the list is empty."
            },

            Field({ name: "entry", type: "octstr" })
        ),

        Attribute({
            name: "CurrentFabricIndex", id: 0x5, type: "uint8", access: "R V", conformance: "M", default: 0,
            xref: "core§11.18.5.6",
            details: "Indicates the accessing fabric index." +
                "\n" +
                "This attribute is useful to contextualize Fabric-Scoped entries obtained from response commands or " +
                "attribute reads, since a given Fabric may be referenced by a different Fabric Index locally on a " +
                "remote Node."
        }),

        Command(
            {
                name: "AttestationRequest", id: 0x0, access: "A", conformance: "M", direction: "request",
                response: "AttestationResponse", xref: "core§11.18.6.1",

                details: "This command is used to perform an attestation request." +
                    "\n" +
                    "This command shall be generated to request the Attestation Information, in the form of an " +
                    "AttestationResponse Command. If the AttestationNonce that is provided in the command is malformed, a " +
                    "recipient shall fail the command with a Status Code of INVALID_COMMAND. The AttestationNonce field " +
                    "shall be used in the computation of the Attestation Information."
            },

            Field({ name: "AttestationNonce", id: 0x0, type: "octstr", conformance: "M", constraint: "32" })
        ),

        Command(
            {
                name: "AttestationResponse", id: 0x1, conformance: "M", direction: "response",
                xref: "core§11.18.6.2",

                details: "This command is used to report the results of the AttestationRequest command. This command shall be " +
                    "generated in response to an Attestation Request command." +
                    "\n" +
                    "See Section 11.18.4.7, “Attestation Information” for details about the generation of the fields " +
                    "within this response command." +
                    "\n" +
                    "See Section F.2, “Device Attestation Response test vector” for an example computation of an " +
                    "AttestationResponse."
            },

            Field({
                name: "AttestationElements", id: 0x0, type: "octstr", conformance: "M", constraint: "max respMax",
                xref: "core§11.18.6.2.1",
                details: "This field shall contain the octet string of the serialized attestation_elements_message."
            }),

            Field({
                name: "AttestationSignature", id: 0x1, type: "octstr", conformance: "M", constraint: "64",
                xref: "core§11.18.6.2.2",
                details: "This field shall contain the octet string of the necessary attestation_signature as described in " +
                    "Section 11.18.4.7, “Attestation Information”."
            })
        ),

        Command(
            {
                name: "CertificateChainRequest", id: 0x2, access: "A", conformance: "M", direction: "request",
                response: "CertificateChainResponse", xref: "core§11.18.6.3",
                details: "This command is used to request a certificate from the device attestation certificate chain." +
                    "\n" +
                    "If the CertificateType is not a valid value per CertificateChainTypeEnum then the command shall fail " +
                    "with a Status Code of INVALID_COMMAND."
            },

            Field({
                name: "CertificateType", id: 0x0, type: "CertificateChainTypeEnum", conformance: "M",
                constraint: "desc"
            })
        ),

        Command(
            {
                name: "CertificateChainResponse", id: 0x3, conformance: "M", direction: "response",
                xref: "core§11.18.6.4",
                details: "This command is used to report the results of the CertificateChainRequest command. This command " +
                    "shall be generated in response to a CertificateChainRequest command."
            },

            Field({
                name: "Certificate", id: 0x0, type: "octstr", conformance: "M", constraint: "max 600",
                xref: "core§11.18.6.4.1",
                details: "This field shall be the DER encoded certificate corresponding to the CertificateType field in the " +
                    "CertificateChainRequest command."
            })
        ),

        Command(
            {
                name: "CsrRequest", id: 0x4, access: "A", conformance: "M", direction: "request",
                response: "CsrResponse", xref: "core§11.18.6.5",

                details: "This command is used to perform a CSR request." +
                    "\n" +
                    "This command shall be generated to execute the Node Operational CSR Procedure and subsequently " +
                    "return the NOCSR Information, in the form of a CSRResponse Command." +
                    "\n" +
                    "The CSRNonce field shall be used in the computation of the NOCSR Information. If the CSRNonce is " +
                    "malformed, then this command shall fail with an INVALID_COMMAND status code." +
                    "\n" +
                    "If the IsForUpdateNOC field is present and set to true, but the command was received over a PASE " +
                    "session, the command shall fail with an INVALID_COMMAND status code, as it would never be possible " +
                    "to use a resulting subsequent certificate issued from the CSR with the UpdateNOC command, which is " +
                    "forbidden over PASE sessions." +
                    "\n" +
                    "If the IsForUpdateNOC field is present and set to true, the internal state of the CSR associated key " +
                    "pair shall be tagged as being for a subsequent UpdateNOC, otherwise the internal state of the CSR " +
                    "shall be tagged as being for a subsequent AddNOC. See Section 11.18.6.8, “AddNOC Command” and " +
                    "Section 11.18.6.9, “UpdateNOC Command” for details about the processing." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, " +
                    "then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If the Node Operational Key Pair generated during processing of the Node Operational CSR Procedure " +
                    "is found to collide with an existing key pair already previously generated and installed, and that " +
                    "check had been executed, then this command shall fail with a FAILURE status code sent back to the " +
                    "initiator."
            },

            Field({ name: "CsrNonce", id: 0x0, type: "octstr", conformance: "M", constraint: "32" }),
            Field({ name: "IsForUpdateNoc", id: 0x1, type: "bool", conformance: "O", default: false })
        ),

        Command(
            {
                name: "CsrResponse", id: 0x5, conformance: "M", direction: "response", xref: "core§11.18.6.6",

                details: "This command is used to report the results of the CSRRequest command. This command shall be " +
                    "generated in response to a CSRRequest Command." +
                    "\n" +
                    "See Section 11.18.4.9, “NOCSR Information” for details about the generation of the fields within " +
                    "this response command." +
                    "\n" +
                    "See Section F.3, “Node Operational CSR Response test vector” for an example computation of a " +
                    "CSRResponse."
            },

            Field({
                name: "NocsrElements", id: 0x0, type: "octstr", conformance: "M", constraint: "max respMax",
                xref: "core§11.18.6.6.1",
                details: "This field shall contain the octet string of the serialized nocsr_elements_message."
            }),

            Field({
                name: "AttestationSignature", id: 0x1, type: "octstr", conformance: "M", constraint: "64",
                xref: "core§11.18.6.6.2",
                details: "This field shall contain the octet string of the necessary attestation_signature as described in " +
                    "Section 11.18.4.9, “NOCSR Information”."
            })
        ),

        Command(
            {
                name: "AddNoc", id: 0x6, access: "A", conformance: "M", direction: "request",
                response: "NocResponse", xref: "core§11.18.6.8",

                details: "This command is used to add a new NOC to the device." +
                    "\n" +
                    "This command shall add a new NOC chain to the device and commission a new Fabric association upon " +
                    "successful validation of all arguments and preconditions." +
                    "\n" +
                    "The new value shall immediately be reflected in the NOCs list attribute." +
                    "\n" +
                    "A Commissioner or Administrator shall issue this command after issuing the CSRRequest command and " +
                    "receiving its response." +
                    "\n" +
                    "A Commissioner or Administrator SHOULD issue this command after performing the Attestation " +
                    "Procedure."
            },

            Field({ name: "NocValue", id: 0x0, type: "octstr", conformance: "M", constraint: "max 400" }),
            Field({ name: "IcacValue", id: 0x1, type: "octstr", conformance: "O", constraint: "max 400" }),

            Field({
                name: "IpkValue", id: 0x2, type: "octstr", conformance: "M", constraint: "16",
                xref: "core§11.18.6.8.1",

                details: "This field shall contain the value of the Epoch Key for the Identity Protection Key (IPK) to set for " +
                    "the Fabric which is to be added. This is needed to bootstrap a necessary configuration value for " +
                    "subsequent CASE to succeed. See Section 4.14.2.6.1, “Identity Protection Key (IPK)” for details." +
                    "\n" +
                    "The IPK shall be provided as an octet string of length CRYPTO_SYMMETRIC_KEY_LENGTH_BYTES." +
                    "\n" +
                    "On successful execution of the AddNOC command, the side-effect of having provided this field shall " +
                    "be equivalent to having done a GroupKeyManagement cluster KeySetWrite command invocation using the " +
                    "newly joined fabric as the accessing fabric and with the following argument fields (assuming " +
                    "KeySetWrite allowed a GroupKeySetID set to 0):"
            }),

            Field({
                name: "CaseAdminSubject", id: 0x3, type: "subject-id", conformance: "M", xref: "core§11.18.6.8.2",

                details: "If the AddNOC command succeeds according to the semantics of the following subsections, then the " +
                    "Access Control subject-id shall be used to atomically add an Access Control Entry enabling that " +
                    "Subject to subsequently administer the Node whose operational identity is being added by this " +
                    "command." +
                    "\n" +
                    "The format of the new Access Control Entry, created from this, shall be:" +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> Unless such an Access Control Entry is added atomically as described here, there would be no way " +
                    "  for the caller on its given Fabric to eventually add another Access Control Entry for CASE " +
                    "  authentication mode, to enable the new Administrator to administer the device, since the Fabric " +
                    "  Scoping of the Access Control List prevents the current Node from being able to write new entries " +
                    "  scoped to that Fabric, if the session is established from CASE. While a session established from " +
                    "  PASE does gain Fabric Scope of a newly-joined Fabric, this argument is made mandatory to provide " +
                    "  symmetry between both types of session establishment, both of which need to eventually add an " +
                    "  \"Administer Node over CASE\" Access Control Entry to finalize new Fabric configuration and " +
                    "  subsequently be able to call the CommissioningComplete command."
            }),

            Field({
                name: "AdminVendorId", id: 0x4, type: "vendor-id", conformance: "M", xref: "core§11.18.6.8.3",

                details: "This field shall be set to the Vendor ID of the entity issuing the AddNOC command. This value shall " +
                    "NOT be one of the reserved Vendor ID values defined in Table 1, “Vendor ID Allocations”." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, " +
                    "then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If the prior CSRRequest state that preceded AddNOC had the IsForUpdateNOC field indicated as true, " +
                    "then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If no prior AddTrustedRootCertificate command was successfully executed within the fail-safe timer " +
                    "period, then this command shall process an error by responding with a NOCResponse with a StatusCode " +
                    "of InvalidNOC as described in Section 11.18.6.7.2, “Handling Errors”. In other words, AddNOC always " +
                    "requires that the client provides the root of trust certificate within the same Fail- Safe context " +
                    "as the rest of the new fabric’s operational credentials, even if some other fabric already uses the " +
                    "exact same root of trust certificate." +
                    "\n" +
                    "If the NOC provided in the NOCValue encodes an Operational Identifier for a <Root Public Key, " +
                    "FabricID> pair already present on the device, then the device shall process the error by responding " +
                    "with a StatusCode of FabricConflict as described in Section 11.18.6.7.2, “Handling Errors”." +
                    "\n" +
                    "If the device already has the CommissionedFabrics attribute equal to the SupportedFabrics attribute, " +
                    "then the device’s operational credentials table is considered full and the device shall process the " +
                    "error by responding with a StatusCode of TableFull as described in Section 11.18.6.7.2, “Handling " +
                    "Errors”." +
                    "\n" +
                    "If the CaseAdminSubject field is not a valid ACL subject in the context of AuthMode set to CASE, " +
                    "such as not being in either the Operational or CASE Authenticated Tag range, then the device shall " +
                    "process the error by responding with a StatusCode of InvalidAdminSubject as described in Section " +
                    "11.18.6.7.2, “Handling Errors”." +
                    "\n" +
                    "Otherwise, the command is considered an addition of credentials, also known as \"joining a fabric\", " +
                    "and the following shall apply:" +
                    "\n" +
                    "  1. A new FabricIndex shall be allocated, taking the next valid fabric-index value in monotonically " +
                    "     incrementing order, wrapping around from 254 (0xFE) to 1, since value 0 is reserved and using " +
                    "     255 (0xFF) would prevent cluster specifications from using nullable fabric-idx fields." +
                    "\n" +
                    "  2. An entry within the Fabrics attribute table shall be added, reflecting the matter-fabric-id RDN " +
                    "     within the NOC’s subject, along with the public key of the trusted root of the chain and the " +
                    "     AdminVendorID field." +
                    "\n" +
                    "  3. The operational key pair associated with the incoming NOC from the NOCValue, and generated by " +
                    "     the prior CSRRequest command, shall be recorded for subsequent use during CASE within the " +
                    "     fail-safe timer period (see Section 5.5, “Commissioning Flows”)." +
                    "\n" +
                    "  4. The incoming NOCValue and ICACValue (if present) shall be stored under the FabricIndex " +
                    "     associated with the new Fabric Scope, along with the RootCACertificate provided with the prior " +
                    "     successful AddTrustedRootCertificate command invoked in the same fail-safe period." +
                    "\n" +
                    "    a. Implementation of certificate chain storage may separate or otherwise encode the components " +
                    "       of the array in implementation-specific ways, as long as they follow the correct format when " +
                    "       being read from the NOCs list or used within other protocols such as CASE." +
                    "\n" +
                    "  5. The NOCs list shall reflect the incoming NOC from the NOCValue field and ICAC from the " +
                    "     ICACValue field (if present)." +
                    "\n" +
                    "  6. The operational discovery service record shall immediately reflect the new Operational " +
                    "     Identifier, such that the Node immediately begins to exist within the Fabric and becomes " +
                    "     reachable over CASE under the new operational identity." +
                    "\n" +
                    "  7. The receiver shall create and add a new Access Control Entry using the CaseAdminSubject field " +
                    "     to grant subsequent Administer access to an Administrator member of the new Fabric. It is " +
                    "     recommended that the Administrator presented in CaseAdminSubject exist within the same entity " +
                    "     that is currently invoking the AddNOC command, within another of the Fabrics of which it is a " +
                    "     member." +
                    "\n" +
                    "    a. If the Managed Device Feature is implemented by the ACL cluster, then one or more ARL entries " +
                    "       with the new FabricIndex may be added to the ARL attribute." +
                    "\n" +
                    "  8. The incoming IPKValue shall be stored in the Fabric-scoped slot within the Group Key Management " +
                    "     cluster (see Section 11.2.7.1, “KeySetWrite Command”), for subsequent use during CASE." +
                    "\n" +
                    "  9. The Fabric Index associated with the armed fail-safe context (see Section 11.10.7.2, " +
                    "     “ArmFailSafe Command”) shall be updated to match the Fabric Index just allocated." +
                    "\n" +
                    "  10. If the current secure session was established with PASE, the receiver shall:" +
                    "\n" +
                    "    a. Augment the secure session context with the FabricIndex generated above, such that subsequent " +
                    "       interactions have the proper accessing fabric." +
                    "\n" +
                    "  11. If the current secure session was established with CASE, subsequent configuration of the newly " +
                    "      installed Fabric requires the opening of a new CASE session from the Administrator from the " +
                    "      Fabric just installed. This Administrator is the one listed in the CaseAdminSubject argument." +
                    "\n" +
                    "Thereafter, the Node shall respond with an NOCResponse with a StatusCode of OK and a FabricIndex " +
                    "field matching the FabricIndex under which the new Node Operational Certificate (NOC) is scoped."
            })
        ),

        Command(
            {
                name: "UpdateNoc", id: 0x7, access: "F A", conformance: "M", direction: "request",
                response: "NocResponse", xref: "core§11.18.6.9",

                details: "This command is used to update an existing NOC on the device." +
                    "\n" +
                    "This command shall replace the NOC and optional associated ICAC (if present) scoped under the " +
                    "accessing fabric upon successful validation of all arguments and preconditions. The new value shall " +
                    "immediately be reflected in the NOCs list attribute." +
                    "\n" +
                    "A Commissioner or Administrator shall issue this command after issuing the CSRRequest Command and " +
                    "receiving its response." +
                    "\n" +
                    "A Commissioner or Administrator SHOULD issue this command after performing the Attestation " +
                    "Procedure." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, " +
                    "then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If a prior AddTrustedRootCertificate command was successfully invoked within the fail-safe timer " +
                    "period, then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator, " +
                    "since the only valid following logical operation is invoking the AddNOC command." +
                    "\n" +
                    "If the prior CSRRequest state that preceded UpdateNOC had the IsForUpdateNOC field indicated as " +
                    "false, then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If any of the following conditions arise, the Node shall process an error by responding with an " +
                    "NOCResponse with a StatusCode of InvalidNOC as described in Section 11.18.6.7.2, “Handling Errors”:" +
                    "\n" +
                    "  • The NOC provided in the NOCValue does not refer in its subject to the FabricID associated with " +
                    "    the accessing fabric." +
                    "\n" +
                    "  • The ICAC provided in the ICACValue (if present) has a FabricID in its subject that does not " +
                    "    match the FabricID associated with the accessing fabric." +
                    "\n" +
                    "Otherwise, the command is considered an update of existing credentials for a given Fabric, and the " +
                    "following shall apply:" +
                    "\n" +
                    "  1. The Operational Certificate under the accessing fabric index in the NOCs list shall be updated " +
                    "     to match the incoming NOCValue and ICACValue (if present), such that the Node’s Operational " +
                    "     Identifier within the Fabric immediately changes." +
                    "\n" +
                    "    a. The operational key pair associated with the incoming NOC from the NOCValue, and generated by " +
                    "       the prior CSRRequest command, shall be committed to permanent storage, for subsequent use " +
                    "       during CASE." +
                    "\n" +
                    "    b. The operational discovery service record shall immediately reflect the new Operational " +
                    "       Identifier." +
                    "\n" +
                    "    c. All internal data reflecting the prior operational identifier of the Node within the Fabric " +
                    "       shall be revoked and removed, to an outcome equivalent to the disappearance of the prior " +
                    "       Node, except for the ongoing CASE session context, which shall temporarily remain valid until " +
                    "       the NOCResponse has been successfully delivered or until the next transport-layer error, so " +
                    "       that the response can be received by the Administrator invoking the command." +
                    "\n" +
                    "Thereafter, the Node shall respond with an NOCResponse with a StatusCode of OK and a FabricIndex " +
                    "field matching the FabricIndex under which the updated NOC is scoped."
            },

            Field({ name: "NocValue", id: 0x0, type: "octstr", access: "F", conformance: "M", constraint: "max 400" }),
            Field({ name: "IcacValue", id: 0x1, type: "octstr", access: "F", conformance: "O", constraint: "max 400" }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "NocResponse", id: 0x8, conformance: "M", direction: "response", xref: "core§11.18.6.10",

                details: "This command is used to report the results of the AddNOC, UpdateNOC, UpdateFabricLabel and " +
                    "RemoveFabric commands." +
                    "\n" +
                    "This command shall be generated in response to the following commands:" +
                    "\n" +
                    "  • AddNOC" +
                    "\n" +
                    "  • UpdateNOC" +
                    "\n" +
                    "  • UpdateFabricLabel" +
                    "\n" +
                    "  • RemoveFabric" +
                    "\n" +
                    "It provides status information about the success or failure of those commands."
            },

            Field({
                name: "StatusCode", id: 0x0, type: "NodeOperationalCertStatusEnum", conformance: "M",
                xref: "core§11.18.6.10.1",
                details: "This field shall contain an NOCStatus value representing the status of an operation involving a NOC."
            }),
            Field({
                name: "FabricIndex", id: 0x1, type: "fabric-idx", conformance: "StatusCode == Ok, O",
                constraint: "1 to 254", xref: "core§11.18.6.10.2",
                details: "If present, it shall contain the Fabric Index of the Fabric last added, removed or updated."
            }),

            Field({
                name: "DebugText", id: 0x2, type: "string", conformance: "O", constraint: "max 128",
                xref: "core§11.18.6.10.3",
                details: "This field may contain debugging textual information from the cluster implementation, which SHOULD " +
                    "NOT be presented to user interfaces in any way. Its purpose is to help developers in troubleshooting " +
                    "errors and the contents may go into logs or crash reports."
            })
        ),

        Command(
            {
                name: "UpdateFabricLabel", id: 0x9, access: "F A", conformance: "M", direction: "request",
                response: "NocResponse", xref: "core§11.18.6.11",

                details: "This command is used to set the user-visible fabric label for a given Fabric." +
                    "\n" +
                    "This command shall be used by an Administrator to set the user-visible Label field for a given " +
                    "Fabric, as reflected by entries in the Fabrics attribute. An Administrator shall use this command to " +
                    "set the Label to a string (possibly selected by the user themselves) that the user can recognize and " +
                    "relate to this Administrator" +
                    "\n" +
                    "  • during the commissioning process, and" +
                    "\n" +
                    "  • whenever the user chooses to update this string." +
                    "\n" +
                    "The Label field, along with the VendorID field in the same entry of the Fabrics attribute, SHOULD be " +
                    "used by Administrators to provide additional per-fabric context when operations such as RemoveFabric " +
                    "are considered or used."
            },

            Field({
                name: "Label", id: 0x0, type: "string", access: "F", conformance: "M", constraint: "max 32",
                xref: "core§11.18.6.11.1",

                details: "This field shall contain the label to set for the fabric associated with the current secure session." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If the Label field is identical to a Label already in use by a Fabric within the Fabrics list that " +
                    "is not the accessing fabric, then an NOCResponse with a StatusCode of LabelConflict shall be " +
                    "returned for the command and there shall NOT be any permanent changes to any Fabric data." +
                    "\n" +
                    "Otherwise, the Label field for the accessing fabric shall immediately be updated to reflect the " +
                    "Label argument provided. Following the update, an NOCResponse with a StatusCode of OK shall be " +
                    "returned." +
                    "\n" +
                    "If the command was invoked within a fail-safe context after a successful UpdateNOC command, then the " +
                    "label update shall apply to the pending update state that will be reverted if fail-safe expires " +
                    "prior to a CommissioningComplete command. In other words, label updates apply to the state of the " +
                    "Fabrics Attribute as currently visible, even for an existing fabric currently in process of being " +
                    "updated."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "RemoveFabric", id: 0xa, access: "A", conformance: "M", direction: "request",
                response: "NocResponse", xref: "core§11.18.6.12",

                details: "This command is used to remove a Fabric from the device." +
                    "\n" +
                    "This command is used by Administrators to remove a given Fabric and delete all associated " +
                    "fabric-scoped data." +
                    "\n" +
                    "If the given Fabric being removed is the last one to reference a given Trusted Root CA Certificate " +
                    "stored in the Trusted Root Certificates list, then that Trusted Root Certificate shall be removed." +
                    "\n" +
                    "### WARNING" +
                    "\n" +
                    "This command, if referring to an already existing Fabric not under the control of the invoking " +
                    "Administrator, shall ONLY be invoked after obtaining some form of explicit user consent through some " +
                    "method executed by the Administrator or Commissioner. This method of obtaining consent SHOULD employ " +
                    "as much data as possible about the existing Fabric associations within the Fabrics list, so that " +
                    "likelihood is as small as possible of a user removing a Fabric unwittingly. If a method exists for " +
                    "an Administrator or Commissioner to convey Fabric Removal to an entity related to that Fabric, " +
                    "whether in-band or out-of-band, then this method SHOULD be used to notify the other Administrative " +
                    "Domain’s party of the removal. Otherwise, users may only observe the removal of a Fabric association " +
                    "as persistently failing attempts to reach a Node operationally."
            },

            Field({
                name: "FabricIndex", id: 0x0, type: "fabric-idx", conformance: "M", constraint: "1 to 254",
                xref: "core§11.18.6.12.1",

                details: "This field shall contain the Fabric Index reference (see Section 7.19.2.23, “Fabric Index Type”) " +
                    "associated with the Fabric which is to be removed from the device." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If the FabricIndex field does not match the FabricIndex of any entry within the Fabrics list, then " +
                    "an NOCResponse with a StatusCode of InvalidFabricIndex shall be returned for the command and there " +
                    "shall NOT be any permanent changes to any device data." +
                    "\n" +
                    "Otherwise, one of the following outcomes shall occur:" +
                    "\n" +
                    "  1. If the FabricIndex matches the last remaining entry in the Fabrics list, then the device shall " +
                    "     delete all Matter related data on the node which was created since it was commissioned. This " +
                    "     includes all Fabric-Scoped data, including Access Control List, Access Restriction List, " +
                    "     bindings, scenes, group keys, operational certificates, etc. All Trusted Roots shall also be " +
                    "     removed. If a time synchronization cluster is present on the Node, the TrustedTimeSource and " +
                    "     DefaultNtp shall be set to null. Any Matter related data including logs, secure sessions, " +
                    "     exchanges and interaction model constructs shall also be removed. Since this operation involves " +
                    "     the removal of the secure session data that may underpin the current set of exchanges, the Node " +
                    "     invoking the command SHOULD NOT expect a response before terminating its secure session with " +
                    "     the target." +
                    "\n" +
                    "  2. If the FabricIndex does not equal the accessing fabric index, then the device shall begin the " +
                    "     process of irrevocably deleting all associated Fabric-Scoped data, including Access Control " +
                    "     Entries, Access Restriction Entries, bindings, group keys, operational certificates, etc. Any " +
                    "     remaining Trusted Roots no longer referenced by any operational certificate shall also be " +
                    "     removed. If a time synchronization cluster is present on the Node, and the TrustedTimeSource " +
                    "     FabricIndex matches the given FabricIndex, the TrustedTimeSource shall be set to null. All " +
                    "     secure sessions, exchanges and interaction model constructs related to the Operational Identity " +
                    "     under the given Fabric shall also be removed. Following the removal, an NOCResponse with a " +
                    "     StatusCode of OK shall be returned." +
                    "\n" +
                    "  3. If the FabricIndex equals the accessing fabric index, then the device shall begin the process " +
                    "     of irrevocably deleting all associated Fabric-Scoped data, including Access Control Entries, " +
                    "     Access Restriction Entries, bindings, group keys, operational certificates, etc. Any remaining " +
                    "     Trusted Roots no longer referenced by any operational certificate shall also be removed. If a " +
                    "     time synchronization cluster is present on the Node, and the TrustedTimeSource FabricIndex " +
                    "     matches the given FabricIndex, the TrustedTimeSource shall be set to null. All secure sessions, " +
                    "     exchanges and interaction model constructs related to the Operational Identity under the given " +
                    "     Fabric shall also be removed. Since this operation involves the removal of the secure session " +
                    "     data that may underpin the current set of exchanges, the Node invoking the command SHOULD NOT " +
                    "     expect a response before terminating its secure session with the target."
            })
        ),

        Command(
            {
                name: "AddTrustedRootCertificate", id: 0xb, access: "A", conformance: "M", direction: "request",
                response: "status", xref: "core§11.18.6.13",

                details: "This command is used to add a trusted root certificate to the device." +
                    "\n" +
                    "This command shall add a Trusted Root CA Certificate, provided as its Matter Certificate Encoding " +
                    "representation, to the TrustedRootCertificates Attribute list and shall ensure the next AddNOC " +
                    "command executed uses the provided certificate as its root of trust." +
                    "\n" +
                    "If the certificate from the RootCACertificate field is already installed, based on exact " +
                    "byte-for-byte equality, then this command shall succeed with no change to the list." +
                    "\n" +
                    "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                    "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "If a prior AddTrustedRootCertificate command was successfully invoked within the fail-safe timer " +
                    "period, which would cause the new invocation to add a second root certificate within a given " +
                    "fail-safe timer period, then this command shall fail with a CONSTRAINT_ERROR status code sent back " +
                    "to the initiator." +
                    "\n" +
                    "If a prior UpdateNOC or AddNOC command was successfully executed within the fail-safe timer period, " +
                    "then this command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator." +
                    "\n" +
                    "If the certificate from the RootCACertificate field fails any validity checks, not fulfilling all " +
                    "the requirements for a valid Matter Certificate Encoding representation, including a truncated or " +
                    "oversize value, then this command shall fail with an INVALID_COMMAND status code sent back to the " +
                    "initiator." +
                    "\n" +
                    "Note that the only method of removing a trusted root is by removing the Fabric that uses it as its " +
                    "root of trust using the RemoveFabric command."
            },

            Field({ name: "RootCaCertificate", id: 0x0, type: "octstr", conformance: "M", constraint: "max 400" })
        ),

        Command(
            {
                name: "SetVidVerificationStatement", id: 0xc, access: "F A", conformance: "M", direction: "request",
                response: "status", xref: "core§11.18.6.14",

                details: "This command is used to manage the VendorID and VIDVerificationStatement fields of the Fabrics " +
                    "attribute, and the VVSC field of an entry in the NOCs attribute." +
                    "\n" +
                    "This command shall be used to one or more of the following:" +
                    "\n" +
                    "  • Update the VendorID associated with an entry in the Fabrics attribute." +
                    "\n" +
                    "  • Associate or remove a VIDVerificationStatement associated with an entry in the Fabrics " +
                    "    attribute." +
                    "\n" +
                    "  • Associate or remove a VendorVerificationSigningCertificate (VVSC) associated with an entry in " +
                    "    the NOCs attribute." +
                    "\n" +
                    "This command shall only operate against the Fabrics and NOCs attribute entries associated with the " +
                    "accessing fabric index." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If the VendorID field is present, the value of the VendorID in the Fabrics attribute entry " +
                    "associated with the accessing fabric index shall have its value replaced with the value from the " +
                    "command field." +
                    "\n" +
                    "If the VVSC field is present, but the ICAC field is already present in the NOCs attribute entry " +
                    "associated with the accessing fabric index, then the command shall fail with a status code of " +
                    "INVALID_COMMAND." +
                    "\n" +
                    "If the VIDVerificationStatement field is present:" +
                    "\n" +
                    "  • If the length of the field’s value is neither exactly 0 nor exactly 85, then the command shall " +
                    "    fail with a status code of CONSTRAINT_ERROR." +
                    "\n" +
                    "  • If the length of the field’s value is exactly 0, then the VIDVerificationStatement field in the " +
                    "    Fabrics attribute entry associated with the accessing fabric index shall be erased and the field " +
                    "    shall disappear from the Fabrics entry." +
                    "\n" +
                    "  • If the length of the field’s value is exactly 85, then the VIDVerificationStatement field in the " +
                    "    Fabrics attribute entry associated with the accessing fabric index shall have its value replaced " +
                    "    with the value from the command field." +
                    "\n" +
                    "If the VVSC field is present:" +
                    "\n" +
                    "  • If the length of the field’s value is exactly 0, then the VVSC field in the NOCs attribute entry " +
                    "    associated with the accessing fabric index shall be erased and the field shall disappear from " +
                    "    the NOCs entry." +
                    "\n" +
                    "  • If the length of the field’s value is not 0, then the VVSC field in the NOCs attribute entry " +
                    "    associated with the accessing fabric index shall have its value replaced with the value from the " +
                    "    command field. The contents of the certificate need not be validated by the server. Clients " +
                    "    shall validate the contents at time of use." +
                    "\n" +
                    "If the command was invoked within a fail-safe context after a successful AddNOC or UpdateNOC " +
                    "command, then the field updates shall apply to the pending update state that will be reverted if " +
                    "fail-safe expires prior to a CommissioningComplete command. In other words, field updates apply to " +
                    "the state of the Fabrics Attribute as currently visible, even for an existing fabric currently in " +
                    "process of being updated."
            },

            Field({ name: "VendorId", id: 0x0, type: "vendor-id", conformance: "O.a+" }),
            Field({ name: "VidVerificationStatement", id: 0x1, type: "octstr", conformance: "O.a+", constraint: "max 85" }),
            Field({ name: "Vvsc", id: 0x2, type: "octstr", conformance: "O.a+", constraint: "max 400" })
        ),

        Command(
            {
                name: "SignVidVerificationRequest", id: 0xd, access: "A", conformance: "M", direction: "request",
                response: "SignVidVerificationResponse", xref: "core§11.18.6.15",

                details: "This command is used to authenticate the fabric associated with the FabricIndex." +
                    "\n" +
                    "This command shall be used to request that the server authenticate the fabric associated with the " +
                    "FabricIndex given by generating the response described in Section 6.4.10, “Fabric Table Vendor ID " +
                    "Verification Procedure”." +
                    "\n" +
                    "The FabricIndex field shall contain the fabric index being targeted by the request." +
                    "\n" +
                    "The ClientChallenge field shall contain a client-provided random challenge to be used during the " +
                    "signature procedure." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "If the FabricIndex field contains a fabric index which does not have an associated entry in the " +
                    "Fabrics attribute, then the command shall fail with a status code of CONSTRAINT_ERROR." +
                    "\n" +
                    "Otherwise, if no other errors have occurred, the command shall generate a " +
                    "SignVIDVerificationResponse."
            },

            Field({ name: "FabricIndex", id: 0x0, type: "fabric-idx", conformance: "M", constraint: "1 to 254" }),
            Field({ name: "ClientChallenge", id: 0x1, type: "octstr", conformance: "M", constraint: "32" })
        ),

        Command(
            {
                name: "SignVidVerificationResponse", id: 0xe, conformance: "M", direction: "response",
                xref: "core§11.18.6.16",

                details: "This command is used to report the results of the SignVIDVerificationRequest command. This command " +
                    "shall contain the response of the SignVIDVerificationRequest, computed as described below." +
                    "\n" +
                    "The FabricIndex field shall contain the same value of FabricIndex as the value from the associated " +
                    "SignVIDVerificationRequest." +
                    "\n" +
                    "The FabricBindingVersion field shall contain value 0x01 for version 1.0 of the Matter Cryptographic " +
                    "Primitives." +
                    "\n" +
                    "The Signature field shall contain the octet string result of CryptoSign(noc_private_key, " +
                    "vendor_id_verification_tbs):" +
                    "\n" +
                    "  • noc_private_key is the operational private key associated with the Node Operational Key Pair for " +
                    "    the FabricIndex requested in the associated SignVIDVerificationRequest." +
                    "\n" +
                    "  • vendor_id_verification_tbs := fabric_binding_version || client_challenge || " +
                    "    attestation_challenge || fabric_index || vendor_fabric_binding_message || " +
                    "    <vid_verification_statement>" +
                    "\n" +
                    "    ◦ fabric_binding_version is the value from the FabricBindingVersion field of this " +
                    "      SignVIDVerificationResponse." +
                    "\n" +
                    "    ◦ client_challenge is the 32-octet ClientChallenge from the SignVIDVerificationRequest." +
                    "\n" +
                    "    ◦ attestation_challenge is the AttestationChallenge from a CASE session, resumed CASE session, " +
                    "      or PASE session depending on the method used to establish the current secure session context " +
                    "      over which the response will be sent." +
                    "\n" +
                    "    ◦ fabric_index is the 1-octet value of FabricIndex from the SignVIDVerificationRequest." +
                    "\n" +
                    "    ◦ vendor_fabric_binding_message is the octet string of the vendor_fabric_binding_message defined " +
                    "      in Section 6.4.10.1, “Algorithm”." +
                    "\n" +
                    "    ◦ vid_verification_statement is the 85-octet (for cryptographic primitives mapping 1.0) value " +
                    "      from the VIDVerificationStatement field of the entry in the Fabrics attribute associated with " +
                    "      the fabric_index, if present. If there is no such field in the Fabrics attribute for the " +
                    "      fabric_index specified, this field shall be omitted from the vendor_id_verification_tbs " +
                    "      message."
            },

            Field({ name: "FabricIndex", id: 0x0, type: "fabric-idx", conformance: "M", constraint: "1 to 254" }),
            Field({ name: "FabricBindingVersion", id: 0x1, type: "uint8", conformance: "M", constraint: "1 to 255" }),
            Field({ name: "Signature", id: 0x2, type: "octstr", conformance: "M", constraint: "min 1" })
        ),

        Datatype(
            {
                name: "CertificateChainTypeEnum", type: "enum8", xref: "core§11.18.4.2",
                details: "This enumeration is used by the CertificateChainRequest command to convey which certificate from the " +
                    "device attestation certificate chain to transmit back to the client."
            },
            Field({
                name: "DacCertificate", id: 0x1, conformance: "M",
                description: "Request the DER- encoded DAC certificate"
            }),
            Field({
                name: "PaiCertificate", id: 0x2, conformance: "M",
                description: "Request the DER- encoded PAI certificate"
            })
        ),

        Datatype(
            {
                name: "NodeOperationalCertStatusEnum", type: "enum8", xref: "core§11.18.4.3",
                details: "This enumeration is used by the NOCResponse common response command to convey detailed outcome of " +
                    "several of this cluster’s operations."
            },
            Field({ name: "Ok", id: 0x0, conformance: "M", description: "OK, no error" }),
            Field({
                name: "InvalidPublicKey", id: 0x1, conformance: "M",
                description: "Public Key in the NOC does not match the public key in the NOCSR"
            }),
            Field({
                name: "InvalidNodeOpId", id: 0x2, conformance: "M",
                description: "The Node Operational ID in the NOC is not formatted correctly."
            }),
            Field({ name: "InvalidNoc", id: 0x3, conformance: "M", description: "Any other validation error in NOC chain" }),
            Field({
                name: "MissingCsr", id: 0x4, conformance: "M",
                description: "No record of prior CSR for which this NOC could match"
            }),
            Field({ name: "TableFull", id: 0x5, conformance: "M", description: "NOCs table full, cannot add another one" }),
            Field({
                name: "InvalidAdminSubject", id: 0x6, conformance: "M",
                description: "Invalid CaseAdminSubject field for an AddNOC command."
            }),
            Field({
                name: "FabricConflict", id: 0x9, conformance: "M",
                description: "Trying to AddNOC instead of UpdateNOC against an existing Fabric."
            }),
            Field({
                name: "LabelConflict", id: 0xa, conformance: "M",
                description: "Label already exists on another Fabric."
            }),
            Field({ name: "InvalidFabricIndex", id: 0xb, conformance: "M", description: "FabricIndex argument is invalid." })
        ),

        Datatype(
            {
                name: "NOCStruct", type: "struct", xref: "core§11.18.4.4",

                details: "This encodes a NOC chain, underpinning a commissioned Operational Identity for a given Node." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> The VVSC field is mutually exclusive with the ICAC field. If the ICAC field is non-null, the VVSC " +
                    "  field shall be omitted. If the VVSC field is present in the structure, the ICAC field shall be " +
                    "  null. The reason for this is to optimize storage usage, as the VID Verification Signer Certificate " +
                    "  (VVSC) is a field that is only needed in root-per-fabric situations without ICAC present." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> The Trusted Root CA Certificate (RCAC) is not included in this structure. The roots are available " +
                    "  in the TrustedRootCertificates attribute under the same associated fabric as the one for the " +
                    "  NOCStruct entry."
            },

            Field({
                name: "Noc", id: 0x1, type: "octstr", access: "F", conformance: "M", constraint: "max 400",
                xref: "core§11.18.4.4.1",
                details: "This field shall contain the NOC for the struct’s associated fabric, encoded using Matter " +
                    "Certificate Encoding."
            }),

            Field({
                name: "Icac", id: 0x2, type: "octstr", access: "F", conformance: "M", constraint: "max 400",
                quality: "X", xref: "core§11.18.4.4.2",
                details: "This field shall contain the ICAC for the struct’s associated fabric, encoded using Matter " +
                    "Certificate Encoding. If no ICAC is present in the chain, this field shall be set to null."
            }),

            Field({
                name: "Vvsc", id: 0x3, type: "octstr", access: "F", conformance: "desc", constraint: "max 400",
                xref: "core§11.18.4.4.3",
                details: "This field shall contain the Vendor Verification Signer Certificate (VVSC) for the struct’s " +
                    "associated fabric, encoded using Matter Certificate Encoding. If no VVSC is needed, this field shall " +
                    "be omitted (in that there shall NOT be a value present, not even an empty octet string). If the ICAC " +
                    "field is non-null, this field shall NOT be present."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            {
                name: "FabricDescriptorStruct", type: "struct", xref: "core§11.18.4.5",
                details: "This structure encodes a Fabric Reference for a fabric within which a given Node is currently " +
                    "commissioned."
            },

            Field({
                name: "RootPublicKey", id: 0x1, type: "octstr", access: "F", conformance: "M", constraint: "65",
                xref: "core§11.18.4.5.1",
                details: "This field shall contain the public key for the trusted root that scopes the fabric referenced by " +
                    "FabricIndex and its associated operational credential (see Section 6.4.5.3, “Trusted Root CA " +
                    "Certificates”). The format for the key shall be the same as that used in the ec-pub-key field of the " +
                    "Matter Certificate Encoding for the root in the operational certificate chain."
            }),

            Field({
                name: "VendorId", id: 0x2, type: "vendor-id", access: "F", conformance: "M", constraint: "desc",
                xref: "core§11.18.4.5.2",

                details: "This field shall contain the value of VendorID associated with the fabric." +
                    "\n" +
                    "This value shall have been provided by the AdminVendorID value provided in the AddNOC command that " +
                    "led to the creation of this FabricDescriptorStruct, or the value updated via the " +
                    "SetVIDVerificationStatement command, whichever was last completed. The set of allowed values is " +
                    "defined in AdminVendorID." +
                    "\n" +
                    "The intent is to provide user transparency about which entities have Administer privileges on the " +
                    "Node." +
                    "\n" +
                    "Clients shall consider the VendorID field value to be untrustworthy until the Fabric Table Vendor ID " +
                    "Verification Procedure has been executed against the fabric entry having this VendorID."
            }),

            Field({
                name: "FabricId", id: 0x3, type: "fabric-id", access: "F", conformance: "M",
                xref: "core§11.18.4.5.3",
                details: "This field shall contain the FabricID allocated to the fabric referenced by FabricIndex. This field " +
                    "shall match the value found in the matter-fabric-id field from the operational certificate providing " +
                    "the operational identity under this Fabric."
            }),

            Field({
                name: "NodeId", id: 0x4, type: "node-id", access: "F", conformance: "M", xref: "core§11.18.4.5.4",
                details: "This field shall contain the NodeID in use within the fabric referenced by FabricIndex. This field " +
                    "shall match the value found in the matter-node-id field from the operational certificate providing " +
                    "this operational identity."
            }),

            Field({
                name: "Label", id: 0x5, type: "string", access: "F", conformance: "M", constraint: "max 32",
                xref: "core§11.18.4.5.5",
                details: "This field shall contain a commissioner-set label for the fabric referenced by FabricIndex. This " +
                    "field is set by the UpdateFabricLabel command."
            }),

            Field({
                name: "VidVerificationStatement", id: 0x6, type: "octstr", access: "F", conformance: "O",
                constraint: "85", xref: "core§11.18.4.5.6",
                details: "This field, if present, shall contain a previously-installed administrator-set " +
                    "vid_verification_statement value (see Section 6.4.10, “Fabric Table Vendor ID Verification " +
                    "Procedure”) for the fabric referenced by FabricIndex. This field is set by the " +
                    "SetVIDVerificationStatement command."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Cluster(
        {
            name: "AdministratorCommissioning", id: 0x3c, classification: "node", pics: "CADMIN",
            xref: "core§11.19",

            details: "This cluster is used to trigger a Node to allow a new Administrator to commission it. It defines " +
                "Attributes, Commands and Responses needed for this purpose." +
                "\n" +
                "There are two methods of commissioning, Basic Commissioning which may be supported and is described " +
                "in Section 5.6.2, “Basic Commissioning Method (BCM)” and Enhanced Commissioning which shall be " +
                "supported and is described in Section 5.6.3, “Enhanced Commissioning Method (ECM)”." +
                "\n" +
                "For the management of Operational Credentials and Trusted Root Certificates, the Operational " +
                "Credentials cluster is used." +
                "\n" +
                "If the Administrator Commissioning Cluster server instance is present on an endpoint with the Root " +
                "Node device type in the Descriptor cluster DeviceTypeList, then:" +
                "\n" +
                "  • The Commissioning Window shall be opened or closed on the node that the Root Node endpoint is " +
                "    on." +
                "\n" +
                "  • The attributes shall indicate the state of the node that the Root Node endpoint is on." +
                "\n" +
                "If the Administrator Commissioning Cluster server instance is present on an endpoint with the " +
                "Bridged Node device type in the Descriptor cluster DeviceTypeList, then:" +
                "\n" +
                "  • The Commissioning Window shall be opened or closed on the node represented by the Bridged Node." +
                "\n" +
                "  • The attributes shall indicate the state of the node that is represented by the Bridged Node."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),
        Attribute(
            { name: "FeatureMap", id: 0xfffc, type: "FeatureMap", xref: "core§11.19.4" },
            Field({ name: "BC", constraint: "0", title: "Basic", details: "Node supports Basic Commissioning Method." })
        ),

        Attribute({
            name: "WindowStatus", id: 0x0, type: "CommissioningWindowStatusEnum", access: "R V",
            conformance: "M", xref: "core§11.19.7.1",

            details: "Indicates whether a new Commissioning window has been opened by an Administrator, using either the " +
                "OpenCommissioningWindow command or the OpenBasicCommissioningWindow command." +
                "\n" +
                "This attribute shall revert to WindowNotOpen upon expiry of a commissioning window." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> An initial commissioning window is not opened using either the OpenCommissioningWindow command or " +
                "  the OpenBasicCommissioningWindow command, and therefore this attribute shall be set to " +
                "  WindowNotOpen on initial commissioning."
        }),

        Attribute({
            name: "AdminFabricIndex", id: 0x1, type: "fabric-idx", access: "R V", conformance: "M",
            quality: "X", xref: "core§11.19.7.2",

            details: "When the WindowStatus attribute is not set to WindowNotOpen, this attribute shall indicate the " +
                "FabricIndex associated with the Fabric scoping of the Administrator that opened the window. This may " +
                "be used to cross-reference in the Fabrics attribute of the Operational Credentials cluster." +
                "\n" +
                "If, during an open commissioning window, the fabric for the Administrator that opened the window is " +
                "removed, then this attribute shall be set to null." +
                "\n" +
                "When the WindowStatus attribute is set to WindowNotOpen, this attribute shall be set to null."
        }),

        Attribute({
            name: "AdminVendorId", id: 0x2, type: "vendor-id", access: "R V", conformance: "M", quality: "X",
            xref: "core§11.19.7.3",

            details: "When the WindowStatus attribute is not set to WindowNotOpen, this attribute shall indicate the " +
                "Vendor ID associated with the Fabric scoping of the Administrator that opened the window. This field " +
                "shall match the VendorID field of the Fabrics attribute list entry associated with the Administrator " +
                "having opened the window, at the time of window opening. If the fabric for the Administrator that " +
                "opened the window is removed from the node while the commissioning window is still open, this " +
                "attribute shall NOT be updated." +
                "\n" +
                "When the WindowStatus attribute is set to WindowNotOpen, this attribute shall be set to null."
        }),

        Command(
            {
                name: "OpenCommissioningWindow", id: 0x0, access: "A T", conformance: "M", direction: "request",
                response: "status", xref: "core§11.19.8.1",

                details: "This command is used by a current Administrator to instruct a Node to go into commissioning mode. " +
                    "The Enhanced Commissioning Method specifies a window of time during which an already commissioned " +
                    "Node accepts PASE sessions. The current Administrator MUST specify a timeout value for the duration " +
                    "of the OpenCommissioningWindow command." +
                    "\n" +
                    "When the OpenCommissioningWindow command expires or commissioning completes, the Node shall remove " +
                    "the Passcode by deleting the PAKE passcode verifier as well as stop publishing the DNS-SD record " +
                    "corresponding to this command as described in Section 4.3.1, “Commissionable Node Discovery”. The " +
                    "commissioning into a new Fabric completes when the Node successfully receives a " +
                    "CommissioningComplete command, see Section 5.5, “Commissioning Flows”." +
                    "\n" +
                    "The parameters for OpenCommissioningWindow command are as follows:" +
                    "\n" +
                    "A current Administrator may invoke this command to put a node in commissioning mode for the next " +
                    "Administrator. On completion, the command shall return a cluster specific status code from the " +
                    "Section 11.19.6, “Status Codes” below reflecting success or reasons for failure of the operation. " +
                    "The new Administrator shall discover the Node on the IP network using DNS-based Service Discovery " +
                    "(DNS-SD) for commissioning." +
                    "\n" +
                    "If any format or validity errors related to the PAKEPasscodeVerifier, Iterations or Salt arguments " +
                    "arise, this command shall fail with a cluster specific status code of PAKEParameterError." +
                    "\n" +
                    "If a commissioning window is already currently open, this command shall fail with a cluster specific " +
                    "status code of Busy." +
                    "\n" +
                    "If the fail-safe timer is currently armed, this command shall fail with a cluster specific status " +
                    "code of Busy, since it is likely that concurrent commissioning operations from multiple separate " +
                    "Commissioners are about to take place." +
                    "\n" +
                    "In case of any other parameter error, this command shall fail with a status code of COMMAND_INVALID."
            },

            Field({
                name: "CommissioningTimeout", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "core§11.19.8.1.1",
                details: "This field shall specify the time in seconds during which commissioning session establishment is " +
                    "allowed by the Node. This timeout value shall follow guidance as specified in the initial " +
                    "Announcement Duration. The CommissioningTimeout applies only to cessation of any announcements and " +
                    "to accepting of new commissioning sessions; it does not apply to abortion of connections, i.e., a " +
                    "commissioning session SHOULD NOT abort prematurely upon expiration of this timeout."
            }),

            Field({
                name: "PakePasscodeVerifier", id: 0x1, type: "octstr", conformance: "M", constraint: "97",
                xref: "core§11.19.8.1.2",

                details: "This field shall specify an ephemeral PAKE passcode verifier (see Section 3.10, " +
                    "“Password-Authenticated Key Exchange (PAKE)”) computed by the existing Administrator to be used for " +
                    "this commissioning. The field is concatenation of two values (w0 || L) shall be " +
                    "(CRYPTO_GROUP_SIZE_BYTES + CRYPTO_PUBLIC_KEY_SIZE_BYTES)-octets long as detailed in " +
                    "Crypto_PAKEValues_Responder. It shall be derived from an ephemeral passcode (See PAKE). It shall be " +
                    "deleted by the Node at the end of commissioning or expiration of the OpenCommissioningWindow " +
                    "command, and shall be deleted by the existing Administrator after sending it to the Node(s)."
            }),

            Field({
                name: "Discriminator", id: 0x2, type: "uint16", conformance: "M", constraint: "0 to 4095",
                xref: "core§11.19.8.1.3",
                details: "This field shall be used by the Node as the long discriminator for DNS-SD advertisement (see Section " +
                    "4.3.1.5, “TXT key for discriminator (D)”) for discovery by the new Administrator. The new " +
                    "Administrator can find and filter DNS-SD records by long discriminator to locate and initiate " +
                    "commissioning with the appropriate Node."
            }),

            Field({
                name: "Iterations", id: 0x3, type: "uint32", conformance: "M", constraint: "1000 to 100000",
                xref: "core§11.19.8.1.4",
                details: "This field shall be used by the Node as the PAKE iteration count associated with the ephemeral PAKE " +
                    "passcode verifier to be used for this commissioning, which shall be sent by the Node to the new " +
                    "Administrator’s software as response to the PBKDFParamRequest during PASE negotiation. The permitted " +
                    "range of values shall match the range specified in Section 3.9, “Password-Based Key Derivation " +
                    "Function (PBKDF)”, within the definition of the Crypto_PBKDFParameterSet."
            }),

            Field({
                name: "Salt", id: 0x4, type: "octstr", conformance: "M", constraint: "16 to 32",
                xref: "core§11.19.8.1.5",

                details: "This field shall be used by the Node as the PAKE Salt associated with the ephemeral PAKE passcode " +
                    "verifier to be used for this commissioning, which shall be sent by the Node to the new " +
                    "Administrator’s software as response to the PBKDFParamRequest during PASE negotiation. The " +
                    "constraints on the value shall match those specified in Section 3.9, “Password-Based Key Derivation " +
                    "Function (PBKDF)”, within the definition of the Crypto_PBKDFParameterSet." +
                    "\n" +
                    "When a Node receives the OpenCommissioningWindow command, it shall begin advertising on DNS-SD as " +
                    "described in Section 4.3.1, “Commissionable Node Discovery” and for a time period as described in " +
                    "CommissioningTimeout." +
                    "\n" +
                    "When the command is received by a ICD, it shall enter into active mode. The ICD shall remain in " +
                    "Active Mode as long as one of these conditions is met:" +
                    "\n" +
                    "  • A commissioning window is open." +
                    "\n" +
                    "  • There is an armed fail-safe timer."
            })
        ),

        Command(
            {
                name: "OpenBasicCommissioningWindow", id: 0x1, access: "A T", conformance: "BC",
                direction: "request", response: "status", xref: "core§11.19.8.2",

                details: "This command may be used by a current Administrator to instruct a Node to go into commissioning " +
                    "mode, if the node supports the Basic Commissioning Method. The Basic Commissioning Method specifies " +
                    "a window of time during which an already commissioned Node accepts PASE sessions. The current " +
                    "Administrator shall specify a timeout value for the duration of the OpenBasicCommissioningWindow " +
                    "command." +
                    "\n" +
                    "If a commissioning window is already currently open, this command shall fail with a cluster specific " +
                    "status code of Busy." +
                    "\n" +
                    "If the fail-safe timer is currently armed, this command shall fail with a cluster specific status " +
                    "code of Busy, since it is likely that concurrent commissioning operations from multiple separate " +
                    "Commissioners are about to take place." +
                    "\n" +
                    "In case of any other parameter error, this command shall fail with a status code of COMMAND_INVALID." +
                    "\n" +
                    "The commissioning into a new Fabric completes when the Node successfully receives a " +
                    "CommissioningComplete command, see Section 5.5, “Commissioning Flows”. The new Administrator shall " +
                    "discover the Node on the IP network using DNS-based Service Discovery (DNS-SD) for commissioning."
            },

            Field({
                name: "CommissioningTimeout", id: 0x0, type: "uint16", conformance: "M", constraint: "desc",
                xref: "core§11.19.8.2.1",

                details: "This field shall specify the time in seconds during which commissioning session establishment is " +
                    "allowed by the Node. This timeout shall follow guidance as specified in the initial Announcement " +
                    "Duration." +
                    "\n" +
                    "When a Node receives the OpenBasicCommissioningWindow command, it shall begin advertising on DNS-SD " +
                    "as described in Section 4.3.1, “Commissionable Node Discovery” and for a time period as described in " +
                    "CommissioningTimeout. When the command is received by a ICD, it shall enter into active mode. The " +
                    "ICD shall remain in Active Mode as long as one of these conditions is met:" +
                    "\n" +
                    "  • A commissioning window is open." +
                    "\n" +
                    "  • There is an armed fail-safe timer."
            })
        ),

        Command({
            name: "RevokeCommissioning", id: 0x2, access: "A T", conformance: "M", direction: "request",
            response: "status", xref: "core§11.19.8.3",

            details: "This command is used by a current Administrator to instruct a Node to revoke any active " +
                "OpenCommissioningWindow or OpenBasicCommissioningWindow command. This is an idempotent command and " +
                "the Node shall (for ECM) delete the temporary PAKEPasscodeVerifier and associated data, and stop " +
                "publishing the DNS-SD record associated with the OpenCommissioningWindow or " +
                "OpenBasicCommissioningWindow command, see Section 4.3.1, “Commissionable Node Discovery”." +
                "\n" +
                "If no commissioning window was open at time of receipt, this command shall fail with a cluster " +
                "specific status code of WindowNotOpen." +
                "\n" +
                "If the commissioning window was open and the fail-safe was armed when this command is received, the " +
                "device shall immediately expire the fail-safe and perform the cleanup steps outlined in Section " +
                "11.10.7.2.2, “Behavior on expiry of Fail-Safe timer”."
        }),

        Datatype(
            { name: "CommissioningWindowStatusEnum", type: "enum8", xref: "core§11.19.5.1" },
            Field({ name: "WindowNotOpen", id: 0x0, conformance: "M", description: "Commissioning window not open" }),
            Field({
                name: "EnhancedWindowOpen", id: 0x1, conformance: "M",
                description: "An Enhanced Commissioning Method window is open"
            }),
            Field({
                name: "BasicWindowOpen", id: 0x2, conformance: "BC",
                description: "A Basic Commissioning Method window is open"
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "core§11.19.6.1" },
            Field({
                name: "Busy", id: 0x2, conformance: "M",
                description: "Could not be completed because another commissioning is in progress"
            }),
            Field({
                name: "PakeParameterError", id: 0x3, conformance: "M",
                description: "Provided PAKE parameters were incorrectly formatted or otherwise invalid"
            }),
            Field({
                name: "WindowNotOpen", id: 0x4, conformance: "M",
                description: "No commissioning window was currently open"
            })
        )
    ),

    Cluster(
        { name: "OtaSoftwareUpdateProvider", id: 0x29, classification: "node", pics: "OTAP", xref: "core§11.20.6" },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Command(
            {
                name: "QueryImage", id: 0x0, access: "O", conformance: "M", direction: "request",
                response: "QueryImageResponse", xref: "core§11.20.6.5.1",
                details: "Upon receipt, this command shall trigger an attempt to find an updated Software Image by the OTA " +
                    "Provider to match the OTA Requestor’s constraints provided in the payload fields."
            },

            Field({
                name: "VendorId", id: 0x0, type: "vendor-id", conformance: "M", xref: "core§11.20.6.5.1.1",
                details: "The value shall be the Vendor ID applying to the OTA Requestor’s Node and shall match the value " +
                    "reported by the Basic Information Cluster VendorID attribute."
            }),
            Field({
                name: "ProductId", id: 0x1, type: "uint16", conformance: "M", xref: "core§11.20.6.5.1.2",
                details: "The value shall be the Product ID applying to the OTA Requestor’s Node and shall match the value " +
                    "reported by the Basic Information Cluster ProductID attribute."
            }),

            Field({
                name: "SoftwareVersion", id: 0x2, type: "uint32", conformance: "M", xref: "core§11.20.6.5.1.3",
                details: "The SoftwareVersion included in the request payload shall provide the value representing the current " +
                    "version running on the OTA Requestor invoking the command. This version shall be equal to the " +
                    "Software Version attribute of the Basic Information Cluster."
            }),

            Field(
                {
                    name: "ProtocolsSupported", id: 0x3, type: "list", conformance: "M", constraint: "max 8",
                    xref: "core§11.20.6.5.1.4",

                    details: "This field shall contain a list of all download protocols supported by the OTA Requestor." +
                        "\n" +
                        "This field shall be used by the OTA Provider to generate the correct URI for the location of the " +
                        "Software Image when one is found to be available. The values of BDX Synchronous and BDX Asynchronous " +
                        "shall always be supported by an OTA Provider. Furthermore, OTA Providers with access to external " +
                        "networking SHOULD support the HTTPS protocol. OTA Providers may support other protocols." +
                        "\n" +
                        "The algorithm to select the specific protocol to use in a given Software Image URI is " +
                        "implementation-dependent, provided that the rules in Section 11.20.3.3.1, “Download Protocol " +
                        "selection” are followed." +
                        "\n" +
                        "See Section 11.20.3.2, “Querying the OTA Provider” and Section 11.20.3.5, “Transfer of OTA Software " +
                        "Update images” for more details about usage of this field."
                },

                Field({ name: "entry", type: "DownloadProtocolEnum" })
            ),

            Field({
                name: "HardwareVersion", id: 0x4, type: "uint16", conformance: "O", xref: "core§11.20.6.5.1.5",
                details: "The value of this field, if present, shall contain the OTA Requestor’s hardware version, and shall " +
                    "be equal to the HardwareVersion attribute of the Basic Information Cluster."
            }),

            Field({
                name: "Location", id: 0x5, type: "string", conformance: "O", constraint: "2",
                xref: "core§11.20.6.5.1.6",
                details: "The location, if present, shall provide the same value as the Basic Information Cluster Location " +
                    "attribute for the OTA Requestor as configured. This may be used by the OTA Provider logic to allow " +
                    "per-region selection of the Software Image."
            }),

            Field({
                name: "RequestorCanConsent", id: 0x6, type: "bool", conformance: "O", default: false,
                xref: "core§11.20.6.5.1.7",
                details: "This field shall be set to true by an OTA Requestor that is capable of obtaining user consent for " +
                    "OTA application by virtue of built-in user interface capabilities. Otherwise, it shall be false." +
                    "\n" +
                    "See Section 11.20.3.4, “Obtaining user consent for updating software” for application details about " +
                    "usage."
            }),

            Field({
                name: "MetadataForProvider", id: 0x7, type: "octstr", conformance: "O", constraint: "max 512",
                xref: "core§11.20.6.5.1.8",

                details: "This optional field, if present, shall consist of a top-level anonymous list; each list element " +
                    "shall have a profile-specific tag encoded in fully-qualified form. Each list element shall contain a " +
                    "manufacturer-specific payload, which the OTA Requestor invoking this command wants to expose to the " +
                    "receiving OTA Provider. This payload may be used for any purpose and SHOULD be as small as " +
                    "practical." +
                    "\n" +
                    "The use of this field SHOULD be restricted to Vendor-specific usage and shall NOT be used as a " +
                    "selector required to match for the selection of a Software Image in production environments, unless " +
                    "absolutely necessary, as the interpretation of this field may be ambiguous to OTA Providers " +
                    "implementing the Cluster in a compliant but divergent way from the sender." +
                    "\n" +
                    "An example of usage for this field is for an OTA Requestor to provide specific data about grouping " +
                    "or authentication in field trial environments, where the OTA Provider is likely to understand it and " +
                    "be able to act upon it, either for special selection of image, or recording of activity." +
                    "\n" +
                    "An OTA Provider shall report the availability of Software Images, if one is found to be applicable " +
                    "using the other provided fields, even if the MetadataForProvider field is deemed to contain invalid " +
                    "or unknown information. That is, the contents of the MetadataForProvider field shall NOT be used to " +
                    "deny a software update to an OTA Requestor, unless both OTA Requestor and OTA Provider have an " +
                    "externally agreed-upon policy whereby strictly correct additional MetadataForProvider is expected to " +
                    "fulfill the OTA Software Update process." +
                    "\n" +
                    "### Usage of the QueryImage Command" +
                    "\n" +
                    "OTA Requestors shall send a QueryImage command to the OTA Provider to determine the availability of " +
                    "a new Software Image." +
                    "\n" +
                    "See Section 11.20.3.2, “Querying the OTA Provider” for full details about the OTA Software Update " +
                    "Query flow which makes use of this command."
            })
        ),

        Command(
            { name: "QueryImageResponse", id: 0x1, conformance: "M", direction: "response", xref: "core§11.20.6.5.2" },

            Field({
                name: "Status", id: 0x0, type: "StatusEnum", conformance: "M", xref: "core§11.20.6.5.2.1",
                details: "This field shall contain the primary response regarding the availability of a Software Image." +
                    "\n" +
                    "See Section 11.20.3.2, “Querying the OTA Provider” for details about the possible values for this " +
                    "field and their meaning."
            }),

            Field({
                name: "DelayedActionTime", id: 0x1, type: "uint32", conformance: "Status == Busy",
                xref: "core§11.20.6.5.2.2",

                details: "This field shall convey the minimum time to wait, in seconds from the time of this response, before " +
                    "sending another QueryImage command or beginning a download from the OTA Provider. OTA Requestors " +
                    "shall respect this minimum delay, unless they had previously restarted and lost track of it. OTA " +
                    "Providers SHOULD expect OTA Requestors to follow this value to their best capability, however, a " +
                    "restarting Node may come back sooner, due to having lost track of this state response." +
                    "\n" +
                    "Beware, this field is conditionally present based on the conformance listed in Section 11.20.6.5.2, " +
                    "“QueryImageResponse Command”." +
                    "\n" +
                    "See Section 11.20.3.2, “Querying the OTA Provider” for details about the rules regarding this field."
            }),

            Field(
                {
                    name: "ImageUri", id: 0x2, type: "string", conformance: "Status == UpdateAvailable",
                    constraint: "max 256", xref: "core§11.20.6.5.2.3",

                    details: "This field, when present, shall contain a URI where the OTA Requestor SHOULD download a Soft ware " +
                        "Image. The syntax of the ImageURI field shall follow the URI syntax as specified in RFC 3986." +
                        "\n" +
                        "Beware, this field is conditionally present based on the conformance listed in Section 11.20.6.5.2, " +
                        "“QueryImageResponse Command”." +
                        "\n" +
                        "If the ImageURI specifies a BDX Protocol bdx: scheme, then the following rules describe the location " +
                        "to be used for download:" +
                        "\n" +
                        "  1. The URI’s scheme field shall be exactly bdx in lowercase characters." +
                        "\n" +
                        "  2. The URI’s authority field shall contain only the host portion and shall use string " +
                        "     representation of the Operational Node ID of the Node where to proceed with the download, on " +
                        "     the same Fabric on which the OTA Requestor received the QueryImageResponse." +
                        "\n" +
                        "  3. The encoding of the Node ID in the host field shall use an uppercase hexadecimal format, using " +
                        "     exactly 16 characters to encode the network byte order value of the NodeID, in a similar " +
                        "     fashion as the Node Identifier portion of the Operational Instance Name." +
                        "\n" +
                        "    a. The Operational Node ID in the host field shall match the NodeID of the OTA Provider " +
                        "       responding with the QueryImageResponse. The usage of a different Node ID than that of the " +
                        "       provider is reserved for future use. This constraint reduces the number of independent CASE " +
                        "       secure channel sessions that have to be maintained to proceed with OTA software updates, thus " +
                        "       reducing energy and resource utilization for the software update process." +
                        "\n" +
                        "  4. The user section of the authority field shall be absent, as there are no \"users\" to be " +
                        "     considered." +
                        "\n" +
                        "  5. The port section of the authority field shall be absent, as the port for transport shall be " +
                        "     determined through Operational Discovery of the target Node." +
                        "\n" +
                        "  6. The URI shall NOT contain a query field." +
                        "\n" +
                        "  7. The URI shall NOT contain a fragment field." +
                        "\n" +
                        "  8. The path field shall employ absolute path representation and shall contain the file designator " +
                        "     of the software image to download at the BDX server. When used with the BDX server, the leading " +
                        "     / separating the URI authority from the path shall be omitted. When contacting the BDX server, " +
                        "     further processing of the file designator shall NOT be done, including handling of URL-encoded " +
                        "     escape sequences. Rather, the exact octets of the path, as received shall be the values used by " +
                        "     both client and server in handling the file designator." +
                        "\n" +
                        "    a. The path shall only contain valid URI characters." +
                        "\n" +
                        "These rules above for BDX URIs simplify parsing for OTA Requestors receiving Image URIs. The " +
                        "following example procedure shows how the format constraints simplify the extraction of the " +
                        "necessary data to reach the BDX server for download." +
                        "\n" +
                        "  1. Verify that the URI is 24 characters or longer, which is the minimum length of a valid BDX URI " +
                        "     with all elements present, for example bdx://00112233AABBCCDD/0." +
                        "\n" +
                        "  2. Verify the presence of prefix bdx:// indicating a BDX URI." +
                        "\n" +
                        "  3. Extract the next 16 characters and convert from uppercase hexadecimal to a 64-bit scalar value, " +
                        "     considering network byte order. This is the destination Node ID." +
                        "\n" +
                        "  4. Verify the presence of a path separator / and skip it." +
                        "\n" +
                        "  5. Extract the remaining characters of the string as the file designator to employ when initiating " +
                        "     the BDX transfer." +
                        "\n" +
                        "Example ImageURI values are below, and illustrate some but not all of valid and invalid cases:" +
                        "\n" +
                        "  • Synchronous or Asynchronous BDX Protocol:" +
                        "\n" +
                        "    ◦ Valid: bdx://8899AABBCCDDEEFF/the_file_designator123" +
                        "\n" +
                        "      ▪ Node ID: 0x8899AABBCCDDEEFF" +
                        "\n" +
                        "      ▪ File designator: the_file_designator123" +
                        "\n" +
                        "    ◦ Valid: bdx://0099AABBCCDDEE77/the%20file%20designator/some_more" +
                        "\n" +
                        "      ▪ Node ID: 0x0099AABBCCDDEE77" +
                        "\n" +
                        "      ▪ File designator: the%20file%20designator/some_more. Note that the %20 are retained and not " +
                        "        converted to ASCII 0x20 (space). The file designator is the path as received verbatim, after " +
                        "        the first '/' (U+002F / SOLIDUS) following the host." +
                        "\n" +
                        "    ◦ Invalid: bdx://99AABBCCDDEE77/the_file_designator123" +
                        "\n" +
                        "      ▪ Node ID: Invalid since it is not exactly 16 characters long, due to having omitted leading " +
                        "        zeros." +
                        "\n" +
                        "    ◦ Invalid: bdx://0099aabbccddee77/the_file_designator123" +
                        "\n" +
                        "      ▪ Node ID: Invalid since lowercase hexadecimal was used." +
                        "\n" +
                        "    ◦ Invalid: bdx:8899AABBCCDDEEFF/the_file_designator123" +
                        "\n" +
                        "      ▪ Invalid since bdx scheme does not contain an authority, that is, it does not have // after " +
                        "        the first :." +
                        "\n" +
                        "  • HTTP over TLS:" +
                        "\n" +
                        "    ◦ Valid: https://example.domain:8466/software/image.bin" +
                        "\n" +
                        "See Section 11.20.3.2, “Querying the OTA Provider” for additional details about the flow."
                }
            ),

            Field({
                name: "SoftwareVersion", id: 0x3, type: "uint32", conformance: "Status == UpdateAvailable",
                xref: "core§11.20.6.5.2.4",

                details: "This field indicates the version of the image being provided to the OTA Requestor by the OTA " +
                    "Provider." +
                    "\n" +
                    "Beware, this field is conditionally present based on the conformance listed in Section 11.20.6.5.2, " +
                    "“QueryImageResponse Command”." +
                    "\n" +
                    "See Section 11.20.3.2, “Querying the OTA Provider” for additional details about the flow and " +
                    "acceptable values."
            }),

            Field({
                name: "SoftwareVersionString", id: 0x4, type: "string", conformance: "Status == UpdateAvailable",
                constraint: "1 to 64", xref: "core§11.20.6.5.2.5",

                details: "This field provides a string version of the image being provided to the OTA Requestor by the OTA " +
                    "Provider." +
                    "\n" +
                    "Beware, this field is conditionally present based on the conformance listed in Section 11.20.6.5.2," +
                    "\n" +
                    "“QueryImageResponse Command”." +
                    "\n" +
                    "See Section 11.20.3.2, “Querying the OTA Provider” for additional details about the flow and " +
                    "acceptable values."
            }),

            Field({
                name: "UpdateToken", id: 0x5, type: "octstr", conformance: "Status == UpdateAvailable",
                constraint: "8 to 32", xref: "core§11.20.6.5.2.6",
                details: "Beware, this field is conditionally present based on the conformance listed in Section 11.20.6.5.2, " +
                    "“QueryImageResponse Command”." +
                    "\n" +
                    "See Section 11.20.3.6.1, “UpdateToken usage” for additional details about the generation and usage " +
                    "of UpdateToken."
            }),

            Field({
                name: "UserConsentNeeded", id: 0x6, type: "bool", conformance: "O", default: false,
                xref: "core§11.20.6.5.2.7",

                details: "This field, if present, shall only be interpreted if the OTA Requestor had previously indicated a " +
                    "value of True in the RequestorCanConsent field of the QueryImageRequest. This field, when present " +
                    "and set to True, shall indicate that a capable OTA Requestor must obtain user-visible consent prior " +
                    "to downloading the OTA Software Image." +
                    "\n" +
                    "See Section 11.20.3.4, “Obtaining user consent for updating software” for application details about " +
                    "usage."
            }),

            Field({
                name: "MetadataForRequestor", id: 0x7, type: "octstr", conformance: "O", constraint: "max 512",
                xref: "core§11.20.6.5.2.8",

                details: "This optional field, if present, shall consist of a top-level anonymous list; each list element " +
                    "shall have a profile-specific tag encoded in fully-qualified form. Each list element shall contain a " +
                    "manufacturer-specific payload, which the OTA Provider wants to expose to the receiving OTA " +
                    "Requestor. This payload may be used for any purpose and SHOULD be as small as practical." +
                    "\n" +
                    "The presence of this field shall NOT be required for correct operation of any OTA Provider compliant " +
                    "with this Cluster specification." +
                    "\n" +
                    "The data for this field does not exist in any Distributed Compliance Ledger record and SHOULD only " +
                    "be emitted by an OTA Provider with this additional knowledge if it has knowledge that the receiving " +
                    "OTA Requestor may be able to use it."
            })
        ),

        Command(
            {
                name: "ApplyUpdateRequest", id: 0x2, access: "O", conformance: "M", direction: "request",
                response: "ApplyUpdateResponse", xref: "core§11.20.6.5.3"
            },

            Field({
                name: "UpdateToken", id: 0x0, type: "octstr", conformance: "M", constraint: "8 to 32",
                xref: "core§11.20.6.5.3.1",
                details: "This field shall contain the UpdateToken as specified in Section 11.20.3.6.1, “UpdateToken usage”. " +
                    "This field may be used by the OTA Provider to track minimal lifecycle state to allow finer-grained " +
                    "scheduling of the application of Software Images by OTA Requestors."
            }),

            Field({
                name: "NewVersion", id: 0x1, type: "uint32", conformance: "M", xref: "core§11.20.6.5.3.2",

                details: "The NewVersion field included in the request payload shall provide the SoftwareVersion value of the " +
                    "new Software Image which the OTA Requestor is ready to start applying. The OTA Provider may use this " +
                    "new version to track or record Software Image application by OTA Requestors." +
                    "\n" +
                    "### When Generated" +
                    "\n" +
                    "The ApplyUpdateRequest Command shall be invoked by an OTA Requestor once it is ready to apply a " +
                    "previously downloaded Software Image." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "Upon receipt of this command the OTA Provider shall respond with an Action field consistent with the " +
                    "next action the OTA Requestor should take, including any possible time delay." +
                    "\n" +
                    "The OTA Provider shall NOT refer to previously stored state about any download progress to reply. If " +
                    "any state keeping is done by the OTA Provider, it shall only relate to the UpdateToken and the " +
                    "history of prior ApplyUpdateRequest commands." +
                    "\n" +
                    "See Section 11.20.3.6, “Applying a software update” for a description of the flow in response to an " +
                    "OTA Provider receiving an invocation of this command." +
                    "\n" +
                    "### Handling Error Cases" +
                    "\n" +
                    "See Section 11.20.3.6, “Applying a software update” for all error-handling information."
            })
        ),

        Command(
            { name: "ApplyUpdateResponse", id: 0x3, conformance: "M", direction: "response", xref: "core§11.20.6.5.4" },

            Field({
                name: "Action", id: 0x0, type: "ApplyUpdateActionEnum", conformance: "M",
                xref: "core§11.20.6.5.4.1",
                details: "The Action field shall express the action that the OTA Provider requests from the OTA Requestor. See " +
                    "Section 11.20.3.6, “Applying a software update” for a description of the Action values provided in " +
                    "response to an OTA Provider receiving an invocation of this command."
            }),

            Field({
                name: "DelayedActionTime", id: 0x1, type: "uint32", conformance: "M", xref: "core§11.20.6.5.4.2",
                details: "The minimum time period the OTA Requestor shall wait before executing the Action, in seconds from " +
                    "receipt." +
                    "\n" +
                    "If this field has a value higher than 86400 seconds (24 hours), then the OTA Requestor may assume a " +
                    "value of 86400, in order to reduce undue Software Image application delays."
            })
        ),

        Command(
            {
                name: "NotifyUpdateApplied", id: 0x4, access: "O", conformance: "M", direction: "request",
                response: "status", xref: "core§11.20.6.5.5"
            },
            Field({
                name: "UpdateToken", id: 0x0, type: "octstr", conformance: "M", constraint: "8 to 32",
                xref: "core§11.20.6.5.5.1",
                details: "This field shall contain the UpdateToken as specified in Section 11.20.3.6.1, “UpdateToken usage”."
            }),

            Field({
                name: "SoftwareVersion", id: 0x1, type: "uint32", conformance: "M", xref: "core§11.20.6.5.5.2",

                details: "The SoftwareVersion included in the request payload shall provide the same value as the " +
                    "SoftwareVersion attribute in the invoking OTA Requestor’s Basic Information Cluster, and SHOULD be " +
                    "consistent with the value representing a new version running on the Node invoking the command." +
                    "\n" +
                    "### When Generated" +
                    "\n" +
                    "The NotifyUpdateApplied command SHOULD be invoked in the following two circumstances:" +
                    "\n" +
                    "  1. An OTA Requestor has just successfully applied a Software Image it had obtained from a previous " +
                    "     QueryImageResponse." +
                    "\n" +
                    "  2. An OTA Requestor has just successfully applied a Software Image it had obtained through means " +
                    "     different than those of this Cluster." +
                    "\n" +
                    "An OTA Provider may use the state of invocation of this command to help track the progress of update " +
                    "for OTA Requestors it knows require a new OTA Software Image. However, due to the possibility that " +
                    "an OTA Requestor may never come back (e.g. device removed from Fabric altogether, or a critical " +
                    "malfunction), an OTA Provider shall NOT expect every OTA Requestor to invoke this command for " +
                    "correct operation of the OTA Provider." +
                    "\n" +
                    "This command shall be considered optional and shall NOT result in reduced availability of the OTA " +
                    "Provider functionality if OTA Requestors never invoke this command." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "An OTA Provider receiving an invocation of this command may log it internally." +
                    "\n" +
                    "On receiving this command, an OTA Provider may use the information to update its bookkeeping of " +
                    "cached Software Images, or use it for other similar administrative purposes."
            })
        ),

        Datatype(
            {
                name: "StatusEnum", type: "enum8", xref: "core§11.20.6.4.1",
                details: "See Section 11.20.3.2, “Querying the OTA Provider” for the semantics of these values."
            },
            Field({
                name: "UpdateAvailable", id: 0x0, conformance: "M",
                description: "Indicates that the OTA Provider has an update available."
            }),
            Field({
                name: "Busy", id: 0x1, conformance: "M",
                description: "Indicates OTA Provider may have an update, but it is not ready yet."
            }),
            Field({
                name: "NotAvailable", id: 0x2, conformance: "M",
                description: "Indicates that there is definitely no update currently available from the OTA Provider."
            }),
            Field({
                name: "DownloadProtocolNotSupported", id: 0x3, conformance: "M",
                description: "Indicates that the requested download protocol is not supported by the OTA Provider."
            })
        ),

        Datatype(
            {
                name: "ApplyUpdateActionEnum", type: "enum8", xref: "core§11.20.6.4.2",
                details: "See Section 11.20.3.6, “Applying a software update” for the semantics of the values. This " +
                    "enumeration is used in the Action field of the ApplyUpdateResponse command. See (Action)."
            },
            Field({ name: "Proceed", id: 0x0, conformance: "M", description: "Apply the update." }),
            Field({ name: "AwaitNextAction", id: 0x1, conformance: "M", description: "Wait at least the given delay time." }),
            Field({
                name: "Discontinue", id: 0x2, conformance: "M",
                description: "The OTA Provider is conveying a desire to rescind a previously provided Software Image."
            })
        ),

        Datatype(
            {
                name: "DownloadProtocolEnum", type: "enum8", xref: "core§11.20.6.4.3",
                details: "Note that only HTTP over TLS (HTTPS) is supported (see RFC 7230). Using HTTP without TLS shall NOT " +
                    "be supported, as there is no way to authenticate the involved participants."
            },
            Field({
                name: "BdxSynchronous", id: 0x0, conformance: "M",
                description: "Indicates support for synchronous BDX."
            }),
            Field({
                name: "BdxAsynchronous", id: 0x1, conformance: "O",
                description: "Indicates support for asynchronous BDX."
            }),
            Field({ name: "Https", id: 0x2, conformance: "O", description: "Indicates support for HTTPS." }),
            Field({
                name: "VendorSpecific", id: 0x3, conformance: "O",
                description: "Indicates support for vendor specific protocol."
            })
        )
    ),

    Cluster(
        { name: "OtaSoftwareUpdateRequestor", id: 0x2a, classification: "node", pics: "OTAR", xref: "core§11.20.7" },
        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute(
            {
                name: "DefaultOtaProviders", id: 0x0, type: "list", access: "RW F VA", conformance: "M",
                constraint: "desc", default: [], quality: "N", xref: "core§11.20.7.5.1",

                details: "This field is a list of ProviderLocation whose entries shall be set by Administrators, either during " +
                    "Commissioning or at a later time, to set the ProviderLocation for the default OTA Provider Node to " +
                    "use for software updates on a given Fabric." +
                    "\n" +
                    "There shall NOT be more than one entry per Fabric. On a list update that would introduce more than " +
                    "one entry per fabric, the write shall fail with CONSTRAINT_ERROR status code." +
                    "\n" +
                    "Provider Locations obtained using the AnnounceOTAProvider command shall NOT overwrite values set in " +
                    "the DefaultOTAProviders attribute."
            },

            Field({ name: "entry", type: "ProviderLocation" })
        ),

        Attribute({
            name: "UpdatePossible", id: 0x1, type: "bool", access: "R V", conformance: "M", default: true,
            xref: "core§11.20.7.5.2",
            details: "This field shall be set to True if the OTA Requestor is currently able to be updated. Otherwise, it " +
                "shall be set to False in case of any condition preventing update being possible, such as " +
                "insufficient capacity of an internal battery. This field is merely informational for diagnostics " +
                "purposes and shall NOT affect the responses provided by an OTA Provider to an OTA Requestor."
        }),

        Attribute({
            name: "UpdateState", id: 0x2, type: "UpdateStateEnum", access: "R V", conformance: "M", default: 0,
            xref: "core§11.20.7.5.3",
            details: "This field shall reflect the current state of the OTA Requestor with regards to obtaining software " +
                "updates. See Section 11.20.7.4.2, “UpdateStateEnum Type” for possible values." +
                "\n" +
                "This field SHOULD be updated in a timely manner whenever OTA Requestor internal state updates."
        }),

        Attribute({
            name: "UpdateStateProgress", id: 0x3, type: "uint8", access: "R V", conformance: "M",
            constraint: "0 to 100", default: null, quality: "X", xref: "core§11.20.7.5.4",

            details: "This field shall reflect the percentage value of progress, relative to the current UpdateState, if " +
                "applicable to the state." +
                "\n" +
                "The value of this field shall be null if a progress indication does not apply to the current state." +
                "\n" +
                "A value of 0 shall indicate that the beginning has occurred. A value of 100 shall indicate " +
                "completion." +
                "\n" +
                "This field may be updated infrequently. Some care SHOULD be taken by Nodes to avoid over-reporting " +
                "progress when this attribute is part of a subscription."
        }),

        Event(
            {
                name: "StateTransition", id: 0x0, access: "V", conformance: "M", priority: "info",
                xref: "core§11.20.7.7.1",
                details: "This event shall be generated when a change of the UpdateState attribute occurs due to an OTA " +
                    "Requestor moving through the states necessary to query for updates."
            },

            Field({
                name: "PreviousState", id: 0x0, type: "UpdateStateEnum", conformance: "M", default: 0,
                xref: "core§11.20.7.7.1.1",
                details: "This field shall be set to the state that preceded the transition causing this event to be " +
                    "generated, if such a state existed. If no previous state exists, the value shall be Unknown."
            }),

            Field({
                name: "NewState", id: 0x1, type: "UpdateStateEnum", conformance: "M", xref: "core§11.20.7.7.1.2",
                details: "This field shall be set to the state now in effect through the transition causing this event to be " +
                    "generated."
            }),
            Field({
                name: "Reason", id: 0x2, type: "ChangeReasonEnum", conformance: "M", xref: "core§11.20.7.7.1.3",
                details: "This field shall be set to the reason why this event was generated."
            }),

            Field({
                name: "TargetSoftwareVersion", id: 0x3, type: "uint32", conformance: "M", default: null,
                quality: "X", xref: "core§11.20.7.7.1.4",
                details: "This field shall be set to the target SoftwareVersion which is the subject of the operation, " +
                    "whenever the NewState is Downloading, Applying or RollingBack. Otherwise TargetSoftwareVersion shall " +
                    "be null."
            })
        ),

        Event(
            {
                name: "VersionApplied", id: 0x1, access: "V", conformance: "M", priority: "critical",
                xref: "core§11.20.7.7.2",
                details: "This event shall be generated whenever a new version starts executing after being applied due to a " +
                    "software update. This event SHOULD be generated even if a software update was done using means " +
                    "outside of this cluster."
            },

            Field({
                name: "SoftwareVersion", id: 0x0, type: "uint32", conformance: "M", xref: "core§11.20.7.7.2.1",
                details: "This field shall be set to the same value as the one available in the Software Version attribute of " +
                    "the Basic Information Cluster for the newly executing version."
            }),

            Field({
                name: "ProductId", id: 0x1, type: "uint16", conformance: "M", xref: "core§11.20.7.7.2.2",
                details: "This field shall be set to the ProductID applying to the executing version, as reflected by the " +
                    "Basic Information Cluster. This can be used to detect a product updating its definition due to a " +
                    "large-scale functional update that may impact aspects of the product reflected in the DeviceModel " +
                    "schema of the Distributed Compliance Ledger."
            })
        ),

        Event(
            {
                name: "DownloadError", id: 0x2, access: "V", conformance: "M", priority: "info",
                xref: "core§11.20.7.7.3",
                details: "This event shall be generated whenever an error occurs during OTA Requestor download operation."
            },
            Field({
                name: "SoftwareVersion", id: 0x0, type: "uint32", conformance: "M", xref: "core§11.20.7.7.3.1",
                details: "This field shall be set to the value of the SoftwareVersion being downloaded, matching the " +
                    "SoftwareVersion field of the QueryImageResponse that caused the failing download to take place."
            }),
            Field({
                name: "BytesDownloaded", id: 0x1, type: "uint64", conformance: "M", xref: "core§11.20.7.7.3.2",
                details: "This field shall be set to the number of bytes that have been downloaded during the failing transfer " +
                    "that caused this event to be generated."
            }),

            Field({
                name: "ProgressPercent", id: 0x2, type: "uint8", conformance: "M", constraint: "0 to 100",
                default: null, quality: "X", xref: "core§11.20.7.7.3.3",
                details: "This field shall be set to the nearest integer percent value reflecting how far within the transfer " +
                    "the failure occurred during the failing transfer that caused this event to be generated, unless the " +
                    "total length of the transfer is unknown, in which case it shall be null."
            }),

            Field({
                name: "PlatformCode", id: 0x3, type: "int64", conformance: "M", default: null, quality: "X",
                xref: "core§11.20.7.7.3.4",
                details: "This field SHOULD be set to some internal product-specific error code, closest in " +
                    "temporal/functional proximity to the failure that caused this event to be generated. Otherwise, it " +
                    "shall be null. This event field may be used for debugging purposes and no uniform definition exists " +
                    "related to its meaning."
            })
        ),

        Command(
            {
                name: "AnnounceOtaProvider", id: 0x0, access: "A", conformance: "O", direction: "request",
                response: "status", xref: "core§11.20.7.6.1",
                details: "This command may be invoked by Administrators to announce the presence of a particular OTA Provider." +
                    "\n" +
                    "This command shall be scoped to the accessing fabric." +
                    "\n" +
                    "If the accessing fabric index is 0, this command shall fail with an UNSUPPORTED_ACCESS status code."
            },

            Field({
                name: "ProviderNodeId", id: 0x0, type: "node-id", access: "F", conformance: "M",
                xref: "core§11.20.7.6.1.1",
                details: "This field shall contain the Node ID of a Node implementing the OTA Provider cluster server, on the " +
                    "accessing fabric."
            }),

            Field({
                name: "VendorId", id: 0x1, type: "vendor-id", access: "F", conformance: "M",
                xref: "core§11.20.7.6.1.2",
                details: "This field shall contain the assigned Vendor ID of the Node invoking this command, as it would " +
                    "appear in that Node’s Basic Information Cluster VendorID attribute."
            }),

            Field({
                name: "AnnouncementReason", id: 0x2, type: "AnnouncementReasonEnum", access: "F", conformance: "M",
                xref: "core§11.20.7.6.1.3",
                details: "This field shall contain a value expressing the reason for the announcement."
            }),

            Field({
                name: "MetadataForNode", id: 0x3, type: "octstr", access: "F", conformance: "O",
                constraint: "max 512", xref: "core§11.20.7.6.1.4",

                details: "This optional field, if present, shall consist of a top-level anonymous list; each list element " +
                    "shall have a profile-specific tag encoded in fully-qualified form. Each list element shall contain a " +
                    "manufacturer-specific payload, which the Node invoking this command wants to expose to the receiving " +
                    "Node. This payload may be used for any purpose and SHOULD be as small as practical, especially if " +
                    "invoked to groups, in order to reduce networking burden of these payloads." +
                    "\n" +
                    "This field SHOULD only be included if the sending OTA Provider has knowledge that some recipient can " +
                    "make use of it."
            }),

            Field({
                name: "Endpoint", id: 0x4, type: "endpoint-no", access: "F", conformance: "M",
                xref: "core§11.20.7.6.1.5",

                details: "This field shall contain the endpoint number which has the OTA Provider device type and OTA Software " +
                    "Update Provider cluster server on the ProviderNodeID. This is provided to avoid having to do " +
                    "discovery of the location of that endpoint by walking over all endpoints and checking their " +
                    "Descriptor Cluster." +
                    "\n" +
                    "### When Generated" +
                    "\n" +
                    "An OTA Provider may invoke this command directly to an OTA Requestor, to announce its presence as an " +
                    "OTA Provider on the Fabric." +
                    "\n" +
                    "These announcements, if made, SHOULD be made at most once every 24 hours for any given target Node, " +
                    "to assist OTA Requestors in discovering available OTA Provider resources, unless the " +
                    "AnnouncementReason is UrgentUpdateAvailable, in which case this command may be more frequent." +
                    "\n" +
                    "Any invocation shall be made with a delay of at least 1 second between invocations from a given OTA " +
                    "Provider, to reduce burden on the networking infrastructure and affect a form of serialized jitter. " +
                    "It is recommended to offset the first announcement of a round (i.e. new set of announcements after a " +
                    "previous complete set) by a random delay time with a distribution span of >= 60 seconds to jitter " +
                    "announcement schedules over time." +
                    "\n" +
                    "### Effect on Receipt" +
                    "\n" +
                    "On receipt of this command, an OTA Requestor SHOULD consider the new ProviderNodeID and " +
                    "AnnouncementReason to possibly query for new software sooner than it would have with its default " +
                    "behavior." +
                    "\n" +
                    "The OTA Requestor SHOULD NOT update entries in the DefaultOTAProviders list based on announcements." +
                    "\n" +
                    "The receiving Node may ignore the content of the announcement if it is unable or unwilling to " +
                    "further query OTA Providers temporarily, or if its provider list is full. If the announcement is " +
                    "ignored, the response SHOULD be SUCCESS." +
                    "\n" +
                    "Depending on the value of the AnnouncementReason field, the OTA Requestor may have to query the OTA " +
                    "Provider. See Section 11.20.7.6.1.3, “AnnouncementReason Field” for the different values and their " +
                    "meaning." +
                    "\n" +
                    "If present, the MetadataForNode field’s may be used by a receiving OTA Requestor in any way it deems " +
                    "satisfactory. The MetadataForNode field SHOULD be empty under most normal operational circumstance, " +
                    "but can be useful in environments such as field trials or integration test environments to hint at " +
                    "additional capabilities which OTA Requestors may use in a particular Vendor-specific context."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Datatype(
            { name: "AnnouncementReasonEnum", type: "enum8", xref: "core§11.20.7.4.1" },

            Field({
                name: "SimpleAnnouncement", id: 0x0, conformance: "M",
                description: "An OTA Provider is announcing its presence.", xref: "core§11.20.7.4.1.1",
                details: "An OTA Provider is announcing its presence, but there is no implication that an OTA Requestor would " +
                    "have a new Software Image available if it queried immediately."
            }),

            Field({
                name: "UpdateAvailable", id: 0x1, conformance: "M",
                description: "An OTA Provider is announcing, either to a single Node or to a group of Nodes, that a new Software Image MAY be available.",
                xref: "core§11.20.7.4.1.2",
                details: "An OTA Provider is announcing, either to a single Node or to a group of Nodes, that a new Software " +
                    "Image may be available. The details may only be obtained by executing a OTA Software Update Query " +
                    "procedure. A receiving OTA Requestor SHOULD only query the indicated OTA Provider at the " +
                    "ProviderLocation at its next upcoming OTA Provider query."
            }),

            Field({
                name: "UrgentUpdateAvailable", id: 0x2, conformance: "M",
                description: "An OTA Provider is announcing, either to a single Node or to a group of Nodes, that a new Software Image MAY be available, which contains an update that needs to be applied urgently.",
                xref: "core§11.20.7.4.1.3",

                details: "An OTA Provider is announcing, either to a single Node or to a group of Nodes, that a new Software " +
                    "Image may be available, which contains an update that needs to be applied urgently. The details may " +
                    "only be obtained by executing a OTA Software Update Query procedure. A receiving OTA Requestor " +
                    "SHOULD query the indicated OTA Provider at the ProviderLocation after a random jitter delay between " +
                    "1 and 600 seconds. This particular reason SHOULD only be employed when an urgent update is " +
                    "available, such as an important security update, or just after initial commissioning of a device, to " +
                    "assist OTA Requestors in more rapidly obtaining updated software."
            })
        ),

        Datatype(
            { name: "UpdateStateEnum", type: "enum8", xref: "core§11.20.7.4.2" },

            Field({
                name: "Unknown", id: 0x0, conformance: "M", description: "Current state is not yet determined.",
                xref: "core§11.20.7.4.2.1",
                details: "This value shall indicate that the current state is not yet determined. Nodes SHOULD attempt a " +
                    "better state reporting."
            }),

            Field({
                name: "Idle", id: 0x1, conformance: "M",
                description: "Indicate a Node not yet in the process of software update.",
                xref: "core§11.20.7.4.2.2",
                details: "This value shall indicate a Node not yet in the process of software update, for example because it " +
                    "is awaiting the moment when a query will be made."
            }),

            Field({
                name: "Querying", id: 0x2, conformance: "M",
                description: "Indicate a Node in the process of querying an OTA Provider.",
                xref: "core§11.20.7.4.2.3",
                details: "This value shall indicate a Node in the process of querying an OTA Provider with QueryImage command, " +
                    "including during the process of awaiting a response to that command."
            }),

            Field({
                name: "DelayedOnQuery", id: 0x3, conformance: "M",
                description: "Indicate a Node waiting after a Busy response.", xref: "core§11.20.7.4.2.4",
                details: "This value shall indicate a Node waiting because it received a prior QueryImageResponse with a " +
                    "Status field indicating Busy."
            }),

            Field({
                name: "Downloading", id: 0x4, conformance: "M",
                description: "Indicate a Node currently in the process of downloading a software update.",
                xref: "core§11.20.7.4.2.5",
                details: "This value shall indicate a Node currently in the process of downloading a software update."
            }),

            Field({
                name: "Applying", id: 0x5, conformance: "M",
                description: "Indicate a Node currently in the process of verifying and applying a software update.",
                xref: "core§11.20.7.4.2.6",
                details: "This value shall indicate a Node currently in the process of verifying and applying a software " +
                    "update."
            }),

            Field({
                name: "DelayedOnApply", id: 0x6, conformance: "M",
                description: "Indicate a Node waiting caused by AwaitNextAction response.",
                xref: "core§11.20.7.4.2.7",
                details: "This value shall indicate a Node waiting because it received a prior ApplyUpdateResponse with an " +
                    "Action field set to AwaitNextAction."
            }),

            Field({
                name: "RollingBack", id: 0x7, conformance: "M",
                description: "Indicate a Node in the process of recovering to a previous version.",
                xref: "core§11.20.7.4.2.8",
                details: "This value shall indicate a Node in the process of recovering to a previous version from a new " +
                    "version that was applied, but that could not remain in force, for reasons such as invalid data " +
                    "detected on boot, or significant runtime issues such as reboot loops. Eventually, the next state " +
                    "seen SHOULD be Unknown or Idle."
            }),

            Field({
                name: "DelayedOnUserConsent", id: 0x8, conformance: "M",
                description: "Indicate a Node is capable of user consent."
            })
        ),

        Datatype(
            { name: "ChangeReasonEnum", type: "enum8", xref: "core§11.20.7.4.3" },
            Field({
                name: "Unknown", id: 0x0, conformance: "M",
                description: "The reason for a state change is unknown.", xref: "core§11.20.7.4.3.1",
                details: "This value shall indicate that the reason for a state change is unknown."
            }),

            Field({
                name: "Success", id: 0x1, conformance: "M",
                description: "The reason for a state change is the success of a prior operation.",
                xref: "core§11.20.7.4.3.2",
                details: "This value shall indicate that the reason for a state change is the success of a prior operation."
            }),

            Field({
                name: "Failure", id: 0x2, conformance: "M",
                description: "The reason for a state change is the failure of a prior operation.",
                xref: "core§11.20.7.4.3.3",
                details: "This value shall indicate that the reason for a state change is the failure of a prior operation."
            }),

            Field({
                name: "TimeOut", id: 0x3, conformance: "M",
                description: "The reason for a state change is a time-out.", xref: "core§11.20.7.4.3.4",
                details: "This value shall indicate that the reason for a state change is a time-out condition as determined " +
                    "by the OTA Requestor."
            }),

            Field({
                name: "DelayByProvider", id: 0x4, conformance: "O",
                description: "The reason for a state change is a request by the OTA Provider to wait.",
                xref: "core§11.20.7.4.3.5",
                details: "This value shall indicate that the reason for a state change is a request by the OTA Provider to " +
                    "await for a delay."
            })
        ),

        Datatype(
            {
                name: "ProviderLocation", type: "struct", xref: "core§11.20.7.4.4",
                details: "This structure encodes a fabric-scoped location of an OTA provider on a given fabric."
            },

            Field({
                name: "ProviderNodeId", id: 0x1, type: "node-id", access: "F", conformance: "M",
                xref: "core§11.20.7.4.4.1",
                details: "This field shall contain the Node ID of the OTA Provider to contact within the Fabric identified by " +
                    "the FabricIndex."
            }),

            Field({
                name: "Endpoint", id: 0x2, type: "endpoint-no", access: "F", conformance: "M",
                xref: "core§11.20.7.4.4.2",
                details: "This field shall contain the endpoint number which has the OTA Provider device type and OTA Software " +
                    "Update Provider cluster server on the ProviderNodeID. This is provided to avoid having to do " +
                    "discovery of the location of that endpoint by walking over all endpoints and checking their " +
                    "Descriptor Cluster."
            }),

            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        )
    ),

    Datatype(
        {
            name: "SoftwareVersionCertificationStatusEnum", type: "enum8", xref: "core§11.23.8.2",
            details: "The values 0 through 2 shall correspond to the values 0 through 2 used in certification_type in the " +
                "Certification Declaration."
        },
        Field({
            name: "DevTest", id: 0x0, conformance: "M",
            description: "used for development and test purposes (These will typically not be placed in DCL)"
        }),
        Field({
            name: "Provisional", id: 0x1, conformance: "M",
            description: "used for a SoftwareVersion when going into certification testing (These might or might not be placed in DCL, depending on the Connectivity Standards Alliance policy and procedures)"
        }),
        Field({
            name: "Certified", id: 0x2, conformance: "M",
            description: "used for a SoftwareVersion which has been certified"
        }),
        Field({
            name: "Revoked", id: 0x3, conformance: "M",
            description: "used for a SoftwareVersion which has been revoked"
        })
    ),

    Cluster(
        {
            name: "JointFabricDatastore", id: 0x752, classification: "node", pics: "JFDS", xref: "core§11.24",

            details: "The Joint Fabric Datastore Cluster is a cluster that provides a mechanism for the Joint Fabric " +
                "Administrators to manage the set of Nodes, Groups, and Group membership among Nodes in the Joint " +
                "Fabric." +
                "\n" +
                "When an Ecosystem Administrator Node is commissioned onto the Joint Fabric, the Ecosystem " +
                "Administrator Node has no knowledge of what Nodes and Groups are present, or what set-up information " +
                "related to the Joint Fabric is provided by the user. To address lack of knowledge, the Joint Fabric " +
                "Datastore provides the information required for all Ecosystem Administrators to maintain a " +
                "consistent view of the Joint Fabric including Nodes, Groups, settings and privileges." +
                "\n" +
                "The Joint Fabric Datastore cluster server shall only be accessible on a Node which is acting as the " +
                "Joint Fabric Anchor Administrator. When not acting as the Joint Fabric Anchor Administrator, the " +
                "Joint Fabric Datastore cluster shall NOT be accessible." +
                "\n" +
                "The Admin level of access to the Joint Fabric Datastore cluster server shall be limited to JF " +
                "Administrator Nodes identified using the Administrator CAT." +
                "\n" +
                "NOTE Support for Joint Fabric Datastore cluster is provisional."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "AnchorRootCa", id: 0x0, type: "octstr", access: "R A", conformance: "P, M",
            xref: "core§11.24.6.1",
            details: "This shall indicate the Anchor Root CA used to sign all NOC Issuers in the Joint Fabric for the " +
                "accessing fabric. A null value indicates that the Joint Fabric is not yet formed."
        }),

        Attribute({
            name: "AnchorNodeId", id: 0x1, type: "node-id", access: "R A", conformance: "P, M",
            xref: "core§11.24.6.2",
            details: "This shall indicate the Node identifier of the Joint Fabric Anchor Root CA for the accessing fabric."
        }),

        Attribute({
            name: "AnchorVendorId", id: 0x2, type: "vendor-id", access: "R A", conformance: "P, M",
            xref: "core§11.24.6.3",
            details: "This shall indicate the Vendor identifier of the Joint Fabric Anchor Root CA for the accessing " +
                "fabric."
        }),

        Attribute({
            name: "FriendlyName", id: 0x3, type: "string", access: "R A", conformance: "P, M",
            constraint: "max 32", xref: "core§11.24.6.4",
            details: "Friendly name for the accessing fabric which can be propagated to nodes."
        }),

        Attribute(
            {
                name: "GroupKeySetList", id: 0x4, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.5",
                details: "This shall indicate the list of DatastoreGroupKeySetStruct used in the Joint Fabric for the " +
                    "accessing fabric." +
                    "\n" +
                    "This attribute shall contain at least one entry, the IPK, which has GroupKeySetID of 0."
            },

            Field({ name: "entry", type: "DatastoreGroupKeySetStruct" })
        ),

        Attribute(
            {
                name: "GroupList", id: 0x5, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.6",
                details: "This shall indicate the list of groups in the Joint Fabric for the accessing fabric." +
                    "\n" +
                    "This list must include, at a minimum, one group with GroupCAT value set to Administrator CAT and one " +
                    "group with GroupCAT value set to Anchor CAT."
            },

            Field({ name: "entry", type: "DatastoreGroupInformationEntryStruct" })
        ),

        Attribute(
            {
                name: "NodeList", id: 0x6, type: "list", access: "R A", conformance: "P, M", xref: "core§11.24.6.7",
                details: "This shall indicate the list of nodes in the Joint Fabric for the accessing fabric."
            },
            Field({ name: "entry", type: "DatastoreNodeInformationEntryStruct" })
        ),

        Attribute(
            {
                name: "AdminList", id: 0x7, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.8",

                details: "This shall indicate the list of administrators in the Joint Fabric for the accessing fabric." +
                    "\n" +
                    "Only one Administrator may serve as the Anchor Root CA and Anchor Fabric Administrator and shall " +
                    "have index value 0. All other Joint Fabric Administrators shall be referenced at index 1 or greater." +
                    "\n" +
                    "A null value or empty list indicates that the Joint Fabric is not yet formed."
            },

            Field({ name: "entry", type: "DatastoreAdministratorInformationEntryStruct" })
        ),

        Attribute({
            name: "Status", id: 0x8, type: "DatastoreStatusEntryStruct", access: "R A", conformance: "P, M",
            xref: "core§11.24.6.9",

            details: "This shall indicate the current state of the Joint Fabric Datastore Cluster for the accessing " +
                "fabric." +
                "\n" +
                "The Committed status indicates the DataStore is ready for use. The Pending status indicates that the " +
                "DataStore is not yet ready for use. The DeletePending status indicates that the DataStore is in the " +
                "process of being transferred to another Joint Fabric Anchor Administrator."
        }),

        Attribute(
            {
                name: "EndpointGroupIdList", id: 0x9, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.10",
                details: "This shall indicate the group membership of endpoints in the accessing fabric." +
                    "\n" +
                    "Any changes to this List (add/remove entry) must follow the pending→committed workflow with current " +
                    "state reflected in the Status Entry."
            },

            Field({ name: "entry", type: "DatastoreEndpointGroupIDEntryStruct" })
        ),

        Attribute(
            {
                name: "EndpointBindingList", id: 0xa, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.11",
                details: "This shall indicate the binding list for endpoints in the accessing fabric." +
                    "\n" +
                    "Any changes to this List (add/remove entry) must follow the pending→committed workflow with current " +
                    "state reflected in the Status Entry."
            },

            Field({ name: "entry", type: "DatastoreEndpointBindingEntryStruct" })
        ),

        Attribute(
            {
                name: "NodeKeySetList", id: 0xb, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.12",
                details: "This shall indicate the KeySet entries for nodes in the accessing fabric." +
                    "\n" +
                    "Any changes to this List (add/remove entry) must follow the pending→committed workflow with current " +
                    "state reflected in the Status Entry."
            },

            Field({ name: "entry", type: "DatastoreNodeKeySetEntryStruct" })
        ),

        Attribute(
            {
                name: "NodeAclList", id: 0xc, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.13",
                details: "This shall indicate the ACL entries for nodes in the accessing fabric." +
                    "\n" +
                    "Any changes to this List (add/remove entry) must follow the pending→committed workflow with current " +
                    "state reflected in the Status Entry."
            },

            Field({ name: "entry", type: "DatastoreACLEntryStruct" })
        ),

        Attribute(
            {
                name: "NodeEndpointList", id: 0xd, type: "list", access: "R A", conformance: "P, M",
                xref: "core§11.24.6.14",
                details: "This shall indicate the Endpoint entries for nodes in the accessing fabric." +
                    "\n" +
                    "Any changes to this List (add/remove entry) must follow the pending→committed workflow with current " +
                    "state reflected in the Status Entry."
            },

            Field({ name: "entry", type: "DatastoreEndpointEntryStruct" })
        ),

        Command(
            {
                name: "AddKeySet", id: 0x0, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.1",

                details: "This command shall be used to add a KeySet to the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "GroupKeySet represents the KeySet to be added to the Joint Fabric Datastore Cluster. Upon receipt of " +
                    "this command, the Datastore shall:" +
                    "\n" +
                    "  1. Ensure there are no KeySets in the KeySetList attribute with the given GroupKeySetID." +
                    "\n" +
                    "  2. If a match is found, return CONSTRAINT_ERROR." +
                    "\n" +
                    "  3. Add the Epoch Key Entry for the KeySet to the KeySetList attribute."
            },

            Field({ name: "GroupKeySet", id: 0x0, type: "DatastoreGroupKeySetStruct", conformance: "M" })
        ),

        Command(
            {
                name: "UpdateKeySet", id: 0x1, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.2",

                details: "This command shall be used to update a KeySet in the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "GroupKeySet represents the KeySet to be updated in the Joint Fabric Datastore Cluster. Upon receipt " +
                    "of this command, the Datastore shall:" +
                    "\n" +
                    "  1. Find the Epoch Key Entry for the KeySet in the KeySetList attribute with the given " +
                    "     GroupKeySetID, and update any changed fields." +
                    "\n" +
                    "  2. If entry is not found, return NOT_FOUND." +
                    "\n" +
                    "  3. If any fields are changed as a result of this command:" +
                    "\n" +
                    "    a. Iterate through each Node Information Entry:" +
                    "\n" +
                    "      i. If the NodeKeySetList contains an entry with the given GroupKeySetID:" +
                    "\n" +
                    "        A. Update the Status on the given DatastoreNodeKeySetEntryStruct tp Pending." +
                    "\n" +
                    "        B. Update the GroupKeySet on the given Node with the new values." +
                    "\n" +
                    "          I. If successful, update the Status on this DatastoreNodeKeySetEntryStruct to Committed." +
                    "\n" +
                    "          II. If not successful, update the State field of the StatusEntry on this " +
                    "              DatastoreNodeKeySetEntryStruct to CommitFailed and FailureCode code to the returned " +
                    "              error. The pending change shall be applied in a subsequent Node Refresh."
            },

            Field({ name: "GroupKeySet", id: 0x0, type: "DatastoreGroupKeySetStruct", conformance: "M" })
        ),

        Command(
            {
                name: "RemoveKeySet", id: 0x2, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.3",

                details: "This command shall be used to remove a KeySet from the Joint Fabric Datastore Cluster of the " +
                    "accessing fabric." +
                    "\n" +
                    "GroupKeySetID represents the unique identifier for the KeySet to be removed from the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "Attempt to remove the IPK, which has GroupKeySetID of 0, shall fail with response CONSTRAINT_ERROR." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. If entry is not found, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure there are no Nodes using this KeySet. To do this:" +
                    "\n" +
                    "    a. Iterate through each Node Information Entry:" +
                    "\n" +
                    "      i. If the NodeKeySetList list contains an entry with the given GroupKeySetID, and the entry " +
                    "         does NOT have Status DeletePending, then return CONSTRAINT_ERROR." +
                    "\n" +
                    "  3. Remove the DatastoreGroupKeySetStruct for the given GroupKeySetID from the GroupKeySetList " +
                    "     attribute."
            },

            Field({ name: "GroupKeySetId", id: 0x0, type: "uint16", conformance: "M" })
        ),

        Command(
            {
                name: "AddGroup", id: 0x3, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.4",

                details: "This command shall be used to add a group to the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "GroupInformationEntry represents the group to be added to the Joint Fabric Datastore Cluster." +
                    "\n" +
                    "GroupCAT values shall fall within the range 1 to 65534. Attempts to add a group with a GroupCAT " +
                    "value of Administrator CAT or Anchor CAT shall fail with CONSTRAINT_ERROR." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. Ensure there are no Groups in the GroupList attribute with the given GroupID. If a match is " +
                    "     found, return CONSTRAINT_ERROR." +
                    "\n" +
                    "  2. Add the DatastoreGroupInformationEntryStruct for the Group with the given GroupID to the " +
                    "     GroupList attribute."
            },

            Field({ name: "GroupId", id: 0x0, type: "group-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x1, type: "string", conformance: "M", constraint: "max 32" }),
            Field({
                name: "GroupKeySetId", id: 0x2, type: "uint16", conformance: "M", constraint: "1 to 65534",
                quality: "X"
            }),
            Field({ name: "GroupCat", id: 0x3, type: "uint16", conformance: "M", constraint: "desc", quality: "X" }),
            Field({
                name: "GroupCatVersion", id: 0x4, type: "uint16", conformance: "M", constraint: "1 to 65534",
                quality: "X"
            }),
            Field({ name: "GroupPermission", id: 0x5, type: "DatastoreAccessControlEntryPrivilegeEnum", conformance: "M" })
        ),

        Command(
            {
                name: "UpdateGroup", id: 0x4, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.5",

                details: "This command shall be used to update a group in the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "GroupID represents the group to be updated in the Joint Fabric Datastore Cluster. NULL values for " +
                    "the additional parameters will be ignored (not updated)." +
                    "\n" +
                    "GroupCAT values shall fall within the range 1 to 65534. Attempts to update the GroupCAT on an " +
                    "existing group which has a GroupCAT value of Administrator CAT or Anchor CAT shall fail with " +
                    "CONSTRAINT_ERROR." +
                    "\n" +
                    "Attempts to set the GroupCAT to Administrator CAT or Anchor CAT shall fail with CONSTRAINT_ERROR." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. If entry is not found, return NOT_FOUND." +
                    "\n" +
                    "  2. Update the DatastoreGroupInformationEntryStruct for the Group with the given GroupID to match " +
                    "     the non-NULL fields passed in." +
                    "\n" +
                    "  3. If any fields are changed as a result of this command:" +
                    "\n" +
                    "    a. Iterate through each Node Information Entry:" +
                    "\n" +
                    "      i. If the GroupKeySetID changed:" +
                    "\n" +
                    "        I. Add a DatastoreNodeKeySetEntryStruct with the new GroupKeySetID, and Status set to " +
                    "           Pending." +
                    "\n" +
                    "        II. Add this KeySet to the Node." +
                    "\n" +
                    "  1. If successful, Set the Status to Committed for this entry in the NodeKeySetList." +
                    "\n" +
                    "  2. If not successful, Set the Status to CommitFailed and the FailureCode to the returned error. " +
                    "     The pending change shall be applied in a subsequent Node Refresh." +
                    "\n" +
                    "    A. If the NodeKeySetList list contains an entry with the previous GroupKeySetID:" +
                    "\n" +
                    "    III. Set the Status set to DeletePending." +
                    "\n" +
                    "    IV. Remove this KeySet from the Node." +
                    "\n" +
                    "  1. If successful, Remove this entry from the NodeKeySetList." +
                    "\n" +
                    "  2. If not successful, the pending change shall be applied in a subsequent Node Refresh." +
                    "\n" +
                    "ii. If the GroupCAT, GroupCATVersion or GroupPermission changed:" +
                    "\n" +
                    "  A. If the ACLList contains an entry for this Group, update the ACL List Entry in the Datastore " +
                    "     with the new values and Status Pending, update the ACL attribute on the given Node with the new " +
                    "     values. If the update succeeds, set the Status to Committed on the ACLList Entry in the " +
                    "     Datastore." +
                    "\n" +
                    "iii. If the FriendlyName changed:" +
                    "\n" +
                    "  A. Iterate through each Endpoint Information Entry:" +
                    "\n" +
                    "    I. If the GroupIDList contains an entry with the given GroupID:" +
                    "\n" +
                    "      1. Update the GroupIDList Entry in the Datastore with the new values and Status" +
                    "\n" +
                    "### Pending" +
                    "\n" +
                    "2. Update the Groups on the given Node with the new values." +
                    "\n" +
                    "  1. If the update succeeds, set the Status to Committed on the GroupIDList Entry in the Datastore." +
                    "\n" +
                    "  2. If not successful, the pending change shall be applied in a subsequent Node Refresh."
            },

            Field({ name: "GroupId", id: 0x0, type: "group-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x1, type: "string", conformance: "M", constraint: "max 32", quality: "X" }),
            Field({
                name: "GroupKeySetId", id: 0x2, type: "uint16", conformance: "M", constraint: "1 to 65535",
                quality: "X"
            }),
            Field({ name: "GroupCat", id: 0x3, type: "uint16", conformance: "M", constraint: "desc", quality: "X" }),
            Field({
                name: "GroupCatVersion", id: 0x4, type: "uint16", conformance: "M", constraint: "1 to 65535",
                quality: "X"
            }),
            Field({
                name: "GroupPermission", id: 0x5, type: "DatastoreAccessControlEntryPrivilegeEnum",
                conformance: "M", constraint: "x"
            })
        ),

        Command(
            {
                name: "RemoveGroup", id: 0x5, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.6",

                details: "This command shall be used to remove a group from the Joint Fabric Datastore Cluster of the " +
                    "accessing fabric." +
                    "\n" +
                    "GroupID represents the unique identifier for the group to be removed from the Joint Fabric Datastore " +
                    "Cluster." +
                    "\n" +
                    "Attempts to remove a group with GroupCAT value set to Administrator CAT or Anchor CAT shall fail " +
                    "with CONSTRAINT_ERROR." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. If entry is not found, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure there are no Nodes in this group. To do this:" +
                    "\n" +
                    "    a. Iterate through each Node Information Entry:" +
                    "\n" +
                    "      i. If the GroupIDList contains an entry with the given GroupID, and the entry does NOT have " +
                    "         Status DeletePending, then return CONSTRAINT_ERROR." +
                    "\n" +
                    "  3. Remove the DatastoreGroupInformationEntryStruct for the Group with the given GroupID from the " +
                    "     GroupList attribute."
            },

            Field({ name: "GroupId", id: 0x0, type: "group-id", conformance: "M" })
        ),

        Command(
            {
                name: "AddAdmin", id: 0x6, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.7",
                details: "This command shall be used to add an admin to the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "NodeID, FriendlyName, VendorID and ICAC represent the admin to be added to the Joint Fabric " +
                    "Datastore Cluster."
            },

            Field({ name: "NodeId", id: 0x1, type: "node-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x2, type: "string", conformance: "M", constraint: "max 32" }),
            Field({ name: "VendorId", id: 0x3, type: "vendor-id", conformance: "M" }),
            Field({ name: "Icac", id: 0x4, type: "octstr", conformance: "M", constraint: "max 400" })
        ),

        Command(
            {
                name: "UpdateAdmin", id: 0x7, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.8",

                details: "This command shall be used to update an admin in the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "NodeID represents the admin to be updated in the Joint Fabric Datastore Cluster. NULL values for the " +
                    "additional parameters will be ignored (not updated)." +
                    "\n" +
                    "If entry is not found, return NOT_FOUND."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M", quality: "X" }),
            Field({ name: "FriendlyName", id: 0x1, type: "string", conformance: "M", constraint: "max 32", quality: "X" }),
            Field({ name: "Icac", id: 0x2, type: "octstr", conformance: "M", constraint: "max 400", quality: "X" })
        ),

        Command(
            {
                name: "RemoveAdmin", id: 0x8, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.9",

                details: "This command shall be used to remove an admin from the Joint Fabric Datastore Cluster of the " +
                    "accessing fabric." +
                    "\n" +
                    "NodeID represents the unique identifier for the admin to be removed from the Joint Fabric Datastore " +
                    "Cluster." +
                    "\n" +
                    "If entry is not found, return NOT_FOUND."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" })
        ),

        Command(
            {
                name: "AddPendingNode", id: 0x9, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.10",

                details: "The command shall be used to add a node to the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "NodeID represents the node to be added to the Joint Fabric Datastore Cluster. Upon receipt of this " +
                    "command, the Datastore shall:" +
                    "\n" +
                    "  1. Update CommissioningStatusEntry of the Node Information Entry with the given NodeID to Pending." +
                    "\n" +
                    "If a Node Information Entry exists for the given NodeID, this command shall return " +
                    "INVALID_CONSTRAINT."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x1, type: "string", conformance: "M", constraint: "max 32" })
        ),

        Command(
            {
                name: "RefreshNode", id: 0xa, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.11",

                details: "The command shall be used to request that Datastore information relating to a Node of the accessing " +
                    "fabric is refreshed." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that a Node Information Entry exists for the given NodeID, and if not, return " +
                    "     NOT_FOUND." +
                    "\n" +
                    "  2. Update the CommissioningStatusEntry for the Node Information Entry to Pending." +
                    "\n" +
                    "  3. Ensure the Endpoint List for the Node Information Entry with the given NodeID matches Endpoint " +
                    "     list on the given Node. This involves the following steps:" +
                    "\n" +
                    "    a. Read the PartsList of the Descriptor cluster from the Node." +
                    "\n" +
                    "    b. For each Endpoint Information Entry in the Endpoint List of the Node Information Entry that " +
                    "       does not match an Endpoint ID in the PartsList, remove the Endpoint Information Entry." +
                    "\n" +
                    "    c. For each Endpoint Information Entry in the Endpoint List of the Node Information Entry that " +
                    "       matches an Endpoint ID in the PartsList:" +
                    "\n" +
                    "      i. Check that each entry in Node’s Group List occurs in the GroupIDList of the Endpoint " +
                    "         Information Entry." +
                    "\n" +
                    "        A. Add any missing entries to the GroupIDList of the Endpoint Information Entry." +
                    "\n" +
                    "        B. For any entries in the GroupIDList with Status of Pending:" +
                    "\n" +
                    "          I. Add the corresponding change to the Node’s Group List." +
                    "\n" +
                    "  1. If successful, mark the Status to Committed." +
                    "\n" +
                    "  2. If not successful, update the Status to CommitFailed and the FailureCode to the returned error. " +
                    "     The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "C. For any entries in the GroupIDList with Status of DeletePending:" +
                    "\n" +
                    "  1. If successful, remove the corresponding entry from the Node’s Group List." +
                    "\n" +
                    "  2. If not successful, update the Status to CommitFailed and the FailureCode to the returned error. " +
                    "     The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "D. For any entries in the GroupIDList with Status of CommitFailure:" +
                    "\n" +
                    "  I. A CommitFailure with an unrecoverable FailureCode shall be handled by removing the entry from " +
                    "     the GroupIDList." +
                    "\n" +
                    "  II. A CommitFailure with a recoverable FailureCode (i.e. TIMEOUT, BUSY) shall be handle in a " +
                    "      subsequent Node Refresh." +
                    "\n" +
                    "ii. Check that each entry in Node’s Binding List occurs in the BindingList of the Endpoint " +
                    "Information Entry." +
                    "\n" +
                    "  A. Add any missing entries to the BindingList of the Endpoint Information Entry." +
                    "\n" +
                    "  B. For any entries in the BindingList with Status of Pending:" +
                    "\n" +
                    "    I. Add the corresponding change to the Node’s Binding List." +
                    "\n" +
                    "      1. If successful, mark the Status to Committed." +
                    "\n" +
                    "      2. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "         error. The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "  C. For any entries in the BindingList with Status of DeletePending:" +
                    "\n" +
                    "    1. If successful, remove the corresponding entry from the Node’s BindingList." +
                    "\n" +
                    "    2. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "       error. The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "  D. For any entries in the BindingList with Status of CommitFailure:" +
                    "\n" +
                    "    I. A CommitFailure with an unrecoverable FailureCode shall be handled by removing the entry from " +
                    "       the BindingList." +
                    "\n" +
                    "    II. A CommitFailure with a recoverable FailureCode (i.e. TIMEOUT, BUSY) shall be handle in a " +
                    "        subsequent Node Refresh." +
                    "\n" +
                    "4. Ensure the GroupKeySetList for the Node Information Entry with the given NodeID matches the Group " +
                    "Keys on the given Node. This involves the following steps:" +
                    "\n" +
                    "  a. Read the Group Keys from the Node." +
                    "\n" +
                    "  b. For each GroupKeySetEntry in the GroupKeySetList of the Node Information Entry with a Pending " +
                    "     Status:" +
                    "\n" +
                    "    i. Add the corresponding DatastoreGroupKeySetStruct to the Node’s Group Key list." +
                    "\n" +
                    "      A. If successful, mark the Status to Committed." +
                    "\n" +
                    "      B. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "         error. The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "  c. For each GroupKeySetEntry in the GroupKeySetList of the Node Information Entry with a " +
                    "     CommitFailure Status:" +
                    "\n" +
                    "    i. A CommitFailure with an unrecoverable FailureCode shall be handled by removing the entry from " +
                    "       the GroupKeySetList." +
                    "\n" +
                    "    ii. A CommitFailure with a recoverable FailureCode (i.e. TIMEOUT, BUSY) shall be handle in a " +
                    "        subsequent Node Refresh." +
                    "\n" +
                    "  d. All remaining entries in the GroupKeySetList should be replaced by the remaining entries on the " +
                    "     Node." +
                    "\n" +
                    "5. Ensure the ACLList for the Node Information Entry with the given NodeID matches the ACL attribute " +
                    "on the given Node. This involves the following steps:" +
                    "\n" +
                    "  a. Read the ACL attribute on the Node." +
                    "\n" +
                    "  b. For each DatastoreACLEntryStruct in the ACLList of the Node Information Entry with a Pending " +
                    "     Status:" +
                    "\n" +
                    "    i. Add the corresponding DatastoreACLEntryStruct to the Node’s ACL attribute." +
                    "\n" +
                    "      A. If successful, mark the Status to Committed." +
                    "\n" +
                    "      B. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "         error. The error shall be handled in a subsequent Node Refresh." +
                    "\n" +
                    "  c. For each DatastoreACLEntryStruct in the ACLList of the Node Information Entry with a " +
                    "     CommitFailure Status:" +
                    "\n" +
                    "    i. A CommitFailure with an unrecoverable FailureCode (i.e. RESOURCE_EXHAUSTED, CONSTRAINT_ERROR) " +
                    "       shall be handled by removing the entry from the ACLList." +
                    "\n" +
                    "    ii. A CommitFailure with a recoverable FailureCode (i.e. TIMEOUT, BUSY) shall be handle in a " +
                    "        subsequent Node Refresh." +
                    "\n" +
                    "  d. All remaining entries in the ACLList should be replaced by the remaining entries on the Node." +
                    "\n" +
                    "6. Update the CommissioningStatusEntry for the Node Information Entry to Committed."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" })
        ),

        Command(
            {
                name: "UpdateNode", id: 0xb, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.12",

                details: "The command shall be used to update the friendly name for a node in the Joint Fabric Datastore " +
                    "Cluster of the accessing fabric." +
                    "\n" +
                    "NodeID represents the node to be updated in the Joint Fabric Datastore Cluster." +
                    "\n" +
                    "If a Node Information Entry does not exist for the given NodeID, this command shall return " +
                    "NOT_FOUND."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x1, type: "string", conformance: "M", constraint: "max 32" })
        ),

        Command(
            {
                name: "RemoveNode", id: 0xc, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.13",

                details: "This command shall be used to remove a node from the Joint Fabric Datastore Cluster of the accessing " +
                    "fabric." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to be removed from the Joint Fabric Datastore " +
                    "Cluster." +
                    "\n" +
                    "If a Node Information Entry does not exist for the given NodeID, this command shall return " +
                    "NOT_FOUND."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" })
        ),

        Command(
            {
                name: "UpdateEndpointForNode", id: 0xd, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.14",

                details: "This command shall be used to update the state of an endpoint for a node in the Joint Fabric " +
                    "Datastore Cluster of the accessing fabric." +
                    "\n" +
                    "EndpointID represents the unique identifier for the endpoint to be updated in the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the endpoint belongs." +
                    "\n" +
                    "If an Endpoint Information Entry does not exist for the given NodeID and EndpointID, this command " +
                    "shall return NOT_FOUND."
            },

            Field({ name: "EndpointId", id: 0x0, type: "endpoint-no", conformance: "M" }),
            Field({ name: "NodeId", id: 0x1, type: "node-id", conformance: "M" }),
            Field({ name: "FriendlyName", id: 0x2, type: "string", conformance: "M", constraint: "max 32" })
        ),

        Command(
            {
                name: "AddGroupIdToEndpointForNode", id: 0xe, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.24.7.15",

                details: "This command shall be used to add a Group ID to an endpoint for a node in the Joint Fabric Datastore " +
                    "Cluster of the accessing fabric." +
                    "\n" +
                    "GroupID represents the unique identifier for the group to be added to the endpoint." +
                    "\n" +
                    "EndpointID represents the unique identifier for the endpoint to be updated in the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the endpoint belongs. Upon receipt of " +
                    "this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that an Endpoint Information Entry exists for the given NodeID and EndpointID, and if " +
                    "     not, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the Group Key List for the Node Information Entry with the given NodeID includes the " +
                    "     KeySet for the given Group ID. If it does not:" +
                    "\n" +
                    "    a. Add an entry for the KeySet of the given Group ID to the Group Key List for the Node. The new " +
                    "       entry’s status shall be set to Pending." +
                    "\n" +
                    "    b. Add a Group Key Entry for this KeySet to the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, update the new KeySet entry in the Datastore to Committed." +
                    "\n" +
                    "      ii. If not successful, the pending change shall be applied in a subsequent Node Refresh." +
                    "\n" +
                    "  3. Ensure the Group List for the Endpoint Information Entry with the given NodeID and EndpointID " +
                    "     includes an entry for the given Group. If it does not:" +
                    "\n" +
                    "    a. Add a Group entry for the given Group ID to the Group List for the Endpoint and Node. The new " +
                    "       entry’s status shall be set to Pending." +
                    "\n" +
                    "    b. Add this Group entry to the given Endpoint ID on the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, update the new Group entry in the Datastore to Committed." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "EndpointId", id: 0x1, type: "endpoint-no", conformance: "M" }),
            Field({ name: "GroupId", id: 0x2, type: "group-id", conformance: "M" })
        ),

        Command(
            {
                name: "RemoveGroupIdFromEndpointForNode", id: 0xf, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.24.7.16",

                details: "This command shall be used to remove a Group ID from an endpoint for a node in the Joint Fabric " +
                    "Datastore Cluster of the accessing fabric." +
                    "\n" +
                    "GroupID represents the unique identifier for the group to be removed from the endpoint." +
                    "\n" +
                    "EndpointID represents the unique identifier for the endpoint to be updated in the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the endpoint belongs. Upon receipt of " +
                    "this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that an Endpoint Information Entry exists for the given NodeID and EndpointID, and if " +
                    "     not, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the Group List for the Endpoint Information Entry with the given NodeID and EndpointID " +
                    "     does not include an entry for the given Group. If it does:" +
                    "\n" +
                    "    a. Update the status to DeletePending of the Group entry for the given Group ID in the Group " +
                    "       List." +
                    "\n" +
                    "    b. Remove this Group entry for the given Endpoint ID on the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, remove the Group entry for the given Group ID in the Group List for this " +
                    "         NodeID and EndpointID in the Datastore." +
                    "\n" +
                    "      ii. If not successful, the pending change shall be applied in a subsequent Node Refresh." +
                    "\n" +
                    "  3. Ensure the Group Key List for the Node Information Entry with the given NodeID does not include " +
                    "     the KeySet for the given Group ID. If it does:" +
                    "\n" +
                    "    a. Update the status to DeletePending for the entry for the KeySet of the given Group ID in the " +
                    "       Node Group Key List." +
                    "\n" +
                    "    b. Remove the Group Key Entry for this KeySet from the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, remove the KeySet entry for the given Node ID." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "EndpointId", id: 0x1, type: "endpoint-no", conformance: "M" }),
            Field({ name: "GroupId", id: 0x2, type: "group-id", conformance: "M" })
        ),

        Command(
            {
                name: "AddBindingToEndpointForNode", id: 0x10, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.24.7.17",

                details: "This command shall be used to add a binding to an endpoint for a node in the Joint Fabric Datastore " +
                    "Cluster of the accessing fabric." +
                    "\n" +
                    "Binding represents the binding to be added to the endpoint." +
                    "\n" +
                    "EndpointID represents the unique identifier for the endpoint to be updated in the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the endpoint belongs. Upon receipt of " +
                    "this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that an Endpoint Information Entry exists for the given NodeID and EndpointID, and if " +
                    "     not, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the Binding List for the Node Information Entry with the given NodeID includes the given " +
                    "     Binding. If it does not:" +
                    "\n" +
                    "    a. Add the Binding to the Binding List for the Node Information Entry for the given NodeID. The " +
                    "       new entry’s status shall be set to Pending." +
                    "\n" +
                    "    b. Add this Binding to the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, update the new Binding in the Datastore to Committed." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "EndpointId", id: 0x1, type: "endpoint-no", conformance: "M" }),
            Field({ name: "Binding", id: 0x2, type: "DatastoreBindingTargetStruct", conformance: "M" })
        ),

        Command(
            {
                name: "RemoveBindingFromEndpointForNode", id: 0x11, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.24.7.18",

                details: "This command shall be used to remove a binding from an endpoint for a node in the Joint Fabric " +
                    "Datastore Cluster of the accessing fabric." +
                    "\n" +
                    "ListID represents the unique identifier for the binding entry in the Datastore’s EndpointBindingList " +
                    "attribute to be removed from the endpoint." +
                    "\n" +
                    "EndpointID represents the unique identifier for the endpoint to be updated in the Joint Fabric " +
                    "Datastore Cluster." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the endpoint belongs. Upon receipt of " +
                    "this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that an Endpoint Information Entry exists for the given NodeID and EndpointID, and if " +
                    "     not, return NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the Binding List for the Node Information Entry with the given NodeID does not include " +
                    "     an entry with the given ListID. If it does:" +
                    "\n" +
                    "    a. Update the status to DeletePending for the given Binding in the Binding List." +
                    "\n" +
                    "    b. Remove this Binding from the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, remove the given Binding from the Binding List." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "ListId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "EndpointId", id: 0x1, type: "endpoint-no", conformance: "M" }),
            Field({ name: "NodeId", id: 0x2, type: "node-id", conformance: "M" })
        ),

        Command(
            {
                name: "AddAclToNode", id: 0x12, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.19",

                details: "This command shall be used to add an ACL to a node in the Joint Fabric Datastore Cluster of the " +
                    "accessing fabric." +
                    "\n" +
                    "NodeID represents the unique identifier for the node to which the ACL is to be added. ACLEntry " +
                    "represents the ACL to be added to the Joint Fabric Datastore Cluster." +
                    "\n" +
                    "Upon receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that a Node Information Entry exists for the given NodeID, and if not, return " +
                    "     NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the ACL List for the given NodeID includes the given ACLEntry. If it does not:" +
                    "\n" +
                    "    a. Add the ACLEntry to the ACL List for the given NodeID. The new entry’s status shall be set to " +
                    "       Pending." +
                    "\n" +
                    "    b. Add this ACLEntry to the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, update the new ACLEntry in the Datastore to Committed." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "NodeId", id: 0x0, type: "node-id", conformance: "M" }),
            Field({ name: "AclEntry", id: 0x1, type: "DatastoreAccessControlEntryStruct", conformance: "M" })
        ),

        Command(
            {
                name: "RemoveAclFromNode", id: 0x13, access: "A", conformance: "P, M", direction: "request",
                response: "status", xref: "core§11.24.7.20",

                details: "This command shall be used to remove an ACL from a node in the Joint Fabric Datastore Cluster of the " +
                    "accessing fabric." +
                    "\n" +
                    "ListID represents the unique identifier for the DatastoreACLEntryStruct to be removed from the " +
                    "Datastore’s list of DatastoreACLEntry." +
                    "\n" +
                    "NodeID represents the unique identifier for the node from which the ACL is to be removed. Upon " +
                    "receipt of this command, the Datastore shall:" +
                    "\n" +
                    "  1. Confirm that a Node Information Entry exists for the given NodeID, and if not, return " +
                    "     NOT_FOUND." +
                    "\n" +
                    "  2. Ensure the ACL List for the given NodeID does not include the given ACLEntry. If it does:" +
                    "\n" +
                    "    a. Update the status to DeletePending for the given ACLEntry in the ACL List." +
                    "\n" +
                    "    b. Remove this ACLEntry from the given Node ID." +
                    "\n" +
                    "      i. If this succeeds, remove the given ACLEntry from the Node ACL List." +
                    "\n" +
                    "      ii. If not successful, update the Status to CommitFailed and the FailureCode to the returned " +
                    "          error. The error shall be handled in a subsequent Node Refresh."
            },

            Field({ name: "ListId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "NodeId", id: 0x1, type: "node-id", conformance: "M" })
        ),

        Datatype(
            { name: "DatastoreStateEnum", type: "enum8", xref: "core§11.24.5.1" },
            Field({ name: "Pending", id: 0x0, conformance: "M", description: "Target device operation is pending" }),
            Field({ name: "Committed", id: 0x1, conformance: "M", description: "Target device operation has been committed" }),
            Field({
                name: "DeletePending", id: 0x2, conformance: "M",
                description: "Target device delete operation is pending"
            }),
            Field({ name: "CommitFailed", id: 0x3, conformance: "M", description: "Target device operation has failed" })
        ),

        Datatype(
            { name: "DatastoreStatusEntryStruct", type: "struct", xref: "core§11.24.5.2" },
            Field({
                name: "State", id: 0x0, type: "DatastoreStateEnum", access: "R V", conformance: "M", default: 0,
                xref: "core§11.24.5.2.1",
                details: "This field shall contain the current state of the target device operation."
            }),
            Field({
                name: "UpdateTimestamp", id: 0x1, type: "epoch-s", access: "R V", conformance: "M",
                xref: "core§11.24.5.2.2",
                details: "This field shall contain the timestamp of the last update."
            }),

            Field({
                name: "FailureCode", id: 0x2, type: "status", access: "R V", conformance: "M", default: 0,
                xref: "core§11.24.5.2.3",
                details: "This field shall contain the StatusCode of the last failed operation where the State field is set to " +
                    "CommitFailure."
            })
        ),

        Datatype(
            { name: "DatastoreNodeKeySetEntryStruct", type: "struct", xref: "core§11.24.5.3" },
            Field({
                name: "NodeId", id: 0x0, type: "node-id", access: "R V", conformance: "M", xref: "core§11.24.5.3.1",
                details: "The unique identifier for the node."
            }),
            Field({ name: "GroupKeySetId", id: 0x1, type: "uint16", access: "R V", conformance: "M" }),
            Field({
                name: "StatusEntry", id: 0x2, type: "DatastoreStatusEntryStruct", access: "R V", conformance: "M",
                xref: "core§11.24.5.3.3",
                details: "Indicates whether entry in this list is pending, committed, delete-pending, or commit-failed."
            })
        ),

        Datatype(
            { name: "DatastoreAccessControlEntryPrivilegeEnum", type: "enum8", xref: "core§11.24.5.4" },
            Field({
                name: "View", id: 0x1, conformance: "M",
                description: "Can read and observe all (except Access Control Cluster)"
            }),
            Field({ name: "ProxyView", id: 0x2, conformance: "D" }),
            Field({
                name: "Operate", id: 0x3, conformance: "M",
                description: "View privileges, and can perform the primary function of this Node (except Access Control Cluster)"
            }),
            Field({
                name: "Manage", id: 0x4, conformance: "M",
                description: "Operate privileges, and can modify persistent configuration of this Node (except Access Control Cluster)"
            }),
            Field({
                name: "Administer", id: 0x5, conformance: "M",
                description: "Manage privileges, and can observe and modify the Access Control Cluster"
            })
        ),

        Datatype(
            { name: "DatastoreGroupInformationEntryStruct", type: "struct", xref: "core§11.24.5.5" },
            Field({
                name: "GroupId", id: 0x0, type: "uint64", access: "R V", conformance: "M", xref: "core§11.24.5.5.1",
                details: "The unique identifier for the group."
            }),
            Field({
                name: "FriendlyName", id: 0x1, type: "string", access: "R V", conformance: "M",
                constraint: "max 32", xref: "core§11.24.5.5.2",
                details: "The friendly name for the group."
            }),

            Field({
                name: "GroupKeySetId", id: 0x2, type: "uint16", access: "R V", conformance: "M",
                constraint: "1 to 65534", quality: "X", xref: "core§11.24.5.5.3",

                details: "The unique identifier for the group key set." +
                    "\n" +
                    "This value may be null when multicast communication is not used for the group. When GroupPermission " +
                    "is Admin or Manage, this value shall be null." +
                    "\n" +
                    "A value of 0 is not allowed since this value is reserved for IPK and the group entry for this value " +
                    "is not managed by the Datastore."
            }),

            Field({
                name: "GroupCat", id: 0x3, type: "uint16", access: "R V", conformance: "M", constraint: "desc",
                quality: "X", xref: "core§11.24.5.5.4",

                details: "CAT value for this group. This is used for control of individual members of a group (non-broadcast " +
                    "commands)." +
                    "\n" +
                    "Allowable values include the range 0x0000 to 0xEFFF, and the Administrator CAT and Anchor CAT " +
                    "values." +
                    "\n" +
                    "This value may be null when unicast communication is not used for the group."
            }),

            Field({
                name: "GroupCatVersion", id: 0x4, type: "uint16", access: "R V", conformance: "M",
                constraint: "1 to 65534", quality: "X", xref: "core§11.24.5.5.5",
                details: "Current version number for this CAT." +
                    "\n" +
                    "This value shall be null when GroupCAT value is null."
            }),

            Field({
                name: "GroupPermission", id: 0x5, type: "DatastoreAccessControlEntryPrivilegeEnum", access: "R V",
                conformance: "M", xref: "core§11.24.5.5.6",
                details: "The permission level associated with ACL entries for this group. There should be only one " +
                    "Administrator group per fabric, and at most one Manage group per Ecosystem (Vendor Entry)."
            })
        ),

        Datatype(
            {
                name: "DatastoreBindingTargetStruct", type: "struct", xref: "core§11.24.5.6",
                details: "The DatastoreBindingTargetStruct represents a Binding on a specific Node (identified by the " +
                    "DatastoreEndpointBindingEntryStruct) which is managed by the Datastore. Only bindings on a specific " +
                    "Node that are fabric-scoped to the Joint Fabric are managed by the Datastore. As a result, " +
                    "references to nodes and groups are specific to the Joint Fabric."
            },

            Field({
                name: "Node", id: 0x1, type: "node-id", conformance: "Endpoint", xref: "core§11.24.5.6.1",
                details: "This field is the binding’s remote target node ID. If the Endpoint field is present, this field " +
                    "shall be present."
            }),

            Field({
                name: "Group", id: 0x2, type: "group-id", conformance: "!Endpoint", constraint: "min 1",
                xref: "core§11.24.5.6.2",
                details: "This field is the binding’s target group ID that represents remote endpoints. If the Endpoint field " +
                    "is present, this field shall NOT be present."
            }),

            Field({
                name: "Endpoint", id: 0x3, type: "endpoint-no", conformance: "!Group", xref: "core§11.24.5.6.3",
                details: "This field is the binding’s remote endpoint that the local endpoint is bound to. If the Group field " +
                    "is present, this field shall NOT be present."
            }),

            Field({
                name: "Cluster", id: 0x4, type: "cluster-id", conformance: "O", xref: "core§11.24.5.6.4",
                details: "This field is the binding’s cluster ID (client & server) on the local and target endpoint(s). If " +
                    "this field is present, the client cluster shall also exist on this endpoint (with this Binding " +
                    "cluster). If this field is present, the target shall be this cluster on the target endpoint(s)."
            })
        ),

        Datatype(
            { name: "DatastoreEndpointBindingEntryStruct", type: "struct", xref: "core§11.24.5.7" },
            Field({
                name: "NodeId", id: 0x0, type: "node-id", access: "R V", conformance: "M", xref: "core§11.24.5.7.1",
                details: "The unique identifier for the node."
            }),
            Field({
                name: "EndpointId", id: 0x1, type: "endpoint-no", access: "R V", conformance: "M",
                xref: "core§11.24.5.7.2",
                details: "The unique identifier for the endpoint."
            }),

            Field({
                name: "ListId", id: 0x2, type: "uint16", access: "R V", conformance: "M", xref: "core§11.24.5.7.3",
                details: "The unique identifier for the entry in the Datastore’s EndpointBindingList attribute, which is a " +
                    "list of DatastoreEndpointBindingEntryStruct." +
                    "\n" +
                    "This field is used to uniquely identify an entry in the EndpointBindingList attribute for the " +
                    "purpose of deletion (RemoveBindingFromEndpointForNode Command)."
            }),

            Field({
                name: "Binding", id: 0x3, type: "DatastoreBindingTargetStruct", access: "R V", conformance: "M",
                constraint: "desc", xref: "core§11.24.5.7.4",
                details: "The binding target structure."
            }),
            Field({
                name: "StatusEntry", id: 0x4, type: "DatastoreStatusEntryStruct", access: "R V", conformance: "M",
                xref: "core§11.24.5.7.5",
                details: "Indicates whether entry in this list is pending, committed, delete-pending, or commit-failed."
            })
        ),

        Datatype(
            { name: "DatastoreEndpointGroupIDEntryStruct", type: "struct", xref: "core§11.24.5.8" },
            Field({
                name: "NodeId", id: 0x0, type: "node-id", access: "R V", conformance: "M", xref: "core§11.24.5.8.1",
                details: "The unique identifier for the node."
            }),
            Field({
                name: "EndpointId", id: 0x1, type: "endpoint-no", access: "R V", conformance: "M",
                xref: "core§11.24.5.8.2",
                details: "The unique identifier for the endpoint."
            }),
            Field({
                name: "GroupId", id: 0x2, type: "group-id", access: "R V", conformance: "M",
                xref: "core§11.24.5.8.3",
                details: "The unique identifier for the group."
            }),
            Field({
                name: "StatusEntry", id: 0x3, type: "DatastoreStatusEntryStruct", access: "R V", conformance: "M",
                xref: "core§11.24.5.8.4",
                details: "Indicates whether entry in this list is pending, committed, delete-pending, or commit-failed."
            })
        ),

        Datatype(
            {
                name: "DatastoreEndpointEntryStruct", type: "struct", xref: "core§11.24.5.9",
                details: "The DatastoreEndpointEntryStruct represents an Endpoint on a specific Node which is managed by the " +
                    "Datastore. Only Nodes on the Joint Fabric are managed by the Datastore. As a result, references to " +
                    "NodeID are specific to the Joint Fabric."
            },

            Field({
                name: "EndpointId", id: 0x0, type: "endpoint-no", access: "R V", conformance: "M",
                xref: "core§11.24.5.9.1",
                details: "The unique identifier for the endpoint."
            }),
            Field({
                name: "NodeId", id: 0x1, type: "node-id", access: "R V", conformance: "M", xref: "core§11.24.5.9.2",
                details: "The unique identifier for the node."
            }),

            Field({
                name: "FriendlyName", id: 0x2, type: "string", access: "R V", conformance: "M",
                constraint: "max 32", xref: "core§11.24.5.9.3",
                details: "Friendly name for this endpoint which is propagated to nodes. Any changes to Friendly Name or Group " +
                    "Id List (add/remove entry) must follow the pending→committed workflow with current state reflected " +
                    "in the Status Entry."
            }),

            Field({
                name: "StatusEntry", id: 0x3, type: "DatastoreStatusEntryStruct", access: "R V", conformance: "M",
                xref: "core§11.24.5.9.4",
                details: "Indicates whether changes to Friendly Name are pending, committed, or commit-failed."
            })
        ),

        Datatype(
            { name: "DatastoreAccessControlEntryAuthModeEnum", type: "enum8", xref: "core§11.24.5.10" },
            Field({ name: "Pase", id: 0x1, conformance: "M", description: "Passcode authenticated session" }),
            Field({ name: "Case", id: 0x2, conformance: "M", description: "Certificate authenticated session" }),
            Field({ name: "Group", id: 0x3, conformance: "M", description: "Group authenticated session" })
        ),

        Datatype(
            { name: "DatastoreAccessControlTargetStruct", type: "struct", xref: "core§11.24.5.11" },
            Field({ name: "Cluster", id: 0x0, type: "cluster-id", conformance: "M", quality: "X" }),
            Field({ name: "Endpoint", id: 0x1, type: "endpoint-no", conformance: "M", quality: "X" }),
            Field({ name: "DeviceType", id: 0x2, type: "devtype-id", conformance: "M", quality: "X" })
        ),

        Datatype(
            {
                name: "DatastoreAccessControlEntryStruct", type: "struct", xref: "core§11.24.5.12",
                details: "The DatastoreAccessControlEntryStruct represents an ACL on a specific Node (identified by the " +
                    "DatastoreACLEntryStruct) which is managed by the Datastore. Only ACLs on a specific Node that are " +
                    "fabric-scoped to the Joint Fabric are managed by the Datastore. As a result, references to nodes and " +
                    "groups are specific to the Joint Fabric."
            },

            Field({ name: "Privilege", id: 0x1, type: "DatastoreAccessControlEntryPrivilegeEnum", conformance: "M" }),
            Field({ name: "AuthMode", id: 0x2, type: "DatastoreAccessControlEntryAuthModeEnum", conformance: "M" }),

            Field(
                {
                    name: "Subjects", id: 0x3, type: "list", conformance: "M",
                    constraint: "max subjectsPerAccessControlEntry", quality: "X"
                },
                Field({ name: "entry", type: "subject-id" })
            ),

            Field(
                {
                    name: "Targets", id: 0x4, type: "list", conformance: "M",
                    constraint: "max targetsPerAccessControlEntry", quality: "X"
                },
                Field({ name: "entry", type: "DatastoreAccessControlTargetStruct" })
            )
        ),

        Datatype(
            {
                name: "DatastoreACLEntryStruct", type: "struct", xref: "core§11.24.5.13",
                details: "The DatastoreACLEntryStruct is a holder for an ACL (DatastoreAccessControlEntryStruct) on a specific " +
                    "Node which is managed by the Datastore. Only ACLs on a specific Node that are fabric-scoped to the " +
                    "Joint Fabric are managed by the Datastore. As a result, references to nodes and groups are specific " +
                    "to the Joint Fabric."
            },

            Field({
                name: "NodeId", id: 0x0, type: "node-id", access: "R V", conformance: "M",
                xref: "core§11.24.5.13.1",
                details: "The unique identifier for the node."
            }),
            Field({
                name: "ListId", id: 0x1, type: "uint16", access: "R V", conformance: "M", xref: "core§11.24.5.13.2",
                details: "The unique identifier for the ACL entry in the Datastore’s list of DatastoreACLEntry."
            }),
            Field({
                name: "AclEntry", id: 0x2, type: "DatastoreAccessControlEntryStruct", access: "R V",
                conformance: "M", xref: "core§11.24.5.13.3",
                details: "The Access Control Entry structure."
            }),
            Field({
                name: "StatusEntry", id: 0x3, type: "DatastoreStatusEntryStruct", access: "R V", conformance: "M",
                xref: "core§11.24.5.13.4",
                details: "Indicates whether entry in this list is pending, committed, delete-pending, or commit-failed."
            })
        ),

        Datatype(
            { name: "DatastoreNodeInformationEntryStruct", type: "struct", xref: "core§11.24.5.14" },
            Field({
                name: "NodeId", id: 0x1, type: "node-id", access: "R V", conformance: "M",
                xref: "core§11.24.5.14.1",
                details: "The unique identifier for the node."
            }),
            Field({
                name: "FriendlyName", id: 0x2, type: "string", access: "R V", conformance: "M",
                constraint: "max 32", xref: "core§11.24.5.14.2",
                details: "Friendly name for this node which is not propagated to nodes."
            }),

            Field({
                name: "CommissioningStatusEntry", id: 0x3, type: "DatastoreStatusEntryStruct", access: "R V",
                conformance: "M", xref: "core§11.24.5.14.3",
                details: "Set to Pending prior to completing commissioning, set to Committed after commissioning complete is " +
                    "successful, or set to CommitFailed if commissioning failed with the FailureCode Field set to the " +
                    "error."
            })
        ),

        Datatype(
            { name: "DatastoreAdministratorInformationEntryStruct", type: "struct", xref: "core§11.24.5.15" },
            Field({
                name: "NodeId", id: 0x1, type: "node-id", access: "R V", conformance: "M",
                xref: "core§11.24.5.15.1",
                details: "The unique identifier for the node."
            }),
            Field({
                name: "FriendlyName", id: 0x2, type: "string", access: "R V", conformance: "M",
                constraint: "max 32", xref: "core§11.24.5.15.2",
                details: "Friendly name for this node which is not propagated to nodes."
            }),
            Field({
                name: "VendorId", id: 0x3, type: "vendor-id", access: "R V", conformance: "M",
                xref: "core§11.24.5.15.3",
                details: "The Vendor ID for the node."
            }),
            Field({
                name: "Icac", id: 0x4, type: "octstr", access: "R V", conformance: "M", constraint: "max 400",
                xref: "core§11.24.5.15.4",
                details: "The ICAC used to issue the NOC."
            })
        ),

        Datatype(
            { name: "DatastoreGroupKeySecurityPolicyEnum", type: "enum8", xref: "core§11.24.5.16" },
            Field({
                name: "TrustFirst", id: 0x0, conformance: "M",
                description: "Message counter synchronization using trust-first"
            })
        ),

        Datatype(
            { name: "DatastoreGroupKeyMulticastPolicyEnum", type: "enum8", xref: "core§11.24.5.17" },
            Field({
                name: "PerGroupId", id: 0x0, conformance: "M",
                description: "Indicates filtering of multicast messages for a specific Group ID"
            }),
            Field({
                name: "AllNodes", id: 0x1, conformance: "M",
                description: "Indicates not filtering of multicast messages"
            })
        ),

        Datatype(
            { name: "DatastoreGroupKeySetStruct", type: "struct", xref: "core§11.24.5.18" },
            Field({ name: "GroupKeySetId", id: 0x0, type: "uint16", conformance: "M" }),
            Field({ name: "GroupKeySecurityPolicy", id: 0x1, type: "DatastoreGroupKeySecurityPolicyEnum", conformance: "M" }),
            Field({ name: "EpochKey0", id: 0x2, type: "octstr", conformance: "M", constraint: "16", quality: "X" }),
            Field({ name: "EpochStartTime0", id: 0x3, type: "epoch-us", conformance: "M", quality: "X" }),
            Field({ name: "EpochKey1", id: 0x4, type: "octstr", conformance: "M", constraint: "16", quality: "X" }),
            Field({ name: "EpochStartTime1", id: 0x5, type: "epoch-us", conformance: "M", quality: "X" }),
            Field({ name: "EpochKey2", id: 0x6, type: "octstr", conformance: "M", constraint: "16", quality: "X" }),
            Field({ name: "EpochStartTime2", id: 0x7, type: "epoch-us", conformance: "M", quality: "X" }),
            Field({
                name: "GroupKeyMulticastPolicy", id: 0x8, type: "DatastoreGroupKeyMulticastPolicyEnum",
                conformance: "P, M"
            })
        )
    ),

    Cluster(
        {
            name: "JointFabricAdministrator", id: 0x753, classification: "node", pics: "JFPKI",
            xref: "core§11.25",
            details: "An instance of the Joint Fabric Administrator Cluster only applies to Joint Fabric Administrator " +
                "nodes fulfilling the role of Anchor CA." +
                "\n" +
                "NOTE Support for Joint Fabric Administrator Cluster is provisional."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "AdministratorFabricIndex", id: 0x0, type: "fabric-idx", access: "A", conformance: "P, M",
            constraint: "1 to 254", quality: "X", xref: "core§11.25.6.1",
            details: "The AdministratorFabricIndex attribute shall indicate the FabricIndex from the Endpoint 0’s " +
                "Operational Cluster Fabrics attribute (i.e. the Fabric Table) which is associated with the " +
                "JointFabric. This field shall have the value of null if there is no fabric associated with the " +
                "JointFabric."
        }),

        Command({
            name: "IcaccsrRequest", id: 0x0, access: "A", conformance: "P, M", direction: "request",
            response: "IcaccsrResponse", xref: "core§11.25.7.1",

            details: "This command shall be generated during Joint Commissioning Method and subsequently be responded in " +
                "the form of an ICACCSRResponse command." +
                "\n" +
                "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                "initiator." +
                "\n" +
                "If this command is received from a peer against FabricFabric Table Vendor ID Verification Procedure " +
                "hasn’t been executed then it shall fail with a JfVidNotVerified status code sent back to the " +
                "initiator." +
                "\n" +
                "If a prior AddICAC command was successfully executed within the fail-safe timer period, then this " +
                "command shall fail with a CONSTRAINT_ERROR status code sent back to the initiator."
        }),

        Command(
            {
                name: "IcaccsrResponse", id: 0x1, conformance: "P, M", direction: "response",
                xref: "core§11.25.7.2",
                details: "This command shall be generated in response to a ICACCSRRequest command. Check ICAC Cross Signing " +
                    "for details about the generation of the ICACCSR."
            },

            Field({
                name: "Icaccsr", id: 0x0, type: "octstr", conformance: "M", constraint: "max 600",
                xref: "core§11.25.7.2.1",
                details: "This field shall be a DER-encoded octet string of a properly encoded PKCS #10 Certificate Signing " +
                    "Request (CSR)."
            })
        ),

        Command(
            {
                name: "AddIcac", id: 0x2, access: "A", conformance: "P, M", direction: "request",
                response: "IcacResponse", xref: "core§11.25.7.3",

                details: "This command shall be generated and executed during Joint Commissioning Method and subsequently be " +
                    "responded in the form of an ICACResponse command." +
                    "\n" +
                    "A Commissioner or Administrator shall issue this command after issuing the ICACCSRRequest command " +
                    "and receiving its response." +
                    "\n" +
                    "A Commissioner or Administrator shall issue this command after performing the Attestation Procedure, " +
                    "Fabric Table VID Verification and after validating that the peer is authorized to act as an " +
                    "Administrator in its own Fabric." +
                    "\n" +
                    "Check ICA Cross Signing for details about the generation of ICACValue."
            },

            Field(
                {
                    name: "IcacValue", id: 0x1, type: "octstr", conformance: "M", constraint: "max 400",
                    xref: "core§11.25.7.3.1",

                    details: "This field shall contain an ICAC encoded using Matter Certificate Encoding." +
                        "\n" +
                        "### Effect on Receipt" +
                        "\n" +
                        "If this command is received without an armed fail-safe context (see Section 11.10.7.2, “ArmFailSafe " +
                        "Command”), then this command shall fail with a FAILSAFE_REQUIRED status code sent back to the " +
                        "initiator." +
                        "\n" +
                        "This command shall be received over a CASE session otherwise it shall fail with an INVALID_COMMAND " +
                        "status code." +
                        "\n" +
                        "Upon receipt, the ICACValue shall be validated in the following ways:" +
                        "\n" +
                        "  1. Verify the ICAC using Crypto_VerifyChain(certificates = [ICACValue, RootCACertificate]) where " +
                        "     RootCACertificate is the associated RCAC of the accessing fabric. If this check fails, the " +
                        "     error status shall be InvalidICAC." +
                        "\n" +
                        "  2. The public key of the ICAC shall match the public key present in the last ICACCSRResponse " +
                        "     provided to the Administrator that sent the AddICAC command. If this check fails, the error " +
                        "     status shall be InvalidPublicKey." +
                        "\n" +
                        "  3. The DN Encoding Rules shall be validated for the ICAC. If this check fails, the error status " +
                        "     shall be InvalidICAC." +
                        "\n" +
                        "If any of the above validation checks fail, the server shall immediately respond to the client with " +
                        "an ICACResponse. The StatusCode field of the ICACResponse shall be set to the error status value " +
                        "specified in the above validation checks." +
                        "\n" +
                        "If all the checks succeed, then the ICACValue shall be used as described in the Joint Commissioning " +
                        "Method."
                }
            )
        ),

        Command(
            {
                name: "IcacResponse", id: 0x3, conformance: "P, M", direction: "response", xref: "core§11.25.7.4",
                details: "This command shall be generated in response to the AddICAC command."
            },

            Field({
                name: "StatusCode", id: 0x0, type: "ICACResponseStatusEnum", conformance: "M",
                xref: "core§11.25.7.4.1",
                details: "This field shall contain an ICACResponseStatusEnum value representing the status of the AddICAC " +
                    "operation."
            })
        ),

        Command(
            {
                name: "OpenJointCommissioningWindow", id: 0x4, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.25.7.5",

                details: "> [!NOTE]" +
                    "\n" +
                    "> This is an alias onto the OpenCommissioningWindow command within the Joint Fabric Administrator " +
                    "  Cluster. Refer to the OpenCommissioningWindow command for a description of the command behavior " +
                    "  and parameters." +
                    "\n" +
                    "This command shall fail with a InvalidAdministratorFabricIndex status code sent back to the " +
                    "initiator if the AdministratorFabricIndex field has the value of null." +
                    "\n" +
                    "The parameters for OpenJointCommissioningWindow command are as follows:"
            },

            Field({ name: "CommissioningTimeout", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
            Field({ name: "PakePasscodeVerifier", id: 0x1, type: "octstr", conformance: "M", constraint: "97" }),
            Field({ name: "Discriminator", id: 0x2, type: "uint16", conformance: "M", constraint: "max 4095" }),
            Field({ name: "Iterations", id: 0x3, type: "uint32", conformance: "M", constraint: "1000 to 100000" }),
            Field({ name: "Salt", id: 0x4, type: "octstr", conformance: "M", constraint: "16 to 32" })
        ),

        Command({
            name: "TransferAnchorRequest", id: 0x5, access: "A", conformance: "P, M", direction: "request",
            response: "TransferAnchorResponse", xref: "core§11.25.7.6",
            details: "This command shall be sent by a candidate Joint Fabric Anchor Administrator to the current Joint " +
                "Fabric Anchor Administrator to request transfer of the Anchor Fabric."
        }),

        Command(
            {
                name: "TransferAnchorResponse", id: 0x6, access: "A", conformance: "P, M", direction: "response",
                xref: "core§11.25.7.7",
                details: "This command shall be generated in response to the Transfer Anchor Request command."
            },
            Field({ name: "StatusCode", id: 0x0, type: "TransferAnchorResponseStatusEnum", conformance: "M" })
        ),

        Command({
            name: "TransferAnchorComplete", id: 0x7, access: "A", conformance: "P, M", direction: "request",
            response: "status", xref: "core§11.25.7.8",
            details: "This command shall indicate the completion of the transfer of the Anchor Fabric to another Joint " +
                "Fabric Ecosystem Administrator."
        }),

        Command(
            {
                name: "AnnounceJointFabricAdministrator", id: 0x8, access: "A", conformance: "P, M",
                direction: "request", response: "status", xref: "core§11.25.7.9",
                details: "This command shall be used for communicating to client the endpoint that holds the Joint Fabric " +
                    "Administrator Cluster." +
                    "\n" +
                    "### This field shall contain the unique identifier for the endpoint that holds the Joint Fabric " +
                    "Administrator Cluster."
            },

            Field({ name: "EndpointId", id: 0x0, type: "endpoint-no", conformance: "M" })
        ),

        Datatype(
            {
                name: "ICACResponseStatusEnum", type: "enum8", xref: "core§11.25.4.1",
                details: "This enumeration is used by the ICACResponse command to convey the outcome of this cluster’s " +
                    "operations."
            },
            Field({ name: "Ok", id: 0x0, conformance: "M", description: "No error" }),
            Field({ name: "InvalidPublicKey", id: 0x1, conformance: "M", description: "Public Key in the ICAC is invalid" }),
            Field({
                name: "InvalidIcac", id: 0x2, conformance: "M",
                description: "ICAC chain validation failed / ICAC DN Encoding rules verification failed"
            })
        ),

        Datatype(
            {
                name: "TransferAnchorResponseStatusEnum", type: "enum8", xref: "core§11.25.4.2",
                details: "This enumeration is used by the TransferAnchorResponse command to convey the detailed outcome of " +
                    "this cluster’s TransferAnchorRequest command."
            },
            Field({ name: "Ok", id: 0x0, conformance: "M", description: "No error" }),
            Field({
                name: "TransferAnchorStatusDatastoreBusy", id: 0x1, conformance: "M",
                description: "Anchor Transfer was not started due to on-going Datastore operations"
            }),
            Field({
                name: "TransferAnchorStatusNoUserConsent", id: 0x2, conformance: "M",
                description: "User has not consented for Anchor Transfer"
            })
        ),

        Datatype(
            { name: "StatusCodeEnum", type: "enum8", xref: "core§11.25.5.1" },
            Field({
                name: "Busy", id: 0x2, conformance: "P, M",
                description: "Could not be completed because another commissioning is in progress"
            }),
            Field({
                name: "PakeParameterError", id: 0x3, conformance: "P, M",
                description: "Provided PAKE parameters were incorrectly formatted or otherwise invalid"
            }),
            Field({
                name: "WindowNotOpen", id: 0x4, conformance: "P, M",
                description: "No commissioning window was currently open"
            }),
            Field({
                name: "VidNotVerified", id: 0x5, conformance: "P, M",
                description: "ICACCSRRequest command has been invoked by a peer against which Fabric Table VID Verification hasn’t been executed"
            }),
            Field({
                name: "InvalidAdministratorFabricIndex", id: 0x6, conformance: "P, M",
                description: "OpenJointCommissioningWindow command has been invoked but the AdministratorFabricIndex field has the value of null"
            })
        )
    ),

    Cluster(
        {
            name: "CommissionerControl", id: 0x751, classification: "node", pics: "CCTRL", xref: "core§11.26",

            details: "The Commissioner Control Cluster supports the ability for clients to request the commissioning of " +
                "themselves or other nodes onto a fabric which the cluster server can commission onto. An example use " +
                "case is ecosystem to ecosystem Fabric Synchronization setup." +
                "\n" +
                "The generalized flow supported by the Commissioner Control Cluster can be seen in the following " +
                "diagram."
        },

        Attribute({ name: "ClusterRevision", id: 0xfffd, type: "ClusterRevision", default: 1 }),

        Attribute({
            name: "SupportedDeviceCategories", id: 0x0, type: "SupportedDeviceCategoryBitmap", access: "R M",
            conformance: "M", default: 0, xref: "core§11.26.5.1",
            details: "Indicates the device categories specified in SupportedDeviceCategoryBitmap that are supported by " +
                "this Commissioner Control Cluster server." +
                "\n" +
                "A client shall NOT send the RequestCommissioningApproval command if the intended node to be " +
                "commissioned does not conform to any of the values specified in SupportedDeviceCategories."
        }),

        Event(
            {
                name: "CommissioningRequestResult", id: 0x0, access: "S M", conformance: "M", priority: "info",
                xref: "core§11.26.7.1",

                details: "This event shall be generated by the server following a RequestCommissioningApproval command which " +
                    "the server responded to with SUCCESS." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> The approval is valid for a period determined by the manufacturer and characteristics of the node " +
                    "  presenting the Commissioner Control Cluster. Clients SHOULD send the CommissionNode command " +
                    "  immediately upon receiving a CommissioningRequestResult event." +
                    "\n" +
                    "11.26.7.2. RequestID / ClientNodeID Fields The RequestID shall match the RequestID provided to " +
                    "RequestCommissioningApproval and the ClientNodeID shall match the NodeID of the client which " +
                    "generated the RequestCommissioningApproval command."
            },

            Field({ name: "RequestId", id: 0x0, type: "uint64", access: "S", conformance: "M" }),
            Field({ name: "ClientNodeId", id: 0x1, type: "node-id", access: "S", conformance: "M" }),
            Field({ name: "StatusCode", id: 0x2, type: "status", access: "S", conformance: "M", constraint: "desc" }),
            Field({ name: "FabricIndex", id: 0xfe, type: "FabricIndex" })
        ),

        Command(
            {
                name: "RequestCommissioningApproval", id: 0x0, access: "M", conformance: "M", direction: "request",
                response: "status", xref: "core§11.26.6.1",

                details: "This command is sent by a client to request approval for a future CommissionNode call. This is " +
                    "required to be a separate step in order to provide the server time for interacting with a user " +
                    "before informing the client that the CommissionNode operation may be successful." +
                    "\n" +
                    "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                    "UNSUPPORTED_ACCESS." +
                    "\n" +
                    "The server may request approval from the user, but it is not required." +
                    "\n" +
                    "The server shall always return SUCCESS to a correctly formatted RequestCommissioningApproval " +
                    "command, and then generate a CommissioningRequestResult event associated with the command’s " +
                    "accessing fabric once the result is ready." +
                    "\n" +
                    "Clients SHOULD avoid using the same RequestID. If the RequestID and client NodeID of a " +
                    "RequestCommissioningApproval match a previously received RequestCommissioningApproval and the server " +
                    "has not returned an error or completed commissioning of a device for the prior request, then the " +
                    "server SHOULD return FAILURE." +
                    "\n" +
                    "The parameters for RequestCommissioningApproval command are as follows:"
            },

            Field({ name: "RequestId", id: 0x0, type: "uint64", conformance: "M" }),
            Field({ name: "VendorId", id: 0x1, type: "vendor-id", conformance: "M" }),
            Field({ name: "ProductId", id: 0x2, type: "uint16", conformance: "M" }),
            Field({ name: "Label", id: 0x3, type: "string", conformance: "O", constraint: "max 64" })
        ),

        Command(
            {
                name: "CommissionNode", id: 0x1, access: "M", conformance: "M", direction: "request",
                response: "ReverseOpenCommissioningWindow", xref: "core§11.26.6.5",

                details: "This command is sent by a client to request that the server begins commissioning a previously " +
                    "approved request." +
                    "\n" +
                    "The server shall return FAILURE if the CommissionNode command is not sent from the same NodeID and " +
                    "on the same fabric as the RequestCommissioningApproval or if the provided RequestID to " +
                    "CommissionNode does not match the value provided to RequestCommissioningApproval." +
                    "\n" +
                    "If the command is not executed via a CASE session, the command shall fail with a status code of " +
                    "UNSUPPORTED_ACCESS." +
                    "\n" +
                    "Upon receipt, the server shall respond with ReverseOpenCommissioningWindow if " +
                    "CommissioningRequestResult was generated with StatusCode of SUCCESS for the matching RequestID field " +
                    "and NodeID of the client." +
                    "\n" +
                    "The server shall return FAILURE if the CommissionNode command is received after the server has " +
                    "already responded to a client with ReverseOpenCommissioningWindow for a matching RequestID field and " +
                    "NodeID of the client unless the client has sent another RequestCommissioningApproval and received an " +
                    "additional CommissioningRequestResult." +
                    "\n" +
                    "The parameters for CommissionNode command are as follows:"
            },

            Field({ name: "RequestId", id: 0x0, type: "uint64", conformance: "M" }),
            Field({
                name: "ResponseTimeoutSeconds", id: 0x1, type: "uint16", conformance: "M", constraint: "30 to 120",
                default: 30
            })
        ),

        Command(
            {
                name: "ReverseOpenCommissioningWindow", id: 0x2, conformance: "M", direction: "response",
                xref: "core§11.26.6.8",

                details: "When received within the timeout specified by ResponseTimeoutSeconds in the CommissionNode command, " +
                    "the client shall open a commissioning window on a node which matches the VendorID and ProductID " +
                    "provided in the associated RequestCommissioningApproval command." +
                    "\n" +
                    "When commissioning this node, the server shall check that the VendorID and ProductID fields provided " +
                    "in the RequestCommissioningApproval command match the VendorID and ProductID attributes of the Basic " +
                    "Information Cluster which have already been verified during the Device Attestation Procedure. If " +
                    "they do not match, the server shall NOT complete commissioning and SHOULD indicate an error to the " +
                    "user." +
                    "\n" +
                    "> [!NOTE]" +
                    "\n" +
                    "> This is an alias onto the OpenCommissioningWindow command within the Administrator Commissioning " +
                    "  Cluster. Refer to the OpenCommissioningWindow command for a description of the command behavior " +
                    "  and parameters." +
                    "\n" +
                    "The parameters for ReverseOpenCommissioningWindow command are as follows:"
            },

            Field({ name: "CommissioningTimeout", id: 0x0, type: "uint16", conformance: "M", constraint: "desc" }),
            Field({ name: "PakePasscodeVerifier", id: 0x1, type: "octstr", conformance: "M", constraint: "97" }),
            Field({ name: "Discriminator", id: 0x2, type: "uint16", conformance: "M", constraint: "max 4095" }),
            Field({ name: "Iterations", id: 0x3, type: "uint32", conformance: "M", constraint: "1000 to 100000" }),
            Field({ name: "Salt", id: 0x4, type: "octstr", conformance: "M", constraint: "16 to 32" })
        ),

        Datatype(
            { name: "SupportedDeviceCategoryBitmap", type: "map32", xref: "core§11.26.4.1" },

            Field({
                name: "FabricSynchronization", constraint: "0",
                description: "Aggregators which support Fabric Synchronization may be commissioned.",
                xref: "core§11.26.4.1.1",
                details: "The FabricSynchronization bit shall be set to 1 if and only if the server supports commissioning " +
                    "nodes that support Fabric Synchronization."
            })
        )
    ),

    DeviceType(
        { name: "Base", classification: "base", xref: "device§1.1" },

        Field(
            { name: "conditions", type: "enum8" },
            Field({ name: "Zha", description: "Zigbee Home Automation standard", xref: "device§1.1.3.1" }),
            Field({ name: "Zse", description: "Zigbee Smart Energy standard", xref: "device§1.1.3.1" }),
            Field({ name: "Gp", description: "Zigbee Green Power standard", xref: "device§1.1.3.1" }),
            Field({ name: "Zigbee", description: "Zigbee standard", xref: "device§1.1.3.1" }),
            Field({ name: "SuZi", description: "Zigbee PRO Sub-GHz standard", xref: "device§1.1.3.1" }),
            Field({ name: "Matter", description: "Matter standard", xref: "device§1.1.3.1" }),
            Field({
                name: "LanguageLocale",
                description: "The node supports localization for conveying text to the user",
                xref: "device§1.1.3.3"
            }),
            Field({
                name: "TimeLocale", description: "The node supports localization for conveying time to the user",
                xref: "device§1.1.3.3"
            }),
            Field({
                name: "UnitLocale",
                description: "The node supports localization for conveying units of measure to the user",
                xref: "device§1.1.3.3"
            }),
            Field({
                name: "Sit", description: "The node is a short idle time intermittently connected device",
                xref: "device§1.1.4"
            }),
            Field({
                name: "Lit", description: "The node is a long idle time intermittently connected device",
                xref: "device§1.1.4"
            }),
            Field({ name: "Active", description: "The node is always able to communicate", xref: "device§1.1.4" }),
            Field({ name: "Node", xref: "device§1.1.5" }),
            Field({ name: "App", xref: "device§1.1.5" }),
            Field({ name: "Simple", xref: "device§1.1.5" }),
            Field({ name: "Dynamic", xref: "device§1.1.5" }),
            Field({ name: "Composed", xref: "device§1.1.5" }),
            Field({ name: "Client", xref: "device§1.1.6" }),
            Field({ name: "Server", xref: "device§1.1.6" }),
            Field({ name: "Duplicate", xref: "device§1.1.6" }),
            Field({ name: "BridgedPowerSourceInfo", xref: "device§1.1.6" })
        ),

        Requirement(
            { name: "Descriptor", id: 0x1d, conformance: "M", element: "serverCluster", xref: "device§1.1.7" },
            Requirement({ name: "TAGLIST", conformance: "Duplicate", element: "feature" })
        ),
        Requirement({ name: "Binding", id: 0x1e, conformance: "Simple & Client", element: "serverCluster", xref: "device§1.1.7" }),
        Requirement({ name: "FixedLabel", id: 0x40, conformance: "O", element: "serverCluster", xref: "device§1.1.7" }),
        Requirement({ name: "UserLabel", id: 0x41, conformance: "O", element: "serverCluster", xref: "device§1.1.7" })
    ),

    DeviceType(
        {
            name: "RootNode", id: 0x16, classification: "node", xref: "device§2.1",

            details: "This defines conformance for a root node endpoint (see System Model specification). This endpoint is " +
                "akin to a \"read me first\" endpoint that describes itself and the other endpoints that make up the " +
                "node." +
                "\n" +
                "  • Device types with Endpoint scope shall NOT be supported on the same endpoint as this device " +
                "    type." +
                "\n" +
                "  • Clusters with an Application role shall NOT be supported on the same endpoint as this device " +
                "    type." +
                "\n" +
                "  • Other device types with Node scope may be supported on the same endpoint as this device type."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 22, revision: 3 } ], element: "attribute" })
        ),

        Field(
            { name: "conditions", type: "enum8" },
            Field({
                name: "CustomNetworkConfig",
                description: "The node only supports out-of-band-configured networking (e.g. rich user interface, manufacturer-specific means, custom commissioning flows, or future IP-compliant network technology not yet directly supported by NetworkCommissioning cluster).",
                xref: "device§2.1.3"
            }),
            Field({
                name: "ManagedAclAllowed",
                description: "The node has at least one endpoint where some Device Type present on the endpoint has a Device Library element requirement table entry that sets this condition to true.",
                xref: "device§2.1.3"
            })
        ),

        Requirement({
            name: "BasicInformation", id: 0x28, conformance: "M", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),

        Requirement(
            {
                name: "AccessControl", id: 0x1f, conformance: "M", element: "serverCluster", quality: "I",
                xref: "device§2.1.5"
            },
            Requirement({ name: "MNGD", conformance: "[ManagedAclAllowed]", constraint: "desc", element: "feature" })
        ),

        Requirement({
            name: "PowerSourceConfiguration", id: 0x2e, conformance: "O, D", element: "serverCluster",
            quality: "I", xref: "device§2.1.5"
        }),
        Requirement({
            name: "TimeSynchronization", id: 0x38, conformance: "O", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "GroupKeyManagement", id: 0x3f, conformance: "M", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "GeneralCommissioning", id: 0x30, conformance: "M", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "NetworkCommissioning", id: 0x31, conformance: "!CustomNetworkConfig",
            element: "serverCluster", xref: "device§2.1.5"
        }),
        Requirement({
            name: "AdministratorCommissioning", id: 0x3c, conformance: "M", element: "serverCluster",
            quality: "I", xref: "device§2.1.5"
        }),
        Requirement({
            name: "OperationalCredentials", id: 0x3e, conformance: "M", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "LocalizationConfiguration", id: 0x2b, conformance: "LanguageLocale",
            element: "serverCluster", quality: "I", xref: "device§2.1.5"
        }),
        Requirement({
            name: "TimeFormatLocalization", id: 0x2c, conformance: "TimeLocale", element: "serverCluster",
            quality: "I", xref: "device§2.1.5"
        }),
        Requirement({
            name: "UnitLocalization", id: 0x2d, conformance: "UnitLocale", element: "serverCluster",
            quality: "I", xref: "device§2.1.5"
        }),
        Requirement({
            name: "GeneralDiagnostics", id: 0x33, conformance: "M", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "DiagnosticLogs", id: 0x32, conformance: "O", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "SoftwareDiagnostics", id: 0x34, conformance: "O", element: "serverCluster", quality: "I",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "EthernetNetworkDiagnostics", id: 0x37, conformance: "[Ethernet]", element: "serverCluster",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "WiFiNetworkDiagnostics", id: 0x36, conformance: "[Wi, Fi]", element: "serverCluster",
            xref: "device§2.1.5"
        }),
        Requirement({
            name: "ThreadNetworkDiagnostics", id: 0x35, conformance: "[Thread]", element: "serverCluster",
            xref: "device§2.1.5"
        }),

        Requirement(
            {
                name: "IcdManagement", id: 0x46, conformance: "SIT | LIT", element: "serverCluster", quality: "I",
                xref: "device§2.1.5"
            },
            Requirement({ name: "LONGIDLETIMESUPPORT", conformance: "LIT", element: "feature" })
        )
    ),

    DeviceType(
        { name: "PowerSource", id: 0x11, classification: "utility", xref: "device§2.2" },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 17, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "PowerSource", id: 0x2f, conformance: "M", element: "serverCluster", xref: "device§2.2.3" })
    ),

    DeviceType(
        {
            name: "OtaRequestor", id: 0x12, classification: "utility", xref: "device§2.3",
            details: "An OTA Requestor is a device that is capable of receiving an OTA software update."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 18, revision: 1 } ], element: "attribute" })
        ),
        Requirement({
            name: "OtaSoftwareUpdateRequestor", id: 0x2a, conformance: "M", element: "serverCluster",
            xref: "device§2.3.3"
        }),
        Requirement({
            name: "OtaSoftwareUpdateProvider", id: 0x29, conformance: "M", element: "clientCluster",
            xref: "device§2.3.3"
        })
    ),

    DeviceType(
        {
            name: "OtaProvider", id: 0x14, classification: "utility", xref: "device§2.4",
            details: "An OTA Provider is a node that is capable of providing an OTA software update to other nodes on the " +
                "same fabric."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 20, revision: 1 } ], element: "attribute" })
        ),
        Requirement({
            name: "OtaSoftwareUpdateRequestor", id: 0x2a, conformance: "O", element: "clientCluster",
            xref: "device§2.4.3"
        }),
        Requirement({
            name: "OtaSoftwareUpdateProvider", id: 0x29, conformance: "M", element: "serverCluster",
            xref: "device§2.4.3"
        })
    ),

    DeviceType(
        {
            name: "BridgedNode", id: 0x13, classification: "utility", xref: "device§2.5",
            details: "This defines conformance for a Bridged Node root endpoint. This endpoint is akin to a \"read me " +
                "first\" endpoint that describes itself and any other endpoints that make up the Bridged Node. A " +
                "Bridged Node endpoint represents a device on a foreign network, but is not the root endpoint of the " +
                "bridge itself."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 19, revision: 3 } ], element: "attribute" })
        ),
        Field(
            { name: "conditions", type: "enum8" },
            Field({ name: "FabricSynchronizedNode", description: "See description below.", xref: "device§2.5.3" })
        ),
        Requirement({
            name: "BridgedDeviceBasicInformation", id: 0x39, conformance: "M", element: "serverCluster",
            xref: "device§2.5.5"
        }),
        Requirement({
            name: "PowerSourceConfiguration", id: 0x2e, conformance: "BridgedPowerSourceInfo, D",
            element: "serverCluster", xref: "device§2.5.5"
        }),
        Requirement({
            name: "PowerSource", id: 0x2f, conformance: "BridgedPowerSourceInfo", element: "serverCluster",
            xref: "device§2.5.5"
        }),
        Requirement({
            name: "EcosystemInformation", id: 0x750, conformance: "FabricSynchronizedNode, O",
            element: "serverCluster", xref: "device§2.5.5"
        }),
        Requirement({
            name: "AdministratorCommissioning", id: 0x3c, conformance: "FabricSynchronizedNode",
            element: "serverCluster", xref: "device§2.5.5"
        })
    ),

    DeviceType(
        {
            name: "ElectricalSensor", id: 0x510, classification: "utility", xref: "device§2.6",
            details: "An Electrical Sensor device measures the electrical power and/or energy being imported and/or " +
                "exported."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 1296, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "PowerTopology", id: 0x9c, conformance: "M", element: "serverCluster", xref: "device§2.6.4" }),
        Requirement({
            name: "ElectricalPowerMeasurement", id: 0x90, conformance: "O.a+", element: "serverCluster",
            xref: "device§2.6.4"
        }),
        Requirement({
            name: "ElectricalEnergyMeasurement", id: 0x91, conformance: "O.a+", element: "serverCluster",
            xref: "device§2.6.4"
        })
    ),

    DeviceType(
        {
            name: "DeviceEnergyManagement", id: 0x50d, classification: "utility", xref: "device§2.7",
            details: "A Device Energy Management device provides reporting and optionally adjustment of the electrical " +
                "power planned on being consumed or produced by the device."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 1293, revision: 2 } ], element: "attribute" })
        ),

        Field(
            { name: "conditions", type: "enum8" },
            Field({
                name: "ControllableEsa",
                description: "The DEM cluster on this endpoint accepts commands to adjust its energy operation.",
                xref: "device§2.7.3"
            })
        ),

        Requirement(
            {
                name: "DeviceEnergyManagement", id: 0x98, conformance: "M", element: "serverCluster",
                xref: "device§2.7.4"
            },
            Requirement({ name: "POWERADJUSTMENT", conformance: "[ControllableESA].a+", element: "feature" }),
            Requirement({ name: "STARTTIMEADJUSTMENT", conformance: "[ControllableESA].a+", element: "feature" }),
            Requirement({ name: "PAUSABLE", conformance: "[ControllableESA].a+", element: "feature" }),
            Requirement({ name: "FORECASTADJUSTMENT", conformance: "[ControllableESA].a+", element: "feature" }),
            Requirement({ name: "CONSTRAINTBASEDADJUSTMENT", conformance: "[ControllableESA].a+", element: "feature" })
        ),

        Requirement({
            name: "DeviceEnergyManagementMode", id: 0x9f, conformance: "ControllableESA, O",
            element: "serverCluster", xref: "device§2.7.4"
        })
    ),

    DeviceType(
        {
            name: "SecondaryNetworkInterface", id: 0x19, classification: "utility", xref: "device§2.8",

            details: "A Secondary Network Interface device provides an additional network interface supported by the Node, " +
                "supplementing the primary interface hosted by the Root Node endpoint." +
                "\n" +
                "A Node supporting multiple network interfaces shall include the primary interface on the Root Node " +
                "endpoint, along with secondary interfaces on other endpoints. The priorities of these network " +
                "interfaces are determined by the order of their endpoints, where interfaces with smaller endpoint " +
                "numbers are higher priority."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 25, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "NetworkCommissioning", id: 0x31, conformance: "M", element: "serverCluster", xref: "device§2.8.3" }),
        Requirement({
            name: "EthernetNetworkDiagnostics", id: 0x37, conformance: "[Ethernet]", element: "serverCluster",
            xref: "device§2.8.3"
        }),
        Requirement({
            name: "WiFiNetworkDiagnostics", id: 0x36, conformance: "[Wi, Fi]", element: "serverCluster",
            xref: "device§2.8.3"
        }),
        Requirement({
            name: "ThreadNetworkDiagnostics", id: 0x35, conformance: "[Thread]", element: "serverCluster",
            xref: "device§2.8.3"
        })
    ),

    DeviceType(
        {
            name: "JointFabricAdministrator", id: 0x130, classification: "utility", xref: "device§2.9",

            details: "A Joint Fabric Administrator device provides capabilities to manage the Joint Fabric Datastore and " +
                "issue an ICAC signed by the Joint Fabric Anchor Root CA." +
                "\n" +
                "A client wanting to access the capabilities of the Joint Fabric Administrator may use the Joint " +
                "Commissioning Method (as specified in the Matter core specification) to be commissioned onto the " +
                "Joint Fabric. Once commissioned, a client may access the capabilities of the Joint Fabric " +
                "Administrator."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 304, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "JointFabricDatastore", id: 0x752, conformance: "M", element: "serverCluster", xref: "device§2.9.4" }),
        Requirement({
            name: "JointFabricAdministrator", id: 0x753, conformance: "M", element: "serverCluster",
            xref: "device§2.9.4"
        })
    ),

    DeviceType(
        {
            name: "OnOffLight", id: 0x100, classification: "simple", xref: "device§4.1",
            details: "The On/Off Light is a lighting device that is capable of being switched on or off by means of a " +
                "bound controller device such as an On/Off Light Switch or a Dimmer Switch. In addition, an on/off " +
                "light is also capable of being switched by means of a bound occupancy sensor."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 256, revision: 3 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§4.1.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§4.1.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§4.1.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§4.1.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "O", element: "serverCluster", xref: "device§4.1.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§4.1.4" }
        )
    ),

    DeviceType(
        {
            name: "DimmableLight", id: 0x101, classification: "simple", xref: "device§4.2",
            details: "A Dimmable Light is a lighting device that is capable of being switched on or off and the intensity " +
                "of its light adjusted by means of a bound controller device such as a Dimmer Switch or a Color " +
                "Dimmer Switch. In addition, a Dimmable Light device is also capable of being switched by means of a " +
                "bound occupancy sensor or other device(s)."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 257, revision: 3 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§4.2.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§4.2.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§4.2.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§4.2.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§4.2.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§4.2.4" }
        )
    ),

    DeviceType(
        {
            name: "ColorTemperatureLight", id: 0x10c, classification: "simple", xref: "device§4.3",
            details: "A Color Temperature Light is a lighting device that is capable of being switched on or off, the " +
                "intensity of its light adjusted, and its color temperature adjusted by means of a bound controller " +
                "device such as a Color Dimmer Switch."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 268, revision: 4 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§4.3.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§4.3.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§4.3.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§4.3.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§4.3.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "ColorControl", id: 0x300, conformance: "M", element: "serverCluster", xref: "device§4.3.4" },
            Requirement({ name: "COLORTEMPERATURE", conformance: "M", element: "feature" }),
            Requirement({ name: "RemainingTime", conformance: "M", element: "attribute" })
        ),
        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§4.3.4" }
        )
    ),

    DeviceType(
        {
            name: "ExtendedColorLight", id: 0x10d, classification: "simple", xref: "device§4.4",
            details: "An Extended Color Light is a lighting device that is capable of being switched on or off, the " +
                "intensity of its light adjusted, and its color adjusted by means of a bound controller device such " +
                "as a Color Dimmer Switch or Control Bridge. The device supports adjustment of color by means of " +
                "hue/saturation, enhanced hue, color looping, XY coordinates, and color temperature. In addition, the " +
                "extended color light is also capable of being switched by means of a bound occupancy sensor."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 269, revision: 4 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§4.4.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§4.4.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§4.4.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§4.4.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§4.4.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "ColorControl", id: 0x300, conformance: "M", element: "serverCluster", xref: "device§4.4.4" },
            Requirement({ name: "HUESATURATION", conformance: "O", element: "feature" }),
            Requirement({ name: "ENHANCEDHUE", conformance: "O", element: "feature" }),
            Requirement({ name: "COLORLOOP", conformance: "O", element: "feature" }),
            Requirement({ name: "XY", conformance: "M", element: "feature" }),
            Requirement({ name: "COLORTEMPERATURE", conformance: "M", element: "feature" }),
            Requirement({ name: "RemainingTime", conformance: "M", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§4.4.4" }
        )
    ),

    DeviceType(
        {
            name: "OnOffPlugInUnit", id: 0x10a, classification: "simple", xref: "device§5.1",

            details: "An On/Off Plug-in Unit is a device that provides power to another device that is plugged into it, " +
                "and is capable of switching that provided power on or off." +
                "\n" +
                "The Mounted On/Off Control (added in Matter 1.4) has identical cluster requirements as the On/Off " +
                "Plug-In Unit, and is marked as superset of this device type (since Matter 1.4.2). For devices " +
                "intended to be mounted permanently, the Mounted On/Off Control device type shall be used, with the " +
                "On/Off Plug-In Unit device type optionally added in the DeviceTypeList of the Descriptor cluster in " +
                "addition to the On/Off Plug-In Unit device type (see [ref_MountedOnOffControlServerGuidance])." +
                "\n" +
                "### Before Matter 1.4, mounted units typically used the On/Off Plug-In Unit device type. Clients can " +
                "encounter devices which were made before or after these specification updates. Therefore, clients " +
                "SHOULD use the following heuristic to distinguish the type of physical device based on the device " +
                "type revision found on an endpoint (\"--\" means the device type is not listed)."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 266, revision: 4 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.1.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§5.1.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§5.1.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§5.1.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "O", element: "serverCluster", xref: "device§5.1.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§5.1.4" }
        )
    ),

    DeviceType(
        {
            name: "DimmablePlugInUnit", id: 0x10b, classification: "simple", xref: "device§5.2",

            details: "A Dimmable Plug-In Unit is a device that provides power to another device that is plugged into it, " +
                "and is capable of being switched on or off and have its level adjusted. The Dimmable Plug-in Unit is " +
                "typically used to control a conventional non-communicating light through its mains connection using " +
                "phase cutting." +
                "\n" +
                "The Mounted Dimmable Load Control (added in Matter 1.4) has identical cluster requirements as the " +
                "Dimmable Plug-In Unit, and is marked as a superset of this device type (since Matter 1.4.2). For " +
                "devices intended to be mounted permanently, the Mounted Dimmable Load Control device type shall be " +
                "used, with the Dimmable Plug-In Unit device type optionally added to the DeviceTypeList of the " +
                "Descriptor cluster in addition to the Mounted Dimmable Load Control device type (see " +
                "[ref_MountedDimmableLoadControlServerGuidance])." +
                "\n" +
                "### Before Matter 1.4, mounted dimmable load control units typically used the Dimmable Plug-In Unit " +
                "device type. Clients can encounter devices which were made before or after these specification " +
                "updates. Therefore, clients SHOULD use the following heuristic to distinguish the type of physical " +
                "device based on the device type revision found on an endpoint (\"--\" means the device type is not " +
                "listed)."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 267, revision: 5 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.2.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§5.2.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§5.2.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§5.2.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§5.2.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§5.2.4" }
        )
    ),

    DeviceType(
        {
            name: "MountedOnOffControl", id: 0x10f, classification: "simple", xref: "device§5.3",

            details: "A Mounted On/Off Control is a fixed device that provides power to another device or power circuit " +
                "that is connected to it, and is capable of switching that provided power on or off." +
                "\n" +
                "This device type is intended for any wall-mounted or hardwired load controller, while On/Off Plug-in " +
                "Unit is intended only for smart plugs and other power switching devices that are not permanently " +
                "connected, and which can be unplugged from their power source." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Since this device type was added in Matter 1.4, for endpoints using this device type it is " +
                "  recommended to add the subset device type On/Off Plug-in Unit to the DeviceTypeList of the " +
                "  Descriptor cluster on the same endpoint for backward compatibility with existing clients." +
                "\n" +
                "See [ref_MountedOnOffClientGuidance] for client guidance with these two device types."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 271, revision: 2 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.3.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§5.3.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§5.3.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§5.3.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "O", element: "serverCluster", xref: "device§5.3.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§5.3.4" }
        )
    ),

    DeviceType(
        {
            name: "MountedDimmableLoadControl", id: 0x110, classification: "simple", xref: "device§5.4",

            details: "A Mounted Dimmable Load Control is a fixed device that provides power to a load connected to it, and " +
                "is capable of being switched on or off and have its level adjusted. The Mounted Dimmable Load " +
                "Control is typically used to control a conventional non-communicating light through its mains " +
                "connection using phase cutting." +
                "\n" +
                "This device type is intended for any wall-mounted or hardwired dimmer-capable load controller, while " +
                "Dimmable Plug-In Unit is intended only for dimmer-capable smart plugs that are not permanently " +
                "connected, and which can be unplugged from their power source." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> Since this device type was added in Matter 1.4, for endpoints using this device type" +
                "\n" +
                "it is recommended to add the subset device type Dimmable Plug-In Unit to the DeviceTypeList of the " +
                "Descriptor cluster on the same endpoint for backward compatibility with existing clients." +
                "\n" +
                "See [ref_MountedDimmablePlugInUnitClientGuidance] for client guidance with these two device types."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 272, revision: 2 } ], element: "attribute" })
        ),
        Requirement(
            { name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.4.4" },
            Requirement({ name: "TriggerEffect", conformance: "M", element: "command" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§5.4.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "serverCluster", xref: "device§5.4.4" },
            Requirement({ name: "CopyScene", conformance: "M", element: "command" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§5.4.4" },
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" })
        ),

        Requirement(
            { name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§5.4.4" },
            Requirement({ name: "ONOFF", conformance: "M", element: "feature" }),
            Requirement({ name: "LIGHTING", conformance: "M", element: "feature" }),
            Requirement({ name: "CurrentLevel", constraint: "1 to 254", element: "attribute" }),
            Requirement({ name: "MinLevel", constraint: "1", element: "attribute" }),
            Requirement({ name: "MaxLevel", constraint: "254", element: "attribute" })
        ),

        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§5.4.4" }
        )
    ),

    DeviceType(
        {
            name: "Pump", id: 0x303, classification: "simple", xref: "device§5.5",
            details: "A Pump device is a pump that may have variable speed. It may have optional built-in sensors and a " +
                "regulation mechanism. It is typically used for pumping fluids like water."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 771, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement({
            name: "PumpConfigurationAndControl", id: 0x200, conformance: "M", element: "serverCluster",
            xref: "device§5.5.4"
        }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }
        ),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement({ name: "PressureMeasurement", id: 0x403, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "O", element: "serverCluster", xref: "device§5.5.4" }
        ),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "clientCluster", xref: "device§5.5.4" }),
        Requirement({ name: "PressureMeasurement", id: 0x403, conformance: "O", element: "clientCluster", xref: "device§5.5.4" }),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "O", element: "clientCluster", xref: "device§5.5.4" }
        ),
        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§5.5.4" }
        )
    ),

    DeviceType(
        {
            name: "WaterValve", id: 0x42, classification: "simple", xref: "device§5.6",
            details: "This defines conformance to the Water Valve device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 66, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§5.6.4" }),
        Requirement({
            name: "ValveConfigurationAndControl", id: 0x81, conformance: "M", element: "serverCluster",
            xref: "device§5.6.4"
        }),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "O", element: "serverCluster", xref: "device§5.6.4" }
        ),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "O", element: "clientCluster", xref: "device§5.6.4" }
        )
    ),

    DeviceType(
        {
            name: "OnOffLightSwitch", id: 0x103, classification: "simple", xref: "device§6.1",
            details: "An On/Off Light Switch is a controller device that, when bound to a lighting device such as an " +
                "On/Off Light, is capable of being used to switch the device on or off."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 259, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.1.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "clientCluster", xref: "device§6.1.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§6.1.4" }),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§6.1.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§6.1.4" }
        )
    ),

    DeviceType(
        {
            name: "DimmerSwitch", id: 0x104, classification: "simple", xref: "device§6.2",
            details: "A Dimmer Switch is a controller device that, when bound to a lighting device such as a Dimmable " +
                "Light, is capable of being used to switch the device on or off and adjust the intensity of the light " +
                "being emitted."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 260, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.2.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "clientCluster", xref: "device§6.2.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§6.2.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§6.2.4" }
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§6.2.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "M", element: "clientCluster", xref: "device§6.2.4" })
    ),

    DeviceType(
        {
            name: "ColorDimmerSwitch", id: 0x105, classification: "simple", xref: "device§6.3",
            details: "A Color Dimmer Switch is a controller device that, when bound to a lighting device such as an " +
                "Extended Color Light, is capable of being used to adjust the color of the light being emitted."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 261, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.3.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "clientCluster", xref: "device§6.3.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§6.3.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§6.3.4" }
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§6.3.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "M", element: "clientCluster", xref: "device§6.3.4" }),
        Requirement({ name: "ColorControl", id: 0x300, conformance: "M", element: "clientCluster", xref: "device§6.3.4" })
    ),

    DeviceType(
        {
            name: "ControlBridge", id: 0x840, classification: "simple", xref: "device§6.4",
            details: "A Control Bridge is a controller device that, when bound to a lighting device such as an Extended " +
                "Color Light, is capable of being used to switch the device on or off, adjust the intensity of the " +
                "light being emitted and adjust the color of the light being emitted. In addition, a Control Bridge " +
                "device is capable of being used for setting scenes."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 2112, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.4.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement({ name: "ColorControl", id: 0x300, conformance: "M", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement({ name: "IlluminanceMeasurement", id: 0x400, conformance: "O", element: "clientCluster", xref: "device§6.4.4" }),
        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§6.4.4" }
        )
    ),

    DeviceType(
        {
            name: "PumpController", id: 0x304, classification: "simple", xref: "device§6.5",
            details: "A Pump Controller device is capable of configuring and controlling a Pump device."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 772, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement({
            name: "PumpConfigurationAndControl", id: 0x200, conformance: "M", element: "clientCluster",
            xref: "device§6.5.4"
        }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.5.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }
        ),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement({ name: "PressureMeasurement", id: 0x403, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "O", element: "clientCluster", xref: "device§6.5.4" }
        )
    ),

    DeviceType(
        {
            name: "GenericSwitch", id: 0xf, classification: "simple", xref: "device§6.6",
            details: "This defines conformance for the Generic Switch device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 15, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§6.6.4" }),
        Requirement({ name: "Switch", id: 0x3b, conformance: "M", element: "serverCluster", xref: "device§6.6.4" })
    ),

    DeviceType(
        {
            name: "ContactSensor", id: 0x15, classification: "simple", xref: "device§7.1",
            details: "This defines conformance to the Contact Sensor device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 21, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.1.4" }),
        Requirement({ name: "BooleanState", id: 0x45, conformance: "M", element: "serverCluster", xref: "device§7.1.4" }),
        Requirement({
            name: "BooleanStateConfiguration", id: 0x80, conformance: "O", element: "serverCluster",
            xref: "device§7.1.4"
        })
    ),

    DeviceType(
        {
            name: "LightSensor", id: 0x106, classification: "simple", xref: "device§7.2",
            details: "A Light Sensor device is a measurement and sensing device that is capable of measuring and reporting " +
                "the intensity of light (illuminance) to which the sensor is being subjected."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 262, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.2.4" }),
        Requirement({ name: "IlluminanceMeasurement", id: 0x400, conformance: "M", element: "serverCluster", xref: "device§7.2.4" })
    ),

    DeviceType(
        {
            name: "OccupancySensor", id: 0x107, classification: "simple", xref: "device§7.3",
            details: "An Occupancy Sensor is a measurement and sensing device that is capable of measuring and reporting " +
                "the occupancy state in a designated area."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 263, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.3.4" }),
        Requirement({
            name: "BooleanStateConfiguration", id: 0x80, conformance: "O", element: "serverCluster",
            xref: "device§7.3.4"
        }),
        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "M", element: "serverCluster", xref: "device§7.3.4" }
        )
    ),

    DeviceType(
        {
            name: "TemperatureSensor", id: 0x302, classification: "simple", xref: "device§7.4",
            details: "A Temperature Sensor device reports measurements of temperature."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 770, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "M", element: "serverCluster", xref: "device§7.4.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.4.4" })
    ),

    DeviceType(
        {
            name: "PressureSensor", id: 0x305, classification: "simple", xref: "device§7.5",
            details: "A Pressure Sensor device measures and reports the pressure of a fluid."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 773, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "PressureMeasurement", id: 0x403, conformance: "M", element: "serverCluster", xref: "device§7.5.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.5.4" })
    ),

    DeviceType(
        {
            name: "FlowSensor", id: 0x306, classification: "simple", xref: "device§7.6",
            details: "A Flow Sensor device measures and reports the flow rate of a fluid."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 774, revision: 2 } ], element: "attribute" })
        ),
        Requirement(
            { name: "FlowMeasurement", id: 0x404, conformance: "M", element: "serverCluster", xref: "device§7.6.4" }
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.6.4" })
    ),

    DeviceType(
        {
            name: "HumiditySensor", id: 0x307, classification: "simple", xref: "device§7.7",
            details: "A humidity sensor (in most cases a Relative humidity sensor) reports humidity measurements."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 775, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.7.4" }),
        Requirement({
            name: "RelativeHumidityMeasurement", id: 0x405, conformance: "M", element: "serverCluster",
            xref: "device§7.7.4"
        })
    ),

    DeviceType(
        {
            name: "OnOffSensor", id: 0x850, classification: "simple", xref: "device§7.8",
            details: "An On/Off Sensor is a measurement and sensing device that, when bound to a lighting device such as a " +
                "Dimmable Light, is capable of being used to switch the device on or off."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 2128, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.8.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "clientCluster", xref: "device§7.8.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§7.8.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§7.8.4" }
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§7.8.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "O", element: "clientCluster", xref: "device§7.8.4" }),
        Requirement({ name: "ColorControl", id: 0x300, conformance: "O", element: "clientCluster", xref: "device§7.8.4" })
    ),

    DeviceType(
        {
            name: "SmokeCoAlarm", id: 0x76, classification: "simple", xref: "device§7.9",

            details: "A Smoke CO Alarm device is capable of sensing smoke, carbon monoxide or both. It is capable of " +
                "issuing a visual and audible alert to indicate elevated concentration of smoke or carbon monoxide." +
                "\n" +
                "Smoke CO Alarms are capable of monitoring themselves and issuing visual and audible alerts for " +
                "hardware faults, critical low battery conditions, and end of service. Optionally, some of the " +
                "audible alerts can be temporarily silenced. Smoke CO Alarms are capable of performing a self-test " +
                "which performs a diagnostic of the primary sensor and issuing a cycle of the audible and visual life " +
                "safety alarm indications." +
                "\n" +
                "Some smoke alarms may be capable of adjusting sensitivity. Smoke CO Alarm may have the ability to " +
                "detect and report humidity levels, temperature levels, and contamination levels."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 118, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.9.5" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "serverCluster", xref: "device§7.9.5" }),
        Requirement({ name: "SmokeCoAlarm", id: 0x5c, conformance: "M", element: "serverCluster", xref: "device§7.9.5" }),
        Requirement({
            name: "RelativeHumidityMeasurement", id: 0x405, conformance: "O", element: "serverCluster",
            xref: "device§7.9.5"
        }),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster", xref: "device§7.9.5" }),
        Requirement({
            name: "CarbonMonoxideConcentrationMeasurement", id: 0x40c, conformance: "O",
            element: "serverCluster", xref: "device§7.9.5"
        })
    ),

    DeviceType(
        {
            name: "AirQualitySensor", id: 0x2c, classification: "simple", xref: "device§7.10",
            details: "This defines conformance for the Air Quality Sensor device type." +
                "\n" +
                "An air quality sensor is a device designed to monitor and measure various parameters related to the " +
                "quality of ambient air in indoor or outdoor environments."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 44, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.10.4" }),
        Requirement({ name: "AirQuality", id: 0x5b, conformance: "M", element: "serverCluster", xref: "device§7.10.4" }),
        Requirement({
            name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "RelativeHumidityMeasurement", id: 0x405, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "CarbonMonoxideConcentrationMeasurement", id: 0x40c, conformance: "O",
            element: "serverCluster", xref: "device§7.10.4"
        }),
        Requirement({
            name: "CarbonDioxideConcentrationMeasurement", id: 0x40d, conformance: "O",
            element: "serverCluster", xref: "device§7.10.4"
        }),
        Requirement({
            name: "NitrogenDioxideConcentrationMeasurement", id: 0x413, conformance: "O",
            element: "serverCluster", xref: "device§7.10.4"
        }),
        Requirement({
            name: "OzoneConcentrationMeasurement", id: 0x415, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "FormaldehydeConcentrationMeasurement", id: 0x42b, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "Pm1ConcentrationMeasurement", id: 0x42c, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "Pm25ConcentrationMeasurement", id: 0x42a, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "Pm10ConcentrationMeasurement", id: 0x42d, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "RadonConcentrationMeasurement", id: 0x42f, conformance: "O", element: "serverCluster",
            xref: "device§7.10.4"
        }),
        Requirement({
            name: "TotalVolatileOrganicCompoundsConcentrationMeasurement", id: 0x42e, conformance: "O",
            element: "serverCluster", xref: "device§7.10.4"
        })
    ),

    DeviceType(
        {
            name: "WaterFreezeDetector", id: 0x41, classification: "simple", xref: "device§7.11",
            details: "This defines conformance to the Water Freeze Detector device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 65, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.11.4" }),
        Requirement(
            { name: "BooleanState", id: 0x45, conformance: "M", element: "serverCluster", xref: "device§7.11.4" },
            Requirement({ name: "StateChange", conformance: "M", element: "event" })
        ),
        Requirement({
            name: "BooleanStateConfiguration", id: 0x80, conformance: "O", element: "serverCluster",
            xref: "device§7.11.4"
        })
    ),

    DeviceType(
        {
            name: "WaterLeakDetector", id: 0x43, classification: "simple", xref: "device§7.12",
            details: "This defines conformance to the Water Leak Detector device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 67, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.12.4" }),
        Requirement(
            { name: "BooleanState", id: 0x45, conformance: "M", element: "serverCluster", xref: "device§7.12.4" },
            Requirement({ name: "StateChange", conformance: "M", element: "event" })
        ),
        Requirement({
            name: "BooleanStateConfiguration", id: 0x80, conformance: "O", element: "serverCluster",
            xref: "device§7.12.4"
        })
    ),

    DeviceType(
        {
            name: "RainSensor", id: 0x44, classification: "simple", xref: "device§7.13",
            details: "This defines conformance to the Rain Sensor device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 68, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§7.13.4" }),
        Requirement(
            { name: "BooleanState", id: 0x45, conformance: "M", element: "serverCluster", xref: "device§7.13.4" },
            Requirement({ name: "StateChange", conformance: "M", element: "event" })
        ),
        Requirement({
            name: "BooleanStateConfiguration", id: 0x80, conformance: "O", element: "serverCluster",
            xref: "device§7.13.4"
        })
    ),

    DeviceType(
        {
            name: "DoorLock", id: 0xa, classification: "simple", xref: "device§8.1",
            details: "A Door Lock is a device used to secure a door. It is possible to actuate a door lock either by means " +
                "of a manual or a remote method."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 10, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§8.1.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "X", element: "serverCluster", xref: "device§8.1.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "X", element: "serverCluster", xref: "device§8.1.4" }
        ),
        Requirement(
            { name: "DoorLock", id: 0x101, conformance: "M", element: "serverCluster", xref: "device§8.1.4" },
            Requirement({ name: "USER", conformance: "PIN | RID | FGP | FACE | ALIRO", element: "feature" }),
            Requirement({ name: "RFIDCREDENTIAL", conformance: "P, O", element: "feature" })
        )
    ),

    DeviceType(
        {
            name: "DoorLockController", id: 0xb, classification: "simple", xref: "device§8.2",
            details: "A Door Lock Controller is a device capable of controlling a door lock."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 11, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§8.2.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§8.2.4" }
        ),
        Requirement(
            { name: "TimeSynchronization", id: 0x38, conformance: "O", element: "serverCluster", xref: "device§8.2.4" }
        ),
        Requirement({ name: "DoorLock", id: 0x101, conformance: "M", element: "clientCluster", xref: "device§8.2.4" })
    ),

    DeviceType(
        {
            name: "WindowCovering", id: 0x202, classification: "simple", xref: "device§8.3",
            details: "This defines conformance to the Window Covering device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 514, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§8.3.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "Active, O", element: "serverCluster", xref: "device§8.3.4" }),
        Requirement(
            { name: "WindowCovering", id: 0x102, conformance: "M", element: "serverCluster", xref: "device§8.3.4" }
        )
    ),

    DeviceType(
        {
            name: "WindowCoveringController", id: 0x203, classification: "simple", xref: "device§8.4",
            details: "A Window Covering Controller is a device that controls an automatic window covering."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 515, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§8.4.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "clientCluster", xref: "device§8.4.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "Active, O", element: "clientCluster", xref: "device§8.4.4" }),
        Requirement(
            { name: "WindowCovering", id: 0x102, conformance: "M", element: "clientCluster", xref: "device§8.4.4" }
        )
    ),

    DeviceType(
        {
            name: "Thermostat", id: 0x301, classification: "simple", xref: "device§9.1",
            details: "A Thermostat device is capable of having either built-in or separate sensors for temperature, " +
                "humidity or occupancy. It allows the desired temperature to be set either remotely or locally. The " +
                "thermostat is capable of sending heating and/or cooling requirement notifications to a " +
                "heating/cooling unit (for example, an indoor air handler) or is capable of including a mechanism to " +
                "control a heating or cooling unit directly."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 769, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§9.1.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "Active", element: "serverCluster", xref: "device§9.1.4" }),

        Requirement(
            { name: "Thermostat", id: 0x201, conformance: "M", element: "serverCluster", xref: "device§9.1.4" },
            Requirement({ name: "SCHEDULECONFIGURATION", conformance: "X", element: "feature" }),
            Requirement({ name: "AlarmMask", conformance: "X", element: "attribute" }),
            Requirement({ name: "GetRelayStatusLog", conformance: "X", element: "command" }),
            Requirement({ name: "GetRelayStatusLogResponse", conformance: "X", element: "command" })
        ),

        Requirement({
            name: "ThermostatUserInterfaceConfiguration", id: 0x204, conformance: "O", element: "serverCluster",
            xref: "device§9.1.4"
        }),
        Requirement(
            { name: "EnergyPreference", id: 0x9b, conformance: "O", element: "serverCluster", xref: "device§9.1.4" }
        ),
        Requirement({ name: "FanControl", id: 0x202, conformance: "O", element: "clientCluster", xref: "device§9.1.4" }),
        Requirement({ name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "clientCluster", xref: "device§9.1.4" }),
        Requirement({
            name: "RelativeHumidityMeasurement", id: 0x405, conformance: "O", element: "clientCluster",
            xref: "device§9.1.4"
        }),
        Requirement(
            { name: "OccupancySensing", id: 0x406, conformance: "O", element: "clientCluster", xref: "device§9.1.4" }
        )
    ),

    DeviceType(
        {
            name: "Fan", id: 0x2b, classification: "simple", xref: "device§9.2",
            details: "A Fan device is typically standalone or mounted on a ceiling or wall and is used to circulate air in " +
                "a room."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 43, revision: 3 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§9.2.5" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "M", element: "serverCluster", xref: "device§9.2.5" }),
        Requirement({ name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§9.2.5" }),
        Requirement(
            { name: "FanControl", id: 0x202, conformance: "M", element: "serverCluster", xref: "device§9.2.5" },
            Requirement({ name: "FanModeSequence", access: "R V", conformance: "Matter", element: "attribute" })
        )
    ),

    DeviceType(
        {
            name: "AirPurifier", id: 0x2d, classification: "simple", xref: "device§9.3",
            details: "An Air Purifier is a standalone device that is designed to clean the air in a room." +
                "\n" +
                "It is a device that has a fan to control the air speed while it is operating. Optionally, it can " +
                "report on the condition of its filters."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 45, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§9.3.5" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "serverCluster", xref: "device§9.3.5" }),
        Requirement({ name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§9.3.5" }),
        Requirement({ name: "FanControl", id: 0x202, conformance: "M", element: "serverCluster", xref: "device§9.3.5" }),
        Requirement({ name: "HepaFilterMonitoring", id: 0x71, conformance: "O", element: "serverCluster", xref: "device§9.3.5" }),
        Requirement({
            name: "ActivatedCarbonFilterMonitoring", id: 0x72, conformance: "O", element: "serverCluster",
            xref: "device§9.3.5"
        })
    ),

    DeviceType(
        {
            name: "ThermostatController", id: 0x30a, classification: "simple", xref: "device§9.4",
            details: "A Thermostat Controller is a device capable of controlling a Thermostat."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 778, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "clientCluster", xref: "device§9.4.4" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "clientCluster", xref: "device§9.4.4" }),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "clientCluster", xref: "device§9.4.4" }
        ),
        Requirement({ name: "Thermostat", id: 0x201, conformance: "M", element: "clientCluster", xref: "device§9.4.4" })
    ),

    DeviceType(
        {
            name: "BasicVideoPlayer", id: 0x28, classification: "simple", xref: "device§10.2",

            details: "This defines conformance to the Basic Video Player device type." +
                "\n" +
                "A Video Player (either Basic or Casting) represents a device that is able to play media to a " +
                "physical output or to a display screen which is part of the device." +
                "\n" +
                "A Basic Video Player has playback controls (play, pause, etc.) and keypad remote controls (up, down, " +
                "number input), but is not able to launch content and is not a content app platform (the Casting " +
                "Video Player device type is used for these functions)." +
                "\n" +
                "For example, a Basic Video Player can be a traditional TV device a physical media playback device " +
                "such as a DVD Player, or a device that provides input to another device like a TV or computer " +
                "monitor." +
                "\n" +
                "See Section 10.1, “Video Player Architecture” for additional Basic Video Player requirements " +
                "relating to Video Player device endpoint composition, commissioning, feature representation in " +
                "clusters, and UI context."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 40, revision: 2 } ], element: "attribute" })
        ),
        Field(
            { name: "conditions", type: "enum8" },
            Field({ name: "PhysicalInputs", description: "The device has physical inputs for media.", xref: "device§10.2.3" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement({ name: "WakeOnLan", id: 0x503, conformance: "O", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement({ name: "Channel", id: 0x504, conformance: "O", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement(
            { name: "TargetNavigator", id: 0x505, conformance: "O", element: "serverCluster", xref: "device§10.2.4" }
        ),
        Requirement(
            { name: "MediaPlayback", id: 0x506, conformance: "M", element: "serverCluster", xref: "device§10.2.4" }
        ),
        Requirement({
            name: "MediaInput", id: 0x507, conformance: "PhysicalInputs", element: "serverCluster",
            xref: "device§10.2.4"
        }),
        Requirement({ name: "LowPower", id: 0x508, conformance: "O", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement({ name: "KeypadInput", id: 0x509, conformance: "M", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement({ name: "AudioOutput", id: 0x50b, conformance: "O", element: "serverCluster", xref: "device§10.2.4" }),
        Requirement(
            { name: "ContentControl", id: 0x50f, conformance: "P, O", element: "serverCluster", xref: "device§10.2.4" }
        ),
        Requirement({ name: "Messages", id: 0x97, conformance: "O", element: "serverCluster", xref: "device§10.2.4" })
    ),

    DeviceType(
        {
            name: "CastingVideoPlayer", id: 0x23, classification: "simple", xref: "device§10.3",

            details: "This defines conformance to the Casting Video Player device type." +
                "\n" +
                "A Video Player (either Basic or Casting) represents a device that is able to play media to a " +
                "physical output or to a display screen which is part of the device." +
                "\n" +
                "A Casting Video Player has basic controls for playback (play, pause, etc.) and keypad input (up, " +
                "down, number input), and is able to launch content." +
                "\n" +
                "For example, a Casting Video Player can be a smart TV device, a TV Set Top Box, or a content " +
                "streaming device that provides input to another device like a TV or computer monitor." +
                "\n" +
                "See Section 10.1, “Video Player Architecture” for additional Casting Video Player requirements " +
                "relating to Video Player device endpoint composition, commissioning, feature representation in " +
                "clusters, and UI context."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 35, revision: 2 } ], element: "attribute" })
        ),

        Field(
            { name: "conditions", type: "enum8" },
            Field({
                name: "ContentAppPlatform",
                description: "The device includes a Content App Platform. A Content App is usually an application built by a Content Provider. A Casting Video Player with a Content App Platform is able to launch Content Apps and represent these apps as separate endpoints.",
                xref: "device§10.3.3"
            }),
            Field({ name: "PhysicalInputs", description: "The device has physical inputs for media.", xref: "device§10.3.3" })
        ),

        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement({ name: "WakeOnLan", id: 0x503, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement({ name: "Channel", id: 0x504, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement(
            { name: "TargetNavigator", id: 0x505, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }
        ),
        Requirement(
            { name: "MediaPlayback", id: 0x506, conformance: "M", element: "serverCluster", xref: "device§10.3.4" }
        ),
        Requirement({
            name: "MediaInput", id: 0x507, conformance: "PhysicalInputs", element: "serverCluster",
            xref: "device§10.3.4"
        }),
        Requirement({ name: "LowPower", id: 0x508, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement({ name: "KeypadInput", id: 0x509, conformance: "M", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement(
            { name: "ContentLauncher", id: 0x50a, conformance: "M", element: "serverCluster", xref: "device§10.3.4" }
        ),
        Requirement({ name: "AudioOutput", id: 0x50b, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }),

        Requirement(
            {
                name: "ApplicationLauncher", id: 0x50c, conformance: "ContentAppPlatform", element: "serverCluster",
                xref: "device§10.3.4"
            },
            Requirement({ name: "APPLICATIONPLATFORM", conformance: "M", element: "feature" })
        ),

        Requirement({ name: "AccountLogin", id: 0x50e, conformance: "O", element: "serverCluster", xref: "device§10.3.4" }),
        Requirement(
            { name: "ContentControl", id: 0x50f, conformance: "P, O", element: "serverCluster", xref: "device§10.3.4" }
        ),
        Requirement({ name: "Messages", id: 0x97, conformance: "O", element: "serverCluster", xref: "device§10.3.4" })
    ),

    DeviceType(
        {
            name: "Speaker", id: 0x22, classification: "simple", xref: "device§10.4",

            details: "This defines conformance to the Speaker device type. This feature controls the speaker volume of the " +
                "device." +
                "\n" +
                "To control unmute/mute, the On/Off cluster shall be used. A value of TRUE for the OnOff attribute " +
                "shall represent the volume on (not muted) state, while a value of FALSE shall represent the volume " +
                "off (muted) state. For volume level control, the Level cluster shall be used." +
                "\n" +
                "A dedicated endpoint is needed because the On/Off cluster can also be used for other purposes, such " +
                "as for power control." +
                "\n" +
                "The decision to use Level and On/Off clusters for volume (rather than defining a new audio control " +
                "cluster) was made in order to treat volume in a fashion consistent with lighting which also uses " +
                "these clusters and has matching functional requirements."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 34, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§10.4.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "M", element: "serverCluster", xref: "device§10.4.4" })
    ),

    DeviceType(
        {
            name: "ContentApp", id: 0x24, classification: "simple", xref: "device§10.5",
            details: "This defines conformance to the Content App device type." +
                "\n" +
                "A Content App is usually an application built by a Content Provider. A Casting Video Player with a " +
                "Content App Platform is able to launch Content Apps and represent these apps as separate endpoints."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 36, revision: 2 } ], element: "attribute" })
        ),

        Field(
            { name: "conditions", type: "enum8" },
            Field({
                name: "ObserverClient", description: "The node is a client for ContentAppObservers.",
                xref: "device§10.5.3"
            })
        ),

        Requirement({ name: "Binding", id: 0x1e, conformance: "ObserverClient", element: "serverCluster", xref: "device§10.5.4" }),
        Requirement({ name: "Channel", id: 0x504, conformance: "O", element: "serverCluster", xref: "device§10.5.4" }),
        Requirement(
            { name: "TargetNavigator", id: 0x505, conformance: "O", element: "serverCluster", xref: "device§10.5.4" }
        ),
        Requirement(
            { name: "MediaPlayback", id: 0x506, conformance: "O", element: "serverCluster", xref: "device§10.5.4" }
        ),
        Requirement({ name: "KeypadInput", id: 0x509, conformance: "M", element: "serverCluster", xref: "device§10.5.4" }),
        Requirement(
            { name: "ContentLauncher", id: 0x50a, conformance: "O", element: "serverCluster", xref: "device§10.5.4" }
        ),

        Requirement(
            {
                name: "ApplicationLauncher", id: 0x50c, conformance: "M", element: "serverCluster",
                xref: "device§10.5.4"
            },
            Requirement({ name: "APPLICATIONPLATFORM", conformance: "X", element: "feature" })
        ),

        Requirement(
            { name: "ApplicationBasic", id: 0x50d, conformance: "M", element: "serverCluster", xref: "device§10.5.4" }
        ),
        Requirement({ name: "AccountLogin", id: 0x50e, conformance: "O", element: "serverCluster", xref: "device§10.5.4" }),
        Requirement({
            name: "ContentAppObserver", id: 0x510, conformance: "ObserverClient", element: "clientCluster",
            xref: "device§10.5.4"
        })
    ),

    DeviceType(
        {
            name: "CastingVideoClient", id: 0x29, classification: "simple", xref: "device§10.6",
            details: "This defines conformance to the Casting Video Client device type." +
                "\n" +
                "A Casting Video Client is a client that can launch content on a Casting Video Player, for example, a " +
                "Smart Speaker or a Content Provider phone app."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 41, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "WakeOnLan", id: 0x503, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "Channel", id: 0x504, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement(
            { name: "TargetNavigator", id: 0x505, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }
        ),
        Requirement(
            { name: "MediaPlayback", id: 0x506, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }
        ),
        Requirement({ name: "MediaInput", id: 0x507, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "LowPower", id: 0x508, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "KeypadInput", id: 0x509, conformance: "M", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement(
            { name: "ContentLauncher", id: 0x50a, conformance: "M", element: "clientCluster", xref: "device§10.6.4" }
        ),
        Requirement({ name: "AudioOutput", id: 0x50b, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement({ name: "ApplicationLauncher", id: 0x50c, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement(
            { name: "ApplicationBasic", id: 0x50d, conformance: "M", element: "clientCluster", xref: "device§10.6.4" }
        ),
        Requirement({ name: "AccountLogin", id: 0x50e, conformance: "O", element: "clientCluster", xref: "device§10.6.4" }),
        Requirement(
            { name: "ContentControl", id: 0x50f, conformance: "P, O", element: "clientCluster", xref: "device§10.6.4" }
        ),
        Requirement({ name: "ContentAppObserver", id: 0x510, conformance: "O", element: "serverCluster", xref: "device§10.6.4" }),
        Requirement({ name: "Messages", id: 0x97, conformance: "O", element: "clientCluster", xref: "device§10.6.4" })
    ),

    DeviceType(
        {
            name: "VideoRemoteControl", id: 0x2a, classification: "simple", xref: "device§10.7",
            details: "This defines conformance to the Video Remote Control device type." +
                "\n" +
                "A Video Remote Control is a client that can control a Video Player, for example, a traditional " +
                "universal remote control."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 42, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "OnOff", id: 0x6, conformance: "M", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "LevelControl", id: 0x8, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "WakeOnLan", id: 0x503, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "Channel", id: 0x504, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement(
            { name: "TargetNavigator", id: 0x505, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }
        ),
        Requirement(
            { name: "MediaPlayback", id: 0x506, conformance: "M", element: "clientCluster", xref: "device§10.7.4" }
        ),
        Requirement({ name: "MediaInput", id: 0x507, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "LowPower", id: 0x508, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "KeypadInput", id: 0x509, conformance: "M", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement(
            { name: "ContentLauncher", id: 0x50a, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }
        ),
        Requirement({ name: "AudioOutput", id: 0x50b, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "ApplicationLauncher", id: 0x50c, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement({ name: "AccountLogin", id: 0x50e, conformance: "O", element: "clientCluster", xref: "device§10.7.4" }),
        Requirement(
            { name: "ContentControl", id: 0x50f, conformance: "P, O", element: "clientCluster", xref: "device§10.7.4" }
        )
    ),

    DeviceType(
        {
            name: "ModeSelect", id: 0x27, classification: "simple", xref: "device§11.1",
            details: "This defines conformance to the Mode Select device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 39, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "ModeSelect", id: 0x50, conformance: "M", element: "serverCluster", xref: "device§11.1.4" })
    ),

    DeviceType(
        {
            name: "Aggregator", id: 0xe, classification: "simple", xref: "device§11.2",

            details: "This device type aggregates endpoints as a collection. Clusters on the endpoint indicating this " +
                "device type provide functionality for the collection of descendant endpoints present in the " +
                "PartsList of the endpoint’s descriptor, for example the Actions cluster." +
                "\n" +
                "The purpose of this device type is to aggregate functionality for a collection of endpoints. The " +
                "definition of the collection or functionality is not defined here." +
                "\n" +
                "When using this device type as a collection of bridged nodes, please see the \"Bridge\" section in the " +
                "System Model specification."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 14, revision: 2 } ], element: "attribute" })
        ),
        Field(
            { name: "conditions", type: "enum8" },
            Field({ name: "FabricSynchronization", description: "See description below.", xref: "device§11.2.3" })
        ),
        Requirement({ name: "Actions", id: 0x25, conformance: "O", element: "serverCluster", xref: "device§11.2.4" }),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§11.2.4" }),
        Requirement({
            name: "CommissionerControl", id: 0x751, conformance: "FabricSynchronization",
            element: "serverCluster", xref: "device§11.2.4"
        })
    ),

    DeviceType(
        {
            name: "RoboticVacuumCleaner", id: 0x74, classification: "simple", xref: "device§12.1",
            details: "This defines conformance for the Robotic Vacuum Cleaner device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 116, revision: 4 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§12.1.4" }),
        Requirement({ name: "RvcRunMode", id: 0x54, conformance: "M", element: "serverCluster", xref: "device§12.1.4" }),
        Requirement({ name: "RvcCleanMode", id: 0x55, conformance: "O", element: "serverCluster", xref: "device§12.1.4" }),

        Requirement(
            {
                name: "RvcOperationalState", id: 0x61, conformance: "M", element: "serverCluster",
                xref: "device§12.1.4"
            },
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        ),

        Requirement({ name: "ServiceArea", id: 0x150, conformance: "O", element: "serverCluster", xref: "device§12.1.4" })
    ),

    DeviceType(
        {
            name: "LaundryWasher", id: 0x73, classification: "simple", xref: "device§13.1",
            details: "A Laundry Washer represents a device that is capable of laundering consumer items. Any laundry " +
                "washer product may utilize this device type." +
                "\n" +
                "A Laundry Washer shall be composed of at least one endpoint with the Laundry Washer device type."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 115, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.1.4" }),
        Requirement(
            { name: "LaundryWasherMode", id: 0x51, conformance: "O", element: "serverCluster", xref: "device§13.1.4" },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§13.1.4" },
            Requirement({ name: "DEADFRONTBEHAVIOR", conformance: "M", element: "feature" })
        ),
        Requirement({ name: "LaundryWasherControls", id: 0x53, conformance: "O", element: "serverCluster", xref: "device§13.1.4" }),
        Requirement(
            { name: "TemperatureControl", id: 0x56, conformance: "O", element: "serverCluster", xref: "device§13.1.4" }
        ),
        Requirement(
            { name: "OperationalState", id: 0x60, conformance: "M", element: "serverCluster", xref: "device§13.1.4" },
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        )
    ),

    DeviceType(
        {
            name: "Refrigerator", id: 0x70, classification: "simple", xref: "device§13.2",
            details: "A refrigerator represents a device that contains one or more cabinets that are capable of chilling " +
                "or freezing food. Examples of consumer products that may make use of this device type include " +
                "refrigerators, freezers, and wine coolers."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 112, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.2.6" }),

        Requirement(
            {
                name: "RefrigeratorAndTemperatureControlledCabinetMode", id: 0x52, conformance: "O",
                element: "serverCluster", xref: "device§13.2.6"
            },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),

        Requirement(
            { name: "RefrigeratorAlarm", id: 0x57, conformance: "O", element: "serverCluster", xref: "device§13.2.6" }
        )
    ),

    DeviceType(
        {
            name: "RoomAirConditioner", id: 0x72, classification: "simple", xref: "device§13.3",
            details: "This defines conformance to the Room Air Conditioner device type." +
                "\n" +
                "A Room Air Conditioner is a device with the primary function of controlling the air temperature in a " +
                "single room."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 114, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "M", element: "serverCluster", xref: "device§13.3.6" }),
        Requirement({ name: "Groups", id: 0x4, conformance: "O", element: "serverCluster", xref: "device§13.3.6" }),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§13.3.6" },
            Requirement({ name: "DEADFRONTBEHAVIOR", conformance: "M", element: "feature" })
        ),
        Requirement(
            { name: "ScenesManagement", id: 0x62, conformance: "O", element: "serverCluster", xref: "device§13.3.6" }
        ),
        Requirement({ name: "Thermostat", id: 0x201, conformance: "M", element: "serverCluster", xref: "device§13.3.6" }),
        Requirement({ name: "FanControl", id: 0x202, conformance: "O", element: "serverCluster", xref: "device§13.3.6" }),

        Requirement(
            {
                name: "ThermostatUserInterfaceConfiguration", id: 0x204, conformance: "O", element: "serverCluster",
                xref: "device§13.3.6"
            },
            Requirement({ name: "KeypadLockout", conformance: "O", element: "attribute" })
        ),

        Requirement({
            name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster",
            xref: "device§13.3.6"
        }),
        Requirement({
            name: "RelativeHumidityMeasurement", id: 0x405, conformance: "O", element: "serverCluster",
            xref: "device§13.3.6"
        })
    ),

    DeviceType(
        {
            name: "TemperatureControlledCabinet", id: 0x71, classification: "simple", xref: "device§13.4",
            details: "A Temperature Controlled Cabinet only exists composed as part of another device type. It represents " +
                "a single cabinet that is capable of having its temperature controlled. Such a cabinet may be " +
                "chilling or freezing food, for example as part of a refrigerator, freezer, wine chiller, or other " +
                "similar device. Equally, such a cabinet may be warming or heating food, for example as part of an " +
                "oven, range, or similar device."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 113, revision: 5 } ], element: "attribute" })
        ),
        Field(
            { name: "conditions", type: "enum8" },
            Field({ name: "Cooler", description: "The device has cooling functionality.", xref: "device§13.4.3" }),
            Field({ name: "Heater", description: "The device has heating functionality.", xref: "device§13.4.3" })
        ),
        Requirement(
            { name: "TemperatureControl", id: 0x56, conformance: "M", element: "serverCluster", xref: "device§13.4.4" },
            Requirement({ name: "TEMPERATURENUMBER", conformance: "M", element: "feature" }),
            Requirement({ name: "TEMPERATURELEVEL", conformance: "X", element: "feature" })
        ),
        Requirement({
            name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster",
            xref: "device§13.4.4"
        }),

        Requirement(
            {
                name: "RefrigeratorAndTemperatureControlledCabinetMode", id: 0x52, conformance: "[Cooler]",
                element: "serverCluster", xref: "device§13.4.4"
            },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),

        Requirement(
            { name: "OvenMode", id: 0x49, conformance: "[Heater]", element: "serverCluster", xref: "device§13.4.4" },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),

        Requirement(
            {
                name: "OvenCavityOperationalState", id: 0x48, conformance: "[Heater]", element: "serverCluster",
                xref: "device§13.4.4"
            },
            Requirement({ name: "Pause", conformance: "X", element: "command" }),
            Requirement({ name: "Resume", conformance: "X", element: "command" }),
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        )
    ),

    DeviceType(
        {
            name: "Dishwasher", id: 0x75, classification: "simple", xref: "device§13.5",
            details: "A dishwasher is a device that is generally installed in residential homes and is capable of washing " +
                "dishes, cutlery, and other items associate with food preparation and consumption. The device can be " +
                "permanently installed or portable and can have variety of filling and draining methods."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 117, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.5.4" }),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§13.5.4" },
            Requirement({ name: "DEADFRONTBEHAVIOR", conformance: "M", element: "feature" })
        ),
        Requirement(
            { name: "TemperatureControl", id: 0x56, conformance: "O", element: "serverCluster", xref: "device§13.5.4" }
        ),
        Requirement(
            { name: "DishwasherMode", id: 0x59, conformance: "O", element: "serverCluster", xref: "device§13.5.4" },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),
        Requirement(
            { name: "DishwasherAlarm", id: 0x5d, conformance: "O", element: "serverCluster", xref: "device§13.5.4" }
        ),
        Requirement(
            { name: "OperationalState", id: 0x60, conformance: "M", element: "serverCluster", xref: "device§13.5.4" },
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        )
    ),

    DeviceType(
        {
            name: "LaundryDryer", id: 0x7c, classification: "simple", xref: "device§13.6",
            details: "A Laundry Dryer represents a device that is capable of drying laundry items."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 124, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.6.4" }),
        Requirement(
            { name: "LaundryWasherMode", id: 0x51, conformance: "O", element: "serverCluster", xref: "device§13.6.4" },
            Requirement({ name: "StartUpMode", conformance: "X", element: "attribute" }),
            Requirement({ name: "ONOFF", conformance: "X", element: "feature" })
        ),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§13.6.4" },
            Requirement({ name: "DEADFRONTBEHAVIOR", conformance: "M", element: "feature" })
        ),
        Requirement({ name: "LaundryDryerControls", id: 0x4a, conformance: "O", element: "serverCluster", xref: "device§13.6.4" }),
        Requirement(
            { name: "TemperatureControl", id: 0x56, conformance: "O", element: "serverCluster", xref: "device§13.6.4" }
        ),
        Requirement(
            { name: "OperationalState", id: 0x60, conformance: "M", element: "serverCluster", xref: "device§13.6.4" },
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        )
    ),

    DeviceType(
        {
            name: "CookSurface", id: 0x77, classification: "simple", xref: "device§13.7",
            details: "A Cook Surface device type represents a heating object on a cooktop or other similar device. It " +
                "shall only be used when composed as part of another device type."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 119, revision: 2 } ], element: "attribute" })
        ),

        Requirement(
            {
                name: "TemperatureControl", id: 0x56, conformance: "O.a+", element: "serverCluster",
                xref: "device§13.7.4"
            },
            Requirement({ name: "TEMPERATURELEVEL", conformance: "M", element: "feature" }),
            Requirement({ name: "TEMPERATURENUMBER", conformance: "X", element: "feature" })
        ),

        Requirement({
            name: "TemperatureMeasurement", id: 0x402, conformance: "O.a+", element: "serverCluster",
            xref: "device§13.7.4"
        }),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "O", element: "serverCluster", xref: "device§13.7.4" },
            Requirement({ name: "OFFONLY", conformance: "M", element: "feature" })
        )
    ),

    DeviceType(
        {
            name: "Cooktop", id: 0x78, classification: "simple", xref: "device§13.8",
            details: "A cooktop is a cooking surface that heats food either by transferring currents from an " +
                "electromagnetic field located below the glass surface directly to the magnetic induction cookware " +
                "placed above or through traditional gas or electric burners."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 120, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.8.5" }),
        Requirement(
            { name: "OnOff", id: 0x6, conformance: "M", element: "serverCluster", xref: "device§13.8.5" },
            Requirement({ name: "OFFONLY", conformance: "M", element: "feature" })
        )
    ),

    DeviceType(
        {
            name: "Oven", id: 0x7b, classification: "simple", xref: "device§13.9",
            details: "An oven represents a device that contains one or more cabinets, and optionally a single cooktop, " +
                "that are all capable of heating food. Examples of consumer products implementing this device type " +
                "include ovens, wall ovens, convection ovens, etc."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 123, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.9.6" })
    ),

    DeviceType(
        {
            name: "ExtractorHood", id: 0x7a, classification: "simple", xref: "device§13.10",

            details: "An Extractor Hood is a device that is generally installed above a cooking surface in residential " +
                "kitchens. An Extractor Hood’s primary purpose is to reduce odors that arise during the cooking " +
                "process by either extracting the air above the cooking surface or by recirculating and filtering it. " +
                "It may also contain a light for illuminating the cooking surface." +
                "\n" +
                "Extractor Hoods may also be known by the following names:" +
                "\n" +
                "  • Hoods" +
                "\n" +
                "  • Extractor Fans" +
                "\n" +
                "  • Extractors" +
                "\n" +
                "  • Range Hoods" +
                "\n" +
                "  • Telescoping Hoods" +
                "\n" +
                "  • Telescoping Extractors"
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 122, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.10.5" }),
        Requirement({ name: "HepaFilterMonitoring", id: 0x71, conformance: "O", element: "serverCluster", xref: "device§13.10.5" }),
        Requirement({
            name: "ActivatedCarbonFilterMonitoring", id: 0x72, conformance: "O", element: "serverCluster",
            xref: "device§13.10.5"
        }),

        Requirement(
            { name: "FanControl", id: 0x202, conformance: "M", element: "serverCluster", xref: "device§13.10.5" },
            Requirement({ name: "ROCKING", conformance: "X", element: "feature" }),
            Requirement({ name: "WIND", conformance: "X", element: "feature" }),
            Requirement({ name: "AIRFLOWDIRECTION", conformance: "X", element: "feature" })
        )
    ),

    DeviceType(
        {
            name: "MicrowaveOven", id: 0x79, classification: "simple", xref: "device§13.11",
            details: "This defines conformance to the Microwave Oven device type." +
                "\n" +
                "A Microwave Oven is a device with the primary function of heating foods and beverages using a " +
                "magnetron."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 121, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§13.11.6" }),
        Requirement(
            { name: "OperationalState", id: 0x60, conformance: "M", element: "serverCluster", xref: "device§13.11.6" },
            Requirement({ name: "CountdownTime", conformance: "M", element: "attribute" }),
            Requirement({ name: "OperationCompletion", conformance: "M", element: "event" })
        ),
        Requirement(
            { name: "FanControl", id: 0x202, conformance: "O", element: "serverCluster", xref: "device§13.11.6" },
            Requirement({ name: "WIND", conformance: "X", element: "feature" }),
            Requirement({ name: "AIRFLOWDIRECTION", conformance: "X", element: "feature" })
        ),
        Requirement(
            { name: "MicrowaveOvenMode", id: 0x5e, conformance: "M", element: "serverCluster", xref: "device§13.11.6" }
        ),
        Requirement({ name: "MicrowaveOvenControl", id: 0x5f, conformance: "M", element: "serverCluster", xref: "device§13.11.6" })
    ),

    DeviceType(
        {
            name: "EnergyEvse", id: 0x50c, classification: "simple", xref: "device§14.1",
            details: "An EVSE (Electric Vehicle Supply Equipment) is a device that allows an EV (Electric Vehicle) to be " +
                "connected to the mains electricity supply to allow it to be charged (or discharged in case of " +
                "Vehicle to Grid / Vehicle to Home applications)."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 1292, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§14.1.6" }),
        Requirement({ name: "EnergyEvse", id: 0x99, conformance: "M", element: "serverCluster", xref: "device§14.1.6" }),
        Requirement(
            { name: "EnergyEvseMode", id: 0x9d, conformance: "M", element: "serverCluster", xref: "device§14.1.6" }
        ),
        Requirement({
            name: "TemperatureMeasurement", id: 0x402, conformance: "O", element: "serverCluster",
            xref: "device§14.1.6"
        })
    ),

    DeviceType(
        {
            name: "WaterHeater", id: 0x50f, classification: "simple", xref: "device§14.2",
            details: "A water heater is a device that is generally installed in properties to heat water for showers, " +
                "baths etc."
        },
        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 1295, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§14.2.6" }),
        Requirement(
            { name: "Thermostat", id: 0x201, conformance: "M", element: "serverCluster", xref: "device§14.2.6" },
            Requirement({ name: "HEATING", conformance: "M", element: "feature" })
        ),
        Requirement({ name: "WaterHeaterManagement", id: 0x94, conformance: "M", element: "serverCluster", xref: "device§14.2.6" }),
        Requirement(
            { name: "WaterHeaterMode", id: 0x9e, conformance: "M", element: "serverCluster", xref: "device§14.2.6" }
        )
    ),

    DeviceType(
        {
            name: "SolarPower", id: 0x17, classification: "simple", xref: "device§14.3",
            details: "A Solar Power device is a device that allows a solar panel array, which can optionally be comprised " +
                "of a set parallel strings of solar panels, and its associated controller and, if appropriate, " +
                "inverter, to be monitored and controlled by an Energy Management System."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 23, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§14.3.6" })
    ),

    DeviceType(
        {
            name: "BatteryStorage", id: 0x18, classification: "simple", xref: "device§14.4",
            details: "A Battery Storage device is a device that allows a DC battery, which can optionally be comprised of " +
                "a set parallel strings of battery packs and associated controller, and an AC inverter, to be " +
                "monitored and controlled by an Energy Management System in order to manage the peaks and troughs of " +
                "supply and demand, and/or to optimize cost of the energy consumed in premises. It is not intended to " +
                "be used for a UPS directly supplying a set of appliances, nor for portable battery storage devices."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 24, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§14.4.7" })
    ),

    DeviceType(
        {
            name: "HeatPump", id: 0x309, classification: "simple", xref: "device§14.5",

            details: "A Heat Pump device is a device that uses electrical energy to heat either spaces or water tanks " +
                "using ground, water or air as the heat source. These typically can heat the air or can pump water " +
                "via central heating radiators or underfloor heating systems. It is typical to also heat hot water " +
                "and store the heat in a hot water tank." +
                "\n" +
                "Note that the Water Heater device type can also be heated by a heat pump and has similar " +
                "requirements, but that cannot be used for space heating."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 777, revision: 1 } ], element: "attribute" })
        ),
        Requirement({ name: "Identify", id: 0x3, conformance: "O", element: "serverCluster", xref: "device§14.5.7" }),
        Requirement({ name: "Thermostat", id: 0x201, conformance: "O", element: "clientCluster", xref: "device§14.5.7" })
    ),

    DeviceType(
        {
            name: "NetworkInfrastructureManager", id: 0x90, classification: "simple", xref: "device§15.3",

            details: "A Network Infrastructure Manager provides interfaces that allow for the management of the Wi-Fi, " +
                "Thread, and Ethernet networks underlying a Matter deployment, realizing the Star Network Topology " +
                "described in [MatterCore]." +
                "\n" +
                "Examples of physical devices that implement the Matter Network Infrastructure Manager device type " +
                "include Wi-Fi gateway routers." +
                "\n" +
                "Relevant hardware and software requirements for Network Infrastructure Manager devices are defined " +
                "in Section 15.3.6, “Other Requirements” and within the clusters mandated by this device type." +
                "\n" +
                "A Network Infrastructure Manager device may be managed by a service associated with the device " +
                "vendor, for example, an Internet Service Provider. Sometimes this managing service will have " +
                "policies that require the use of the Managed Device feature of the Access Control Cluster (see " +
                "Section 15.3.5.1, “Access Control MNGD Conformance”). Consequently, Commissioners of this device " +
                "type should be aware of this feature and its use."
        },

        Requirement(
            { name: "Descriptor", id: 0x1d, element: "serverCluster" },
            Requirement({ name: "DeviceTypeList", default: [ { deviceType: 144, revision: 2 } ], element: "attribute" })
        ),
        Requirement({ name: "WiFiNetworkManagement", id: 0x451, conformance: "M", element: "serverCluster", xref: "device§15.3.4" }),
        Requirement({
            name: "ThreadBorderRouterManagement", id: 0x452, conformance: "M", element: "serverCluster",
            xref: "device§15.3.4"
        }),
        Requirement({
            name: "ThreadNetworkDirectory", id: 0x453, conformance: "M", element: "serverCluster",
            xref: "device§15.3.4"
        }),
        Requirement({
            name: "ThreadNetworkDiagnostics", id: 0x35, conformance: "M", element: "serverCluster",
            xref: "device§15.3.4"
        })
    ),

    SemanticNamespace(
        {
            name: "Closure", id: 0x1, xref: "namespace§2",

            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a feature of a Closure, e.g. the button to activate opening a garage door." +
                "\n" +
                "> [!NOTE]" +
                "\n" +
                "> This namespace has been deprecated as of Matter 1.4.2." +
                "\n" +
                "Clients SHOULD still have support for these tags, since the tags could be used by a server certified " +
                "on a previous revision of Matter."
        },

        SemanticTag({ name: "Opening", id: 0x0, description: "Move toward open position" }),
        SemanticTag({ name: "Closing", id: 0x1, description: "Move toward closed position" }),
        SemanticTag({ name: "Stop", id: 0x2, description: "Stop any movement" })
    ),

    SemanticNamespace(
        {
            name: "CompassDirection", id: 0x2, xref: "namespace§3",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a movement into a certain compass direction. Note the difference with Chapter 4, " +
                "Common Compass Location Semantic Tag Namespace."
        },

        SemanticTag({ name: "Northward", id: 0x0 }),
        SemanticTag({ name: "NorthEastward", id: 0x1 }),
        SemanticTag({ name: "Eastward", id: 0x2 }),
        SemanticTag({ name: "SouthEastward", id: 0x3 }),
        SemanticTag({ name: "Southward", id: 0x4 }),
        SemanticTag({ name: "SouthWestward", id: 0x5 }),
        SemanticTag({ name: "Westward", id: 0x6 }),
        SemanticTag({ name: "NorthWestward", id: 0x7 })
    ),

    SemanticNamespace(
        {
            name: "CompassLocation", id: 0x3, xref: "namespace§4",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position in a certain compass direction (e.g. an outdoor sensor in the North " +
                "garden). Note the difference with Chapter 3, Common Compass Direction Semantic Tag Namespace."
        },

        SemanticTag({ name: "North", id: 0x0 }),
        SemanticTag({ name: "NorthEast", id: 0x1 }),
        SemanticTag({ name: "East", id: 0x2 }),
        SemanticTag({ name: "SouthEast", id: 0x3 }),
        SemanticTag({ name: "South", id: 0x4 }),
        SemanticTag({ name: "SouthWest", id: 0x5 }),
        SemanticTag({ name: "West", id: 0x6 }),
        SemanticTag({ name: "NorthWest", id: 0x7 })
    ),

    SemanticNamespace(
        {
            name: "Direction", id: 0x4, xref: "namespace§5",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a movement in a certain direction relative to the device. Note the difference with " +
                "Chapter 9, Common Position Semantic Tag Namespace."
        },

        SemanticTag({ name: "Upward", id: 0x0 }),
        SemanticTag({ name: "Downward", id: 0x1 }),
        SemanticTag({ name: "Leftward", id: 0x2 }),
        SemanticTag({ name: "Rightward", id: 0x3 }),
        SemanticTag({ name: "Forward", id: 0x4 }),
        SemanticTag({ name: "Backward", id: 0x5 })
    ),

    SemanticNamespace(
        {
            name: "Level", id: 0x5, xref: "namespace§6",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a certain level for a feature of a device (e.g. a button to set the speed of a " +
                "fan)."
        },

        SemanticTag({ name: "Low", id: 0x0 }),
        SemanticTag({ name: "Medium", id: 0x1 }),
        SemanticTag({ name: "High", id: 0x2 })
    ),

    SemanticNamespace(
        {
            name: "Location", id: 0x6, xref: "namespace§7",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a location of a device (e.g. an outdoor temperature sensor)."
        },
        SemanticTag({
            name: "Indoor", id: 0x0,
            description: "Element is indoors or related to indoor equipment/conditions (e.g. the \"indoor\" temperature)."
        }),
        SemanticTag({
            name: "Outdoor", id: 0x1,
            description: "Element is outdoors or related to outdoor equipment/conditions (e.g. the \"outdoor\" temperature)."
        }),
        SemanticTag({
            name: "Inside", id: 0x2,
            description: "Element is located inside the equipment (e.g. a sensor \"inside\" a cabinet)."
        }),
        SemanticTag({
            name: "Outside", id: 0x3,
            description: "Element is located outside the equipment (e.g. a sensor \"outside\" a cabinet)."
        }),
        SemanticTag({
            name: "Zone", id: 0x4,
            description: "Element is a part of a location divided into zones (e.g. a yard irrigation zone)."
        })
    ),

    SemanticNamespace(
        {
            name: "Number", id: 0x7, xref: "namespace§8",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a certain numeric feature of a device (e.g. a numeric input button)."
        },
        SemanticTag({ name: "Zero", id: 0x0 }),
        SemanticTag({ name: "One", id: 0x1 }),
        SemanticTag({ name: "Two", id: 0x2 }),
        SemanticTag({ name: "Three", id: 0x3 }),
        SemanticTag({ name: "Four", id: 0x4 }),
        SemanticTag({ name: "Five", id: 0x5 }),
        SemanticTag({ name: "Six", id: 0x6 }),
        SemanticTag({ name: "Seven", id: 0x7 }),
        SemanticTag({ name: "Eight", id: 0x8 }),
        SemanticTag({ name: "Nine", id: 0x9 }),
        SemanticTag({ name: "Ten", id: 0xa }),
        SemanticTag({ name: "Eleven", id: 0xb }),
        SemanticTag({ name: "Twelve", id: 0xc }),
        SemanticTag({ name: "Thirteen", id: 0xd }),
        SemanticTag({ name: "Fourteen", id: 0xe }),
        SemanticTag({ name: "Fifteen", id: 0xf }),
        SemanticTag({ name: "Sixteen", id: 0x10 }),
        SemanticTag({ name: "Seventeen", id: 0x11 }),
        SemanticTag({ name: "Eighteen", id: 0x12 }),
        SemanticTag({ name: "Nineteen", id: 0x13 }),
        SemanticTag({ name: "Twenty", id: 0x14 }),
        SemanticTag({ name: "TwentyOne", id: 0x15 }),
        SemanticTag({ name: "TwentyTwo", id: 0x16 }),
        SemanticTag({ name: "TwentyThree", id: 0x17 }),
        SemanticTag({ name: "TwentyFour", id: 0x18 }),
        SemanticTag({ name: "TwentyFive", id: 0x19 }),
        SemanticTag({ name: "TwentySix", id: 0x1a }),
        SemanticTag({ name: "TwentySeven", id: 0x1b }),
        SemanticTag({ name: "TwentyEight", id: 0x1c }),
        SemanticTag({ name: "TwentyNine", id: 0x1d }),
        SemanticTag({ name: "Thirty", id: 0x1e })
    ),

    SemanticNamespace(
        {
            name: "Position", id: 0x8, xref: "namespace§9",

            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position relative to the device (e.g. the temperature sensor in the top drawer of " +
                "a refrigerator, or location of the buttons on a multi-button switch device). Note the difference " +
                "with Chapter 5, Common Direction Semantic Tag Namespace." +
                "\n" +
                "When multiple endpoints are used for device types, and the associated consumer-facing locations of " +
                "those endpoints are organized in a straight line, grid or matrix, these endpoints SHOULD be " +
                "allocated in top-to-bottom, left-to-right order." +
                "\n" +
                "For grids or arrays larger than 3 elements in any direction, the Row and Column tags SHOULD be used." +
                "\n" +
                "If the Row or Column tags are used, the Label field in the same Semantic Tag structure shall be " +
                "filled with a number comprised of Arabic numerals encoded as a string to indicate the row/column of " +
                "the item. Number words (e.g. \"one\", \"two\", etc.) shall NOT be used to describe the position of the " +
                "item. The first row/column shall use Label \"1\"." +
                "\n" +
                "The following example illustrates a compound device comprised of 9 endpoints arranged in a 3x3 grid. " +
                "This example uses position tags to indicate position."
        },

        SemanticTag({ name: "Left", id: 0x0 }),
        SemanticTag({ name: "Right", id: 0x1 }),
        SemanticTag({ name: "Top", id: 0x2 }),
        SemanticTag({ name: "Bottom", id: 0x3 }),
        SemanticTag({ name: "Middle", id: 0x4 }),
        SemanticTag({ name: "Row", id: 0x5, description: "Numeric value provided in Label field" }),
        SemanticTag({ name: "Column", id: 0x6, description: "Numeric value provided in Label field" })
    ),

    SemanticNamespace(
        {
            name: "LandmarkNamespace", id: 0x11, xref: "namespace§10",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a home landmark."
        },
        SemanticTag({ name: "AirConditioner", id: 0x0 }),
        SemanticTag({ name: "AirPurifier", id: 0x1 }),
        SemanticTag({ name: "BackDoor", id: 0x2 }),
        SemanticTag({ name: "BarStool", id: 0x3 }),
        SemanticTag({ name: "BathMat", id: 0x4 }),
        SemanticTag({ name: "Bathtub", id: 0x5 }),
        SemanticTag({ name: "Bed", id: 0x6 }),
        SemanticTag({ name: "Bookshelf", id: 0x7 }),
        SemanticTag({ name: "Chair", id: 0x8 }),
        SemanticTag({ name: "ChristmasTree", id: 0x9 }),
        SemanticTag({ name: "CoatRack", id: 0xa }),
        SemanticTag({ name: "CoffeeTable", id: 0xb }),
        SemanticTag({ name: "CookingRange", id: 0xc }),
        SemanticTag({ name: "Couch", id: 0xd }),
        SemanticTag({ name: "Countertop", id: 0xe }),
        SemanticTag({ name: "Cradle", id: 0xf }),
        SemanticTag({ name: "Crib", id: 0x10 }),
        SemanticTag({ name: "Desk", id: 0x11 }),
        SemanticTag({ name: "DiningTable", id: 0x12 }),
        SemanticTag({ name: "Dishwasher", id: 0x13 }),
        SemanticTag({ name: "Door", id: 0x14 }),
        SemanticTag({ name: "Dresser", id: 0x15 }),
        SemanticTag({ name: "LaundryDryer", id: 0x16 }),
        SemanticTag({ name: "Fan", id: 0x17 }),
        SemanticTag({ name: "Fireplace", id: 0x18 }),
        SemanticTag({ name: "Freezer", id: 0x19 }),
        SemanticTag({ name: "FrontDoor", id: 0x1a }),
        SemanticTag({ name: "HighChair", id: 0x1b }),
        SemanticTag({ name: "KitchenIsland", id: 0x1c }),
        SemanticTag({ name: "Lamp", id: 0x1d }),
        SemanticTag({ name: "LitterBox", id: 0x1e }),
        SemanticTag({ name: "Mirror", id: 0x1f }),
        SemanticTag({ name: "Nightstand", id: 0x20 }),
        SemanticTag({ name: "Oven", id: 0x21 }),
        SemanticTag({ name: "PetBed", id: 0x22 }),
        SemanticTag({ name: "PetBowl", id: 0x23 }),
        SemanticTag({ name: "PetCrate", id: 0x24, description: "An indoor furnishing for pets to rest or sleep inside" }),
        SemanticTag({ name: "Refrigerator", id: 0x25 }),
        SemanticTag({ name: "ScratchingPost", id: 0x26 }),
        SemanticTag({ name: "ShoeRack", id: 0x27 }),
        SemanticTag({ name: "Shower", id: 0x28, description: "An area where a showerhead dispenses water for people to shower" }),
        SemanticTag({ name: "SideDoor", id: 0x29 }),
        SemanticTag({ name: "Sink", id: 0x2a }),
        SemanticTag({ name: "Sofa", id: 0x2b }),
        SemanticTag({ name: "Stove", id: 0x2c }),
        SemanticTag({ name: "Table", id: 0x2d }),
        SemanticTag({ name: "Toilet", id: 0x2e }),
        SemanticTag({ name: "TrashCan", id: 0x2f }),
        SemanticTag({ name: "LaundryWasher", id: 0x30 }),
        SemanticTag({ name: "Window", id: 0x31 }),
        SemanticTag({
            name: "WineCooler", id: 0x32,
            description: "A type of refrigerator that is shelved to hold wine bottles and (typically) display them through a glass front"
        })
    ),

    SemanticNamespace(
        {
            name: "RelativePosition", id: 0x12, xref: "namespace§11",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with a position relative to some reference, which must be specified by the user of these " +
                "tags. For example, the position may be relative to a household item, such as a dining table, and the " +
                "user of these tags must indicate that. Note the difference with Chapter 9, Common Position Semantic " +
                "Tag Namespace, which contains tags indicating the position relative to the device."
        },

        SemanticTag({ name: "Under", id: 0x0 }),
        SemanticTag({ name: "NextTo", id: 0x1, description: "Area in proximity to the point of reference" }),
        SemanticTag({ name: "Around", id: 0x2, description: "The area surrounding the point the reference" }),
        SemanticTag({ name: "On", id: 0x3 }),
        SemanticTag({ name: "Above", id: 0x4 }),
        SemanticTag({ name: "FrontOf", id: 0x5 }),
        SemanticTag({ name: "Behind", id: 0x6 })
    ),

    SemanticNamespace(
        {
            name: "ElectricalMeasurement", id: 0xa, xref: "namespace§12",
            details: "The tags contained in this namespace are restricted for use in the electrical measurement domain and " +
                "shall NOT be used in any other domain or context."
        },
        SemanticTag({ name: "DC", id: 0x0, description: "Indicates values measured for a DC load" }),
        SemanticTag({
            name: "AC", id: 0x1,
            description: "Indicates values measured for a single-phase AC load, or values measured for the collective load on a polyphase AC power supply"
        }),
        SemanticTag({
            name: "ACPhase1", id: 0x2,
            description: "Indicates values measured for an AC load on phase 1 of a polyphase power supply"
        }),
        SemanticTag({
            name: "ACPhase2", id: 0x3,
            description: "Indicates values measured for an AC load on phase 2 of a polyphase power supply"
        }),
        SemanticTag({
            name: "ACPhase3", id: 0x4,
            description: "Indicates values measured for an AC load on phase 3 of a polyphase power supply"
        })
    ),

    SemanticNamespace(
        {
            name: "AreaNamespace", id: 0x10, xref: "namespace§13",
            details: "The tags contained in this namespace may be used in any domain or context, to indicate an " +
                "association with an indoor or outdoor area of a home."
        },
        SemanticTag({ name: "Aisle", id: 0x0 }),
        SemanticTag({ name: "Attic", id: 0x1 }),
        SemanticTag({ name: "BackDoor", id: 0x2 }),
        SemanticTag({ name: "BackYard", id: 0x3 }),
        SemanticTag({ name: "Balcony", id: 0x4 }),
        SemanticTag({ name: "Ballroom", id: 0x5 }),
        SemanticTag({ name: "Bathroom", id: 0x6, description: "Also known as Restroom" }),
        SemanticTag({ name: "Bedroom", id: 0x7 }),
        SemanticTag({ name: "Border", id: 0x8 }),
        SemanticTag({ name: "Boxroom", id: 0x9, description: "A small room typically used for storage" }),
        SemanticTag({ name: "BreakfastRoom", id: 0xa }),
        SemanticTag({ name: "Carport", id: 0xb }),
        SemanticTag({ name: "Cellar", id: 0xc }),
        SemanticTag({ name: "Cloakroom", id: 0xd }),
        SemanticTag(
            { name: "Closet", id: 0xe, description: "A small room for storing clothing, linens, and other items." }
        ),
        SemanticTag({ name: "Conservatory", id: 0xf }),
        SemanticTag({ name: "Corridor", id: 0x10 }),
        SemanticTag({ name: "CraftRoom", id: 0x11 }),
        SemanticTag({ name: "Cupboard", id: 0x12 }),
        SemanticTag({ name: "Deck", id: 0x13 }),
        SemanticTag({
            name: "Den", id: 0x14,
            description: "A small, comfortable room for individual activities such as work or hobbies"
        }),
        SemanticTag({ name: "Dining", id: 0x15 }),
        SemanticTag({ name: "DrawingRoom", id: 0x16 }),
        SemanticTag({ name: "DressingRoom", id: 0x17 }),
        SemanticTag({ name: "Driveway", id: 0x18 }),
        SemanticTag({ name: "Elevator", id: 0x19 }),
        SemanticTag({ name: "Ensuite", id: 0x1a, description: "A bathroom directly accessible from a bedroom" }),
        SemanticTag({ name: "Entrance", id: 0x1b }),
        SemanticTag({ name: "Entryway", id: 0x1c }),
        SemanticTag({ name: "FamilyRoom", id: 0x1d }),
        SemanticTag({ name: "Foyer", id: 0x1e }),
        SemanticTag({ name: "FrontDoor", id: 0x1f }),
        SemanticTag({ name: "FrontYard", id: 0x20 }),
        SemanticTag({ name: "GameRoom", id: 0x21 }),
        SemanticTag({ name: "Garage", id: 0x22 }),
        SemanticTag({ name: "GarageDoor", id: 0x23 }),
        SemanticTag({ name: "Garden", id: 0x24 }),
        SemanticTag({ name: "GardenDoor", id: 0x25 }),
        SemanticTag({ name: "GuestBathroom", id: 0x26, description: "Also known as Guest Restroom" }),
        SemanticTag({ name: "GuestBedroom", id: 0x27 }),
        SemanticTag(
            { name: "Reserved1", id: 0x28, description: "Deprecated: was Guest Restroom; use 0x26 Guest Bathroom" }
        ),
        SemanticTag({ name: "GuestRoom", id: 0x29, description: "Also known as Guest Bedroom" }),
        SemanticTag({ name: "Gym", id: 0x2a }),
        SemanticTag({ name: "Hallway", id: 0x2b }),
        SemanticTag({ name: "HearthRoom", id: 0x2c, description: "A cozy room containing a fireplace or other point heat source" }),
        SemanticTag({ name: "KidsRoom", id: 0x2d }),
        SemanticTag({ name: "KidsBedroom", id: 0x2e }),
        SemanticTag({ name: "Kitchen", id: 0x2f }),
        SemanticTag({ name: "Reserved2", id: 0x30, description: "Deprecated: was Larder; use 0x3D Pantry" }),
        SemanticTag({ name: "LaundryRoom", id: 0x31 }),
        SemanticTag({ name: "Lawn", id: 0x32 }),
        SemanticTag({ name: "Library", id: 0x33 }),
        SemanticTag({ name: "LivingRoom", id: 0x34 }),
        SemanticTag({ name: "Lounge", id: 0x35 }),
        SemanticTag({ name: "MediaTvRoom", id: 0x36 }),
        SemanticTag({
            name: "MudRoom", id: 0x37,
            description: "A space used to remove soiled garments prior to entering the domicile proper"
        }),
        SemanticTag({ name: "MusicRoom", id: 0x38 }),
        SemanticTag({ name: "Nursery", id: 0x39 }),
        SemanticTag({ name: "Office", id: 0x3a }),
        SemanticTag({ name: "OutdoorKitchen", id: 0x3b }),
        SemanticTag({ name: "Outside", id: 0x3c }),
        SemanticTag({ name: "Pantry", id: 0x3d, description: "AKA a larder, a place where food is stored" }),
        SemanticTag({ name: "ParkingLot", id: 0x3e }),
        SemanticTag({ name: "Parlor", id: 0x3f }),
        SemanticTag({ name: "Patio", id: 0x40 }),
        SemanticTag({ name: "PlayRoom", id: 0x41 }),
        SemanticTag({ name: "PoolRoom", id: 0x42, description: "A room centered around a pool/billiards table" }),
        SemanticTag({ name: "Porch", id: 0x43 }),
        SemanticTag({ name: "PrimaryBathroom", id: 0x44 }),
        SemanticTag({ name: "PrimaryBedroom", id: 0x45 }),
        SemanticTag({ name: "Ramp", id: 0x46 }),
        SemanticTag({ name: "ReceptionRoom", id: 0x47 }),
        SemanticTag({ name: "RecreationRoom", id: 0x48 }),
        SemanticTag({ name: "Reserved3", id: 0x49, description: "Deprecated: was Restroom; use 0x06 Bathroom" }),
        SemanticTag({ name: "Roof", id: 0x4a }),
        SemanticTag({ name: "Sauna", id: 0x4b }),
        SemanticTag({ name: "Scullery", id: 0x4c, description: "A utility space for cleaning dishes and laundry" }),
        SemanticTag({ name: "SewingRoom", id: 0x4d }),
        SemanticTag({ name: "Shed", id: 0x4e }),
        SemanticTag({ name: "SideDoor", id: 0x4f }),
        SemanticTag({ name: "SideYard", id: 0x50 }),
        SemanticTag({ name: "SittingRoom", id: 0x51 }),
        SemanticTag({
            name: "Snug", id: 0x52,
            description: "An informal space meant to be 'cozy', 'snug', relaxed, meant to share with family or friends"
        }),
        SemanticTag({ name: "Spa", id: 0x53 }),
        SemanticTag({ name: "Staircase", id: 0x54 }),
        SemanticTag({ name: "SteamRoom", id: 0x55 }),
        SemanticTag({ name: "StorageRoom", id: 0x56 }),
        SemanticTag({ name: "Studio", id: 0x57 }),
        SemanticTag({ name: "Study", id: 0x58 }),
        SemanticTag({ name: "SunRoom", id: 0x59 }),
        SemanticTag({ name: "SwimmingPool", id: 0x5a }),
        SemanticTag({ name: "Terrace", id: 0x5b }),
        SemanticTag({ name: "UtilityRoom", id: 0x5c }),
        SemanticTag({ name: "Ward", id: 0x5d, description: "The innermost area of a large home" }),
        SemanticTag({ name: "Workshop", id: 0x5e }),
        SemanticTag({ name: "Toilet", id: 0x5f, description: "A room dedicated to a toilet; a water closet / WC" })
    ),

    SemanticNamespace(
        {
            name: "Laundry", id: 0xe, xref: "namespace§14",
            details: "The tags contained in this namespace are restricted for use in the laundry domain and shall NOT be " +
                "used in any other domain or context."
        },
        SemanticTag({ name: "Normal", id: 0x0 }),
        SemanticTag({ name: "LightDry", id: 0x1 }),
        SemanticTag({ name: "ExtraDry", id: 0x2 }),
        SemanticTag({ name: "NoDry", id: 0x3 })
    ),

    SemanticNamespace(
        {
            name: "PowerSource", id: 0xf, xref: "namespace§15",
            details: "The tags contained in this namespace are restricted for use in the power source domain and shall NOT " +
                "be used in any other domain or context."
        },
        SemanticTag({
            name: "Unknown", id: 0x0,
            description: "The Power Source cluster is related to power provided from an unknown source"
        }),

        SemanticTag({
            name: "Grid", id: 0x1,
            description: "The Power Source cluster is related to power provided from the electrical grid",
            xref: "namespace§15.1",
            details: "Power Source clusters with this tag shall implement the WIRED feature."
        }),

        SemanticTag({
            name: "Solar", id: 0x2,
            description: "The Power Source cluster is related to power provided from a solar panel array",
            xref: "namespace§15.2",
            details: "Power Source clusters with this tag shall implement the WIRED feature."
        }),

        SemanticTag({
            name: "Battery", id: 0x3,
            description: "The Power Source cluster is related to power provided from a battery",
            xref: "namespace§15.3",
            details: "Power Source clusters with this tag shall implement the BAT feature."
        }),

        SemanticTag({
            name: "Ev", id: 0x4,
            description: "The Power Source cluster is related to power provided from an electric vehicle",
            xref: "namespace§15.4",
            details: "Power Source clusters with this tag shall implement the BAT feature."
        })
    ),

    SemanticNamespace(
        {
            name: "Refrigerator", id: 0x41, xref: "namespace§16",
            details: "The tags contained in this namespace are restricted for use in the refrigerator domain and shall NOT " +
                "be used in any other domain or context."
        },
        SemanticTag({ name: "Refrigerator", id: 0x0 }),
        SemanticTag({ name: "Freezer", id: 0x1 })
    ),

    SemanticNamespace(
        {
            name: "RoomAirConditioner", id: 0x42, xref: "namespace§17",
            details: "The tags contained in this namespace are restricted for use in the room air conditioner domain and " +
                "shall NOT be used in any other domain or context."
        },
        SemanticTag({ name: "Evaporator", id: 0x0 }),
        SemanticTag({ name: "Condenser", id: 0x1 })
    ),

    SemanticNamespace(
        {
            name: "Switches", id: 0x43, xref: "namespace§18",

            details: "The tags contained in this namespace are restricted for use in the switches domain and shall NOT be " +
                "used in any other domain or context. They are intended to indicate the function of a button on a " +
                "switch device to allow a client to make an optimized user interface which matches the actual device " +
                "without requiring a-priori knowledge of the layout of each specific switch device." +
                "\n" +
                "See the rules for applying these and other tags for switch devices, e.g. from the Common Position " +
                "Namespace and the Common Number Namespace in the Generic Switch device type section in the Device " +
                "Library."
        },

        SemanticTag({ name: "On", id: 0x0 }),
        SemanticTag({ name: "Off", id: 0x1 }),
        SemanticTag({ name: "Toggle", id: 0x2 }),
        SemanticTag({ name: "Up", id: 0x3, description: "e.g. dim up (light)" }),
        SemanticTag({ name: "Down", id: 0x4, description: "e.g. dim down (light)" }),
        SemanticTag({ name: "Next", id: 0x5, description: "e.g. select next scene" }),
        SemanticTag({ name: "Previous", id: 0x6, description: "e.g. select previous scene" }),
        SemanticTag({ name: "EnterOkSelect", id: 0x7, description: "Enter/OK/Select function" }),

        SemanticTag({
            name: "Custom", id: 0x8, description: "Textual description provided in Label field",
            xref: "namespace§18.1",
            details: "When this value is used, the Label field in the same Semantic Tag structure shall be filled with a " +
                "textual description of the function indicated on the button, such as a label or icon printed on the " +
                "button, e.g. \"dining\"."
        }),

        SemanticTag({ name: "Open", id: 0x9, description: "e.g. open window covering" }),
        SemanticTag({ name: "Close", id: 0xa, description: "e.g. close window covering" }),
        SemanticTag({ name: "Stop", id: 0xb, description: "e.g. stop moving window covering" })
    )
);
